{"/home/travis/build/npmtest/node-npmtest-sails/test.js":"/* istanbul instrument in package npmtest_sails */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-sails/lib.npmtest_sails.js":"/* istanbul instrument in package npmtest_sails */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_sails = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_sails = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-sails/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-sails && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_sails */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_sails\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_sails.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_sails.rollup.js'] =\n            local.assetsDict['/assets.npmtest_sails.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_sails.__dirname + '/lib.npmtest_sails.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/index.js":"/**\n * Module dependencies\n */\n\nvar Sails = require('./app');\n\n\n\n// Instantiate and expose a Sails singleton\n// (maintains legacy support)\nmodule.exports = new Sails();\n\n// Expose constructor for convenience/tests\nmodule.exports.Sails = Sails;\n\n\n// To access the Sails app constructor, do:\n// var Sails = require('sails').constructor;\n// or:\n// var Sails = require('sails').Sails;\n//\n// Then:\n// var newApp = new Sails();\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/app/index.js":"/**\n * Module dependencies.\n */\n\n// try {console.time('require_core');}catch(e){}\nvar Sails = require('./Sails');\nvar _ = require('@sailshq/lodash');\n\n\n/**\n * Expose `Sails` factory\n * (maintains backwards compatibility w/ constructor usage)\n */\n\nmodule.exports = SailsFactory;\n\nfunction SailsFactory() {\n  return new Sails();\n}\n\n\n// Backwards compatibility for Sails singleton usage:\nvar singleton = SailsFactory();\nSailsFactory.isLocalSailsValid = _.bind(singleton.isLocalSailsValid, singleton);\nSailsFactory.isSailsAppSync = _.bind(singleton.isSailsAppSync, singleton);\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/app/Sails.js":"/**\n * Module dependencies.\n */\n\nvar events = require('events');\nvar _ = require('@sailshq/lodash');\nvar util = require('util');\nvar loadSails = require('./load');\nvar mixinAfter = require('./private/after');\nvar __Router = require('../router');\nvar CaptainsLog = require('captains-log');\n\n\n\n/**\n * Construct a Sails (app) instance.\n *\n * @constructor\n */\n\nfunction Sails() {\n\n  // Inherit methods from EventEmitter\n  events.EventEmitter.call(this);\n\n  // Remove memory-leak warning about max listeners\n  // See: http://nodejs.org/docs/latest/api/events.html#events_emitter_setmaxlisteners_n\n  this.setMaxListeners(0);\n\n  // Keep track of spawned child processes\n  this.childProcesses = [];\n\n  // Ensure CaptainsLog exists\n  this.log = CaptainsLog();\n\n  // Build a Router instance (which will attach itself to the sails object)\n  __Router(this);\n\n  // Mixin `load()` method to load the pieces\n  // of a Sails app\n  this.load = loadSails(this);\n\n  // Mixin support for `Sails.prototype.after()`\n  mixinAfter(this);\n\n  // Bind `this` context for all `Sails.prototype.*` methods\n  this.load = _.bind(this.load, this);\n  this.request = _.bind(this.request, this);\n  this.lift = _.bind(this.lift, this);\n  this.lower = _.bind(this.lower, this);\n  this.getBaseurl = _.bind(this.getBaseurl, this);\n  this.initialize = _.bind(this.initialize, this);\n  this.exposeGlobals = _.bind(this.exposeGlobals, this);\n  this.runBootstrap = _.bind(this.runBootstrap, this);\n  this.getHost = _.bind(this.getHost, this);\n  this.isLocalSailsValid = _.bind(this.isLocalSailsValid, this);\n  this.isSailsAppSync = _.bind(this.isSailsAppSync, this);\n  this.inspect = _.bind(this.inspect, this);\n  this.toString = _.bind(this.toString, this);\n  this.toJSON = _.bind(this.toJSON, this);\n  this.all = _.bind(this.all, this);\n  this.get = _.bind(this.get, this);\n  this.post = _.bind(this.post, this);\n  this.put = _.bind(this.put, this);\n  this['delete'] = _.bind(this['delete'], this);\n}\n\n\n// Extend from EventEmitter to allow hooks to listen to stuff\nutil.inherits(Sails, events.EventEmitter);\n\n\n// Public methods\n////////////////////////////////////////////////////////\n\nSails.prototype.lift = require('./lift');\n\nSails.prototype.lower = require('./lower');\n\nSails.prototype._getBaseUrl = require('./getBaseurl');\nSails.prototype.getBaseurl = function() {\n  this.log.warn(\"sails.getBaseUrl() is deprecated and will be removed in Sails v1.0.  See http://sailsjs.org/documentation/reference/application/sails-getbaseurl for more info.\");\n  return this._getBaseUrl();\n};\nSails.prototype.getBaseURL = Sails.prototype.getBaseurl;\nSails.prototype.getBaseUrl = Sails.prototype.getBaseurl;\n\n\nSails.prototype.getRouteFor = require('./get-route-for');\nSails.prototype.getUrlFor = require('./get-url-for');\n\n\n\n// Experimental methods\n////////////////////////////////////////////////////////\n\nSails.prototype.request = require('./request');\n\n\n// Expose Express-esque synonyms for low-level usage of router\nSails.prototype.all = function(path, action) {\n  this.router.bind(path, action);\n  return this;\n};\nSails.prototype.get = function(path, action) {\n  this.router.bind(path, action, 'get');\n  return this;\n};\nSails.prototype.post = function(path, action) {\n  this.router.bind(path, action, 'post');\n  return this;\n};\nSails.prototype.put = function(path, action) {\n  this.router.bind(path, action, 'put');\n  return this;\n};\nSails.prototype.del = Sails.prototype['delete'] = function(path, action) {\n  this.router.bind(path, action, 'delete');\n  return this;\n};\n\n// Private methods:\n////////////////////////////////////////////////////////\n\nSails.prototype.initialize = require('./private/initialize');\nSails.prototype.exposeGlobals = require('./private/exposeGlobals');\nSails.prototype.runBootstrap = require('./private/bootstrap');\nSails.prototype.getHost = require('./private/getHost');\nSails.prototype.isLocalSailsValid = require('./private/isLocalSailsValid');\nSails.prototype.isSailsAppSync = require('./private/isSailsAppSync');\n\n// Presentation\nSails.prototype.inspect = require('./private/inspect');\nSails.prototype.toString = require('./private/toString');\nSails.prototype.toJSON = require('./private/toJSON');\n\n// Utilities\n// Includes lodash, node's `util`, and a few additional\n// static helper methods.\n// (may be deprecated in a future release)\nSails.prototype.util = require('sails-util');\n\n// Expose Sails constructor\nmodule.exports = Sails;\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/app/load.js":"var async = require('async');\nvar _ = require('@sailshq/lodash');\nvar util = require('util');\nvar __Configuration = require('./configuration');\nvar __initializeHooks = require('./private/loadHooks');\n\nmodule.exports = function(sails) {\n\n  var Configuration = __Configuration(sails);\n  var initializeHooks = __initializeHooks(sails);\n\n  /**\n   * Expose loader start point.\n   * (idempotent)\n   *\n   * @api public\n   */\n  return function load(configOverride, cb) {\n\n    if (sails._exiting) {\n      return cb(new Error('\\n*********\\nCannot load or lift an app after it has already been lowered. \\nYou can make a new app instance with:\\nvar SailsApp = require(\\'sails\\').Sails;\\nvar sails = new SailsApp();\\n\\nAnd then you can do:\\nsails.load([opts,] cb)\\n\\n'));\n    }\n\n    // configOverride is optional\n    if (_.isFunction(configOverride)) {\n      cb = configOverride;\n      configOverride = {};\n    }\n\n    // Ensure override is an object and clone it (or make an empty object if it's not)\n    configOverride = configOverride || {};\n    sails.config = _.cloneDeep(configOverride);\n\n\n    // If host is explicitly specified, set `explicitHost`\n    // (otherwise when host is omitted, Express will accept all connections via INADDR_ANY)\n    if (configOverride.host) {\n      configOverride.explicitHost = configOverride.host;\n    }\n\n    // Optionally expose services, models, sails, _, async, etc. as globals as soon as the\n    // user config loads.\n    sails.on('hook:userconfig:loaded', sails.exposeGlobals);\n\n    async.auto({\n\n      // Apply core defaults and hook-agnostic configuration,\n      // esp. overrides including command-line options, environment variables,\n      // and options that were passed in programmatically.\n      config: [Configuration.load],\n\n      // Load hooks into memory, with their middleware and routes\n      hooks: ['config', loadHooks],\n\n      // Populate the \"registry\"\n      // Houses \"middleware-esque\" functions bound by various hooks and/or Sails core itself.\n      // (i.e. `function (req, res [,next]) {}`)\n      //\n      // (Basically, that means we grab an exposed `middleware` object,\n      // full of functions, from each hook, then make it available as\n      // `sails.middleware.[HOOK_ID]`.)\n      //\n      // TODO: finish refactoring to change \"middleware\" nomenclature\n      // to avoid confusion with the more specific (and more common)\n      // usage of the term.\n      registry: ['hooks',\n        function populateRegistry(cb) {\n\n          sails.log.verbose('Instantiating registry...');\n\n          // Iterate through hooks and absorb the middleware therein\n          // Save a reference to registry and expose it on\n          // the Sails instance.\n          sails.middleware = sails.registry =\n          // Namespace functions by their source hook's identity\n          _.reduce(sails.hooks, function(registry, hook, identity) {\n            registry[identity] = hook.middleware;\n            return registry;\n          }, {});\n\n          sails.emit('middleware:registered');\n\n          cb();\n        }\n      ],\n\n      // Load the router and bind routes in `sails.config.routes`\n      router: ['registry', sails.router.load]\n\n    }, ready__(cb));\n\n    // Makes `app.load()` chainable\n    return sails;\n  };\n\n  /**\n   * Load hooks in parallel\n   * let them work out dependencies themselves,\n   * taking advantage of events fired from the sails object\n   *\n   * @api private\n   */\n  function loadHooks(cb) {\n    sails.hooks = { };\n\n    // If config.hooks is disabled, skip hook loading altogether\n    if (sails.config.hooks === false) {\n      return cb();\n    }\n\n    async.series([\n\n      function(cb) {\n        loadHookDefinitions(sails.hooks, cb);\n      },\n      function(cb) {\n        initializeHooks(sails.hooks, cb);\n      }\n    ], function(err) {\n      if (err) return cb(err);\n\n      // Inform any listeners that the initial, built-in hooks\n      // are finished loading\n      sails.emit('hooks:builtIn:ready');\n      sails.log.verbose('Built-in hooks are ready.');\n      return cb();\n    });\n  }\n\n  /**\n   * Load built-in hook definitions from `sails.config.hooks`\n   * and put them back into `hooks` (probably `sails.hooks`)\n   *\n   * @api private\n   */\n  function loadHookDefinitions(hooks, cb) {\n\n    // Mix in user-configured hook definitions\n    _.extend(hooks, sails.config.hooks);\n\n    // Make sure these changes to the hooks object get applied\n    // to sails.config.hooks to keep logic consistent\n    // (I think we can get away w/o this, but leaving as a stub)\n    // sails.config.hooks = hooks;\n\n    // If user configured `loadHooks`, only include those.\n    if (sails.config.loadHooks) {\n      if (!_.isArray(sails.config.loadHooks)) {\n        return cb('Invalid `loadHooks` config.  ' +\n          'Please specify an array of string hook names.\\n' +\n          'You specified ::' + util.inspect(sails.config.loadHooks));\n      }\n\n      _.each(hooks, function(def, hookName) {\n        if (!_.contains(sails.config.loadHooks, hookName)) {\n          hooks[hookName] = false;\n        }\n      });\n      sails.log.verbose('Deliberate partial load-- will only initialize hooks ::', sails.config.loadHooks);\n    }\n\n    return cb();\n  }\n\n  /**\n   * Returns function which is fired when Sails is ready to go\n   *\n   * @api private\n   */\n  function ready__(cb) {\n    return function(err) {\n      if (err) {\n        return cb && cb(err);\n      }\n\n      sails.log.verbose('All hooks were loaded successfully.');\n\n      // If userconfig hook is turned off, still load globals.\n      if (sails.config.hooks && sails.config.hooks.userconfig === false ||\n           (sails.config.loadHooks && sails.config.loadHooks.indexOf('userconfig') == -1)) {\n            sails.exposeGlobals();\n      }\n\n      cb && cb(null, sails);\n    };\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/app/configuration/index.js":"/**\n * Module dependencies.\n */\n\nvar _ = require('@sailshq/lodash');\nvar path = require('path');\nvar DEFAULT_HOOKS = require('./default-hooks');\n\nmodule.exports = function(sails) {\n\n  /**\n   * Expose new instance of `Configuration`\n   */\n\n  return new Configuration();\n\n\n  function Configuration() {\n\n\n    /**\n     * Sails default configuration\n     *\n     * @api private\n     */\n    this.defaults = function defaultConfig(appPath) {\n\n      var defaultEnv;\n      // If we're not loading the userconfig hook, which normally takes care\n      // of ensuring that we have an environment, then make sure we set one here.\n      if (_.isObject(sails.config.hooks) && sails.config.hooks.userconfig === false ||\n         (_.isArray(sails.config.loadHooks) && sails.config.loadHooks.indexOf('userconfig') == -1)\n      ) {\n        defaultEnv = sails.config.environment || \"development\";\n      }\n\n      // If `appPath` not specified, unfortunately, this is a fatal error,\n      // since reasonable defaults cannot be assumed\n      if (!appPath) {\n        throw new Error('No `appPath` specified!');\n      }\n\n      // Set up config defaults\n      return {\n\n        environment: defaultEnv,\n\n        // Note: to avoid confusion re: timing, `hooks` configuration may eventually be removed\n        // from `sails.config` in favor of something more flexible / obvious, e.g. the `app` object\n        // itself (i.e. because you can't configure hooks in `userconfig`-- only in `overrides`).\n\n        // Core (default) hooks\n        hooks: _.reduce(DEFAULT_HOOKS, function (memo, hookBundled, hookIdentity) {\n\n          // if `true`, then the core hook is bundled in the `lib/hooks/` directory\n          // as `lib/hooks/HOOK_IDENTITY`.\n          if (hookBundled === true) {\n            memo[hookIdentity] = require('../../hooks/'+hookIdentity);\n          }\n          // if it's a string, then the core hook is an NPM dependency of sails,\n          // so require it (which grabs it from `node_modules/`)\n          else if (_.isString(hookBundled)) {\n            var hook;\n            try {\n              hook = require(hookBundled);\n            }\n            catch (e) {\n              throw new Error('Sails internal error: Could not require(\\''+hookBundled+'\\')');\n            }\n            memo[hookIdentity] = hook;\n          }\n          // otherwise freak out\n          else {\n            throw new Error('Sails internal error: \"'+hookIdentity+'\", a core hook, is invalid!');\n          }\n          return memo;\n        }, {}) || {},\n\n        // Save appPath in implicit defaults\n        // appPath is passed from above in case `sails lift` was used\n        // This is the directory where this Sails process is being initiated from.\n        // (  usually this means `process.cwd()`  )\n        appPath: appPath,\n\n        // Built-in path defaults\n        paths: {\n          tmp: path.resolve(appPath, '.tmp')\n        },\n\n        // Start off `routes` and `middleware` as empty objects\n        routes: {},\n        middleware: {}\n\n      };\n    },\n\n\n\n    /**\n     * Load the configuration modules\n     *\n     * @api private\n     */\n\n    this.load = require('./load')(sails);\n\n\n\n    // Bind the context of all instance methods\n    _.bindAll(this);\n\n  }\n\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/app/configuration/default-hooks.js":"/**\n * Default hooks\n *\n * (order still matters for now for some of these-\n *  but mostly not, due to ouruse of events...\n *  ...but for a few core hooks, e.g. `moduleloader`,\n *  it still does.)\n */\n\nmodule.exports = {\n  'moduleloader': true,\n  'logger': true,\n  'request': true,\n  'orm': 'sails-hook-orm',\n  'views': true,\n  'blueprints': true,\n  'responses': true,\n  'controllers': true,\n  'sockets': 'sails-hook-sockets',\n  'pubsub': true,\n  'policies': true,\n  'services': true,\n  'csrf': true,\n  'cors': true,\n  'i18n': true,\n  'userconfig': true,\n  'session': true,\n  'grunt': true,\n  'http': true,\n  'userhooks': true\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/app/private/loadHooks.js":"var _ = require('@sailshq/lodash');\nvar async = require('async');\nvar __hooks = require('../../hooks');\nvar defaultsDeep = require('merge-defaults');\n\nmodule.exports = function(sails) {\n\n  var Hook = __hooks(sails);\n\n  /**\n   * Resolve the hook definitions and then finish loading them\n   *\n   * @api private\n   */\n  return function initializeHooks(hooks, cb) {\n\n    function prepareHook(id) {\n\n      var hookPrototype = hooks[id];\n\n      // Allow disabling of hooks by setting them to \"false\"\n      if (hookPrototype === false || hookPrototype === 'false' || hooks[id.split('.')[0]] === false) {\n        delete hooks[id];\n        return;\n      }\n\n      // Check for invalid hook config\n      if (hooks.userconfig && !hooks.moduleloader) {\n        return cb('Invalid configuration:: Cannot use the `userconfig` hook w/o the `moduleloader` hook enabled!');\n      }\n\n      // Handle folder-defined modules (default to index.js)\n      // Since a hook definition must be a function\n      if (_.isObject(hookPrototype) && !_.isArray(hookPrototype) && !_.isFunction(hookPrototype)) {\n        hookPrototype = hookPrototype.index;\n      }\n\n      if (!_.isFunction(hookPrototype)) {\n        sails.log.error('Malformed hook! (' + id + ')');\n        sails.log.error('Hooks should be a function with one argument (`sails`)');\n        process.exit(1);\n      }\n\n      // Instantiate the hook\n      var def = hookPrototype(sails);\n\n      // Mix in an `identity` property to hook definition\n      def.identity = id.toLowerCase();\n\n      // If a config key was defined for this hook when it was loaded,\n      // (probably because a user is overridding the default config key)\n      // set it on the hook definition\n      def.configKey = hookPrototype.configKey || def.identity;\n\n      // New up an actual Hook instance\n      hooks[id] = new Hook(def);\n    }\n\n    // Function to apply a hook's \"defaults\" obj or function\n    function applyDefaults(hook) {\n      // Get the hook defaults\n      var defaults = (_.isFunction(hook.defaults) ?\n                hook.defaults(sails.config) :\n                hook.defaults) || {};\n      // Replace the special __configKey__ key with the actual config key\n      if (hook.defaults.__configKey__ && hook.configKey) {\n        hook.defaults[hook.configKey] = hook.defaults.__configKey__;\n        delete hook.defaults.__configKey__;\n      }\n\n      defaultsDeep(sails.config, defaults);\n    }\n\n    // Load a hook (bind its routes, load any modules and initialize it)\n    function loadHook(id, cb) {\n\n      var timeoutInterval = (sails.config[hooks[id].configKey || id] && sails.config[hooks[id].configKey || id]._hookTimeout) || sails.config.hookTimeout || 20000;\n      var hookTimeout;\n      if (id != 'userhooks') {\n        hookTimeout = setTimeout(function tooLong() {\n          var hooksTookTooLongErr = 'The hook `'+id+'` is taking too long to load.\\n' +\n            'Make sure it is triggering its `initialize()` callback, ' +\n            'or else set `sails.config.' + (hooks[id].configKey || id) +\n            '._hookTimeout to a higher value (currently ' + timeoutInterval + ')';\n          var err = new Error(hooksTookTooLongErr);\n          err.code = 'E_HOOK_TIMEOUT';\n          cb(err);\n        }, timeoutInterval);\n      }\n      hooks[id].load(function(err) {\n        if (id != 'userhooks') {\n          clearTimeout(hookTimeout);\n        }\n        if (err) {\n          if (id != 'userhooks') {\n            sails.log.error('A hook (`' + id + '`) failed to load!');\n          }\n          sails.emit('hook:' + id + ':error');\n          return cb(err);\n        }\n\n        sails.log.verbose(id, 'hook loaded successfully.');\n        sails.emit('hook:' + id + ':loaded');\n\n        // Defer to next tick to allow other stuff to happen\n        process.nextTick(cb);\n      });\n    }\n\n    async.series({\n\n        // First load the moduleloader (if any)\n        moduleloader: function(cb) {\n          if (!hooks.moduleloader) {\n            return cb();\n          }\n          prepareHook('moduleloader');\n          applyDefaults(hooks['moduleloader']);\n          hooks['moduleloader'].configure();\n          loadHook('moduleloader', cb);\n        },\n\n        // Next load the user config (if any)\n        userconfig: function(cb) {\n          if (!hooks.userconfig) {\n            return cb();\n          }\n          prepareHook('userconfig');\n          applyDefaults(hooks['userconfig']);\n          hooks['userconfig'].configure();\n          loadHook('userconfig', cb);\n        },\n\n        // Next get the user hooks (if any), which will be\n        // added to the list of hooks to load\n        userhooks: function(cb) {\n          if (!hooks.userhooks) {\n            return cb();\n          }\n          prepareHook('userhooks');\n          applyDefaults(hooks['userhooks']);\n          hooks['userhooks'].configure();\n          loadHook('userhooks', cb);\n        },\n\n        // Prepare all other hooks\n        prepare: function(cb) {\n          async.each(_.without(_.keys(hooks), 'userconfig', 'moduleloader', 'userhooks'), function (id, cb) {\n            prepareHook(id);\n            // Defer to next tick to allow other stuff to happen\n            process.nextTick(cb);\n          }, cb);\n        },\n\n        // Apply the default config for all other hooks\n        defaults: function(cb) {\n          async.each(_.without(_.keys(hooks), 'userconfig', 'moduleloader', 'userhooks'), function (id, cb) {\n            var hook = hooks[id];\n            applyDefaults(hook);\n            // Defer to next tick to allow other stuff to happen\n            process.nextTick(cb);\n          }, cb);\n        },\n\n        // Run configuration method for all other hooks\n        configure: function(cb) {\n          async.each(_.without(_.keys(hooks), 'userconfig', 'moduleloader', 'userhooks'), function (id, cb) {\n            var hook = hooks[id];\n            try {\n              hook.configure();\n            } catch (e) {\n              return cb(e);\n            }\n            // Defer to next tick to allow other stuff to happen\n            process.nextTick(cb);\n          }, cb);\n        },\n\n        // Load all other hooks\n        load: function(cb) {\n          async.each(_.without(_.keys(hooks), 'userconfig', 'moduleloader', 'userhooks'), function (id, cb) {\n            sails.log.silly('Loading hook: ' + id);\n            loadHook(id, cb);\n          }, cb);\n        }\n      },\n\n      function hooksReady(err) {\n        return cb(err);\n      });\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/hooks/index.js":"/**\n * Module dependencies.\n */\n\nvar _ = require('@sailshq/lodash');\nvar async = require('async');\n\n\n\n\nmodule.exports = function(sails) {\n\n\n  /**\n   * Expose hook constructor\n   *\n   * @api private\n   */\n\n  return function Hook(definition) {\n\n    // A few sanity checks to make sure te provided definition does not contain any reserved properties.\n    if (!_.isObject(definition)) {\n      // This particular behavior can be made a bit less genteel in future versions (it is currently\n      // forgiving for backwards compatibility)\n      definition = definition || {};\n    }\n    \n    if (_.isFunction(definition.config)) {\n      throw new Error('Error defining hook: `config` is a reserved property and cannot be used as a custom hook method.');\n    }\n    if (_.isFunction(definition.middleware)) {\n      throw new Error('Error defining hook: `middleware` is a reserved property and cannot be used as a custom hook method.');\n    }\n    \n\n\n    /**\n     * Load the hook asynchronously\n     *\n     * @api private\n     */\n\n    this.load = function(cb) {\n\n      var self = this;\n\n      var routeCallbacks = function(routes) {\n        _.each(routes, function(middleware, route) {\n          middleware._middlewareType = self.identity.toUpperCase() + ' HOOK' + (middleware.name ? (': ' + middleware.name) : '');\n          sails.router.bind(route, middleware);\n        });\n      };\n\n      // Determine if this hook should load based on Sails environment & hook config\n      if (this.config.envs &&\n        this.config.envs.length > 0 &&\n        this.config.envs.indexOf(sails.config.environment) === -1) {\n        return cb();\n      }\n\n      // Convenience config to bind routes before any of the static app routes\n      sails.on('router:before', function() {\n        routeCallbacks(self.routes.before);\n      });\n\n      // Convenience config to bind routes after the static app routes\n      sails.on('router:after', function() {\n        routeCallbacks(self.routes.after);\n      });\n\n      // Run loadModules method if moduleloader is loaded\n      async.auto({\n\n        modules: function(cb) {\n\n            if (sails.config.hooks.moduleloader) {\n\n              return self.loadModules(cb);\n\n            }\n            return cb();\n          }\n\n      }, function(err) {\n        if (err) return cb(err);\n        try {\n          self.initialize(cb);\n        } catch(e) {\n          return cb(e);\n        }\n      });\n\n    };\n\n\n\n    /**\n     * `defaults`\n     *\n     * Default configuration for this hook.\n     *\n     * Hooks may override this function, or use a dictionary instead.\n     *\n     * @type {Function|Dictionary}\n     *       @returns {Dictionary} [default configuration for this hook to be merged into sails.config]\n     */\n    this.defaults = function(config) {\n      return {};\n    };\n\n    /**\n     * `configure`\n     *\n     * If this hook provides this function, the provided implementation should\n     * normalize and validate configuration related to this hook.  That config is\n     * already in `sails.config` at the time this function is called.  Any modifications\n     * should be made in place on `sails.config`\n     *\n     * Hooks may override this function.\n     *\n     * @type {Function}\n     */\n    this.configure = function() {\n\n    };\n\n    /**\n     * `loadModules`\n     *\n     * Load any modules as a dictionary and pass the loaded modules to the callback when finished.\n     *\n     * Hooks may override this function (This runs before `initialize()`!)\n     *\n     * @type {Function}\n     * @async\n     */\n    this.loadModules = function(cb) {\n      return cb();\n    };\n\n\n    /**\n     * `initialize`\n     *\n     * If provided, this implementation should prepare the hook, then trigger the callback.\n     *\n     * Hooks may override this function.\n     *\n     * @type {Function}\n     * @async\n     */\n    this.initialize = function(cb) {\n      return cb();\n    };\n\n\n\n    // Ensure that the hook definition has valid properties\n    _normalize(this);\n    definition = _normalize(definition);\n\n    // Merge default definition with overrides in the definition passed in\n    _.extend(definition.config, this.config, definition.config);\n    _.extend(definition.middleware, this.middleware, definition.middleware);\n    _.extend(definition.routes.before, this.routes.before, definition.routes.before);\n    _.extend(definition.routes.after, this.routes.after, definition.routes.after);\n    _.extend(this, definition);\n\n    // Bind context of new methods from definition\n    _.bindAll(this);\n\n\n\n    /**\n     * Ensure that a hook definition has the required properties.\n     * \n     * @returns {Dictionary} [coerced hook definition]\n     * @api private\n     */\n\n    function _normalize(def) {\n\n      def = def || {};\n\n      // Default hook config\n      def.config = def.config || {};\n\n      // list of environments to run in, if empty defaults to all\n      def.config.envs = def.config.envs || [];\n\n      def.middleware = def.middleware || {};\n\n      // Default hook routes\n      def.routes = def.routes || {};\n      def.routes.before = def.routes.before || {};\n      def.routes.after = def.routes.after || {};\n\n      return def;\n    }\n  };\n\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/app/private/after.js":"/**\n * Module dependencies\n */\n\nvar _ = require('@sailshq/lodash');\nvar async = require('async');\n\n\n//\n// TODO\n// Pull this into a separate module, since it's not specific to Sails.\n//\n\n\n/**\n * Mix-in an `after` function to an EventEmitter.\n *\n * If `events` have already fired, trigger fn immediately (with no args)\n * Otherwise bind a normal one-time event using `EventEmitter.prototype.once()`.\n * Useful for checking whether or not something has finished loading, etc.\n *\n * This is a lot like jQuery's `$(document).ready()`.\n *\n * @param  {EventEmitter} emitter\n */\n\nmodule.exports = function mixinAfter(emitter) {\n\n\n  /**\n   * { emitter.warmEvents }\n   *\n   * Events which have occurred at least once\n   * (Required to support `emitter.after()`)\n   */\n  emitter.warmEvents = {};\n\n\n  /**\n   * emitter.emit()\n   *\n   * Override `EventEmitter.prototype.emit`.\n   * (Required to support `emitter.after()`)\n   */\n\n  var _emit = emitter.emit;\n  emitter.emit = function(evName) {\n    var args = Array.prototype.slice.call(arguments, 0);\n    emitter.warmEvents[evName] = true;\n    _emit.apply(emitter, args);\n  };\n\n\n  /**\n   * `emitter.after()`\n   *\n   * Fires your handler **IF THE SPECIFIED EVENT HAS ALREADY BEEN TRIGGERED** or **WHEN IT IS TRIGGERED**.\n   *\n   * @param  {String|Array} events   [name of the event(s)]\n   * @param  {Function}     fn       [event handler function]\n   * @context {Sails}\n   */\n\n  emitter.after = function(events, fn) {\n\n    // Support a single event or an array of events\n    if (!_.isArray(events)) {\n      events = [events];\n    }\n\n    // Convert named event dependencies into an array\n    // of async-compatible functions.\n    var dependencies = _.reduce(events,\n      function(dependencies, event) {\n\n        var handlerFn = function(cb) {\n          if (emitter.warmEvents[event]) {\n            cb();\n          } else {\n            emitter.once(event, cb);\n          }\n        };\n        dependencies.push(handlerFn);\n        return dependencies;\n      }, []);\n\n    // When all events have fired, call `fn`\n    // (all arguments passed to `emit()` calls are discarded)\n    async.parallel(dependencies, function(err) {\n      if (err) sails.log.error(err);\n      return fn();\n    });\n\n  };\n\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/router/index.js":"/**\n * Module dependencies.\n */\n\nvar Readable = require('stream').Readable;\nvar QS = require('querystring');\nvar _ = require('@sailshq/lodash');\nvar Express = require('@sailshq/express');\n\nvar buildReq = require('./req');\nvar buildRes = require('./res');\nvar defaultHandlers = require('./bindDefaultHandlers');\n\n\n/**\n * Expose new instance of `Router`\n *\n * @api private\n */\nmodule.exports = function(sails) {\n  return new Router({sails: sails});\n};\n\n\n\n/**\n * Initialize a new `Router`\n *\n * @param {Object} options\n * @api private\n */\n\nfunction Router(options) {\n\n  options = options || {};\n  this.sails = options.sails;\n  this.defaultHandlers = defaultHandlers(this.sails);\n\n  // Expose router on `sails` object\n  this.sails.router = this;\n\n  // Required for dynamic NODE_ENV setting via command line args\n  // TODO:\n  // instead, use: https://www.npmjs.org/package/path-to-regexp\n  // (or: https://www.npmjs.org/package/path-match)\n  this._privateRouter = Express();\n\n  // Bind the context of all instance methods\n  this.load = _.bind(this.load, this);\n  this.bind = _.bind(this.bind, this);\n  this.unbind = _.bind(this.unbind, this);\n  this.reset = _.bind(this.reset, this);\n  this.flush = _.bind(this.flush, this);\n  this.route = _.bind(this.route, this);\n}\n\n\n/**\n * _privateRouter\n *\n * This internal \"private\" instance of an Express appobject\n * is used only for routing. (i.e. it will not be used for\n * listening to actual HTTP requests; instead, one or more\n * delegate servers can be attached- see the `http` or\n * `sockets` hooks for examples of attaching a server to\n * Sails)\n *\n * NOTE: Requires calling `load()` before use in order to\n * provide access to the proper NODE_ENV, since Express\n * uses that to determine its environment (development vs.\n * production.)\n */\n\n// Router.prototype._privateRouter;\n\n\n\n/**\n * `sails.router.load()`\n *\n * Expose the router, create the Express private router,\n * then call flush(), which will bind configured routes\n * and emit the appropriate events.\n *\n * @api public\n */\n\nRouter.prototype.load = function(cb) {\n  var sails = this.sails;\n\n  sails.log.verbose('Loading router...');\n\n  // Maintain a reference to the static route config\n  this.explicitRoutes = sails.config.routes;\n\n  // Save reference to sails logger\n  this.log = sails.log;\n\n  var sessionSecret = sails.config.session && sails.config.session.secret;\n  // If a session store is configured, hook it up as `req.session` by passing\n  // it down to the session middleware\n  if (sails.hooks.session) {\n    sails.after('hook:session:loaded', function (){\n      // if (!sails.config.session || !sails.config.session.store || !sails.config.session.secret) {\n      //   return cb(new Error('Consistency violation: expected session store+secret config to exist if the session hook is enabled. Is `sails.config.session` valid?'));\n      // }\n\n      // Set \"resave\" and \"saveUninitialized\" options or else express-session gives you a stern warning.\n      var opts = _.merge({\n        resave: true,\n        saveUninitialized: true\n      }, sails.config.session);\n      sails._privateSessionMiddleware = require('express-session')(opts);\n    });\n  }\n  // Otherwise double check the session secret (if one is provided) since it's usually checked\n  // in the session hook.\n  else {\n    // If available, Sails uses the configured session secret for signing cookies.\n    if (sessionSecret) {\n      // Ensure secret is a string.  This check happens in the session hook as well,\n      // but sails.config.session.secret may still be provided even if the session hook\n      // is turned off, so to be extra anal we'll check here as well.\n      if (!_.isString(sessionSecret)) {\n        return cb(new Error('If provided, sails.config.session.secret should be a string.'));\n      }\n    }\n  }\n  if (sessionSecret) {\n    sails._privateCpMware = require('cookie-parser')(sessionSecret);\n  } else {\n    sails._privateCpMware = require('cookie-parser')();\n  }\n\n  // Wipe any existing routes and bind them anew\n  this.flush();\n\n  // Listen for requests\n  sails.on('router:request', this.route);\n\n  // Listen for unhandled errors and unmatched routes\n  sails.on('router:request:500', this.defaultHandlers[500]);\n  sails.on('router:request:404', this.defaultHandlers[404]);\n\n  cb();\n};\n\n\n\n/**\n * `sails.router.route(partialReq, partialRes)`\n *\n * Interpret the specified (usually partial) request and response objects into\n * streams with all of the expected methods, then routes the fully-formed request\n * using the built-in private router. Useful for creating virtual request/response\n * streams from non-HTTP sources, like Socket.io or unit tests.\n *\n * This method is not always helpful-- it is not called for HTTP requests, for instance,\n * since the true HTTP req/res streams already exist.  In that case, at lift-time, Sails\n * calls `router:bind`, which loads Sails' routes as normal middleware/routes in the http hook.\n * stack will run as usual.\n *\n * On the other hand, Socket.io needs to use this method (i.e. the `router:request` event)\n * to simulate a connect-style router since it can't bind dynamic routes ahead of time.\n *\n * Keep in mind that, if `route` is not used, the implementing server is responsible\n * for routing to Sails' default `next(foo)` handler.\n *\n * @param {Request} req\n * @param {Response} res\n * @api private\n */\n\nRouter.prototype.route = function(req, res) {\n  var sails = this.sails;\n  var _privateRouter = this._privateRouter;\n\n  // If sails is `_exiting`, ignore the request.\n  if (sails._exiting) {\n    return;\n  }\n\n  // Provide access to SailsApp instance as `req._sails`.\n  req._sails = req._sails || sails;\n\n  // Note that, at this point, `req` and `res` are just dictionaries containing\n  // the properties of each object that have been built up _so far_.\n  //\n  // Use base req and res definitions to ensure the specified\n  // objects are at least ducktype-able as standard node HTTP\n  // req and req streams.\n  //\n  // Make sure request and response objects have reasonable defaults\n  // (will use the supplied definitions if possible)\n  req = buildReq(req);\n  res = buildRes(req, res);\n\n  // console.log('\\n\\n\\n\\n=======================\\nReceived request to %s %s\\nwith req.body:\\n',req.method,req.url, req.body);\n\n  // Deprecation error:\n  res._cb = function _cbIsDeprecated(err) {\n    throw new Error('As of v0.10, `_cb()` shim is no longer supported in the Sails router.');\n  };\n\n\n  // Run some basic middleware\n  sails.log.silly('Handling virtual request :: Running virtual querystring parser...');\n  qsParser(req,res, function (err) {\n    if (err) {\n      return res.send(400, err && err.stack);\n    }\n\n    // Parse cookies\n    parseCookies(req, res, function(err){\n      if (err) {\n        return res.send(400, err && err.stack);\n      }\n\n      // console.log('Ran cookie parser');\n      // console.log('res.writeHead= ',res.writeHead);\n\n      // Load session (if relevant)\n      loadSession(req, res, function (err) {\n        if (err) {\n          return res.send(400, err && err.stack);\n        }\n        // console.log('res is now:\\n',res);\n        // console.log('\\n\\n');\n        // console.log('Ran session middleware');\n        // console.log('req.sessionID= ',req.sessionID);\n        // console.log('The loaded req.session= ',req.session);\n\n        sails.log.silly('Handling virtual request :: Running virtual body parser...');\n        bodyParser(req,res, function (err) {\n          if (err) {\n            return res.send(400, err && err.stack);\n          }\n\n          // Use our private router to route the request\n          _privateRouter.router(req, res, function handleUnmatchedNext(err) {\n            //\n            // In the event of an unmatched `next()`, `next('foo')`,\n            // or `next('foo', errorCode)`...\n            //\n\n            // Use the default server error handler\n            if (err) {\n              sails.log.silly('Handling virtual request :: Running final \"error\" handler...');\n              sails.emit('router:request:500', err, req, res);\n              return;\n            }\n\n            // Or the default not found handler\n            sails.log.silly('Handling virtual request :: Running final \"not found\" handler...');\n            sails.emit('router:request:404', req, res);\n            return;\n          });\n        });\n      });\n\n    });\n  });\n\n};\n\n\n\n/**\n * `sails.router.bind()`\n *\n * Bind new route(s)\n *\n * @param {String|RegExp} path\n * @param {String|Object|Array|Function} bindTo\n * @param {String} verb\n * @api private\n */\n\nRouter.prototype.bind = require('./bind');\n\n\n\n/**\n * `sails.router.unbind()`\n *\n * Unbind existing route\n *\n * @param {Object} route\n * @api private\n */\n\nRouter.prototype.unbind = function(route) {\n\n  var sails = this.sails;\n\n  // Inform attached servers that route should be unbound\n  sails.emit('router:unbind', route);\n\n  // Remove route in internal router\n  var newRoutes = [];\n  _.each(this._privateRouter.routes[route.method], function(expressRoute) {\n    if (expressRoute.path !== route.path) {\n      newRoutes.push(expressRoute);\n    }\n  });\n  this._privateRouter.routes[route.method] = newRoutes;\n\n};\n\n\n\n/**\n * `sails.router.reset()`\n *\n * Unbind all routes currently attached to the router\n *\n * @api private\n */\n\nRouter.prototype.reset = function() {\n  var sails = this.sails;\n\n  // Unbind everything\n  _.each(this._privateRouter.routes, function(routes, httpMethod) {\n\n    // Unbind each route for the specified HTTP verb\n    var routesToUnbind = this._privateRouter.routes[httpMethod] || [];\n    _.each(routesToUnbind, this.unbind, this);\n\n  }, this);\n\n\n  // Emit reset event to allow attached servers to\n  // unbind all of their routes as well\n  sails.emit('router:reset');\n\n};\n\n\n\n/**\n * `sails.router.flush()`\n *\n * Unbind all current routes, then re-bind everything, re-emitting the routing\n * lifecycle events (e.g. `router:before` and `router:after`)\n *\n * @param {Object} routes - (optional)\n *  If specified, replaces `this.explicitRoutes` before flushing.\n *\n * @api private\n */\n\nRouter.prototype.flush = function(routes) {\n  var sails = this.sails;\n\n  // Wipe routes\n  this.reset();\n\n  // Fired before static routes are bound\n  sails.emit('router:before');\n\n  // If specified, replace `this.explicitRoutes`\n  if (routes) {\n    this.explicitRoutes = routes;\n  }\n\n  // Use specified path to bind static routes\n  _.each(this.explicitRoutes, function(target, path) {\n    this.bind(path, target);\n  }, this);\n\n\n  // Fired after static routes are bound\n  sails.emit('router:after');\n};\n\n\n\n\n\n\n\n\n\n////////////////////////////////////////////////////////////////////////////////////////////////////\n//\n// ||     Private functions\n// \\/\n//\n////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n\n\n\n// Extremely simple query string parser (`req.query`)\nfunction qsParser(req,res,next) {\n  var queryStringPos = req.url.indexOf('?');\n  if (queryStringPos !== -1) {\n    req.query = _.merge(req.query, QS.parse(req.url.substr(queryStringPos + 1)));\n  }\n  else {\n    req.query = req.query || {};\n  }\n  next();\n}\n// Extremely simple body parser (`req.body`)\nfunction bodyParser (req, res, next) {\n\n  // Set up a mock `req.file()` clarifying that req.file() is not available\n  // outside of the context of Skipper (i.e. in this case, most commonly from\n  // socket.io virtual requests).\n  req.file = function fileUploadsNotAvailable(){\n    return res.send(500, 'Streaming file uploads via `req.file()` are only available over HTTP with Skipper.');\n  };\n\n  var bodyBuffer='';\n  if (req.method === 'GET' || req.method === 'HEAD' || req.method === 'DELETE'){\n    req.body = _.extend({}, req.body);\n    return next();\n  }\n\n  // Ensure that `req` is a readable stream at this point\n  if ( ! req instanceof Readable ) {\n    return next(new Error('Sails Internal Error: `req` should be a Readable stream by the time `route()` is called'));\n  }\n\n  req.on('readable', function() {\n    var chunk;\n    while (null !== (chunk = req.read())) {\n      bodyBuffer += chunk;\n    }\n  });\n  req.on('end', function() {\n\n    var parsedBody;\n    try {\n      parsedBody = JSON.parse(bodyBuffer);\n    } catch (e) {}\n\n    req.body = _.merge(req.body, parsedBody);\n    next();\n  });\n}\n\n\n\n\n\n\n\n/**\n * [parseCookies description]\n * @param  {[type]}   req  [description]\n * @param  {[type]}   res  [description]\n * @param  {Function} next [description]\n * @return {[type]}        [description]\n */\nfunction parseCookies (req, res, next){\n\n  // req._sails.log.verbose('Parsing cookie:',req.headers.cookie);\n\n  if (req._sails._privateCpMware) {\n    // Run the middleware\n    return req._sails._privateCpMware(req, res, next);\n  }\n\n  // Otherwise don't even worry about it.\n  return next();\n}\n\n\n\n/**\n * [loadSession description]\n * @param  {[type]}   req  [description]\n * @param  {[type]}   res  [description]\n * @param  {Function} next [description]\n * @return {[type]}        [description]\n */\nfunction loadSession (req, res, next){\n\n  // If a session store is configured, and we haven't deliberately disabled\n  // session support for this request by setting the \"nosession\" header,\n  // hook up the store up as `req.session` by passing it down to the\n  // session middleware.\n  if (req._sails._privateSessionMiddleware && !req.headers.nosession) {\n\n    // Access store preconfigured session middleware as a private property on the app instance.\n    return req._sails._privateSessionMiddleware(req, res, next);\n  }\n\n  // Otherwise don't even worry about it.\n  return next();\n}\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/router/req.js":"/**\n * Module dependencies\n */\n\nvar _ = require('@sailshq/lodash');\nvar defaultsDeep = require('merge-defaults');\nvar MockReq = require('mock-req');\nvar parseurl = require('parseurl');\n\n/**\n * Factory which builds generic Sails request object (i.e. `req`).\n *\n * This generic implementation of `req` forms the basis for\n * Sails' transport-agnostic support of Connect/Express\n * middleware.  Used by hooks (i.e. sockets) but also for\n * tests-- both at the app-level and in Sails core.\n *\n * @param {Dictionary} _req\n *        the properties of this simulated request object that\n *        have been built up _so far_.\n *\n * @return {Request} simulated HTTP request object\n * @idempotent\n */\n\nmodule.exports = function buildRequest (_req) {\n\n  // Make sure _req is not undefined\n  _req = _req||{};\n\n  // Start our request object, which will be built by inheriting/transforming\n  // properties of _req and adding some spice of our own\n  var req;\n\n  // Attempt to parse the URL in _req, so that we can get the querystring\n  // and path\n  var parsedUrl;\n  try {parsedUrl = parseurl(_req) || {};}\n  catch (e) {parsedUrl = {};}\n\n  // If `_req` appears to be a stream (duck-typing), then don't try\n  // and turn it into a mock stream again.\n  if (typeof _req === 'object' && _req.read) {\n    req = _req;\n  }\n  else {\n\n    // TODO: send a PR to mock-req with a fix for this\n    if (_req.headers && typeof _req.headers === 'object') {\n      // Strip undefined headers\n      _.each(_req.headers, function (headerVal, headerKey) {\n        if (_.isUndefined(headerVal)){\n          delete _req.headers[headerKey];\n        }\n      });\n      // Make sure all remaining headers are strings\n      _req.headers = _.mapValues(_req.headers, function (headerVal, headerKey) { // :TODO 'headerKey' is defined but never used\n        if (typeof headerVal !== 'string') {\n          headerVal = ''+headerVal+'';\n        }\n        return headerVal;\n      });\n    }\n\n    // Create a mock IncomingMessage stream.\n    req = new MockReq({\n      method: _req && (_.isString(_req.method) ? _req.method.toUpperCase() : 'GET'),\n      headers: _req && _req.headers || {},\n      url: _req && _req.url\n    });\n\n    // Add .get() and .header() methods to match express 3\n    req.get = req.header = function (name) {\n      switch (name = name.toLowerCase()) {\n      case 'referer':\n      case 'referrer':\n        return this.headers.referrer || this.headers.referer;\n      default:\n        return this.headers[name];\n      }\n    };\n\n    // Now pump client request body to the mock IncomingMessage stream (req)\n    // Req stream ends automatically if this is a GET or HEAD or DELETE request\n    // (since there is no request body in that case) so no need to do it again.\n    if (req.method !== 'GET' && req.method !== 'HEAD' && req.method !== 'DELETE') {\n\n      // Only write the body if there IS a body.\n      if (req.body) {\n        req.write(req.body);\n      }\n      req.end();\n    }\n  }\n\n  // Track request start time\n  req._startTime = new Date();\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // Note that other core methods _could_ be added here for use w/ the virtual\n  // router.  But as per convo w/ dougwilson, the same _cannot_ be done for HTTP\n  // requests coming out of Express.  They would either have to (a) rely on modifying\n  // the HTTP request (IncomingMessage) prototype, or (B) rely on context (i.e. `this`),\n  // which would require `_.bind()`-ing them to avoid issues when triggered from\n  // userland code. And re: (B) at that point, the performance impact is effectively\n  // the same as if they were attached on the fly on a per-request basis.\n  //\n  // So we only initially attach `req.*` methods & properties here which are _not_\n  // already built-in to the mock request, and which are _not_ already taken care of\n  // by hooks, AND which don't rely on `res` (because it hasn't been built yet).\n  ////////////////////////////////////////////////////////////////////////////////\n\n  // Provide defaults for other request state and methods\n  req = defaultsDeep(req, {\n    params: [],\n    query: (_req && _req.query) || require('querystring').parse(parsedUrl.query) || {},\n    body: (_req && _req.body) || {},\n    param: function(paramName, defaultValue) {\n\n      var key, params = {};\n      for (key in (req.params || {}) ) {\n        params[key] = params[key] || req.params[key];\n      }\n      for (key in (req.query || {}) ) {\n        params[key] = params[key] || req.query[key];\n      }\n      for (key in (req.body || {}) ) {\n        params[key] = params[key] || req.body[key];\n      }\n\n      // Grab the value of the parameter from the appropriate place\n      // and return it\n      if (typeof params[paramName] !== 'undefined') {\n        return params[paramName];\n      } else {\n        return defaultValue;\n      }\n\n    },\n    wantsJSON: (_req && _req.wantsJSON === false) ? false : true,\n    method: 'GET',\n    originalUrl: _req.originalUrl || _req.url,\n    path: _req.path || parsedUrl.pathname\n  }, _req||{});\n\n  return req;\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/router/res.js":"/**\n * Module dependencies\n */\nvar util = require('util');\nvar Transform = require('stream').Transform;\nvar _ = require('@sailshq/lodash');\nvar MockRes = require('mock-res');\n\n\n/**\n * Ensure that response object has a minimum set of reasonable defaults\n * Used primarily as a test fixture.\n *\n * @api private\n * @idempotent\n */\n\nmodule.exports = function _buildResponse (req, _res) {\n  _res = _res||{};\n  req = req||{};\n\n  var res;\n\n  // If `_res` appears to be a stream (duck-typing), then don't try\n  // and turn it into a mock stream again.\n  if (typeof _res === 'object' && _res.end) {\n    res = _res;\n  }\n  else {\n    res = new MockRes();\n    delete res.statusCode;\n  }\n\n\n  // Ensure res.headers and res.locals exist.\n  res = _.extend(res, {locals: {}, headers: {}, _headers: {}});\n  res = _.extend(res, _res);\n\n  // Now that we're sure `res` is a Transform stream, we'll handle the two different\n  // approaches which a user of the virtual request interpreter might have taken:\n\n  // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  // (1) Providing a callback function (`_clientCallback`)\n  //\n  // If a `_clientCallback` function was provided, also pipe `res` into a\n  // fake clientRes stream where the response `body` will be buffered.\n  if (res._clientCallback) {\n\n    // If `res._clientRes` WAS NOT provided, then create one\n    if (!res._clientRes) {\n      res._clientRes = new MockClientResponse();\n    }\n\n    // Session is saved automatically since the virtual request interpreter is\n    // using `express-session` directly as of https://github.com/balderdashy/sails/commit/58e93f5a5f2e667e3fbeddf5b4b356f813e3555e.\n\n    // The stream should trigger the callback when it finishes or errors.\n    res._clientRes.on('finish', function() {\n      return res._clientCallback(res._clientRes);\n    });\n    res._clientRes.on('error', function(err) {\n      err = err || new Error('Error on response stream');\n      res._clientRes.statusCode = 500;\n      res._clientRes.body = err;\n      return res._clientCallback(res._clientRes);\n    });\n\n  }\n  // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  // (2) Providing a Writable stream (`_clientRes`)\n  //\n  // If a `_clientRes` response Transform stream was provided, pipe `res` directly to it.\n  if (res._clientRes) {\n    res.pipe(res._clientRes);\n  }\n  //\n  // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n\n  // Track whether headers have been written\n  // (TODO: pull all this into mock-res via a PR)\n\n  // res.writeHead() is wrapped in closure by the `on-header` module,\n  // but it still needs the underlying impl\n  res.writeHead = function ( /* statusCode, [reasonPhrase], headers */) {\n    // console.log('\\n\\n res.writeHead(%s)', Array.prototype.slice.call(arguments));\n    var statusCode = +arguments[0];\n    //TODO: Analyze this code, reasonPhras not used\n    var reasonPhrase = (function(){\n      if (arguments[2] && _.isString(arguments[1])) {\n        return arguments[1];\n      }\n      return undefined;\n    })();\n    var newHeaders = (function (){\n      if (arguments[2] && _.isObject(arguments[2])) {\n        return arguments[2];\n      }\n      return arguments[1];\n    })();\n\n    if (!statusCode) {\n      throw new Error('`statusCode` must be passed to res.writeHead().');\n    }\n    // Set status code\n    res.statusCode = statusCode;\n\n    // Ensure `._headers` have been merged into `.headers`\n    _.extend(res.headers, res._headers);\n\n    if (newHeaders) {\n      if (!_.isObject(newHeaders)) {\n        throw new Error('`headers` must be passed to res.writeHead() as an object. Got: '+util.inspect(newHeaders, false, null));\n      }\n      // Set new headers\n      _.extend(res.headers, newHeaders);\n    }\n\n    // Set status code and headers on the `_clientRes` stream so they are accessible\n    // to the provider of that stream.\n    // (this has to happen in `send()` because the code/headers might have just changed)\n    if (res._clientRes) {\n      // console.log('Setting headers on clientRes- res.headers = ',res.headers);\n      res._clientRes.headers = res.headers;\n      res._clientRes.statusCode = res.statusCode;\n    }\n\n  };\n\n\n  // Wrap res.write() and res.end() to get them to call writeHead()\n  var prevWrite = res.write;\n  res.write = function (){\n    res.writeHead(res.statusCode, _.extend(res._headers,res.headers));\n    // console.log('res.write():: called writeHead with headers=',_.extend(res._headers,res.headers));\n    prevWrite.apply(res, Array.prototype.slice.call(arguments));\n  };\n  var prevEnd = res.end;\n  res.end = function (){\n    res.writeHead(res.statusCode, _.extend(res._headers,res.headers));\n    // console.log('our res.end() was triggered');\n    // console.log('res.end():: called writeHead with headers=',_.extend(res._headers,res.headers));\n    prevEnd.apply(res, Array.prototype.slice.call(arguments));\n  };\n\n\n  // we get `setHeader` from mock-res\n  // see http://nodejs.org/api/http.html#http_response_setheader_name_value\n  //\n  // Usage:\n  // response.setHeader(\"Set-Cookie\", [\"type=ninja\", \"language=javascript\"]);\n\n  // If we ever need to wrap it...\n  //\n  // var prevSetHeader = res.setHeader;\n  // res.setHeader = function (){\n  //   prevSetHeader.apply(res, Array.prototype.slice.call(arguments));\n  // };\n\n  // res.status()\n  res.status = res.status || function status_shim (statusCode) {\n    res.statusCode = statusCode;\n    return res;\n  };\n\n  // res.send()\n  res.send = res.send || function send_shim () {\n    var args = normalizeResArgs(arguments);\n\n    // Don't allow users to respond/redirect more than once per request\n    // TODO: prbly move this check to our `res.writeHead()` impl\n    try {\n      onlyAllowOneResponse(res);\n    }\n    catch (e) {\n      if (req._sails && req._sails.log && req._sails.log.error) {\n        req._sails.log.error(e);\n        return;\n      }\n      // TODO: use debug()\n      console.error(e);\n      return;\n    }\n\n    // Ensure charset is set\n    res.charset = res.charset || 'utf-8';\n\n    // Ensure headers are set\n    _.extend(res.headers, res._headers);\n\n    // Ensure statusCode is set\n    // (override `this.statusCode` if `statusCode` argument specified)\n    res.statusCode = args.statusCode || res.statusCode || 200;\n\n    // if a `_clientCallback` was specified, we'll skip the streaming stuff for res.send().\n    if (res._clientCallback) {\n\n      // Hard-code `res.body` rather than writing to the stream.\n      // (but don't include body if it is empty)\n      if (args.other) {\n        res.body = args.other;\n        // Then expose on res._clientRes.body\n        res._clientRes.body = res.body;\n      }\n\n      // End the `res` stream (which will in turn end the `res._clientRes` stream)\n      res.end();\n      return;\n    }\n\n    //\n    // Otherwise, the hook using the interpreter must have provided us with a `res._clientRes` stream,\n    // so we'll need to serialize everything to work w/ that stream.\n    //\n\n    // console.log('\\n---\\nwriting to clientRes stream...');\n    // console.log('res.headers =>',res.headers);\n    // console.log('res._headers =>',res._headers);\n\n    // Write body to `res` stream\n    if (args.other) {\n\n      var toWrite = args.other;\n\n      if (typeof toWrite === 'object') {\n        try {\n          toWrite = JSON.stringify(args.other);\n\n          // original way:\n          // toWrite = util.inspect(toWrite);\n        }\n        catch(e) {\n          var failedStringify = new Error(\n            'Failed to stringify specified JSON response body :: ' + util.inspect(args.other) +\n            '\\nError:\\n' + util.inspect(e)\n          );\n          // console.log('failed to stringify!');\n          if (req._sails && req._sails.log && req._sails.log.error) {\n            req._sails.log.error(failedStringify);\n          }\n          else {\n            // todo: use debug()\n            console.error(failedStringify);\n          }\n          toWrite = failedStringify.message;\n          res.statusCode = 500;\n        }\n      }\n      res.write(toWrite);\n    }\n\n    // End the `res` stream.\n    res.end();\n  };\n\n  // res.json()\n  res.json = res.json || function json_shim () {\n    var args = normalizeResArgs(arguments);\n    return res.send(args.other, args.statusCode || res.statusCode || 200);\n  };\n\n  // res.render()\n  res.render = res.render || function render_shim (relativeViewPath, locals, cb) {\n    if (_.isFunction(arguments[1])) {\n      cb = arguments[1];\n      locals = {};\n    }\n\n    if (!req._sails) {\n      return  res.send(500, 'Cannot call res.render() - `req._sails` was not attached');\n    }\n    if (!req._sails.renderView) {\n      return res.send(500, 'Cannot call res.render() - `req._sails.renderView` was not attached (perhaps `views` hook is not enabled?)');\n    }\n\n    // TODO:\n    // Instead of this shim, turn `sails.renderView` into something like\n    // `sails.hooks.views.render()`, and then call it.\n    return res.send(501,'Not implemented in core yet');\n  };\n\n  // res.redirect()\n  res.redirect = res.redirect || function redirect_shim () {\n    var args = normalizeResArgs(arguments);\n\n    var address = args.other;\n\n    // Set location header\n    res.set('Location',address);\n\n    // address = this.get('Location');\n    return res.send(args.statusCode || res.statusCode || 302, 'Redirecting to '+encodeURI(address));\n  };\n\n\n\n  /**\n   * res.set( headerName, value )\n   *\n   * @param {[type]} headerName [description]\n   * @param {[type]} value   [description]\n   */\n  res.set = function (headerName, value) {\n    res.headers = res.headers || {};\n    res.headers[headerName] = value;\n    return this;\n  };\n\n  /**\n   * res.get( headerName )\n   *\n   * @param  {[type]} headerName [description]\n   * @return {[type]}            [description]\n   */\n  res.get = function (headerName) {\n    return res.headers && res.headers[headerName];\n  };\n\n\n\n  return res;\n\n\n};\n\n\n/**\n * As long as one of them is a number (i.e. a status code),\n * allows a 2-nary method to be called with flip-flopped arguments:\n *    method( [statusCode|other], [statusCode|other] )\n *\n * This avoids confusing errors & provides Express 2.x backwards compat.\n *\n * E.g. usage in res.send():\n *    var args    = normalizeResArgs.apply(this, arguments),\n *      body    = args.other,\n *      statusCode  = args.statusCode;\n *\n * @api private\n */\nfunction normalizeResArgs( args ) {\n\n  // Traditional usage:\n  // `method( other [,statusCode] )`\n  var isNumeric = function (x) {\n    return (+x === x);\n  };\n  if (isNumeric(args[0])) {\n    return {\n      statusCode: args[0],\n      other: args[1]\n    };\n  }\n  else return {\n    statusCode: args[1],\n    other: args[0]\n  };\n}\n\n\n/**\n * NOTE: ALL RESPONSES (INCLUDING REDIRECTS) ARE PREVENTED ONCE THE RESPONSE HAS BEEN SENT!!\n * Even though this is not strictly required with sockets, since res.redirect()\n * is an HTTP-oriented method from Express, it's important to maintain consistency.\n *\n * @api private\n */\nfunction onlyAllowOneResponse (res) {\n  if (res._virtualResponseStarted) {\n    throw new Error('Cannot write to response more than once');\n  }\n  res._virtualResponseStarted = true;\n}\n\n\n// The constructor for clientRes stream\n// (just a normal transform stream)\nfunction MockClientResponse() {\n  Transform.call(this);\n}\nutil.inherits(MockClientResponse, Transform);\nMockClientResponse.prototype._transform = function(chunk, encoding, next) {\n  this.push(chunk);\n  next();\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/router/bindDefaultHandlers.js":"/**\n * Module dependencies\n */\n\nvar _ = require('@sailshq/lodash');\n\n\n/**\n * Default 500 and 404 handler.\n * (defers to res.serverError() and res.notFound() whenever possible)\n *\n * With default hook configuration, these handlers apply to both HTTP\n * and virtual requests\n */\nmodule.exports = function(sails) {\n\n\n  return {\n\n    /**\n     * Default 500 handler.\n     * (for errors implicitly thrown in middleware/routes)\n     *\n     * @param  {*} err\n     * @param  {Request} req\n     * @param  {Response} res\n     */\n    500: function(err, req, res) {\n\n      // console.log('* * * FIRED DEFAULT HANDLER (500) * * *');\n      // console.log('args:',arguments);\n      // console.log('* * * </FIRED_DEFAULT_HANDLER_500> * * *');\n      // console.log();\n\n      // First, check for special built-in errors from Express.\n      // We don't necessarily want to treat any error that is thrown with\n      // a `status` property of 400 as if it were intentional.  So we also check\n      // the error message.  In Express 5, hopefully this can be improved a bit\n      // further.\n      if (_.isError(err)) {\n        var msgMatches = err.message.match(/^Failed to decode param \\'([^']+)\\'/);\n        if (err.status === 400 && msgMatches) {\n          sails.log.verbose('Bad request: Could not decode the requested URL ('+req.path+')');\n          // Note for future: The problematic URL section is: `msgMatches[1]`\n          return res.send(400, 'Bad request: Could not decode requested URL.');\n        }\n      }//>-\n\n      // Next, try to use `res.negotiate()`, if it exists and is valid.\n      try {\n\n        if (typeof res.negotiate === 'function') {\n          return res.negotiate(err);\n        }//>-\n\n      } catch (e) { /* ignore any unexpected error encountered when attempting to respond w/ res.negotiate(). */ }\n\n      // Catch-all:\n      // Log a message and try to use `res.send` to respond.\n      try {\n\n        sails.log.error('Server Error:');\n        sails.log.error(err);\n        if (process.env.NODE_ENV === 'production') { return res.send(500); }\n        return res.send(500, err);\n\n      } catch (errorSendingResponse) {\n\n        // Serious error occurred-- unable to send response.\n        //\n        // Note that in the future, we could also emit an `abort` message on the request object\n        // in this case-- then if an attached server is managing this request, it could monitor\n        // for `abort` events and manage its private resources (e.g. TCP sockets) accordingly.\n        // However, such contingencies should really handled by the underlying HTTP hook, so\n        // this might not actually make sense.\n        sails.log.error('But no response could be sent because another error occurred:');\n        sails.log.error(errorSendingResponse);\n\n      }//</catch>\n    },\n\n\n\n    /**\n     * Default 404 handler.\n     * (for unmatched routes)\n     *\n     * @param  {Request} req\n     * @param  {Response} res\n     */\n    404: function(req, res) {\n\n      // Use `notFound` handler if it exists\n      try {\n        if (typeof res.notFound === 'function') {\n          return res.notFound();\n        }\n      } catch (e) {}\n\n      // Catch-all:\n      // Log a message and try to use `res.send` to respond.\n      try {\n        sails.log.verbose('A request (%s) did not match any routes, and no `res.notFound` handler is configured.', req.url);\n        res.send(404);\n        return;\n      }\n\n      // Serious error occurred-- unable to send response.\n      //\n      // Note that in the future, we could also emit an `abort` message on the request object\n      // in this case-- then if an attached server is managing this request, it could monitor\n      // for `abort` events and manage its private resources (e.g. TCP sockets) accordingly.\n      // However, such contingencies should really handled by the underlying HTTP hook, so\n      // this might not actually make sense.\n      catch (e) {\n        sails.log.error('An unmatched route was encountered in a request...');\n        sails.log.error('But no response could be sent because an error occurred:');\n        sails.log.error(e);\n        return;\n      }\n    }\n  };\n\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/router/bind.js":"/**\n * Module dependencies.\n */\n\nvar _ = require('@sailshq/lodash');\nvar sailsUtil = require('sails-util');\n\n\n\n/**\n * Expose `bind` method.\n */\nmodule.exports = bind;\n\n\n\n/**\n * Bind new route(s)\n *\n * @param {String|RegExp} path\n * @param {String|Object|Array|Function} target\n * @param {String} verb (optional)\n * @param {Object} options (optional)\n *\n * @this {SJSRouter}\n * @return {SJSApp}\n *\n * @api private\n */\n\nfunction bind( /* path, target, verb, options */ ) {\n  var sails = this.sails;\n\n  var args = sanitize.apply(this, Array.prototype.slice.call(arguments));\n  var path = args.path;\n  var target = args.target;\n  var verb = args.verb;\n  var options = args.options;\n\n  // Don't allow paths with \"length\" as a route param, because Express chokes on it\n  if (path.match(/\\/:length($|\\/)/)) {\n    throw new Error('Failed to bind route: `'+ path +'`\\n'+\n    'Routes which contain `/:length` in their address URL are not supported by Sails/Express (consider using `/:len`)');\n  }\n\n  // Bind a list of multiple functions in order\n  if (_.isArray(target)) {\n    bindArray.apply(this, [path, target, verb, options]);\n  }\n  // Handle string redirects\n  // (to either public-facingURLs or internal routes)\n  else if (_.isString(target) && target.match(/^(https?:|\\/)/)) {\n    bindRedirect.apply(this, [path, target, verb, options]);\n  }\n\n  // Bind a middleware function directly\n  else if (_.isFunction(target)) {\n    bindFunction.apply(this, [path, target, verb, options]);\n  }\n\n  // If target is an object with a `target`, pull out the rest\n  // of the keys as route options and then bind the target.\n  else if (_.isPlainObject(target) && (target.target || target.fn)) {\n    var _target = target.target || target.fn;\n    options = _.merge(options, _.omit(target, 'target'));\n    bind.apply(this, [path, _target, verb, options]);\n  }\n  else {\n\n    // If we make it here, the router doesn't know how to parse the target.\n    //\n    // This doesn't mean that it's necessarily invalid though--\n    // so we'll emit an event informing any listeners that an unrecognized route\n    // target was encountered.  Then hooks can listen to this event and act\n    // accordingly.  This makes it easier to add functionality to Sails.\n    sails.emit('route:typeUnknown', {\n      path: path,\n      target: target,\n      verb: verb,\n      options: options\n    });\n\n    // Note that, in the future, it would be good to track emissions of \"typeUnknown\" to\n    // avoid logic errors that result in circular routes.\n    // (part of the effort to make a more friendly environment for custom hook developers)\n  }\n\n  // Makes `.bind()` chainable (sort of)\n  return sails;\n\n}\n\n\n\n/**\n * Requests will be redirected to the specified string\n * (which should be a URL or redirectable path.)\n *\n * @api private\n */\nfunction bindRedirect(path, redirectTo, verb, options) {\n  var sails = this.sails;\n\n  bind.apply(this,[path, function(req, res) {\n    sails.log.verbose('Redirecting request (`' + path + '`) to `' + redirectTo + '`...');\n    res.redirect(redirectTo);\n  }, verb, options]);\n}\n\n\n/**\n * Recursively bind an array of targets in order\n *\n * TODO: Use a counter to prevent indefinite loops--\n * only possible if a bad route is bound,\n * but would still potentially be helpful.\n *\n * @api private\n */\nfunction bindArray(path, target, verb, options) {\n  var self = this;\n  var sails = this.sails;\n\n  if (target.length === 0) {\n    sails.log.verbose('Ignoring empty array in `router.bind(' + path + ')`...');\n  } else {\n    // Bind each middleware fn\n    _.each(target, function(fn) {\n      bind.apply(self,[path, fn, verb, options]);\n    });\n  }\n}\n\n\n\n/**\n * Attach middleware function to route.\n *\n * @api private\n */\nfunction bindFunction(path, fn, verb, options) {\n  var sails = this.sails;\n\n  // Regex to check if a URL is an asset (something with a file extension)\n  var skipAssetsRegex = /^[^?]*\\/[^?\\/]+\\.[^?\\/]+(\\?.*)?$/;\n\n  // Make sure (optional) options is a valid plain object ({})\n  options = _.isPlainObject(options) ? _.cloneDeep(options) : {};\n  var _middlewareType = options._middlewareType || fn._middlewareType || (fn.name && ('FUNCTION: ' + fn.name));\n  sails.log.silly('Binding route :: ', verb || '', path, _middlewareType?('('+_middlewareType+')'):'');\n\n\n  /**\n   * `router:route`\n   *\n   * Create a closure that emits the `router:route` event each time the route is hit\n   * before actually triggering the target function.\n   *\n   * NOTE: Modifications to route path parameters (i.e. `req.params`) or to `req.options`\n   * must be made here, since their values can change not only on a per-request, but\n   * also a per-route basis.\n   */\n  var enhancedFn = function routeTargetFnWrapper(req, res, next) {\n\n    // Set req.options, using `options` to supply default values\n    req.options = _.merge({}, options || {}, req.options || {});\n\n    // This event can be tapped into to take control of\n    // (synchronous) logic that should be run before each bound\n    // route handler function runs.\n    sails.emit('router:route', {\n      req: req,\n      res: res,\n      next: next,\n      options: options,\n      fn: fn\n    });\n\n\n    // Trigger original route handler function.\n    fn(req, res, next);\n  };\n\n  /**\n   * Wrap a regex route in a helper function that pulls out regex params\n   *\n   * Example: for route: 'r|/\\\\d+/(.*)/(.*)$|foo,bar', the two parenthesized\n   * groups would be pulled out as req.params[0] and req.params[1] by Express;\n   * the regexRouteWrapper would then map them to req.params['foo'] and req.params['bar']\n   *\n   * @param  {array} params List of params to apply to the req.params object\n   * @return {Function} A middleware function\n   */\n  var regexRouteWrapper = function(params) {\n\n    return function(req, res, next) {\n      // Apply the regex route params\n      params.forEach(function(param, index) {\n        req.params[param] = req.params[index];\n      });\n      // Call enhancedFn\n      enhancedFn(req, res, next);\n    };\n  };\n\n  /**\n   * Wrap a route in a helper function that first checks whether the URL matches\n   * any of a set of regexes, and if so, skips the defined handler.\n   *\n   * @param  {array}   regexes Array of regexes to match the URL against\n   * @param  {Function} fn      Middleware function to run if URL does NOT match regexes\n   * @return {Function} A middleware function\n   */\n  var skipRegexesWrapper = function(regexes, fn) {\n\n    // Remove anything that's not a regex\n    regexes = _.compact(regexes.map(function(regex) {\n      if (regex instanceof RegExp) {\n        return regex;\n      }\n      sails.log.warn('Invalid regex \"' + regex + \"' supplied to skipRegexesWrapper; ignoring.\");\n      return undefined;\n    }));\n\n\n    return function(req, res, next) {\n\n      // Check for matches\n      for (var i = 0; i < regexes.length; i++) {\n        if (req.url.match(regexes[i])) {\n          // If we find one, bail out\n          return next();\n        }\n      }\n\n      // Otherwise continue with the handler\n      return fn(req, res, next);\n\n    };\n\n  };\n\n  // If verb is not specified, default to CRUD methods.\n  // You can still explicitly route to \"all /path\" if you want ALLLLlllll the things.\n  var targetVerb = verb || ['get', 'put', 'post', 'delete', 'patch'];\n\n  // Function to actually bind\n  var targetFn;\n\n  // Regex to check if the route is...a regex.\n  var regExRoute = /^r\\|(.*)\\|(.*)$/;\n\n  // Perform the check\n  var matches = path.match(regExRoute);\n\n  // If it *is* a regex, create a RegExp object that Express can bind,\n  // pull out the params, and wrap the handler in regexRouteWrapper\n  if (matches) {\n    path = new RegExp(matches[1]);\n    var params = matches[2].split(',');\n    targetFn = regexRouteWrapper(params);\n  }\n\n  // Otherwise just bind enhancedFn\n  else {\n    targetFn = enhancedFn;\n  }\n\n  // If options.skipRegex is specified, make sure it's an array\n  if (options.skipRegex) {\n    if (!Array.isArray(options.skipRegex)) {\n      options.skipRegex = [options.skipRegex];\n    }\n  }\n  // Otherwise just make it an empty array\n  else {\n    options.skipRegex = [];\n  }\n\n  // If \"skipAssets\" option is true, add the skipAssets regex\n  // to the options.skipRegex array\n  if (options.skipAssets) {\n    options.skipRegex.push(skipAssetsRegex);\n  }\n\n  // If we have anything in the options.skipRegex array, wrap\n  // the target function again.\n  if (options.skipRegex.length) {\n    targetFn = skipRegexesWrapper(options.skipRegex, targetFn);\n  }\n\n  // Ensure targetVerb is an array\n  if (!Array.isArray(targetVerb)) {targetVerb = [targetVerb];}\n  // Loop through the verbs we want to bind\n  targetVerb.forEach(function(verb) {\n    verb = verb.toLowerCase();\n    // Bind the function to the private router\n    sails.router._privateRouter[verb](path, targetFn);\n    // Emit an event to make hooks aware that a route was bound\n    // This allows hooks to handle routes directly if they want to-\n    // e.g. with Express, the handler for this event looks like:\n    // sails.hooks.http.app[verb || 'all'](path, target);\n    sails.emit('router:bind', {\n      path: path,\n      target: targetFn,\n      verb: verb,\n      options: options,\n      originalFn: fn\n    });\n\n  });\n\n\n}\n\n\n\n/**\n * Sanitize the arguments to `sails.router.bind()`\n *\n * @returns {Object} sanitized arguments\n * @api private\n */\nfunction sanitize(path, target, verb, options) {\n  options = options || {};\n\n  // If trying to bind '*', that's probably not what was intended, so fix it up\n  path = path === '*' ? '/*' : path;\n\n  // If route has an HTTP verb (e.g. `get /foo/bar`, `put /bar/foo`, etc.) parse it out,\n  var detectedVerb = sailsUtil.detectVerb(path);\n  // then prune it from the path\n  path = detectedVerb.original;\n  // Keep track of parsed verb so we know if it was specified later\n  options.detectedVerb = detectedVerb;\n\n  // If a verb override was not specified,\n  // use the detected verb from the string route\n  if (!verb) {\n    verb = detectedVerb.verb;\n  }\n\n  return {\n    path: path,\n    target: target,\n    verb: verb,\n    options: options\n  };\n}\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails-util/index.js":"var _ = require('lodash'),\n\tnodeutil = require('util'),\n\tfs = require('fs'),\n\tsafeStringify = require('json-stringify-safe');\n\t_.str = require('underscore.string');\n\n\n\n\n// Extend util with underscore/lodash\n// and underscore.string methods\n_.extend(exports, _);\n\n\n// Merge in util submodules\nvar CLIUtil = require('./cli');\n_.extend(exports, CLIUtil);\n\n\n// Extend with node util methods\n_.extend(exports, nodeutil);\n\n\n/**\n * Accept things like `FooController` or `FoO`, then transform\n * and lower-case them to things like `foo`\n *\n * @api private\n */\n\nexports.normalizeControllerId = function normalizeControllerId (controllerId) {\n\tif (!_.isString(controllerId)) {\n\t\treturn null;\n\t}\n\tcontrollerId = controllerId.replace(/(.+)Controller$/i, '$1');\n\tcontrollerId = controllerId.toLowerCase();\n\treturn controllerId;\n};\n\n\n\n\n\n/**\n * Accept things like `FooAdapter` or `FoO`, then transform\n * and lower-case them to things like `foo`\n *\n * Works for adapters, controllers, and services\n *\n * @api private\n */\n\nexports.normalizeId = function normalizeId (id) {\n\tif (!_.isString(id)) {\n\t\treturn null;\n\t}\n\tid = id.replace(/(.+)(Controller|Adapter|Service)$/i, '$1');\n\tid = id.toLowerCase();\n\treturn id;\n};\n\n\n\n\n\n/**\n * isValidECMA51Variable\n *\n * @param {String} v\n *\n * @api private\n */\n\nexports.isValidECMA51Variable = function(v) {\n\treturn v.match(/^(?!(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$)[$A-Z\\_a-z\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u08a0\\u08a2-\\u08ac\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0977\\u0979-\\u097f\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c33\\u0c35-\\u0c39\\u0c3d\\u0c58\\u0c59\\u0c60\\u0c61\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d60\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f4\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f0\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1877\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191c\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19c1-\\u19c7\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1ce9-\\u1cec\\u1cee-\\u1cf1\\u1cf5\\u1cf6\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2119-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u212d\\u212f-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u2e2f\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309d-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua697\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua78e\\ua790-\\ua793\\ua7a0-\\ua7aa\\ua7f8-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa80-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uabc0-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc][$A-Z\\_a-z\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u08a0\\u08a2-\\u08ac\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0977\\u0979-\\u097f\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c33\\u0c35-\\u0c39\\u0c3d\\u0c58\\u0c59\\u0c60\\u0c61\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d60\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f4\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f0\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1877\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191c\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19c1-\\u19c7\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1ce9-\\u1cec\\u1cee-\\u1cf1\\u1cf5\\u1cf6\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2119-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u212d\\u212f-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u2e2f\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309d-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua697\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua78e\\ua790-\\ua793\\ua7a0-\\ua7aa\\ua7f8-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa80-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uabc0-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc0-9\\u0300-\\u036f\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u0669\\u0670\\u06d6-\\u06dc\\u06df-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u06f0-\\u06f9\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07c0-\\u07c9\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0859-\\u085b\\u08e4-\\u08fe\\u0900-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09cd\\u09d7\\u09e2\\u09e3\\u09e6-\\u09ef\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2\\u0ae3\\u0ae6-\\u0aef\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c01-\\u0c03\\u0c3e-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0c66-\\u0c6f\\u0c82\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0ce6-\\u0cef\\u0d02\\u0d03\\u0d3e-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4d\\u0d57\\u0d62\\u0d63\\u0d66-\\u0d6f\\u0d82\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0df2\\u0df3\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0e50-\\u0e59\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e\\u0f3f\\u0f71-\\u0f84\\u0f86\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102b-\\u103e\\u1040-\\u1049\\u1056-\\u1059\\u105e-\\u1060\\u1062-\\u1064\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b4-\\u17d3\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u18a9\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u194f\\u19b0-\\u19c0\\u19c8\\u19c9\\u19d0-\\u19d9\\u1a17-\\u1a1b\\u1a55-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1b00-\\u1b04\\u1b34-\\u1b44\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1b82\\u1ba1-\\u1bad\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c24-\\u1c37\\u1c40-\\u1c49\\u1c50-\\u1c59\\u1cd0-\\u1cd2\\u1cd4-\\u1ce8\\u1ced\\u1cf2-\\u1cf4\\u1dc0-\\u1de6\\u1dfc-\\u1dff\\u200c\\u200d\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2cef-\\u2cf1\\u2d7f\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua620-\\ua629\\ua66f\\ua674-\\ua67d\\ua69f\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua823-\\ua827\\ua880\\ua881\\ua8b4-\\ua8c4\\ua8d0-\\ua8d9\\ua8e0-\\ua8f1\\ua900-\\ua909\\ua926-\\ua92d\\ua947-\\ua953\\ua980-\\ua983\\ua9b3-\\ua9c0\\ua9d0-\\ua9d9\\uaa29-\\uaa36\\uaa43\\uaa4c\\uaa4d\\uaa50-\\uaa59\\uaa7b\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uaaeb-\\uaaef\\uaaf5\\uaaf6\\uabe3-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe26\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f]*$/);\n};\n\n\n\n\n\n\n/**\n * defaultsDeep\n *\n * Implement a deep version of `_.defaults`.\n *\n * @api private\n */\n\nexports.defaultsDeep = _.partialRight(_.merge, _.defaults);\n\n\n\n\n\n\n/**\n * Normalize an error or array of errors into an array of proper, readable Errors\n *\n * @param {String|Object|Error|Array} errOrErrs\n * @returns {Array[Error]}\n *\n * @api private\n */\n\nexports.normalizeErrors = function normalizeErrors(errOrErrs) {\n\n\t// If `errOrErrs` is not an array already, make it one\n\tvar errorsToDisplay = _.isArray(errOrErrs) ? errOrErrs : [errOrErrs];\n\n\t// Ensure that each error is formatted correctly\n\treturn _.map(errorsToDisplay, function (e, i) {\n\t\tvar displayError;\n\n\t\t// Make error easier to read, and normalize its type\n\t\tif (e instanceof Error) {\n\t\t\tdisplayError = e;\n\t\t}\n\n\t\t// Create an error ad hoc\n\t\t// (but save reference to original)\n\t\telse {\n\t\t\tdisplayError = new Error( nodeutil.inspect(e) );\n\t\t\tdisplayError.original = e;\n\t\t}\n\n\t\treturn displayError;\n\t});\n};\n\n\n\n\n\n\n/**\n * Detect HTTP verb in an expression like:\n * `get baz`    or     `get /foo/baz`\n *\n * @api private\n */\n\nexports.detectVerb = function (haystack) {\n\tvar verbExpr = /^(all|get|post|put|delete|trace|options|connect|patch|head)\\s+/i;\n\tvar verbSpecified = _.last(haystack.match(verbExpr) || []) || '';\n\tverbSpecified = verbSpecified.toLowerCase();\n\n\t// If a verb was specified, eliminate the verb from the original string\n\tif (verbSpecified) {\n\t\thaystack = haystack.replace(verbExpr,'');\n\t}\n\n\treturn {\n\t\tverb: verbSpecified,\n\t\toriginal: haystack,\n\t\tpath: haystack\n\t};\n};\n\n\n\n\n\n\n\n/**\n * pluralize\n *\n * Run a method meant for a single object on a single instance OR array.\n * For a list, run the method on each item return the resulting array.\n * For anything else, return it silently.\n *\n * @api private\n */\n\nexports.pluralize = function pluralize(collection, application) {\n\tif(_.isArray(collection)) {\n\t\treturn _.map(collection, application);\n\t}\n\treturn application(collection);\n};\n\n\n\n\n\n\n/**\n * Detect if a string is \"safe\" to eval()\n *\n * @api private\n */\n\nexports.safeToEval = function(someString) {\n\ttry {\n\t\t!(/[^,:{}\\[\\]0-9.\\-+Eaeflnr-u \\n\\r\\t]/.test(someString.replace(/\"(\\\\.|[^\"\\\\])*\"/g, ''))) && eval('(' + someString + ')');\n\t} catch(e) {\n\t\treturn false;\n\t}\n\treturn true;\n};\n\n\n\n\n\n\n/**\n * Return whether the specified item is an object, but NOT an array or function\n *\n * TODO:\treplace usages of this method with `instanceof`\n *\t\t\tand `_.isPlainObject()`\n *\n * @api private\n *\n * @api private\n */\nexports.isDictionary = function isDictionary(thing) {\n\treturn _.isObject(thing) && !_.isArray(thing) && !_.isFunction(thing);\n};\n\n\n\n\n\n\n\n\n/**\n * optional\n *\n * Wrap a callback function to make it optional\n *\n * @api private\n */\n\nexports.optional = function wrapOptionalCallback (cb) {\n\tif ( _.isFunction(cb) ) return cb;\n\treturn function _noOp (){};\n\n\t// return function optionalCallback () {\n\t// \tif (!cb) return;\n\t// \tvar args = Array.prototype.slice.call(arguments);\n\t// \treturn cb.apply(this, args);\n\t// };\n};\n\n\n\n\n/**\n * Get the domain out of the origin header--\n * compare it to the host\n *\n * @api private\n */\n\nexports.isSameOrigin = function isSameOrigin(req, strict) {\n\n\t// If there's no origin header, consider it same origin unless\n\t// we're in strict mode\n\tif (!req.headers.origin) {\n\t\treturn !strict;\n\t}\n\n\t// Get the domain and port out of the origin header\n\tvar matches = req.headers.origin.match(/^https?:\\/\\/([^:]+)(:(\\d+))?$/);\n\t// If the origin doesn't match the regex, consider it okay if we're not\n\t// in strict mode--this will allow non-http origins like \"chrome-extension://\"\n\tif (matches === null) {\n\t\treturn !strict;\n\t}\n\tvar domain = matches[1];\n\tvar port = matches[3];\n\n\t// Compare it to the host\n\treturn (req.host == domain && (!port || req.port == port));\n};\n\n\n\n\n/**\n * Return whether the given object is an instance of Error\n *\n * @api private\n */\n\nexports.isError = function (e) {\n\treturn e instanceof Error;\n};\n\n\n\n\n\n/**\n * Extract the file extension suffix from a filename or path\n *\n * @api private\n */\n\nexports.fileExtension = function(str) {\n\tif(str === null) return '';\n\tvar pieces = String(str).split('.');\n\treturn pieces.length > 1 ? _.last(pieces) : '';\n};\n\n\n\n\n/**\n * Return the abbreviated ordinal string for a given integer\n *\n * http://en.wikipedia.org/wiki/Ordinal_number_(linguistics)\n * i.e. prettier rendering of things like: 1st, 2nd, 3rd, 4th\n *\n * @api private\n */\n\nexports.ordinal = function(integer) {\n\tif(_.isFinite(+integer) && Math.floor(+integer) === +integer) {\n\t\tvar lastDigit = +integer % 10;\n\t\tvar lastTwoDigits = +integer % 100;\n\t\tvar response = integer + \"\";\n\n\t\t// Handle n-teen case\n\t\tif(lastTwoDigits >= 11 && lastTwoDigits <= 13) {\n\t\t\treturn response + \"th\";\n\t\t}\n\n\t\t// Handle general case\n\t\tswitch(lastDigit) {\n\t\tcase 1:\n\t\t\treturn response + \"st\";\n\t\tcase 2:\n\t\t\treturn response + \"nd\";\n\t\tcase 3:\n\t\t\treturn response + \"rd\";\n\t\tdefault:\n\t\t\treturn response + \"th\";\n\t\t}\n\t}\n\tthrow new Error(\"sails.util.ordinal() only works on integers!\");\n};\n\n\n\n\n\n/**\n * Get the names of a function's arguments\n *\n * @param {Function} func\n * @returns array of argument names, e.g. ['req', 'res']\n *\n * @api private\n */\nexports.getParamNames = function(func) {\n\n\tvar STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg;\n\tvar fnStr = func.toString().replace(STRIP_COMMENTS, '');\n\tvar result = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).match(/([^\\s,]+)/g);\n\tif (result === null)\n\t\tresult = [];\n\treturn result;\n};\n\n\n\n\n/**\n * parseJSONFile\n *\n * Read a json file at the specified path.\n * If an error occurs, call cb(err), and dont throw!\n *\n * @api private\n */\n\nexports.parseJSONFile = function ( path, cb ) {\n\tif (!cb) throw new Error('Callback required!');\n\tif (cb === 'sync') {\n\t\tvar jsonString;\n\t\ttry {\n\t\t\tjsonString = fs.readFileSync(path, 'utf-8');\n\t\t}\n\t\tcatch (e) {\n\t\t\treturn false;\n\t\t}\n\t\treturn andThen(jsonString);\n\t}\n\tfs.readFile(path, 'utf-8', function (err, file) {\n\t\tif (err) return cb(err);\n\t\tandThen(file);\n\t});\n\n\t// Attempt to parse JSON, then return\n\tfunction andThen( json ) {\n\t\tvar err;\n\t\ttry {\n\t\t\tjson = JSON.parse(json);\n\t\t} catch (e) {\n\t\t\terr = e;\n\t\t\tjson = false;\n\t\t}\n\n\t\t// Parse failed:\n\t\tif (err) {\n\t\t\tif (cb==='sync') return false;\n\t\t\telse return cb(err);\n\t\t}\n\n\t\t// Success:\n\t\tif ( cb === 'sync' ) return json;\n\t\treturn cb(null, json);\n\t}\n};\n\n/**\n * getJSONFileSync\n *\n * Synchronous version of getJSONFile()\n * Returns false if json file cannot be read or parsed.\n *\n * @api private\n */\n\nexports.parseJSONFileSync = function ( path ) {\n\treturn exports.parseJSONFile(path, 'sync');\n};\n\n\n\n\n/**\n * getPackage\n *\n * Read package.json file in the directory at the specified\n * path.  If an error occurs, call cb(err), and dont throw!\n *\n * @api private\n */\n\nexports.getPackage = function (path, cb) {\n\tpath = _.str.rtrim(path, '/');\n\tpath += '/package.json';\n\n\texports.parseJSONFile(path, function (err, json) {\n\t\tif (err) return cb(err);\n\n\t\t// Success:\n\t\t// Ensure dependencies are at least an empty object\n\t\tjson.dependencies = json.dependencies || {};\n\t\tif ( cb === 'sync' ) return json;\n\t\treturn cb(null, json);\n\t});\n};\n\n\n\n\n\n\n/**\n * getPackageSync\n *\n * Synchronous version of getPackage()\n * Returns false if package.json cannot be read or parsed.\n *\n * @api private\n */\n\nexports.getPackageSync = function (path) {\n\tpath = _.str.rtrim(path, '/');\n\tpath += '/package.json';\n\n\t// Success:\n\t// Ensure dependencies are at least an empty object\n\tvar json = exports.parseJSONFileSync(path, 'sync');\n\tif (!json) return json;\n\tjson.dependencies = json.dependencies || {};\n\treturn json;\n};\n\n\n\n\n/**\n * Get path to the home directory in an OS-agnostic way\n *\n * @api private\n */\n\nexports.homeDirectory = function () {\n\treturn process.env[\n\t\t(process.platform == 'win32') ?\n\t\t'USERPROFILE' :\n\t\t'HOME'\n\t];\n};\n\n\n\n\n\n/**\n * tolerantParse\n *\n * Parse specified JSON, but if it fails,\n * return false instead of throwing.\n *\n * @api private\n */\n\nexports.tolerantParse = function ( json ) {\n\tvar args = Array.prototype.slice.call(arguments);\n\ttry {\n\t\treturn JSON.parse.apply(this, args);\n\t} catch (e) {\n\t\treturn false;\n\t}\n};\n\n\n\n\n\n/**\n * Wrapper for @isaacs' `json-stringify-safe`\n *\n * Automatically handles circular references.\n * See: https://github.com/isaacs/json-stringify-safe\n *\n * If stringification doesn't work, instead of throwing,\n * return false.\n *\n * @api private\n */\nexports.stringify = function ( json, serializer, indent, decycler ) {\n\tvar args = Array.prototype.slice.call(arguments);\n\ttry {\n\t\treturn safeStringify.apply(this, args);\n\t}\n\tcatch (e) {\n\t\treturn false;\n\t}\n};\n\n\n\n\n\n\n\n// Underscore extensions for objects\n_.extend(exports,{\n\n\n\n\t/**\n\t * _.objMap\n\t *\n\t * _.map for objects, keeps key/value associations\n\t *\n\t * @api private\n\t */\n\n\tobjMap: function(input, mapper, context) {\n\t\treturn _.reduce(input, function(obj, v, k) {\n\t\t\tobj[k] = mapper.call(context, v, k, input);\n\t\t\treturn obj;\n\t\t}, {}, context);\n\t},\n\n\n\n\n\t/**\n\t * _.objFilter\n\t *\n\t * _.filter for objects, keeps key/value associations\n\t * but only includes the properties that pass test().\n\t *\n\t * @api private\n\t */\n\n\tobjFilter: function(input, test, context) {\n\t\treturn _.reduce(input, function(obj, v, k) {\n\t\t\tif(test.call(context, v, k, input)) {\n\t\t\t\tobj[k] = v;\n\t\t\t}\n\t\t\treturn obj;\n\t\t}, {}, context);\n\t},\n\n\n\n\n\t/**\n\t * _.objReject\n\t *\n\t * _.reject for objects, keeps key/value associations\n\t * but does not include the properties that pass test().\n\t *\n\t * @api private\n\t */\n\n\tobjReject: function(input, test, context) {\n\t\treturn _.reduce(input, function(obj, v, k) {\n\t\t\tif(!test.call(context, v, k, input)) {\n\t\t\t\tobj[k] = v;\n\t\t\t}\n\t\t\treturn obj;\n\t\t}, {}, context);\n\t},\n\n\n\n\t/**\n\t * _.objInvoke\n\t *\n\t * Usage:\n\t *\tobj -> the object\n\t *\targuments* -> other arguments can be specified to be invoked on each of the functions\n\t *\n\t * @api private\n\t */\n\n\tobjInvoke: function(obj) {\n\t\tvar args = _.toArray(arguments).shift();\n\t\treturn exports.objMap(obj, function(fn) {\n\t\t\treturn fn(args);\n\t\t});\n\t},\n\n\t/**\n\t * _.objCompact\n\t *\n\t * _.compact for objects; keeps only keys whose values are not undefined\n\t *\tobj -> the object\n\t *\tstrict -> if \"true\", only keep keys whose values are falsy\n\t *\n\t * @api private\n\t */\n\tobjCompact: function(obj, strict) {\n\t\tobj = _.reduce(obj, function(memo, value, paramName) {\n\t\t\tif (strict) {\n\t\t\t\tif (value !== undefined && value !== null && value !== false && value !== '') {\n\t\t\t\t\tmemo[paramName] = value;\n\t\t\t\t}\n\t\t\t} else if (value !== undefined) {\n        \t\tmemo[paramName] = value;\n      \t\t}\n      \t\treturn memo;\n    \t}, {});\n    \treturn obj;\n\t},\n\n\t/**\n\t * _.objDeref\n\t *\n\t * Safely dereference an object given a path\n\t * @param  {object} obj  The object to dereference\n\t * @param  {string} path The dot-delimited path to use\n\t * @return {mixed}      The value of the object at that path, or undefined\n\t */\n\tobjDeref: function(obj, path) {\n\t\treturn path.split('.').reduce(_objDeref, obj);\n\t}\n\n});\n\nfunction _objDeref(obj,i) {return (typeof obj == 'object' && obj !== null) ? obj[i] : undefined;}","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails-util/node_modules/underscore.string/lib/underscore.string.js":"//  Underscore.string\n//  (c) 2010 Esa-Matti Suuronen <esa-matti aet suuronen dot org>\n//  Underscore.string is freely distributable under the terms of the MIT license.\n//  Documentation: https://github.com/epeli/underscore.string\n//  Some code is borrowed from MooTools and Alexandru Marasteanu.\n//  Version '2.3.2'\n\n!function(root, String){\n  'use strict';\n\n  // Defining helper functions.\n\n  var nativeTrim = String.prototype.trim;\n  var nativeTrimRight = String.prototype.trimRight;\n  var nativeTrimLeft = String.prototype.trimLeft;\n\n  var parseNumber = function(source) { return source * 1 || 0; };\n\n  var strRepeat = function(str, qty){\n    if (qty < 1) return '';\n    var result = '';\n    while (qty > 0) {\n      if (qty & 1) result += str;\n      qty >>= 1, str += str;\n    }\n    return result;\n  };\n\n  var slice = [].slice;\n\n  var defaultToWhiteSpace = function(characters) {\n    if (characters == null)\n      return '\\\\s';\n    else if (characters.source)\n      return characters.source;\n    else\n      return '[' + _s.escapeRegExp(characters) + ']';\n  };\n\n  // Helper for toBoolean\n  function boolMatch(s, matchers) {\n    var i, matcher, down = s.toLowerCase();\n    matchers = [].concat(matchers);\n    for (i = 0; i < matchers.length; i += 1) {\n      matcher = matchers[i];\n      if (!matcher) continue;\n      if (matcher.test && matcher.test(s)) return true;\n      if (matcher.toLowerCase() === down) return true;\n    }\n  }\n\n  var escapeChars = {\n    lt: '<',\n    gt: '>',\n    quot: '\"',\n    amp: '&',\n    apos: \"'\"\n  };\n\n  var reversedEscapeChars = {};\n  for(var key in escapeChars) reversedEscapeChars[escapeChars[key]] = key;\n  reversedEscapeChars[\"'\"] = '#39';\n\n  // sprintf() for JavaScript 0.7-beta1\n  // http://www.diveintojavascript.com/projects/javascript-sprintf\n  //\n  // Copyright (c) Alexandru Marasteanu <alexaholic [at) gmail (dot] com>\n  // All rights reserved.\n\n  var sprintf = (function() {\n    function get_type(variable) {\n      return Object.prototype.toString.call(variable).slice(8, -1).toLowerCase();\n    }\n\n    var str_repeat = strRepeat;\n\n    var str_format = function() {\n      if (!str_format.cache.hasOwnProperty(arguments[0])) {\n        str_format.cache[arguments[0]] = str_format.parse(arguments[0]);\n      }\n      return str_format.format.call(null, str_format.cache[arguments[0]], arguments);\n    };\n\n    str_format.format = function(parse_tree, argv) {\n      var cursor = 1, tree_length = parse_tree.length, node_type = '', arg, output = [], i, k, match, pad, pad_character, pad_length;\n      for (i = 0; i < tree_length; i++) {\n        node_type = get_type(parse_tree[i]);\n        if (node_type === 'string') {\n          output.push(parse_tree[i]);\n        }\n        else if (node_type === 'array') {\n          match = parse_tree[i]; // convenience purposes only\n          if (match[2]) { // keyword argument\n            arg = argv[cursor];\n            for (k = 0; k < match[2].length; k++) {\n              if (!arg.hasOwnProperty(match[2][k])) {\n                throw new Error(sprintf('[_.sprintf] property \"%s\" does not exist', match[2][k]));\n              }\n              arg = arg[match[2][k]];\n            }\n          } else if (match[1]) { // positional argument (explicit)\n            arg = argv[match[1]];\n          }\n          else { // positional argument (implicit)\n            arg = argv[cursor++];\n          }\n\n          if (/[^s]/.test(match[8]) && (get_type(arg) != 'number')) {\n            throw new Error(sprintf('[_.sprintf] expecting number but found %s', get_type(arg)));\n          }\n          switch (match[8]) {\n            case 'b': arg = arg.toString(2); break;\n            case 'c': arg = String.fromCharCode(arg); break;\n            case 'd': arg = parseInt(arg, 10); break;\n            case 'e': arg = match[7] ? arg.toExponential(match[7]) : arg.toExponential(); break;\n            case 'f': arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg); break;\n            case 'o': arg = arg.toString(8); break;\n            case 's': arg = ((arg = String(arg)) && match[7] ? arg.substring(0, match[7]) : arg); break;\n            case 'u': arg = Math.abs(arg); break;\n            case 'x': arg = arg.toString(16); break;\n            case 'X': arg = arg.toString(16).toUpperCase(); break;\n          }\n          arg = (/[def]/.test(match[8]) && match[3] && arg >= 0 ? '+'+ arg : arg);\n          pad_character = match[4] ? match[4] == '0' ? '0' : match[4].charAt(1) : ' ';\n          pad_length = match[6] - String(arg).length;\n          pad = match[6] ? str_repeat(pad_character, pad_length) : '';\n          output.push(match[5] ? arg + pad : pad + arg);\n        }\n      }\n      return output.join('');\n    };\n\n    str_format.cache = {};\n\n    str_format.parse = function(fmt) {\n      var _fmt = fmt, match = [], parse_tree = [], arg_names = 0;\n      while (_fmt) {\n        if ((match = /^[^\\x25]+/.exec(_fmt)) !== null) {\n          parse_tree.push(match[0]);\n        }\n        else if ((match = /^\\x25{2}/.exec(_fmt)) !== null) {\n          parse_tree.push('%');\n        }\n        else if ((match = /^\\x25(?:([1-9]\\d*)\\$|\\(([^\\)]+)\\))?(\\+)?(0|'[^$])?(-)?(\\d+)?(?:\\.(\\d+))?([b-fosuxX])/.exec(_fmt)) !== null) {\n          if (match[2]) {\n            arg_names |= 1;\n            var field_list = [], replacement_field = match[2], field_match = [];\n            if ((field_match = /^([a-z_][a-z_\\d]*)/i.exec(replacement_field)) !== null) {\n              field_list.push(field_match[1]);\n              while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {\n                if ((field_match = /^\\.([a-z_][a-z_\\d]*)/i.exec(replacement_field)) !== null) {\n                  field_list.push(field_match[1]);\n                }\n                else if ((field_match = /^\\[(\\d+)\\]/.exec(replacement_field)) !== null) {\n                  field_list.push(field_match[1]);\n                }\n                else {\n                  throw new Error('[_.sprintf] huh?');\n                }\n              }\n            }\n            else {\n              throw new Error('[_.sprintf] huh?');\n            }\n            match[2] = field_list;\n          }\n          else {\n            arg_names |= 2;\n          }\n          if (arg_names === 3) {\n            throw new Error('[_.sprintf] mixing positional and named placeholders is not (yet) supported');\n          }\n          parse_tree.push(match);\n        }\n        else {\n          throw new Error('[_.sprintf] huh?');\n        }\n        _fmt = _fmt.substring(match[0].length);\n      }\n      return parse_tree;\n    };\n\n    return str_format;\n  })();\n\n\n\n  // Defining underscore.string\n\n  var _s = {\n\n    VERSION: '2.3.0',\n\n    isBlank: function(str){\n      if (str == null) str = '';\n      return (/^\\s*$/).test(str);\n    },\n\n    stripTags: function(str){\n      if (str == null) return '';\n      return String(str).replace(/<\\/?[^>]+>/g, '');\n    },\n\n    capitalize : function(str){\n      str = str == null ? '' : String(str);\n      return str.charAt(0).toUpperCase() + str.slice(1);\n    },\n\n    chop: function(str, step){\n      if (str == null) return [];\n      str = String(str);\n      step = ~~step;\n      return step > 0 ? str.match(new RegExp('.{1,' + step + '}', 'g')) : [str];\n    },\n\n    clean: function(str){\n      return _s.strip(str).replace(/\\s+/g, ' ');\n    },\n\n    count: function(str, substr){\n      if (str == null || substr == null) return 0;\n\n      str = String(str);\n      substr = String(substr);\n\n      var count = 0,\n        pos = 0,\n        length = substr.length;\n\n      while (true) {\n        pos = str.indexOf(substr, pos);\n        if (pos === -1) break;\n        count++;\n        pos += length;\n      }\n\n      return count;\n    },\n\n    chars: function(str) {\n      if (str == null) return [];\n      return String(str).split('');\n    },\n\n    swapCase: function(str) {\n      if (str == null) return '';\n      return String(str).replace(/\\S/g, function(c){\n        return c === c.toUpperCase() ? c.toLowerCase() : c.toUpperCase();\n      });\n    },\n\n    escapeHTML: function(str) {\n      if (str == null) return '';\n      return String(str).replace(/[&<>\"']/g, function(m){ return '&' + reversedEscapeChars[m] + ';'; });\n    },\n\n    unescapeHTML: function(str) {\n      if (str == null) return '';\n      return String(str).replace(/\\&([^;]+);/g, function(entity, entityCode){\n        var match;\n\n        if (entityCode in escapeChars) {\n          return escapeChars[entityCode];\n        } else if (match = entityCode.match(/^#x([\\da-fA-F]+)$/)) {\n          return String.fromCharCode(parseInt(match[1], 16));\n        } else if (match = entityCode.match(/^#(\\d+)$/)) {\n          return String.fromCharCode(~~match[1]);\n        } else {\n          return entity;\n        }\n      });\n    },\n\n    escapeRegExp: function(str){\n      if (str == null) return '';\n      return String(str).replace(/([.*+?^=!:${}()|[\\]\\/\\\\])/g, '\\\\$1');\n    },\n\n    splice: function(str, i, howmany, substr){\n      var arr = _s.chars(str);\n      arr.splice(~~i, ~~howmany, substr);\n      return arr.join('');\n    },\n\n    insert: function(str, i, substr){\n      return _s.splice(str, i, 0, substr);\n    },\n\n    include: function(str, needle){\n      if (needle === '') return true;\n      if (str == null) return false;\n      return String(str).indexOf(needle) !== -1;\n    },\n\n    join: function() {\n      var args = slice.call(arguments),\n        separator = args.shift();\n\n      if (separator == null) separator = '';\n\n      return args.join(separator);\n    },\n\n    lines: function(str) {\n      if (str == null) return [];\n      return String(str).split(\"\\n\");\n    },\n\n    reverse: function(str){\n      return _s.chars(str).reverse().join('');\n    },\n\n    startsWith: function(str, starts){\n      if (starts === '') return true;\n      if (str == null || starts == null) return false;\n      str = String(str); starts = String(starts);\n      return str.length >= starts.length && str.slice(0, starts.length) === starts;\n    },\n\n    endsWith: function(str, ends){\n      if (ends === '') return true;\n      if (str == null || ends == null) return false;\n      str = String(str); ends = String(ends);\n      return str.length >= ends.length && str.slice(str.length - ends.length) === ends;\n    },\n\n    succ: function(str){\n      if (str == null) return '';\n      str = String(str);\n      return str.slice(0, -1) + String.fromCharCode(str.charCodeAt(str.length-1) + 1);\n    },\n\n    titleize: function(str){\n      if (str == null) return '';\n      str  = String(str).toLowerCase();\n      return str.replace(/(?:^|\\s|-)\\S/g, function(c){ return c.toUpperCase(); });\n    },\n\n    camelize: function(str){\n      return _s.trim(str).replace(/[-_\\s]+(.)?/g, function(match, c){ return c ? c.toUpperCase() : \"\"; });\n    },\n\n    underscored: function(str){\n      return _s.trim(str).replace(/([a-z\\d])([A-Z]+)/g, '$1_$2').replace(/[-\\s]+/g, '_').toLowerCase();\n    },\n\n    dasherize: function(str){\n      return _s.trim(str).replace(/([A-Z])/g, '-$1').replace(/[-_\\s]+/g, '-').toLowerCase();\n    },\n\n    classify: function(str){\n      return _s.titleize(String(str).replace(/[\\W_]/g, ' ')).replace(/\\s/g, '');\n    },\n\n    humanize: function(str){\n      return _s.capitalize(_s.underscored(str).replace(/_id$/,'').replace(/_/g, ' '));\n    },\n\n    trim: function(str, characters){\n      if (str == null) return '';\n      if (!characters && nativeTrim) return nativeTrim.call(str);\n      characters = defaultToWhiteSpace(characters);\n      return String(str).replace(new RegExp('\\^' + characters + '+|' + characters + '+$', 'g'), '');\n    },\n\n    ltrim: function(str, characters){\n      if (str == null) return '';\n      if (!characters && nativeTrimLeft) return nativeTrimLeft.call(str);\n      characters = defaultToWhiteSpace(characters);\n      return String(str).replace(new RegExp('^' + characters + '+'), '');\n    },\n\n    rtrim: function(str, characters){\n      if (str == null) return '';\n      if (!characters && nativeTrimRight) return nativeTrimRight.call(str);\n      characters = defaultToWhiteSpace(characters);\n      return String(str).replace(new RegExp(characters + '+$'), '');\n    },\n\n    truncate: function(str, length, truncateStr){\n      if (str == null) return '';\n      str = String(str); truncateStr = truncateStr || '...';\n      length = ~~length;\n      return str.length > length ? str.slice(0, length) + truncateStr : str;\n    },\n\n    /**\n     * _s.prune: a more elegant version of truncate\n     * prune extra chars, never leaving a half-chopped word.\n     * @author github.com/rwz\n     */\n    prune: function(str, length, pruneStr){\n      if (str == null) return '';\n\n      str = String(str); length = ~~length;\n      pruneStr = pruneStr != null ? String(pruneStr) : '...';\n\n      if (str.length <= length) return str;\n\n      var tmpl = function(c){ return c.toUpperCase() !== c.toLowerCase() ? 'A' : ' '; },\n        template = str.slice(0, length+1).replace(/.(?=\\W*\\w*$)/g, tmpl); // 'Hello, world' -> 'HellAA AAAAA'\n\n      if (template.slice(template.length-2).match(/\\w\\w/))\n        template = template.replace(/\\s*\\S+$/, '');\n      else\n        template = _s.rtrim(template.slice(0, template.length-1));\n\n      return (template+pruneStr).length > str.length ? str : str.slice(0, template.length)+pruneStr;\n    },\n\n    words: function(str, delimiter) {\n      if (_s.isBlank(str)) return [];\n      return _s.trim(str, delimiter).split(delimiter || /\\s+/);\n    },\n\n    pad: function(str, length, padStr, type) {\n      str = str == null ? '' : String(str);\n      length = ~~length;\n\n      var padlen  = 0;\n\n      if (!padStr)\n        padStr = ' ';\n      else if (padStr.length > 1)\n        padStr = padStr.charAt(0);\n\n      switch(type) {\n        case 'right':\n          padlen = length - str.length;\n          return str + strRepeat(padStr, padlen);\n        case 'both':\n          padlen = length - str.length;\n          return strRepeat(padStr, Math.ceil(padlen/2)) + str\n                  + strRepeat(padStr, Math.floor(padlen/2));\n        default: // 'left'\n          padlen = length - str.length;\n          return strRepeat(padStr, padlen) + str;\n        }\n    },\n\n    lpad: function(str, length, padStr) {\n      return _s.pad(str, length, padStr);\n    },\n\n    rpad: function(str, length, padStr) {\n      return _s.pad(str, length, padStr, 'right');\n    },\n\n    lrpad: function(str, length, padStr) {\n      return _s.pad(str, length, padStr, 'both');\n    },\n\n    sprintf: sprintf,\n\n    vsprintf: function(fmt, argv){\n      argv.unshift(fmt);\n      return sprintf.apply(null, argv);\n    },\n\n    toNumber: function(str, decimals) {\n      if (!str) return 0;\n      str = _s.trim(str);\n      if (!str.match(/^-?\\d+(?:\\.\\d+)?$/)) return NaN;\n      return parseNumber(parseNumber(str).toFixed(~~decimals));\n    },\n\n    numberFormat : function(number, dec, dsep, tsep) {\n      if (isNaN(number) || number == null) return '';\n\n      number = number.toFixed(~~dec);\n      tsep = typeof tsep == 'string' ? tsep : ',';\n\n      var parts = number.split('.'), fnums = parts[0],\n        decimals = parts[1] ? (dsep || '.') + parts[1] : '';\n\n      return fnums.replace(/(\\d)(?=(?:\\d{3})+$)/g, '$1' + tsep) + decimals;\n    },\n\n    strRight: function(str, sep){\n      if (str == null) return '';\n      str = String(str); sep = sep != null ? String(sep) : sep;\n      var pos = !sep ? -1 : str.indexOf(sep);\n      return ~pos ? str.slice(pos+sep.length, str.length) : str;\n    },\n\n    strRightBack: function(str, sep){\n      if (str == null) return '';\n      str = String(str); sep = sep != null ? String(sep) : sep;\n      var pos = !sep ? -1 : str.lastIndexOf(sep);\n      return ~pos ? str.slice(pos+sep.length, str.length) : str;\n    },\n\n    strLeft: function(str, sep){\n      if (str == null) return '';\n      str = String(str); sep = sep != null ? String(sep) : sep;\n      var pos = !sep ? -1 : str.indexOf(sep);\n      return ~pos ? str.slice(0, pos) : str;\n    },\n\n    strLeftBack: function(str, sep){\n      if (str == null) return '';\n      str += ''; sep = sep != null ? ''+sep : sep;\n      var pos = str.lastIndexOf(sep);\n      return ~pos ? str.slice(0, pos) : str;\n    },\n\n    toSentence: function(array, separator, lastSeparator, serial) {\n      separator = separator || ', ';\n      lastSeparator = lastSeparator || ' and ';\n      var a = array.slice(), lastMember = a.pop();\n\n      if (array.length > 2 && serial) lastSeparator = _s.rtrim(separator) + lastSeparator;\n\n      return a.length ? a.join(separator) + lastSeparator + lastMember : lastMember;\n    },\n\n    toSentenceSerial: function() {\n      var args = slice.call(arguments);\n      args[3] = true;\n      return _s.toSentence.apply(_s, args);\n    },\n\n    slugify: function(str) {\n      if (str == null) return '';\n\n      var from  = \"\",\n          to    = \"aaaaaaaaaceeeeeiiiilnoooooosstuuuunczz\",\n          regex = new RegExp(defaultToWhiteSpace(from), 'g');\n\n      str = String(str).toLowerCase().replace(regex, function(c){\n        var index = from.indexOf(c);\n        return to.charAt(index) || '-';\n      });\n\n      return _s.dasherize(str.replace(/[^\\w\\s-]/g, ''));\n    },\n\n    surround: function(str, wrapper) {\n      return [wrapper, str, wrapper].join('');\n    },\n\n    quote: function(str, quoteChar) {\n      return _s.surround(str, quoteChar || '\"');\n    },\n\n    unquote: function(str, quoteChar) {\n      quoteChar = quoteChar || '\"';\n      if (str[0] === quoteChar && str[str.length-1] === quoteChar)\n        return str.slice(1,str.length-1);\n      else return str;\n    },\n\n    exports: function() {\n      var result = {};\n\n      for (var prop in this) {\n        if (!this.hasOwnProperty(prop) || prop.match(/^(?:include|contains|reverse)$/)) continue;\n        result[prop] = this[prop];\n      }\n\n      return result;\n    },\n\n    repeat: function(str, qty, separator){\n      if (str == null) return '';\n\n      qty = ~~qty;\n\n      // using faster implementation if separator is not needed;\n      if (separator == null) return strRepeat(String(str), qty);\n\n      // this one is about 300x slower in Google Chrome\n      for (var repeat = []; qty > 0; repeat[--qty] = str) {}\n      return repeat.join(separator);\n    },\n\n    naturalCmp: function(str1, str2){\n      if (str1 == str2) return 0;\n      if (!str1) return -1;\n      if (!str2) return 1;\n\n      var cmpRegex = /(\\.\\d+)|(\\d+)|(\\D+)/g,\n        tokens1 = String(str1).toLowerCase().match(cmpRegex),\n        tokens2 = String(str2).toLowerCase().match(cmpRegex),\n        count = Math.min(tokens1.length, tokens2.length);\n\n      for(var i = 0; i < count; i++) {\n        var a = tokens1[i], b = tokens2[i];\n\n        if (a !== b){\n          var num1 = parseInt(a, 10);\n          if (!isNaN(num1)){\n            var num2 = parseInt(b, 10);\n            if (!isNaN(num2) && num1 - num2)\n              return num1 - num2;\n          }\n          return a < b ? -1 : 1;\n        }\n      }\n\n      if (tokens1.length === tokens2.length)\n        return tokens1.length - tokens2.length;\n\n      return str1 < str2 ? -1 : 1;\n    },\n\n    levenshtein: function(str1, str2) {\n      if (str1 == null && str2 == null) return 0;\n      if (str1 == null) return String(str2).length;\n      if (str2 == null) return String(str1).length;\n\n      str1 = String(str1); str2 = String(str2);\n\n      var current = [], prev, value;\n\n      for (var i = 0; i <= str2.length; i++)\n        for (var j = 0; j <= str1.length; j++) {\n          if (i && j)\n            if (str1.charAt(j - 1) === str2.charAt(i - 1))\n              value = prev;\n            else\n              value = Math.min(current[j], current[j - 1], prev) + 1;\n          else\n            value = i + j;\n\n          prev = current[j];\n          current[j] = value;\n        }\n\n      return current.pop();\n    },\n\n    toBoolean: function(str, trueValues, falseValues) {\n      if (typeof str === \"number\") str = \"\" + str;\n      if (typeof str !== \"string\") return !!str;\n      str = _s.trim(str);\n      if (boolMatch(str, trueValues || [\"true\", \"1\"])) return true;\n      if (boolMatch(str, falseValues || [\"false\", \"0\"])) return false;\n    }\n  };\n\n  // Aliases\n\n  _s.strip    = _s.trim;\n  _s.lstrip   = _s.ltrim;\n  _s.rstrip   = _s.rtrim;\n  _s.center   = _s.lrpad;\n  _s.rjust    = _s.lpad;\n  _s.ljust    = _s.rpad;\n  _s.contains = _s.include;\n  _s.q        = _s.quote;\n  _s.toBool   = _s.toBoolean;\n\n  // Exporting\n\n  // CommonJS module is defined\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports)\n      module.exports = _s;\n\n    exports._s = _s;\n  }\n\n  // Register as a named module with AMD.\n  if (typeof define === 'function' && define.amd)\n    define('underscore.string', [], function(){ return _s; });\n\n\n  // Integrate with Underscore.js if defined\n  // or create our own underscore object.\n  root._ = root._ || {};\n  root._.string = root._.str = _s;\n}(this, String);\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails-util/cli.js":"\n/**\n * Module dependencies.\n */\n\nvar _\t\t\t= require('lodash'),\n\targv\t\t= require('optimist').argv;\n\n\n\n// Start building object to export\nvar util = {};\n\n\n/**\n * Expose `fs`, but monkey-patched to make sure existsSync()\n * doesn't crash older versions of Node\n *\n * @api private\n */\n\nvar fs = require('fs-extra');\nfs.existsSync = fs.existsSync || require('path').existsSync;\nutil.fs = fs;\n\n\n\n\n\n/**\n * Convert command-line arguments into configuration\n * options for the Sails core\n *\n * @param argv\n *\n * @api private\n */\n\nutil.getCLIConfig = function ( argv ) {\n\n\treturn {\n\t\t\n\t\t// `--silent` command-line argument\n\t\t// `--verbose` command-line argument\n\t\t// `--silly` command-line argument\n\t\tlog:\targv.verbose ? {level: 'verbose'} : \n\t\t\t\targv.silly ? {level: 'silly'} :\n\t\t\t\targv.silent ? {level: 'silent'} :\n\t\t\t\tundefined,\n\n\t\t// `--port=?` command-line argument\n\t\tport: argv.port || undefined,\n\n\t\t// `--prod` command-line argument\n\t\tenvironment: argv.prod ? 'production' : undefined\n\n\t};\n};\n\n\n\n\n/**\n * Methods which return a string with usage information\n * for the Sails CLI\n */\n\nutil.usage = {\n\n\tsails: function () {\n\t\tvar usage = 'Usage: sails <command>\\n\\n';\n\t\t// (if node_modules/sails exists, it will be used instead of the global install)\\n';\n\t\tusage += _tab('sails lift') + 'Run the Sails app in the current directory:\\n';\n\t\tusage += _tab('  [--prod]') + '  - in production mode \\n';\n\t\tusage += _tab('  [--port 3000]') + '  - on port 3000 \\n';\n\t\tusage += _tab('  [--verbose]') + '  - with verbose logging enabled \\n';\n\t\tusage += '\\n';\n\t\tusage += _tab('sails new <appName>') + 'Create a new Sails project in a folder called <appName>:\\n';\n\t\tusage += _tab('  [--no-linker]') + '  - disable auto-<link> of assets in HTML files via Grunt\\n';\n\t\tusage += '\\n';\n\t\tusage += _tab('sails generate model <foo>') + 'Generate a model (`api/models/Foo.js`)\\n';\n\t\tusage += _tab('sails generate controller <foo>') + 'Generate a controller (`api/controllers/FooController.js`)\\n';\n\t\tusage += _tab('sails generate <foo>') + 'Generate both.\\n';\n\t\tusage += _tab('  [--dry]') + 'Don\\'t actually create the module file.\\n';\n\t\tusage += '\\n';\n\t\tusage += _tab('sails console') + 'Run Sails in interactive mode (REPL)\\n';\n\t\tusage += _tab('sails version') + 'Get the current globally installed Sails version\\n';\n\t\tusage += _tab('sails run <command>') + 'Run a management command (exported by YOUR_APP/commands/index.js)';\n\n\t\treturn usage;\n\t},\n\n\n\tgenerate: {\n\t\tmodel: function () {\n\t\t\tvar usage = 'Usage:\\n';\n\t\t\tusage += 'sails generate model <foo> [attribute0Name:type] [attribute1Name:attribute1Type] [...]' + '\\n';\n\t\t\tusage += '\\n';\n\t\t\tusage += 'E.g., to generate api/models/Cockatiel.js:' + '\\n';\n\t\t\tusage += 'sails generate model cockatiel' + '\\n';\n\t\t\tusage += '\\n';\n\t\t\tusage += 'With some attributes:' + '\\n';\n\t\t\tusage += 'sails generate model cockatiel name:string weight:float birthdate:date color:string';\n\t\t}\n\t}\n};\n\n\n\n\n\n\n\n/**\n * Generate a file\n *\n * @api private\n */\n\nutil.generateFile = function(boilerplatePath, newPath) {\n\tvar fullBpPath = __dirname + '/boilerplates/' + (boilerplatePath || '');\n\tvar file = fs.readFileSync(fullBpPath, 'utf8');\n\tvar newFilePath = (newPath || '');\n\tutil.verifyDoesntExist(newFilePath, 'A file/directory already exists at ' + newFilePath);\n\n\t// Touch output file to make sure the path to it exists\n\tif (fs.createFileSync(newFilePath)) {\n\t\tlog.error('Could not create file, ' + newFilePath + '!');\n\t\tprocess.exit(1);\n\t}\n\tfs.writeFileSync(newFilePath, file);\n};\n\n\n\n/**\n * Generate a directory\n *\n * @api private\n */\n\nutil.generateDir = function(newPath, gitkeep) {\n\tif (!newPath) {\n\t\tlog.verbose('Creating directory in pwd...');\n\t} else {\n\t\tlog.verbose('Creating directory directory in ' + newPath + '...');\n\t}\n\tvar newDirPath = (newPath || '');\n\tutil.verifyDoesntExist(newDirPath, 'A file/directory already exists at ' + newDirPath);\n\tfs.mkdirSync(newDirPath);\n\t// If directory will be empty, create a .gitkeep in it\n\tif (gitkeep) {\n\t\tgenerateFile('.gitkeep', newPath + '/.gitkeep');\n\t}\n};\n\n\n/**\n * Verify that a file doesn't exist\n *\n * @api private\n */\n\nutil.verifyDoesntExist = function(path, msg) {\n\tif (util.fileExists(path)) {\n\t\tlog.error(msg);\n\t\tprocess.exit(1);\n\t}\n};\n\n\n\n/** \n * Check if a file or directory exists\n *\n * @api private\n */\n\nutil.fileExists = function(path) {\n\ttry {\n\t\t// Query the entry\n\t\tvar stats = fs.lstatSync(path);\n\n\t\t// Is it a directory?\n\t\tif (stats.isDirectory() || stats.isFile()) {\n\t\t\treturn true;\n\t\t}\n\t} catch (e) {\n\t\t// ...\n\t}\n\n\treturn false;\n};\n\n\n\n/** \n * Read an EJS template representing a Sails module,\n * then send back the return string.\n *\n * @api private\n */\n\n// util.renderBoilerplateTemplate = function(path, data) {\n// \tvar boilerplatePath = __dirname + '/boilerplates/templates/' + boilerplate;\n// \tutil.verifyExists(boilerplatePath, \"Boilerplate (\" + boilerplate + \") doesn't exist!\");\n// \tvar file = fs.readFileSync(boilerplatePath, 'utf8');\n// \treturn ejs.render(file, data);\n// };\n\n\n\n/** \n *\n *\n * @api private\n */\n\nutil.verifyExists = function(path, msg) {\n\tif (!util.fileExists(path)) {\n\t\tlog.error(msg);\n\t\tprocess.exit(1);\n\t}\n};\n\n\n\n/** \n * Copy a boilerplate directory or file\n *\n * @api private\n */\n\nutil.copyBoilerplate = function(boilerplate, destination, cb) {\n\tvar boilerplatePath = __dirname + '/boilerplates/' + boilerplate;\n\tfs.copy(boilerplatePath, destination, function(err) {\n\t\treturn cb && cb(err);\n\t});\n};\n\n\n\n/** \n * Copy global sails module into current project as a local dependency\n * (currently unusued)\n *\n * @api private\n */\n\nutil.copySails = function(destination, cb) {\n\ttry {\n\t\tfs.mkdirSync(destination);\n\t} catch (e) {\n\t\treturn cb && cb(e);\n\t}\n\n\t// Progress notifications\n\tvar stopShowingProgressNotifications,\n\t\terrorCopying,\n\t\tinterval = 150;\n\n\n\t// Draw progress notification\n\t// Returns progress function\n\tlog.verbose('Copying modules into ' + destination + '...');\n\tvar canvas = turtle();\n\n\tasync.until(\n\n\tfunction checkIfDone() {\n\t\tcanvas.tick();\n\t\treturn stopShowingProgressNotifications;\n\t},\n\n\tfunction setAlarm(cb) {\n\t\tsetTimeout(cb, interval);\n\t},\n\n\tfunction done(err) {\n\t\t// If an error occurred, send it back\n\t\terr = err || errorCopying;\n\t\treturn cb && cb(err);\n\t});\n\n\tasync.each(['lib', 'package.json', 'node_modules'], function(fileOrDir, cb) {\n\t\tfs.copy(__dirname + '/../' + fileOrDir, destination + '/' + fileOrDir, cb);\n\t}, function doneCopying(err) {\n\n\t\t// Hold onto error if there is one\n\t\terrorCopying = err;\n\n\t\t// When finished copying, mark done\n\t\t// progress notifications will trigger the callback\n\t\tstopShowingProgressNotifications = true;\n\t});\n};\n\n\n\n/** \n * Copy a core Sails dependency to the top-level node_modules directory\n * of the current application---- in a smart way\n *\n * @api private\n */\n\nutil.copySailsDependency = function(moduleName, pathToNewNodeModules, cb) {\n\tvar path = __dirname + '/../node_modules/' + moduleName;\n\tfs.copy(path, pathToNewNodeModules + '/' + moduleName, function(err) {\n\t\tif (err) return cb && cb(err);\n\n\t\t// Parse the module's package.json\n\t\tvar packageJSONPath = path + '/package.json';\n\t\tvar packageJSON;\n\t\ttry {\n\t\t\tpackageJSON = JSON.parse(fs.readFileSync(packageJSONPath, 'utf-8'));\n\t\t} catch (e) {\n\n\t\t\t// Ignore missing package.json\n\t\t\tpackageJSON = {\n\t\t\t\tdependencies: {}\n\t\t\t};\n\t\t}\n\n\t\t// Get actual dependencies in this module's node_modules directory\n\t\tvar dependencies;\n\t\ttry {\n\t\t\tdependencies = fs.readdirSync(path + '/node_modules');\n\n\t\t\t// Remove hidden files\n\t\t\t_.without(dependencies, function(val) {\n\t\t\t\treturn val.match(/\\..+/);\n\t\t\t});\n\t\t} catch (e) {\n\t\t\t// Assume empty dependencies\n\t\t\tdependencies = {};\n\t\t}\n\n\t\t// If there are any missing dependencies which are being pulled from Sails,\n\t\t// copy them from Sails' main node_modules directory\n\t\tvar missingModules = _.difference(_.keys(packageJSON.dependencies || {}), _.values(dependencies));\n\t\t_.each(missingModules, function(missingModuleName) {\n\t\t\tlog.verbose('Resolving ' + moduleName + '\\'s missing dependency (' + missingModuleName + ') using the version in Sails.');\n\t\t\tutil.copySailsDependency(missingModuleName, pathToNewNodeModules + '/' + moduleName + '/node_modules/');\n\t\t});\n\n\t\treturn cb && cb(err);\n\t});\n};\n\n\n\n\n/**\n * Return a tabbed-over version of the string,\n * adjusting for spacing\n *\n * @api private\n */\nfunction _tab (str) {\n\tvar n = (33 - str.length);\n\treturn str + _.str.repeat(' ', n);\n}\n\n\n\n// Export `util` object\nmodule.exports = _.cloneDeep(util);\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails-util/node_modules/fs-extra/lib/index.js":"\"use strict\"\n\nvar fs = null\n  , path = require('path')\n  , jsonFile = require('jsonfile')\n  , json = require('./json')\n  , fse = {};\n\ntry {\n  // optional dependency\n  fs = require(\"graceful-fs\")\n} catch (er) {\n  fs = require(\"fs\")\n}\n\nObject.keys(fs).forEach(function(key) {\n  var func = fs[key];\n  if (typeof func == 'function')\n    fse[key] = func;\n});\n\nfs = fse;\n\n// copy\n\nfs.copy = require('./copy').copy;\nfs.copySync = require('./copy').copySync;\n\n// remove\n\nvar remove = require('./remove');\nfs.remove = remove.remove;\nfs.removeSync = remove.removeSync;\nfs['delete'] = fs.remove\nfs.deleteSync = fs.removeSync\n\n// mkdir\n\nvar mkdir = require('./mkdir')\nfs.mkdirs = mkdir.mkdirs\nfs.mkdirsSync = mkdir.mkdirsSync\nfs.mkdirp = mkdir.mkdirs\nfs.mkdirpSync = mkdir.mkdirsSync\n\n// create\n\nvar create = require('./create')\nfs.createFile = create.createFile;\nfs.createFileSync = create.createFileSync;\n\n//deprecated\nfs.touch = function touch() {\n  console.log('fs.touch() is deprecated. Please use fs.createFile().')\n  fs.createFile.apply(null, arguments)\n}\n\nfs.touchSync = function touchSync() {\n  console.log('fs.touchSync() is deprecated. Please use fs.createFileSync().')\n  fs.createFileSync.apply(null, arguments)\n}\n\n// output\n\nvar output = require('./output');\nfs.outputFile = output.outputFile;\nfs.outputFileSync = output.outputFileSync;\n\n// read\n\n/*fs.readTextFile = function(file, callback) {\n  return fs.readFile(file, 'utf8', callback)\n}\n\nfs.readTextFileSync = function(file, callback) {\n  return fs.readFileSync(file, 'utf8')\n}*/\n\n// json files\n\nfs.readJsonFile = jsonFile.readFile;\nfs.readJSONFile = jsonFile.readFile;\nfs.readJsonFileSync = jsonFile.readFileSync;\nfs.readJSONFileSync = jsonFile.readFileSync;\n\nfs.readJson = jsonFile.readFile;\nfs.readJSON = jsonFile.readFile;\nfs.readJsonSync = jsonFile.readFileSync;\nfs.readJSONSync = jsonFile.readFileSync;\n\nfs.outputJsonSync = json.outputJsonSync;\nfs.outputJSONSync = json.outputJsonSync;\nfs.outputJson = json.outputJson;\nfs.outputJSON = json.outputJson;\n\nfs.writeJsonFile = jsonFile.writeFile;\nfs.writeJSONFile = jsonFile.writeFile;\nfs.writeJsonFileSync = jsonFile.writeFileSync;\nfs.writeJSONFileSync = jsonFile.writeFileSync;\n\nfs.writeJson = jsonFile.writeFile;\nfs.writeJSON = jsonFile.writeFile;\nfs.writeJsonSync = jsonFile.writeFileSync;\nfs.writeJSONSync = jsonFile.writeFileSync;\n\n\nmodule.exports = fs\n\njsonFile.spaces = 2; //set to 2\nmodule.exports.jsonfile = jsonFile; //so users of fs-extra can modify jsonFile.spaces;\n\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails-util/node_modules/jsonfile/lib/jsonfile.js":"var fs = require('fs');\n\nvar me = module.exports;\n\nme.spaces = 2;\n\nme.readFile = function(file, callback) {\n  fs.readFile(file, 'utf8', function(err, data) {\n    if (err) return callback(err, null);\n\n    var obj = null;\n    try {\n      obj = JSON.parse(data);\n    } catch (err2) {\n      callback(err2, null);\n      return;\n    }\n    callback(null, obj);\n  })\n}\n\nme.readFileSync = function(file) {\n  return JSON.parse(fs.readFileSync(file, 'utf8'));\n}\n\nme.writeFile = function(file, obj, options, callback) {\n  if (callback == null) { // odd little swap because options is optional\n    callback = options;\n    options = null;\n  }\n\n  var str = '';\n  try {\n    str = JSON.stringify(obj, null, module.exports.spaces);\n  } catch (err) {\n    if (callback) {\n      callback(err, null);\n    }\n    return;\n  }\n  fs.writeFile(file, str, options, callback);\n}\n\nme.writeFileSync = function(file, obj, options) {\n  var str = JSON.stringify(obj, null, module.exports.spaces);\n  return fs.writeFileSync(file, str, options); //not sure if fs.writeFileSync returns anything, but just in case\n}","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails-util/node_modules/fs-extra/lib/json.js":"\"use strict\"\n\nvar jsonFile = require('jsonfile')\n  , fs = require('fs')\n  , mkdir = require('./mkdir')\n  , path = require('path')\n\nvar me = module.exports\n\nme.outputJsonSync = function(file, data) {\n  var dir = path.dirname(file)\n\n  if (!fs.existsSync(dir))\n    mkdir.mkdirsSync(dir)\n\n  jsonFile.writeFileSync(file, data)\n}\n\nme.outputJson = function(file, data, callback) {\n  var dir = path.dirname(file)\n\n  fs.exists(dir, function(itDoes) {\n    if (itDoes) return jsonFile.writeFile(file, data, callback)\n\n    mkdir.mkdirs(dir, function(err) {\n      if (err) return callback(err)\n      jsonFile.writeFile(file, data, callback)\n    })\n  })\n}","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails-util/node_modules/fs-extra/lib/mkdir.js":"\"use strict\"\n\nvar mkdirp = require('mkdirp');\n\nmodule.exports.mkdirs = mkdirp;\nmodule.exports.mkdirsSync = mkdirp.sync;\n\n\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails-util/node_modules/mkdirp/index.js":"var path = require('path');\nvar fs = require('fs');\n\nmodule.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;\n\nfunction mkdirP (p, mode, f, made) {\n    if (typeof mode === 'function' || mode === undefined) {\n        f = mode;\n        mode = 0777 & (~process.umask());\n    }\n    if (!made) made = null;\n\n    var cb = f || function () {};\n    if (typeof mode === 'string') mode = parseInt(mode, 8);\n    p = path.resolve(p);\n\n    fs.mkdir(p, mode, function (er) {\n        if (!er) {\n            made = made || p;\n            return cb(null, made);\n        }\n        switch (er.code) {\n            case 'ENOENT':\n                mkdirP(path.dirname(p), mode, function (er, made) {\n                    if (er) cb(er, made);\n                    else mkdirP(p, mode, cb, made);\n                });\n                break;\n\n            // In the case of any other error, just see if there's a dir\n            // there already.  If so, then hooray!  If not, then something\n            // is borked.\n            default:\n                fs.stat(p, function (er2, stat) {\n                    // if the stat fails, then that's super weird.\n                    // let the original error be the failure reason.\n                    if (er2 || !stat.isDirectory()) cb(er, made)\n                    else cb(null, made);\n                });\n                break;\n        }\n    });\n}\n\nmkdirP.sync = function sync (p, mode, made) {\n    if (mode === undefined) {\n        mode = 0777 & (~process.umask());\n    }\n    if (!made) made = null;\n\n    if (typeof mode === 'string') mode = parseInt(mode, 8);\n    p = path.resolve(p);\n\n    try {\n        fs.mkdirSync(p, mode);\n        made = made || p;\n    }\n    catch (err0) {\n        switch (err0.code) {\n            case 'ENOENT' :\n                made = sync(path.dirname(p), mode, made);\n                sync(p, mode, made);\n                break;\n\n            // In the case of any other error, just see if there's a dir\n            // there already.  If so, then hooray!  If not, then something\n            // is borked.\n            default:\n                var stat;\n                try {\n                    stat = fs.statSync(p);\n                }\n                catch (err1) {\n                    throw err0;\n                }\n                if (!stat.isDirectory()) throw err0;\n                break;\n        }\n    }\n\n    return made;\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails-util/node_modules/fs-extra/lib/copy.js":"\"use strict\"\n\nvar fs = require('fs')\n  , ncp = require('ncp').ncp\n  , path = require('path')\n  , mkdir = require('./mkdir'),\n    create = require('./create')\n\nmodule.exports.copy = copy;\nmodule.exports.copySync = copySync;\n\nvar BUF_LENGTH = 64 * 1024\nvar _buff = new Buffer(BUF_LENGTH)\n\nvar copyFileSync = function(srcFile, destFile) {\n  var bytesRead, fdr, fdw, pos;\n  fdr = fs.openSync(srcFile, 'r');\n  fdw = fs.openSync(destFile, 'w');\n  bytesRead = 1;\n  pos = 0;\n  while (bytesRead > 0) {\n    bytesRead = fs.readSync(fdr, _buff, 0, BUF_LENGTH, pos);\n    fs.writeSync(fdw, _buff, 0, bytesRead);\n    pos += bytesRead;\n  }\n  fs.closeSync(fdr);\n  return fs.closeSync(fdw);\n}\n\nfunction copy(src, dest, filter, callback) {\n  if( typeof filter === \"function\" && !callback) {\n      callback = filter;\n      filter = null;\n  }\n  callback = callback || function(){}\n\n  fs.lstat(src, function(err, stats) {\n    if (err) return callback(err)\n\n    var dir = null\n    if (stats.isDirectory()) {\n      var parts = dest.split(path.sep)\n      parts.pop()\n      dir = parts.join(path.sep)\n    } else {\n      dir = path.dirname(dest)\n    }\n\n    fs.exists(dir, function(dirExists) {\n      if (dirExists) return ncp(src, dest, {filter: filter}, callback);\n      mkdir.mkdirs(dir, function(err) {\n        if (err) return callback(err)\n        ncp(src, dest, {filter: filter}, callback);\n      })\n    })\n  })\n}\n\nfunction copySync(src, dest, filter) {\n  filter = filter || function () { return true; };\n  var stats = fs.lstatSync(src),\n      destExists = fs.exists(dest),\n      performCopy = false;\n  if (stats.isFile()) {\n    if (filter instanceof RegExp) performCopy = filter.test(src);\n    else if (typeof filter === \"function\") performCopy = filter(src);\n    if(performCopy) {\n      if (!destExists) create.createFileSync(dest);\n      copyFileSync(src, dest);\n    }\n  }\n  else if (stats.isDirectory()) {\n    if (!destExists) mkdir.mkdirsSync(dest);\n    var contents = fs.readdirSync(src);\n    contents.forEach(function (content) {\n      copySync(src + \"/\" + content, dest + \"/\" + content);\n    });\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails-util/node_modules/fs-extra/lib/create.js":"\"use strict\"\n\nvar mkdir = require('./mkdir')\n  , path = require('path')\n  , fs = require('fs')\n  , exists = fs.exists || path.exists\n  , existsSync = fs.existsSync || path.existsSync\n\nfunction createFile (file, callback) {\n  function makeFile() {\n    fs.writeFile(file, '', function(err) {\n      if (err)\n        callback(err)\n      else\n        callback(null);\n    })\n  }\n\n  exists(file, function(fileExists) {\n    if (fileExists)\n      return callback(null);\n    else {\n      var dir = path.dirname(file);\n\n      exists(dir, function(dirExists) {\n        if (!dirExists) {\n          mkdir.mkdirs(dir, function(err) {\n            if (err)\n              callback(err)\n            else\n              makeFile();\n          })\n        } else {\n          makeFile();\n        }\n      })\n    }\n  })\n}\n\n\nfunction createFileSync (file) {\n  if (existsSync(file))\n    return;\n\n  var dir = path.dirname(file);\n  if (!existsSync(dir))\n    mkdir.mkdirsSync(dir);\n\n  fs.writeFileSync(file, '');\n}\n\n\nmodule.exports.createFile = createFile;\nmodule.exports.createFileSync = createFileSync;","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails-util/node_modules/fs-extra/lib/remove.js":"\"use strict\"\n\nvar rimraf = require('rimraf')\n  , fs = require('fs');\n\nfunction rmrfSync(dir) {\n    return rimraf.sync(dir);\n}\n\nfunction rmrf(dir, cb) {\n    if (cb != null) {\n        return rimraf(dir, cb);\n    } else {\n        return rimraf(dir, (function() {}));\n    }\n}\n\nmodule.exports.remove = rmrf;\nmodule.exports.removeSync = rmrfSync;\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails-util/node_modules/fs-extra/lib/output.js":"\"use strict\"\n\nvar mkdir = require('./mkdir')\n  , path = require('path')\n  , fs = require('fs')\n  , exists = fs.exists || path.exists\n  , existsSync = fs.existsSync || path.existsSync\n\nfunction outputFile (file, data, encoding, callback) {\n  if (typeof encoding === 'function') {\n    callback = encoding\n    encoding = 'utf8'\n  }\n\n  var dir = path.dirname(file)\n  exists(dir, function(itDoes) {\n    if (itDoes) return fs.writeFile(file, data, encoding, callback)\n\n    mkdir.mkdirs(dir, function(err) {\n      if (err) return callback(err)\n\n      fs.writeFile(file, data, encoding, callback)\n    })\n  })\n}\n\n\nfunction outputFileSync (file, data, encoding) {\n  var dir = path.dirname(file)\n  if (existsSync(dir)) return fs.writeFileSync.apply(fs, arguments)\n  mkdir.mkdirsSync(dir)\n  fs.writeFileSync.apply(fs, arguments)\n}\n\n\nmodule.exports.outputFile = outputFile;\nmodule.exports.outputFileSync = outputFileSync;","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/app/lift.js":"/**\n * Module dependencies.\n */\n\nvar async = require('async');\nvar _ = require('@sailshq/lodash');\nvar chalk = require('chalk');\n\n/**\n * Sails.prototype.lift()\n *\n * Loads the app, then starts all attached servers.\n *\n * @api public\n */\n\nmodule.exports = function lift(configOverride, cb) {\n  var sails = this;\n\n  // configOverride is optional\n  if (_.isFunction(configOverride)) {\n    cb = configOverride;\n    configOverride = {};\n  }\n\n  // Callback is optional\n  cb = cb || function(err) {\n    if (err) return sails.log.error(err);\n  };\n\n  async.series([\n\n    function(cb) {\n      sails.load(configOverride, cb);\n    },\n\n    sails.initialize\n\n  ], function sailsReady(err, async_data) { //TODO: unused variable async_data\n    if (err) {\n      return sails.lower(function (errorLoweringSails){\n        if (errorLoweringSails) {\n          sails.log.error('When trying to lower the app as a result of a failed lift, encountered an error:',errorLoweringSails);\n        }\n        cb(err);\n      });\n    }\n\n    _printSuccessMsg(sails);\n\n    // try {console.timeEnd('core_lift');}catch(e){}\n\n    sails.emit('lifted');\n    sails.isLifted = true;\n    return cb(null, sails);\n  });\n};\n\n\n\n// Gather app meta-info and log startup message (the boat).\nfunction _printSuccessMsg(sails) {\n\n  // If `config.noShip` is set, skip the startup message.\n  if (!(sails.config.log && sails.config.log.noShip)) {\n\n    sails.log.ship && sails.log.ship();\n    sails.log.info(('Server lifted in `' + sails.config.appPath + '`'));\n    sails.log.info(chalk.underline('To see your app, visit ' + (sails._getBaseUrl() || '')));\n    sails.log.info(('To shut down Sails, press <CTRL> + C at any time.'));\n    sails.log.blank();\n    sails.log(chalk.grey(Array(56).join('-')));\n    sails.log(chalk.grey(':: ' + new Date()));\n    sails.log.blank();\n    sails.log('Environment : ' + sails.config.environment);\n\n    // Only log the host if an explicit host is set\n    if (sails.getHost()) {\n      sails.log('Host        : ' + sails.getHost()); // 12 - 4 = 8 spaces\n    }\n    sails.log('Port        : ' + sails.config.port); // 12 - 4 = 8 spaces\n    sails.log(chalk.grey(Array(56).join('-')));\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/app/lower.js":"/**\n * Module dependencies.\n */\n\nvar async = require('async');\nvar _ = require('@sailshq/lodash');\n\n\n/**\n * Sails.prototype.lower()\n *\n * The inverse of `lift()`, this method\n * shuts down all attached servers.\n *\n * It also unbinds listeners and terminates child processes.\n *\n * @api public\n */\n\nmodule.exports = function lower(options, cb) {\n  var sails = this;\n\n  sails.log.verbose('Lowering sails...');\n\n  // `options` is optional.\n  if ('function' === typeof options) {\n    cb = options;\n    options = null;\n  }\n\n  // Callback is optional\n  cb = cb || function(err) {\n    if (err)  { return sails.log.error(err); }\n  };\n\n  options = options || {};\n  options.delay = options.delay || 100;\n\n  // Flag `sails._exiting` as soon as the app has begun to shutdown.\n  // This may be used by core hooks and other parts of core.\n  // (e.g. to stop handling HTTP requests and prevent ugly error msgs)\n  sails._exiting = true;\n\n  var beforeShutdown = (sails.config && sails.config.beforeShutdown) || function(cb) {\n    return cb();\n  };\n\n  // Wait until beforeShutdown logic runs\n  beforeShutdown(function(err) {\n\n    // If an error occurred, don't stop-- still go ahead and take care of other teardown tasks.\n    if (err) {\n      sails.log.error(err);\n    }\n\n    // Try to kill all child processes\n    _.each(sails.childProcesses, function kill(childProcess) {\n      sails.log.verbose('Sent kill signal to child process (' + childProcess.pid + ')...');\n      try {\n        childProcess.kill('SIGINT');\n      } catch (e) {\n        sails.log.error('While lowering Sails app: received error killing child process: ', e.stack);\n      }\n    });\n\n    // Shut down HTTP server\n    sails.emit('lower');\n    // (Note for future: would be cleaner to provide a way to defer this to the http\n    // and sockets hooks-- i.e. having hooks expose a `teardown(cb)` interceptor. Keep\n    // in mind we'd need a way to distinguish between a graceful shutdown and a force\n    // kill.  In a force kill situation, it's never ok for the process to hang.)\n\n    async.series([\n\n      function shutdownSockets(cb) {\n\n        // If the sockets hook is disabled, skip this.\n        // Also skip if the socket server is piggybacking on the main HTTP server, to avoid\n        // the onClose event possibly being called multiple times (because you can't tell\n        // socket.io to close without it trying to close the http server).  If we're piggybacking\n        // we'll call sails.io.close in the main \"shutdownHTTP\" code below.\n        if (!_.isObject(sails.hooks) || !sails.hooks.sockets || (sails.io && sails.io.httpServer && sails.hooks.http.server === sails.io.httpServer)) {\n          return cb();\n        }\n\n        var timeOut;\n\n        try {\n          sails.log.verbose('Shutting down socket server...');\n          timeOut = setTimeout(function() {\n            sails.io.httpServer.removeListener('close', onClose);\n            return cb();\n          }, 100);\n          sails.io.httpServer.unref();\n          sails.io.httpServer.once('close', onClose);\n          sails.io.close();\n        } catch (e) {\n          sails.log.verbose('Error occurred closing socket server: ', e);\n          clearTimeout(timeOut);\n          cb();\n        }\n\n        function onClose() {\n          sails.log.verbose('Socket server shut down successfully.');\n          clearTimeout(timeOut);\n          cb();\n        }\n\n      },\n\n      function shutdownHTTP(cb) {\n        if (!_.isObject(sails.hooks) || !sails.hooks.http) {\n          return cb();\n        }\n\n        var timeOut;\n\n        try {\n          sails.log.verbose('Shutting down HTTP server...');\n\n          // Allow process to exit once this server is closed\n          sails.hooks.http.server.unref();\n\n          // If we have a socket server and it's piggybacking on the main HTTP server, tell\n          // socket.io to close now.  This may call `.close()` on the HTTP server, which will\n          // happen again below, but the second synchronous call to .close() will have no\n          // additional effect.  Leaving this as-is in case future versions of socket.io\n          // DON'T automatically close the http server for you.\n          if (sails.io && sails.io.httpServer && sails.hooks.http.server === sails.io.httpServer) {\n            sails.io.close();\n          }\n\n          // If the \"hard shutdown\" option is on, destroy the server immediately,\n          // severing all connections\n          if (options.hardShutdown) {\n            sails.hooks.http.destroy();\n          }\n          // Otherwise just stop the server from accepting new connections,\n          // and wait options.delay for the existing connections to close\n          // gracefully before destroying.\n          else {\n            timeOut = setTimeout(sails.hooks.http.destroy, options.delay);\n            sails.hooks.http.server.close();\n          }\n\n          // Wait for the existing connections to close\n          sails.hooks.http.server.once('close', function () {\n            sails.log.verbose('HTTP server shut down successfully.');\n            clearTimeout(timeOut);\n            cb();\n          });\n\n        } catch (e) {\n          sails.log.verbose('Error occurred closing HTTP server: ', e);\n          clearTimeout(timeOut);\n          cb();\n        }\n      },\n\n      function removeListeners(cb) {\n        // Manually remove all event listeners\n        _.each(_.keys(sails._events)||[], function (eventName){\n          sails.removeAllListeners(eventName);\n        });\n\n        var listeners = sails._processListeners;\n        if (listeners) {\n          process.removeListener('SIGUSR2', listeners.sigusr2);\n          process.removeListener('SIGINT', listeners.sigint);\n          process.removeListener('SIGTERM', listeners.sigterm);\n          process.removeListener('exit', listeners.exit);\n        }\n        sails._processListeners = null;\n\n        // If `sails.config.process.removeAllListeners` is set, do that.\n        // This is no longer necessary due to https://github.com/balderdashy/sails/pull/2693\n        // Deprecating for v0.12.\n        if (sails.config && sails.config.process && sails.config.process.removeAllListeners) {\n          sails.log.debug('sails.config.process.removeAllListeners is deprecated; please remove listeners indivually!');\n          process.removeAllListeners();\n        }\n\n        cb();\n      },\n    ], function (err) {\n      if (err) {\n        // This should never happen because `err` is never passed in any of the async\n        // functions above.  Still, just to be safe, we set up an error log.\n        sails.log.error('While lowering Sails app: received unexpected error:', err.stack);\n        return cb(err);\n      }\n\n      // If `sails._setNodeEnvAutomatically` is set, then we should revert it to what it was\n      // beforehand (`sails._originalNodeEnv`), even if it wasn't set at all.\n      // (see load.js for more background)\n      if (sails._setNodeEnvAutomatically) {\n        process.env['NODE_ENV'] = sails._originalNodeEnv;\n      }\n\n      return cb();\n\n    });//</async.series>\n\n  });//</beforeShutdown()>\n\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/app/getBaseurl.js":"/**\n * Module dependencies\n */\n\nvar _ = require('@sailshq/lodash');\n\n\n\n\n/**\n * Calculate the base URL (useful in emails, etc.)\n * @return {String} [description]\n */\n\nmodule.exports = function getBaseurl() {\n  var sails = this;\n\n  var usingSSL = sails.config.ssl === true || (sails.config.ssl && ((sails.config.ssl.key && sails.config.ssl.cert) || sails.config.ssl.pfx));\n  var host = sails.getHost() || 'localhost';\n  var port = sails.config.proxyPort || sails.config.port;\n  var probablyUsingSSL = (port === 443);\n\n  // If host doesn't contain `http*` already, include the protocol string.\n  var protocolString = '';\n  if (!_.contains(host,'http')) {\n    protocolString = ((usingSSL || probablyUsingSSL) ? 'https' : 'http') + '://';\n  }\n  var portString = (port === 80 || port === 443 ? '' : ':' + port);\n  var localAppURL = protocolString + host + portString;\n\n  return localAppURL;\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/app/get-route-for.js":"/**\n * Module dependencies\n */\n\nvar util = require('util');\nvar _ = require('@sailshq/lodash');\nvar sailsUtil = require('sails-util');\n\n\n/**\n * getRouteFor()\n *\n * Look up more information about the first explicit route defined in this app\n * which has the given route target.\n *\n * Note that this function _only searches explicit routes_ which have been configured\n * manually (e.g. in `config/routes.js`).  For more info, see:\n * https://github.com/balderdashy/sails/issues/3402#issuecomment-171633341\n *\n * @this {SailsApp}\n * ----------------------------------------------------------------------------------------\n *\n * Usage:\n *\n * ```\n * getRouteFor('DuckController.quack');\n * getRouteFor({ target: 'DuckController.quack' });\n * // =>\n * // {\n * //   url: '/ducks/:id/quack',\n * //   method: 'post'\n * // }\n * ```\n */\nmodule.exports = function getRouteFor(routeQuery){\n\n  // Get reference to sails app instance.\n  var sails = this;\n\n  // Validate and normalize usage.\n  var routeTargetToLookup;\n  if ( _.isString(routeQuery) ) {\n    routeTargetToLookup = routeQuery;\n  }\n  else if ( _.isObject(routeQuery) && _.isString(routeQuery.target) ) {\n    routeTargetToLookup = routeQuery.target;\n  }\n  else {\n    var invalidUsageErr = new Error('Usage error: `sails.getRouteFor()` expects a string route target (e.g. \"DuckController.quack\") or a dictionary with a target property (e.g. `{target: \"DuckController.quack\"}`).  But instead, it received a `'+typeof routeQuery+'`: '+util.inspect(routeQuery, {depth: null}) );\n    invalidUsageErr.code = 'E_USAGE';\n    throw invalidUsageErr;\n  }\n\n  // Split the provided route target string to look up on its dot, getting its controller and action parts.\n  var routeTargetToLookupPieces = routeTargetToLookup.split('.');\n\n  // If it doesn't have a dot, throw a usage error.\n  if ( routeTargetToLookupPieces.length < 2 ) {\n    var ambiguousUsageErr = new Error('Usage error: Ambiguous usage- target specified to `sails.getRouteFor()` is not a valid route target string (e.g. \"DuckController.quack\") because there is no dot (\".\")');\n    ambiguousUsageErr.code = 'E_USAGE';\n    throw ambiguousUsageErr;\n  }\n\n  // Now look up the first route with this target (`routeTargetToLookup`).\n  var firstMatchingRouteAddress;\n  _.any(sails.router.explicitRoutes, function (routeTarget, key) {\n    // If route target syntax is a string, compare it directly with the provided `routeTargetToLookup`.\n    if ( _.isString(routeTarget) ) {\n      if (routeTarget===routeTargetToLookup ) {\n        firstMatchingRouteAddress = key;\n        return true;\n      }\n      else {\n        // TODO: If that check fails, try removing \"Controller\" suffix from both `routeTargetToLookup` and the controller in the `routeTarget` and comparing those. Note that this means you _should not define `ControllerController.js`_!\n        // * * * ACTUALLY, see: https://github.com/balderdashy/sails/issues/3402#issuecomment-173255376   * * *\n      }\n    }\n    else if ( _.isObject(routeTarget) ) {\n      // If route target syntax itself contains a string `target` key, compare it directly with the provided `routeTargetToLookup`.\n      if ( _.isString(routeTarget.target) && routeTarget.target===routeTargetToLookup ) {\n        // TODO: If that check fails, try removing \"Controller\" suffix from both `routeTargetToLookup` and the controller in the `routeTarget` and comparing those. Note that this means you _should not define `ControllerController.js`_!\n        // * * * ACTUALLY, see: https://github.com/balderdashy/sails/issues/3402#issuecomment-173255376   * * *\n        firstMatchingRouteAddress = key;\n        return true;\n      }\n      // If route target syntax contains `controller`+`action` keys, then check those against the relevant pieces of the provided `routeTargetToLookup`.\n      else if ( _.isString(routeTarget.controller) && _.isString(routeTarget.action) && routeTarget.controller===routeTargetToLookupPieces[0] && routeTarget.action===routeTargetToLookupPieces[1] ) {\n        // TODO: If that check fails, try removing \"Controller\" suffix from both `routeTargetToLookup` and the controller in the `routeTarget` and comparing those. Note that this means you _should not define `ControllerController.js`_!\n        // * * * ACTUALLY, see: https://github.com/balderdashy/sails/issues/3402#issuecomment-173255376   * * *\n        firstMatchingRouteAddress = key;\n        return true;\n      }\n      // If route target syntax contains only `controller`, compare assuming the \"index\" action against the relevant pieces of the provided `routeTargetToLookup`.\n      else if ( _.isString(routeTarget.controller) && !routeTarget.action && routeTarget.controller===routeTargetToLookupPieces[0] && 'index'===routeTargetToLookupPieces[1] ) {\n        // TODO: If that check fails, try removing \"Controller\" suffix from both `routeTargetToLookup` and the controller in the `routeTarget` and comparing those. Note that this means you _should not define `ControllerController.js`_!\n        // * * * ACTUALLY, see: https://github.com/balderdashy/sails/issues/3402#issuecomment-173255376   * * *\n        firstMatchingRouteAddress = key;\n        return true;\n      }\n      // Note that we ignore non-matches or anything utterly insane.\n    }\n  });\n\n\n  // If no route was found, throw an error.\n  if (!firstMatchingRouteAddress) {\n    var unrecognizedTargetErr = new Error('Route not found: No explicit route could be found in this app with the specified target (`'+routeTargetToLookup+'`).');\n    unrecognizedTargetErr.code = 'E_NOT_FOUND';\n    throw unrecognizedTargetErr;\n  }\n\n  // Now that the raw route address been located, we'll normalize it:\n  //\n  // If route address is '*', it will be automatically corrected to `/*` when bound, so also reflect that here.\n  firstMatchingRouteAddress = firstMatchingRouteAddress === '*' ? '/*' : firstMatchingRouteAddress;\n\n  // Then we parse it into its HTTP method and URL pattern parts.\n  var parsedAddress = sailsUtil.detectVerb(firstMatchingRouteAddress);\n\n  // At this point we being building the final return value- the route info dictionary.\n  var routeInfo = {};\n  routeInfo.method = parsedAddress.verb || '';\n  routeInfo.url = parsedAddress.path;\n\n\n  // And finally return the route info.\n  return routeInfo;\n\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/app/get-url-for.js":"/**\n * Module dependencies\n */\n\n// N/A\n\n\n/**\n * getUrlFor()\n *\n * Look up the URL of this app's first explicit route with the given route target.\n *\n * Note that this function _only searches explicit routes_ which have been configured\n * manually (e.g. in `config/routes.js`).  For more info, see:\n * https://github.com/balderdashy/sails/issues/3402#issuecomment-171633341\n *\n *\n * @this {SailsApp}\n * ----------------------------------------------------------------------------------------\n *\n * Usage:\n *\n * ```\n * getUrlFor('DuckController.quack');\n * // => '/ducks/:id/quack'\n *\n * getUrlFor({ target: 'DuckController.quack' });\n * // => '/ducks/:id/quack'\n * ```\n */\nmodule.exports = function getUrlFor(routeQuery){\n\n  // Get reference to sails app instance.\n  var sails = this;\n\n  // Now attempt to look up the first route that matches the specified argument\n  // and if it works, then return its URL.\n  return sails.getRouteFor(routeQuery).url;\n\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/app/request.js":"/**\n * Module dependencies.\n */\n\nvar _ = require('@sailshq/lodash');\nvar util = require('util');\nvar QS = require('querystring');\nvar Transform = require('stream').Transform;\n\n\n/**\n * Originate a new client request instance and lob it at this Sails\n * app at the specified route `address`.\n *\n * Particularly useful for running unit/integration tests without\n * actually having to bind the HTTP and/or WebSocket servers to\n * a TCP port.\n *\n * @param  {String} address\n * @param  {Object} body\n * @param  {Function} cb\n * @return {Stream.Readable}\n *\n * @api public\n */\n\nmodule.exports = function request( /* address, body, cb */ ) {\n\n  var sails = this;\n\n  //\n  // Body params may be passed in to DELETE, HEAD, and GET requests,\n  // even though these types of requests don't normally contain a body.\n  // (this method just serializes them as if they were sent in the querystring)\n  //\n\n\n  // Normalize usage\n  var address = arguments[0];\n  var body;\n  var cb;\n\n  var method;\n  var headers;\n  var url;\n\n  // Usage:\n  // sails.request(opts, cb)\n  //  opts.url\n  //  opts.method\n  //  opts.params\n  //  opts.headers\n  //\n  // (`opts.url` is required)\n  if (_.isObject(arguments[0]) && arguments[0].url) {\n    url = arguments[0].url;\n    method = arguments[0].method;\n    headers = arguments[0].headers || {};\n    body = arguments[0].params || arguments[0].data || {};\n  }\n  // console.log('called sails.request() ');\n  // console.log('headers: ',headers);\n  // console.log('method: ',method);\n\n\n  // Usage:\n  // sails.request(address, [params], cb)\n  if (arguments[2]) {\n    cb = arguments[2];\n    body = arguments[1];\n  }\n  if (_.isFunction(arguments[1])) {\n    cb = arguments[1];\n  } else if (arguments[1]) {\n    body = arguments[1];\n  }\n\n  // If route has an HTTP verb (e.g. `get /foo/bar`, `put /bar/foo`, etc.) parse it out,\n  // (unless method or url was explicitly defined)\n  method = method || sails.util.detectVerb(address).verb;\n  method = method ? method.toUpperCase() : 'GET';\n  url = url || sails.util.detectVerb(address).original;\n\n  // Parse query string (`req.query`)\n  var queryStringPos = url.indexOf('?');\n\n  // If this is a GET, HEAD, or DELETE request, treat the \"body\"\n  // as parameters which should be serialized into the querystring.\n  if (_.isObject(body) && _.contains(['GET', 'HEAD', 'DELETE'], method)) {\n\n    var stringifiedParams = QS.stringify(body);\n\n    if (queryStringPos === -1) {\n      url += '?' + stringifiedParams;\n    } else {\n      url = url.substring(0, queryStringPos) + '?' + stringifiedParams;\n    }\n  }\n\n\n\n  // Build HTTP Client Response stream\n  var clientRes = new MockClientResponse();\n  clientRes.on('finish', function() {\n\n    // console.log('clientRes finished. Headers:',clientRes.headers);\n\n    // Only dump the buffer if a callback was supplied\n    if (cb) {\n\n      // Attempt to read the response buffer into a string\n      try {\n        clientRes.body = clientRes.read();\n        if (clientRes.body !== null) {\n          clientRes.body = clientRes.body.toString();\n          clientRes.body = JSON.parse(clientRes.body);\n        }\n      } catch (e) {}\n\n      // Don't include body if it is empty\n      if (!clientRes.body) {delete clientRes.body;}\n\n      // If status code is indicative of an error, send the\n      // response body or status code as the first error argument.\n      if (clientRes.statusCode < 200 || clientRes.statusCode >= 400) {\n        var error = new Error(util.inspect(clientRes.body || clientRes.statusCode));\n        if (clientRes.body) {error.body = clientRes.body;}\n        error.status = clientRes.statusCode;\n        return cb(error);\n      }\n      else {\n        return cb(null, clientRes, clientRes.body);\n      }\n    }\n  });\n  clientRes.on('error', function(err) {\n    err = err || new Error('Error on response stream');\n    if (cb) return cb(err);\n    else return clientRes.emit('error', err);\n  });\n\n  // To kick things off, pass `opts` (as req) and `res` to the Sails router\n  sails.router.route({\n    method: method,\n    url: url,\n    body: body,\n    headers: headers || {}\n  }, {\n    _clientRes: clientRes\n  });\n\n  // Return clientRes stream\n  return clientRes;\n\n};\n\n\n\nfunction MockClientResponse() {\n  Transform.call(this);\n}\nutil.inherits(MockClientResponse, Transform);\nMockClientResponse.prototype._transform = function(chunk, encoding, next) {\n  this.push(chunk);\n  next();\n};\n\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/app/private/initialize.js":"/**\n * Module dependencies\n */\n\nvar util = require('util');\nvar _ = require('@sailshq/lodash');\nvar async = require('async');\n\n\n\n\n/**\n * Sails.prototype.initialize()\n *\n * Start the Sails server\n * NOTE: sails.load() should be run first.\n *\n * @param {Function?} callback  [optional]\n *\n * @api private\n */\n\nmodule.exports = function initialize(cb) {\n\n  var sails = this;\n\n  // Callback is optional\n  cb = cb || function(err) {\n    if (err) { sails.log.error(err); }\n  };\n\n  // Indicate that server is starting\n  sails.log.verbose('Starting app at ' + sails.config.appPath + '...');\n\n  var listeners = {\n    sigusr2: function() {\n      sails.lower(function() {\n        process.kill(process.pid, 'SIGUSR2');\n      });\n    },\n    sigint: function() {\n      sails.lower(function (){\n        process.exit();\n      });\n    },\n    sigterm: function() {\n      sails.lower(function (){\n        process.exit();\n      });\n    },\n    exit: function() {\n      if (!sails._exiting) {\n        sails.lower();\n      }\n    }\n  };\n\n  // Add \"beforeShutdown\" events\n  process.once('SIGUSR2', listeners.sigusr2);\n\n  process.on('SIGINT', listeners.sigint);\n  process.on('SIGTERM', listeners.sigterm);\n  process.on('exit', listeners.exit);\n\n  sails._processListeners = listeners;\n\n  // Run the app bootstrap\n  sails.runBootstrap(function afterBootstrap(err) {\n    if (err) {\n      sails.log.error('Bootstrap encountered an error: (see below)');\n      return cb(err);\n    }\n\n    // Fire the `ready` event for backwards-compatibility.\n    // (this will be removed in a future version of Sails!)\n    sails.emit('ready');\n\n\n    // Now loop over each hook, and if it exposes a `handleLift` function, then run it.\n    // (this is used by attached servers, etc.)\n    if (!_.isObject(sails.hooks)) { return cb(new Error('Consistency violation: `sails.hooks` should be a dictionary.')); }\n    async.each(Object.keys(sails.hooks), function (hookName, next){\n      if (!_.isFunction(sails.hooks[hookName].handleLift)) {\n        return next();\n      }\n      return sails.hooks[hookName].handleLift(next);\n    }, function (err){\n      if (err) { return cb(err); }\n      return cb(null, sails);\n    });\n\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/app/private/exposeGlobals.js":"/**\n * Module dependencies.\n */\n\nvar _ = require('@sailshq/lodash');\nvar async = require('async');\n\n\n/**\n * exposeGlobals()\n *\n * Expose certain global variables\n * (if config says so)\n *\n * @api private\n */\n\nmodule.exports = function exposeGlobals() {\n  var sails = this;\n\n\n  // Globals explicitly disabled\n  if (sails.config.globals === false) {\n    sails.log.verbose('No global variables will be exposed.');\n    return;\n  }\n\n  sails.log.verbose('Exposing global variables... (you can customize/disable this by modifying the properties in `sails.config.globals`.  Set it to `false` to disable all globals.)');\n\n  sails.config.globals = sails.config.globals || {};\n\n  // Provide global access (if allowed in config)\n  if (sails.config.globals._ !== false) {\n    global['_'] = _;\n  }\n  if (sails.config.globals.async !== false) {\n    global['async'] = async;\n  }\n  if (sails.config.globals.sails !== false) {\n    global['sails'] = sails;\n  }\n\n  // `services` hook takes care of globalizing services (if enabled)\n\n  // `orm` hook takes care of globalizing models and adapters (if enabled)\n\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/app/private/bootstrap.js":"/**\n * Module dependencies\n */\n\nvar util = require('util');\n\n\n/**\n * runBootstrap\n *\n * TODO: move this into a new `bootstrap` hook so that it may be flipped\n * on and off explicitly w/o loading/depending on user config\n *\n * @param  {Function} cb [description]\n *\n * @api private\n */\n\nmodule.exports = function runBootstrap(cb) {\n\n  var sails = this;\n\n  // Run bootstrap script if specified\n  // Otherwise, do nothing and continue\n  if (!sails.config.bootstrap) {\n    return cb();\n  }\n\n  sails.log.verbose('Running the setup logic in `sails.config.bootstrap(cb)`...');\n\n  // IF bootstrap takes too long, display warning message\n  // (just in case user forgot to call their bootstrap's `cb`)\n  var timeoutMs = sails.config.bootstrapTimeout || 2000;\n  var timer = setTimeout(function bootstrapTookTooLong() {\n    sails.log.warn(util.format(\n    'Bootstrap is taking unusually long to execute its callback (%d milliseconds).\\n'+\n    'Perhaps you forgot to call it?  The callback is the first argument of the function, `cb`.',\n    timeoutMs));\n  }, timeoutMs);\n\n  var ranBootstrapFn = false;\n\n  try {\n    return sails.config.bootstrap(function bootstrapDone(err) {\n      if (ranBootstrapFn) {\n        sails.log.error('You called the callback in `sails.config.bootstrap` more than once!');\n        return;\n      }\n      ranBootstrapFn = true;\n      clearTimeout(timer);\n      return cb(err);\n    });\n  }\n  catch (e) {\n    if (ranBootstrapFn) {\n      sails.log.error('The bootstrap function threw an error after its callback was called ::',e);\n      return;\n    }\n    ranBootstrapFn = true;\n    clearTimeout(timer);\n    return cb(e);\n  }\n\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/app/private/getHost.js":"/**\n * Sails.prototype.getHost()\n *\n * @return {String} the configured hostname of the server\n * (IMPORTANT: returns undefined if not specifically configured)\n */\n\nmodule.exports = function getHost() {\n  var sails = this;\n\n  var hasExplicitHost = sails.config.hooks.http && sails.config.explicitHost;\n  var host = sails.config.proxyHost || hasExplicitHost || sails.config.host;\n  return host;\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/app/private/isLocalSailsValid.js":"/**\n * Module dependencies\n */\n\nvar fs = require('fs');\nvar CaptainsLog = require('captains-log');\nvar sailsutil = require('sails-util');\nvar semver = require('semver');\nvar Err = require('../../../errors');\n\n\n\n/**\n * Check if the specified installation of Sails is valid for the specified project.\n *\n * @param sailsPath\n * @param appPath\n */\n\nmodule.exports = function isLocalSailsValid(sailsPath, appPath) {\n\n  var sails = this;\n\n  // Has no package.json file\n  if (!fs.existsSync(appPath + '/package.json')) {\n    Err.warn.noPackageJSON();\n  }\n\n  // Load this app's package.json and dependencies\n  var appPackageJSON = sailsutil.getPackageSync(appPath);\n  var appDependencies = appPackageJSON.dependencies;\n\n\n  // Package.json exists, but doesn't list Sails as a dependency\n  if (!(appDependencies && appDependencies.sails)) {\n    Err.warn.notSailsApp();\n    return;\n  }\n\n  // Ensure the target Sails exists\n  if (!fs.existsSync(sailsPath)) {\n    return false;\n  }\n\n  // Read the package.json in the local installation of Sails\n  var sailsPackageJSON = sailsutil.getPackageSync(sailsPath);\n\n  // Local Sails has a corrupted package.json\n  if (!sailsPackageJSON) {\n    Err.warn.badLocalDependency(sailsPath, appDependencies.sails);\n    return;\n  }\n\n\n  // Lookup sails dependency requirement in app's package.json\n  var requiredSailsVersion = appDependencies.sails;\n\n  //\n  // TODO: use npm's built-in version comparator instead of taking care of\n  // all these edge cases:\n  //\n\n  // If you're using a `git://` sails dependency, you probably know\n  // what you're doing, but we'll let you know just in case.\n  var expectsGitVersion = requiredSailsVersion.match(/^git:\\/\\/.+/);\n  if (expectsGitVersion) {\n    var log = sails.log ? sails.log : CaptainsLog();\n\n    log.blank();\n    log.debug('NOTE:');\n    log.debug('This app depends on an unreleased version of Sails:');\n    log.debug(requiredSailsVersion);\n    log.blank();\n  }\n\n  // Ignore `latest` and `beta` (kind of like how we handle specified git:// deps)\n  var expectsLatest = requiredSailsVersion === 'latest';\n  if (expectsLatest) {\n    // ...\n  }\n  var expectsBeta = requiredSailsVersion === 'beta';\n  if (expectsBeta) {\n    // ...\n  }\n\n  // Error out if it has the wrong version in its package.json\n  if (!expectsLatest && !expectsBeta && !expectsGitVersion) {\n\n    // Use semver for version comparison\n    if (!semver.satisfies(sailsPackageJSON.version, requiredSailsVersion)) {\n      Err.warn.incompatibleLocalSails(requiredSailsVersion, sailsPackageJSON.version);\n    }\n  }\n\n  // If we made it this far, the target Sails installation must be OK\n  return true;\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/errors/index.js":"// Merge together error sub-modules\nmodule.exports = {\n  fatal: require('./fatal'),\n  warn: require('./warn')\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/errors/fatal.js":"/**\n * Module dependencies\n */\nvar nodeutil = require('util');\nvar nodepath = require('path');\nvar chalk = require('chalk');\n\n// Build logger using best-available information\n// when this module is initially required.\nvar log = require('captains-log')(require('../lib/app/configuration/rc'));\n\n/**\n * Fatal Errors\n */\nmodule.exports = {\n\n  // Lift-time and load-time errors\n  failedToLoadSails: function(err) {\n    log.error(err);\n    log.error('Could not load Sails.');\n    log.error('Are you using the latest stable version?');\n    _terminateProcess(1);\n  },\n\n  noPackageJSON: function() {\n    log.error('Cannot read package.json in the current directory (' + process.cwd() + ')');\n    log.error('Are you sure this is a Sails app?');\n    _terminateProcess(1);\n  },\n\n  notSailsApp: function() {\n    log.error('The package.json in the current directory does not list Sails as a dependency...');\n    log.error('Are you sure `' + process.cwd() + '` is a Sails app?');\n    _terminateProcess(1);\n  },\n\n  badLocalDependency: function(pathTo_localSails, requiredVersion) {\n    log.error(\n      'The local Sails dependency installed at `' + pathTo.localSails + '` ' +\n      'has a corrupted, missing, or un-parsable package.json file.'\n    );\n    log.error('You may consider running:');\n    log.error('rm -rf ' + pathTo_localSails + ' && npm install sails@' + app.dependencies.sails);\n    _terminateProcess(1);\n  },\n\n  // TODO: replace the inline version of this error\n  // app/loadHooks.js:42\n  malformedHook: function() {\n    log.error('Malformed hook! (' + id + ')');\n    log.error('Hooks should be a function with one argument (`sails`)');\n    _terminateProcess(1);\n  },\n\n  // TODO: replace the inline version of this error\n  // app/load.js:146\n  hooksTookTooLong: function() {\n    var hooksTookTooLongErr = 'Hooks are taking way too long to get ready...  ' +\n      'Something might be amiss.\\nAre you using any custom hooks?\\nIf so, make sure the hook\\'s ' +\n      '`initialize()` method is triggering its callback.';\n    log.error(hooksTookTooLongErr);\n    process.exit(1);\n  },\n\n\n\n  // Invalid user module errors\n  invalidCustomResponse: function(responseIdentity) {\n    log.error('Cannot define custom response `' + responseIdentity + '`.');\n    log.error('`res.' + responseIdentity + '` has special meaning in Connect/Express/Sails.');\n    log.error('Please remove the `' + responseIdentity + '` file from the `responses` directory.');\n    _terminateProcess(1);\n  },\n\n\n\n  // This doesn't technically _need_ to be a fatal error- it just is\n  // because certain grunt modules (e.g. grunt-contrib-watch) don't restart\n  // when an error occurs.\n  __GruntAborted__: function(consoleMsg, stackTrace) {\n\n    var gruntErr =\n      '\\n------------------------------------------------------------------------\\n' +\n      consoleMsg + '\\n' + (stackTrace || '') +\n      '\\n------------------------------------------------------------------------';\n    log.error(gruntErr);\n    log.blank();\n\n    log.error('Looks like a Grunt error occurred--');\n    log.error('Please fix it, then **restart Sails** to continue running tasks (e.g. watching for changes in assets)');\n    log.error('Or if you\\'re stuck, check out the troubleshooting tips below.');\n    log.blank();\n\n    log.error(chalk.underline('Troubleshooting tips:'));\n    var relativePublicPath = (nodepath.resolve(process.cwd(), './.tmp'));\n    var uid = process.getuid && process.getuid() || 'YOUR_COMPUTER_USER_NAME';\n    log.error();\n    log.error(' *-> Are \"grunt\" and related grunt task modules installed locally?  Run `npm install` if you\\'re not sure.');\n    log.error();\n    log.error(' *-> You might have a malformed LESS, SASS, CoffeeScript file, etc.');\n    log.error();\n    log.error(' *-> Or maybe you don\\'t have permissions to access the `.tmp` directory?');\n    log.error('     e.g., `' + relativePublicPath + '`', '?');\n    log.error();\n    log.error('     If you think this might be the case, try running:');\n    log.error('     sudo chown -R', uid, relativePublicPath);\n    log.blank();\n\n    // See note above this function - for now, this will not\n    // actually terminate the process.  The rest of Sails should\n    // continue to run.\n    // return _terminateProcess(1);\n  },\n\n\n  __UnknownPolicy__: function(policy, source, pathToPolicies) {\n    source = source || 'config.policies';\n\n    log.error('Unknown policy, \"' + policy + '\", referenced in `' + source + '`.');\n    log.error('Are you sure that policy exists?');\n    log.error('It would be located at: `' + pathToPolicies + '/' + policy + '.js`');\n    return _terminateProcess(1);\n  },\n\n  __InvalidConnection__: function(connection, sourceModelId) {\n    log.error('In model (' + sourceModelId + '), invalid connection ::', connection);\n    log.error('Must contain an `adapter` key referencing the adapter to use.');\n    return _terminateProcess(1);\n  },\n\n  __UnknownConnection__: function(connectionId, sourceModelId) {\n    log.error('Unknown connection, \"' + connectionId + '\", referenced in model `' + sourceModelId + '`.');\n    log.error('Are you sure that connection exists?  It should be defined in `sails.config.connections`.');\n\n    // var probableAdapterModuleName = connectionId.toLowerCase();\n    // if ( ! probableAdapterModuleName.match(/^(sails-|waterline-)/) ) {\n    // \tprobableAdapterModuleName = 'sails-' + probableAdapterModuleName;\n    // }\n    // log.error('Otherwise, if you\\'re trying to use an adapter named `' + connectionId + '`, please run ' +\n    // \t'`npm install ' + probableAdapterModuleName + '@' + sails.majorVersion + '.' + sails.minorVersion + '.x`');\n    return _terminateProcess(1);\n  },\n\n\n  __ModelIsMissingConnection__: function(sourceModelId) {\n    log.error(nodeutil.format('One of your models (%s) doesn\\'t have a connection.', sourceModelId));\n    log.error('Do you have a default `connection` in your `config/models.js` file?');\n    return _terminateProcess(1);\n  },\n\n  __UnknownAdapter__: function(adapterId, sourceModelId, sailsMajorV, sailsMinorV) {\n    log.error('Trying to use unknown adapter, \"' + adapterId + '\", in model `' + sourceModelId + '`.');\n    log.error('Are you sure that adapter is installed in this Sails app?');\n    log.error('If you wrote a custom adapter with identity=\"' + adapterId + '\", it should be in this app\\'s adapters directory.');\n\n    var probableAdapterModuleName = adapterId.toLowerCase();\n    if (!probableAdapterModuleName.match(/^(sails-|waterline-)/)) {\n      probableAdapterModuleName = 'sails-' + probableAdapterModuleName;\n    }\n    log.error('Otherwise, if you\\'re trying to use an adapter named `' + adapterId + '`, please run ' +\n      '`npm install ' + probableAdapterModuleName + ' --save'/*'@' + sailsMajorV + '.' + sailsMinorV + '.x`'*/);\n    return _terminateProcess(1);\n  },\n\n  __InvalidAdapter__: function(attemptedModuleName, supplementalErrMsg) {\n    log.error('There was an error attempting to require(\"' + attemptedModuleName + '\")');\n    log.error('Is this a valid Sails/Waterline adapter?  The following error was encountered ::');\n    log.error(supplementalErrMsg);\n\n    return _terminateProcess(1);\n  }\n};\n\n\n\n/**\n *\n * TODO: Make all of this more elegant.\n * ========================================================\n * + Ideally we don't call `process.exit()` at all.\n * We should consistently use `sails.lower()` for unhandleable core\n * errors and just trigger the appropriate callback w/ an error for\n * core lift/load and any CLI errors.\n *\n * + Then we won't have to worry as much about dangling child processes\n * and things like that. Plus it's more testable that way.\n *\n * In practice, the best way to do this may be an error domain or an\n * event emitted on the sails object (or both!)\n * ========================================================\n *\n *\n *\n * TODO: Merge w/ app/teardown.js\n * ========================================================\n * (probably achievable by doing the aforementioned cleanup)\n * ========================================================\n */\n\n\n\n/**\n * _terminateProcess\n *\n * Terminate the process as elegantly as possible.\n * If process.env is 'test', throw instead.\n *\n * @param  {[type]} code [console error code]\n * @param  {[type]} opts [currently unused]\n */\nfunction _terminateProcess(code, opts) {\n  if (process.env.NODE_ENV === 'test') {\n    var Signal = new Error({\n      type: 'terminate',\n      code: code,\n      options: {\n        todo: 'put the stuff from the original errors in here'\n      }\n    });\n    throw Signal;\n  }\n\n  return process.exit(code);\n}\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/app/configuration/rc.js":"/**\n * Module dependencies\n */\n\nvar rc = require('rc');\n\n\n/**\n * Locate and load a .sailsrc file if one exists.\n *\n * NOTE: this occurs almost immediately when sails is required,\n * and since `rc` is synchronous, the examination of env variables,\n * cmdline opts, and .sailsrc files is immediate, and happens only once.\n *\n * @type {Object}\n */\nmodule.exports = rc('sails');\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/errors/warn.js":"/**\n * Module dependencies\n */\n\nvar nodepath = require('path');\n\n// Build logger using best-available information\n// when this module is initially required.\nvar log = require('captains-log')(require('../lib/app/configuration/rc'));\n\n\n/**\n * Warnings\n */\nmodule.exports = {\n\n  incompatibleLocalSails: function(requiredVersion, localVersion) {\n    log.warn('Trying to lift app using a local copy of `sails`');\n    log.warn('(located in ' + nodepath.resolve(process.cwd(), 'node_modules/sails') + ')');\n    log.warn();\n    log.warn('But the package.json in the current directory indicates a dependency');\n    log.warn('on Sails `' + requiredVersion + '`, and the locally installed Sails is `' + localVersion + '`!');\n    log.warn();\n    log.warn('If you run into compatibility issues, try installing ' + requiredVersion + ' locally:');\n    log.warn('    $ npm install sails@' + requiredVersion);\n    log.warn();\n    log.blank();\n  },\n\n\n\n  // Verbose-only warnings:\n\n  noPackageJSON: function() {\n    log.warn('Cannot read package.json in the current directory (' + process.cwd() + ')');\n    log.warn('Are you sure this is a Sails app?');\n    log.warn();\n  },\n\n  notSailsApp: function() {\n    log.warn('The package.json in the current directory does not list Sails as a dependency...');\n    log.warn('Are you sure `' + process.cwd() + '` is a Sails app?');\n    log.warn();\n  },\n\n  badLocalDependency: function(pathTo_localSails, requiredVersion) {\n    log.warn(\n      'The local Sails dependency installed at `' + pathTo_localSails + '` ' +\n      'has a corrupted, missing, or un-parsable package.json file.'\n    );\n    log.warn('You may consider running:');\n    log.warn('rm -rf ' + pathTo_localSails + ' && npm install sails@' + requiredVersion);\n    log.warn();\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/app/private/isSailsAppSync.js":"/**\n * Module dependencies\n */\n\nvar fs = require('fs'),\n  path = require('path'),\n  sailsutil = require('sails-util');\n\n\n\n/**\n * Check if the specified appPath contains something that looks like a Sails app.\n *\n * @param {String} appPath\n */\n\nmodule.exports = function isSailsAppSync(appPath) {\n\n  // Has no package.json file\n  if (!fs.existsSync(path.join(appPath, 'package.json'))) {\n    return false;\n  }\n\n  // Package.json exists, but doesn't list Sails as a dependency\n  var appPackageJSON = sailsutil.getPackageSync(appPath);\n  var appDependencies = appPackageJSON.dependencies;\n  if (!(appDependencies && appDependencies.sails)) {\n    return false;\n  }\n\n  return true;\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/app/private/inspect.js":"/**\n * Module dependencies\n */\n\nvar util = require('util');\nvar _ = require('@sailshq/lodash');\n\n\n\n/**\n * Sails.prototype.inspect()\n *\n * The string that should be returned when this `Sails` instance\n * is passed to `util.inspect()` (i.e. when logged w/ `console.log()`)\n *\n * @return {String}\n */\n\nmodule.exports = function inspect () {\n  var sails = this;\n\n  return util.format('\\n'+\n  '  |>   %s', this.toString()) + '\\n' +\n  '\\\\___/  For help, see: http://sailsjs.org/documentation/concepts/'+\n  '\\n\\n' +\n  'Tip: Use `sails.config` to access your app\\'s runtime configuration.'+\n  '\\n\\n' +\n  util.format('%d Models:\\n', _(sails.models).toArray().value().length) +\n  _(sails.models).toArray().filter(function (it) {return !it.junctionTable;}).pluck('globalId').value() +\n  '\\n\\n' +\n  util.format('%d Controllers:\\n', _(sails.controllers).toArray().value().length)+\n  _(sails.controllers).toArray().pluck('globalId').map(function (it) {return it+'Controller';}).value() +\n  '\\n\\n' +\n  // 'Routes:\\n'+\n  // _(sails.routes).toArray().filter(function (it) {return !it.junctionTable;}).pluck('globalId').map(function (it) {return it+'Controller';}).value() +\n  // '\\n\\n' +\n  util.format('%d Hooks:\\n', _(sails.hooks).toArray().value().length)+\n  _(sails.hooks).toArray().pluck('identity').value() +\n  '\\n' +\n  '';\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/app/private/toString.js":"/**\n * Module dependencies\n */\n\nvar util = require('util');\n\n\n/**\n * Sails.prototype.toString()\n *\n * e.g.\n * ('This is how `sails` looks when toString()ed: ' + sails)\n *\n * @return {String}\n */\nmodule.exports = function toString () {\n  return util.format('[a %sSails app%s]', this.isLifted ? 'lifted ' : '', this.isLifted && this.config.port ? ' on port '+this.config.port : '');\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/app/private/toJSON.js":"/**\n * Module dependencies\n */\n\nvar _ = require('@sailshq/lodash');\n\n\n/**\n * [exports description]\n * @return {[type]} [description]\n */\n\nmodule.exports = function toJSON () {\n  return _.reduce(this, function (pojo, val, key) {\n    if (key === 'config') {\n      pojo[key] = val;\n    }\n    if (key === 'hooks') {\n      pojo[key] = _.reduce(val, function (memo, hook, ident) {\n        memo.push(ident);\n        return memo;\n      }, []);\n    }\n    if (key === 'models') {\n      pojo[key] = _.reduce(val, function (memo, model, ident) { //TODO: unused variable ident\n        if (!model.junctionTable) {\n          memo.push({\n            attributes: model.attributes,\n            identity: model.identity,\n            globalId: model.globalId,\n            connection: model.connection,\n            schema: model.schema,\n            tableName: model.tableName\n          });\n        }\n        return memo;\n      }, []);\n    }\n\n    return pojo;\n  }, {});\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/app/configuration/load.js":"/**\n * Module dependencies.\n */\n\nvar _ = require('@sailshq/lodash');\nvar async = require('async');\nvar CaptainsLog = require('captains-log');\nvar path = require('path');\n\n\nmodule.exports = function(sails) {\n\n  /**\n   * Expose Configuration loader\n   *\n   * Load command-line overrides\n   *\n   * TODO: consider merging this into the `app` directory\n   *\n   * For reference, config priority is:\n   * --> implicit defaults\n   * --> environment variables\n   * --> user config files\n   * --> local config file\n   * --> configOverride ( in call to sails.lift() )\n   * --> --cmdline args\n   */\n\n  return function loadConfig(cb) {\n\n    // Save reference to context for use in closures\n    var self = this;\n\n    // Commence with loading/validating/defaulting all the rest of the config\n    async.auto({\n\n        /**\n         * Until this point this point, `sails.config` is composed only of\n         * configuration overrides passed into `sails.lift(overrides)`\n         * (or `sails.load(overrides)`-- same thing)\n         *\n         * This step clones this into an \"overrides\" object, negotiating cmdline\n         * shortcuts into the properly namespced sails configuration options.\n         */\n        mapOverrides: function(cb) {\n\n          // Clone the `overrides` that were passed in.\n          var overrides = _.cloneDeep(sails.config || {});\n\n          // TODO: bring the rconf stuff from bin/sails-lift in here\n\n          // Command-line arguments take highest precedence\n          // overrides = _.merge(overrides, argv);\n\n          // Map Sails options from overrides\n          overrides = _.merge(overrides, {\n\n            // `--verbose` command-line argument\n            // `--silly` command-line argument\n            // `--silent` command-line argument\n            log: overrides.verbose ? {\n              level: 'verbose'\n            } : overrides.silly ? {\n              level: 'silly'\n            } : overrides.silent ? {\n              level: 'silent'\n            } : undefined,\n\n            // `--port=?` command-line argument\n            port: overrides.port || undefined,\n\n            // `--prod` command-line argument\n            environment: overrides.prod ? 'production' : (overrides.dev ? 'development' : undefined)\n\n          });\n\n\n          // Pass on overrides object\n          cb(null, overrides);\n        },\n\n\n\n        /**\n         * Immediately instantiate the default logger in case a log-worthy event occurs\n         * Even though the app might actually use its own custom logger, we don't know\n         * all of the user configurations yet.\n         *\n         * Makes sails.log accessible for the first time\n         */\n        logger: ['mapOverrides',\n          function(cb, async_data) {\n            var logConfigSoFar = async_data.mapOverrides.log;\n            sails.log = new CaptainsLog(logConfigSoFar);\n            cb();\n          }\n        ],\n\n\n        /**\n         * Expose version/dependency info for the currently-running\n         * Sails on the `sails` object (from its `package.json`)\n         */\n        versionAndDependencyInfo: function(cb) {\n\n          var pathToThisVersionOfSails = path.join(__dirname, '../../..');\n          sails.util.getPackage(pathToThisVersionOfSails, function(err, json) {\n            if (err) return cb(err);\n\n            sails.version = json.version;\n            sails.majorVersion = sails.version.split('.')[0].replace(/[^0-9]/g, '');\n            sails.minorVersion = sails.version.split('.')[1].replace(/[^0-9]/g, '');\n            sails.patchVersion = sails.version.split('.')[2].replace(/[^0-9]/g, '');\n            sails.dependencies = json.dependencies;\n\n            cb();\n          });\n        },\n\n\n        /**\n         * Ensure that environment variables are applied to important configs\n         */\n        mixinDefaults: ['mapOverrides',\n          function(cb, results) {\n\n            // Get overrides\n            var overrides = results.mapOverrides; //_.cloneDeep(results.mapOverrides);\n\n            // Apply environment variables\n            // (if the config values are not set in overrides)\n            overrides.environment = overrides.environment || process.env.NODE_ENV;\n            overrides.port = overrides.port || process.env.PORT;\n\n            // Generate implicit, built-in framework defaults for the app\n            var implicitDefaults = self.defaults(overrides.appPath || process.cwd());\n\n            // Extend copy of implicit defaults with user config\n            var mergedConfig = _.merge(_.cloneDeep(implicitDefaults), overrides);\n\n\n            // Set the NODE_ENV environment variable so express and other modules\n            // which expect NODE_ENV to be set mirror the configured Sails environment\n            // setting (i.e. `sails.config.environment`).\n            //\n            // Note:\n            // Setting an environment var explicitly to \"undefined\" sets it to the\n            // *string* \"undefined\".  So we only bother setting it if it is truthy.\n            sails.log.verbose('Setting Node environment...');\n            if (mergedConfig.environment) {\n              // If we end up setting NODE_ENV, we first save the original value of NODE_ENV\n              // as `sails._originalNodeEnv`, so that we can potentially revert to it when\n              // lowering the app.  This way if a Sails app is loaded subsequently in the same\n              // process (e.g. tests), it does not end up using an unexpected environment due\n              // to NODE_ENV being set from previous lifts/loads. See the implementation of\n              // `.lower()` for further explanation.\n              sails._originalNodeEnv = process.env['NODE_ENV'];\n              // Note that we also set a flag indicating that we set the `NODE_ENV` at all.\n              // (we could just compare the current NODE_ENV with _originalNodeEnv in `.lower()`,\n              //  but it's not guaranteed to be accurate, since NODE_ENV could have been set again\n              //  for some reason at runtime; e.g. multiple test apps lifting/lowering/popping/locking)\n              sails._setNodeEnvAutomatically = true;\n              process.env['NODE_ENV'] = mergedConfig.environment;\n            }\n\n            cb(null, mergedConfig);\n          }\n        ]\n\n      },\n\n\n      function configLoaded(err, results) {\n        if (err) {\n          sails.log.error('Error encountered loading config ::\\n', err);\n          return cb(err);\n        }\n\n        // Override the previous contents of sails.config with the new, validated\n        // config w/ defaults and overrides mixed in the appropriate order.\n        sails.config = results.mixinDefaults;\n\n        cb();\n      });\n  };\n\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/preinstall_npmcheck.js":"/**\n * npm pre-install script.\n *\n * This script checks if the installed npm-version matches the required engine\n * defined in the package.json.\n */\n\nvar exec = require('child_process').exec;\nvar project = require('./../package.json');\n\n\n// Validate npm version before installing Sails.\nif (project.engines && project.engines.npm) exec('npm -v', validateNpmVersion);\n\n/**\n * Callback for the 'npm -v' execution.\n * @param  err    Possible command execution error.\n * @param  stdout Command execution result.\n */\nfunction validateNpmVersion(err, stdout) {\n\n  // Throw-up process errors.\n  if (err) return exitWithMessage(err);\n\n  // Parse Semver for current and required.\n  var semver = getSemver(stdout);\n  var requiredNpmSemver = getSemver(project.engines.npm, true);\n\n  // Get only the release numbering.\n  var version = semver && semver[1];\n  var requiredNpmVersion = requiredNpmSemver && requiredNpmSemver[1];\n\n  // If no version is identified, stop install.\n  if (!version) exitWithMessage([\n    'Unable to check your npm-version',\n    '',\n    'Please reinstall npm to use Sails.js'\n  ]);\n\n  // Handle old npm installations.\n  if (!satisfiesVersion(version, requiredNpmVersion)) exitWithMessage([\n    'Your current npm version (' + version + ') is not supported:',\n    'Sails requires at least version ' + project.engines.npm,\n    '',\n    'Try uploading npm before installing Sails.'\n  ]);\n\n  console.log('Sails.js Installation: Checking npm-version successful');\n\n  // Exit process with success.\n  process.exit(0);\n}\n\n/**\n * Exit proccess with a given error beautifully.\n */\nfunction exitWithMessage(err, code) {\n\n  // Exit error header.\n  console.log('\\033[31mSails.js Installation - Error');\n  console.log('--------------------------------------------------------\\033[00m');\n\n  // Exit (possibly multiple) error lines.\n  (typeof err === 'string' ? [err] : err).forEach(function (err) {\n    console.log(err);\n  });\n\n  // Exit error footer.\n  console.log('\\033[31m--------------------------------------------------------');\n\n  // Exit processing with a 1 (error) default code.\n  process.exit(code === undefined ? 1 : code);\n}\n\n/**\n * Parse version string into semver array.\n * @param {string} version\n * @param {boolean} range If version is a range, make sure to consider up-front\n *                        specification.\n * @return {Array}  An array with the version's parts or null if not valid.\n */\nfunction getSemver(version, range) {\n\n  // Fulfil possibly missing zeros, if range is allowed.\n  if (range) {\n    version = version.split('.');\n    var missing = 3 - version.length;\n\n    for(;missing > 0; missing--) {\n      version.push(0);\n    }\n\n    version = version.join('.');\n  }\n\n  var versionRegex = '(([0-9]{1,})\\\\.([0-9]{1,})\\\\.([0-9]{1,}))(?:-?(.*))';\n  var regex = new RegExp('^' + (range ? '(?:.*)' : '') + versionRegex + '$');\n\n  return version.replace(/\\s+/g, '').match(regex);\n}\n\n/**\n * Makes a simple '>=' version comparison.\n * @param  {string} version\n * @param  {string} compare\n * @return {boolean}\n */\nfunction satisfiesVersion(version, compare) {\n  version = version.split('.');\n  compare = compare.split('.');\n  var satisfied;\n\n  return compare.every(function (value, i) {\n    if (satisfied !== undefined) return satisfied;\n    if (version[i] > value) return satisfied = true;\n    if (version[i] < value) return satisfied = false;\n\n    return true;\n  }) && satisfied !== false;\n}\n"}