{"/home/travis/build/npmtest/node-npmtest-sails/test.js":"/* istanbul instrument in package npmtest_sails */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-sails/lib.npmtest_sails.js":"/* istanbul instrument in package npmtest_sails */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_sails = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_sails = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-sails/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-sails && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_sails */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_sails\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_sails.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_sails.rollup.js'] =\n            local.assetsDict['/assets.npmtest_sails.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_sails.__dirname + '/lib.npmtest_sails.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/index.js":"/**\n * Module dependencies\n */\n\nvar Sails = require('./app');\n\n\n\n// Instantiate and expose a Sails singleton\n// (maintains legacy support)\nmodule.exports = new Sails();\n\n// Expose constructor for convenience/tests\nmodule.exports.Sails = Sails;\n\n\n// To access the Sails app constructor, do:\n// var Sails = require('sails').constructor;\n// or:\n// var Sails = require('sails').Sails;\n//\n// Then:\n// var newApp = new Sails();\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/app/index.js":"/**\n * Module dependencies.\n */\n\n// try {console.time('require_core');}catch(e){}\nvar Sails = require('./Sails');\nvar _ = require('@sailshq/lodash');\n\n\n/**\n * Expose `Sails` factory\n * (maintains backwards compatibility w/ constructor usage)\n */\n\nmodule.exports = SailsFactory;\n\nfunction SailsFactory() {\n  return new Sails();\n}\n\n\n// Backwards compatibility for Sails singleton usage:\nvar singleton = SailsFactory();\nSailsFactory.isLocalSailsValid = _.bind(singleton.isLocalSailsValid, singleton);\nSailsFactory.isSailsAppSync = _.bind(singleton.isSailsAppSync, singleton);\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/app/Sails.js":"/**\n * Module dependencies.\n */\n\nvar events = require('events');\nvar _ = require('@sailshq/lodash');\nvar util = require('util');\nvar loadSails = require('./load');\nvar mixinAfter = require('./private/after');\nvar __Router = require('../router');\nvar CaptainsLog = require('captains-log');\n\n\n\n/**\n * Construct a Sails (app) instance.\n *\n * @constructor\n */\n\nfunction Sails() {\n\n  // Inherit methods from EventEmitter\n  events.EventEmitter.call(this);\n\n  // Remove memory-leak warning about max listeners\n  // See: http://nodejs.org/docs/latest/api/events.html#events_emitter_setmaxlisteners_n\n  this.setMaxListeners(0);\n\n  // Keep track of spawned child processes\n  this.childProcesses = [];\n\n  // Ensure CaptainsLog exists\n  this.log = CaptainsLog();\n\n  // Build a Router instance (which will attach itself to the sails object)\n  __Router(this);\n\n  // Mixin `load()` method to load the pieces\n  // of a Sails app\n  this.load = loadSails(this);\n\n  // Mixin support for `Sails.prototype.after()`\n  mixinAfter(this);\n\n  // Bind `this` context for all `Sails.prototype.*` methods\n  this.load = _.bind(this.load, this);\n  this.request = _.bind(this.request, this);\n  this.lift = _.bind(this.lift, this);\n  this.lower = _.bind(this.lower, this);\n  this.getBaseurl = _.bind(this.getBaseurl, this);\n  this.initialize = _.bind(this.initialize, this);\n  this.exposeGlobals = _.bind(this.exposeGlobals, this);\n  this.runBootstrap = _.bind(this.runBootstrap, this);\n  this.getHost = _.bind(this.getHost, this);\n  this.isLocalSailsValid = _.bind(this.isLocalSailsValid, this);\n  this.isSailsAppSync = _.bind(this.isSailsAppSync, this);\n  this.inspect = _.bind(this.inspect, this);\n  this.toString = _.bind(this.toString, this);\n  this.toJSON = _.bind(this.toJSON, this);\n  this.all = _.bind(this.all, this);\n  this.get = _.bind(this.get, this);\n  this.post = _.bind(this.post, this);\n  this.put = _.bind(this.put, this);\n  this['delete'] = _.bind(this['delete'], this);\n}\n\n\n// Extend from EventEmitter to allow hooks to listen to stuff\nutil.inherits(Sails, events.EventEmitter);\n\n\n// Public methods\n////////////////////////////////////////////////////////\n\nSails.prototype.lift = require('./lift');\n\nSails.prototype.lower = require('./lower');\n\nSails.prototype._getBaseUrl = require('./getBaseurl');\nSails.prototype.getBaseurl = function() {\n  this.log.warn(\"sails.getBaseUrl() is deprecated and will be removed in Sails v1.0.  See http://sailsjs.org/documentation/reference/application/sails-getbaseurl for more info.\");\n  return this._getBaseUrl();\n};\nSails.prototype.getBaseURL = Sails.prototype.getBaseurl;\nSails.prototype.getBaseUrl = Sails.prototype.getBaseurl;\n\n\nSails.prototype.getRouteFor = require('./get-route-for');\nSails.prototype.getUrlFor = require('./get-url-for');\n\n\n\n// Experimental methods\n////////////////////////////////////////////////////////\n\nSails.prototype.request = require('./request');\n\n\n// Expose Express-esque synonyms for low-level usage of router\nSails.prototype.all = function(path, action) {\n  this.router.bind(path, action);\n  return this;\n};\nSails.prototype.get = function(path, action) {\n  this.router.bind(path, action, 'get');\n  return this;\n};\nSails.prototype.post = function(path, action) {\n  this.router.bind(path, action, 'post');\n  return this;\n};\nSails.prototype.put = function(path, action) {\n  this.router.bind(path, action, 'put');\n  return this;\n};\nSails.prototype.del = Sails.prototype['delete'] = function(path, action) {\n  this.router.bind(path, action, 'delete');\n  return this;\n};\n\n// Private methods:\n////////////////////////////////////////////////////////\n\nSails.prototype.initialize = require('./private/initialize');\nSails.prototype.exposeGlobals = require('./private/exposeGlobals');\nSails.prototype.runBootstrap = require('./private/bootstrap');\nSails.prototype.getHost = require('./private/getHost');\nSails.prototype.isLocalSailsValid = require('./private/isLocalSailsValid');\nSails.prototype.isSailsAppSync = require('./private/isSailsAppSync');\n\n// Presentation\nSails.prototype.inspect = require('./private/inspect');\nSails.prototype.toString = require('./private/toString');\nSails.prototype.toJSON = require('./private/toJSON');\n\n// Utilities\n// Includes lodash, node's `util`, and a few additional\n// static helper methods.\n// (may be deprecated in a future release)\nSails.prototype.util = require('sails-util');\n\n// Expose Sails constructor\nmodule.exports = Sails;\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/app/load.js":"var async = require('async');\nvar _ = require('@sailshq/lodash');\nvar util = require('util');\nvar __Configuration = require('./configuration');\nvar __initializeHooks = require('./private/loadHooks');\n\nmodule.exports = function(sails) {\n\n  var Configuration = __Configuration(sails);\n  var initializeHooks = __initializeHooks(sails);\n\n  /**\n   * Expose loader start point.\n   * (idempotent)\n   *\n   * @api public\n   */\n  return function load(configOverride, cb) {\n\n    if (sails._exiting) {\n      return cb(new Error('\\n*********\\nCannot load or lift an app after it has already been lowered. \\nYou can make a new app instance with:\\nvar SailsApp = require(\\'sails\\').Sails;\\nvar sails = new SailsApp();\\n\\nAnd then you can do:\\nsails.load([opts,] cb)\\n\\n'));\n    }\n\n    // configOverride is optional\n    if (_.isFunction(configOverride)) {\n      cb = configOverride;\n      configOverride = {};\n    }\n\n    // Ensure override is an object and clone it (or make an empty object if it's not)\n    configOverride = configOverride || {};\n    sails.config = _.cloneDeep(configOverride);\n\n\n    // If host is explicitly specified, set `explicitHost`\n    // (otherwise when host is omitted, Express will accept all connections via INADDR_ANY)\n    if (configOverride.host) {\n      configOverride.explicitHost = configOverride.host;\n    }\n\n    // Optionally expose services, models, sails, _, async, etc. as globals as soon as the\n    // user config loads.\n    sails.on('hook:userconfig:loaded', sails.exposeGlobals);\n\n    async.auto({\n\n      // Apply core defaults and hook-agnostic configuration,\n      // esp. overrides including command-line options, environment variables,\n      // and options that were passed in programmatically.\n      config: [Configuration.load],\n\n      // Load hooks into memory, with their middleware and routes\n      hooks: ['config', loadHooks],\n\n      // Populate the \"registry\"\n      // Houses \"middleware-esque\" functions bound by various hooks and/or Sails core itself.\n      // (i.e. `function (req, res [,next]) {}`)\n      //\n      // (Basically, that means we grab an exposed `middleware` object,\n      // full of functions, from each hook, then make it available as\n      // `sails.middleware.[HOOK_ID]`.)\n      //\n      // TODO: finish refactoring to change \"middleware\" nomenclature\n      // to avoid confusion with the more specific (and more common)\n      // usage of the term.\n      registry: ['hooks',\n        function populateRegistry(cb) {\n\n          sails.log.verbose('Instantiating registry...');\n\n          // Iterate through hooks and absorb the middleware therein\n          // Save a reference to registry and expose it on\n          // the Sails instance.\n          sails.middleware = sails.registry =\n          // Namespace functions by their source hook's identity\n          _.reduce(sails.hooks, function(registry, hook, identity) {\n            registry[identity] = hook.middleware;\n            return registry;\n          }, {});\n\n          sails.emit('middleware:registered');\n\n          cb();\n        }\n      ],\n\n      // Load the router and bind routes in `sails.config.routes`\n      router: ['registry', sails.router.load]\n\n    }, ready__(cb));\n\n    // Makes `app.load()` chainable\n    return sails;\n  };\n\n  /**\n   * Load hooks in parallel\n   * let them work out dependencies themselves,\n   * taking advantage of events fired from the sails object\n   *\n   * @api private\n   */\n  function loadHooks(cb) {\n    sails.hooks = { };\n\n    // If config.hooks is disabled, skip hook loading altogether\n    if (sails.config.hooks === false) {\n      return cb();\n    }\n\n    async.series([\n\n      function(cb) {\n        loadHookDefinitions(sails.hooks, cb);\n      },\n      function(cb) {\n        initializeHooks(sails.hooks, cb);\n      }\n    ], function(err) {\n      if (err) return cb(err);\n\n      // Inform any listeners that the initial, built-in hooks\n      // are finished loading\n      sails.emit('hooks:builtIn:ready');\n      sails.log.verbose('Built-in hooks are ready.');\n      return cb();\n    });\n  }\n\n  /**\n   * Load built-in hook definitions from `sails.config.hooks`\n   * and put them back into `hooks` (probably `sails.hooks`)\n   *\n   * @api private\n   */\n  function loadHookDefinitions(hooks, cb) {\n\n    // Mix in user-configured hook definitions\n    _.extend(hooks, sails.config.hooks);\n\n    // Make sure these changes to the hooks object get applied\n    // to sails.config.hooks to keep logic consistent\n    // (I think we can get away w/o this, but leaving as a stub)\n    // sails.config.hooks = hooks;\n\n    // If user configured `loadHooks`, only include those.\n    if (sails.config.loadHooks) {\n      if (!_.isArray(sails.config.loadHooks)) {\n        return cb('Invalid `loadHooks` config.  ' +\n          'Please specify an array of string hook names.\\n' +\n          'You specified ::' + util.inspect(sails.config.loadHooks));\n      }\n\n      _.each(hooks, function(def, hookName) {\n        if (!_.contains(sails.config.loadHooks, hookName)) {\n          hooks[hookName] = false;\n        }\n      });\n      sails.log.verbose('Deliberate partial load-- will only initialize hooks ::', sails.config.loadHooks);\n    }\n\n    return cb();\n  }\n\n  /**\n   * Returns function which is fired when Sails is ready to go\n   *\n   * @api private\n   */\n  function ready__(cb) {\n    return function(err) {\n      if (err) {\n        return cb && cb(err);\n      }\n\n      sails.log.verbose('All hooks were loaded successfully.');\n\n      // If userconfig hook is turned off, still load globals.\n      if (sails.config.hooks && sails.config.hooks.userconfig === false ||\n           (sails.config.loadHooks && sails.config.loadHooks.indexOf('userconfig') == -1)) {\n            sails.exposeGlobals();\n      }\n\n      cb && cb(null, sails);\n    };\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/app/configuration/index.js":"/**\n * Module dependencies.\n */\n\nvar _ = require('@sailshq/lodash');\nvar path = require('path');\nvar DEFAULT_HOOKS = require('./default-hooks');\n\nmodule.exports = function(sails) {\n\n  /**\n   * Expose new instance of `Configuration`\n   */\n\n  return new Configuration();\n\n\n  function Configuration() {\n\n\n    /**\n     * Sails default configuration\n     *\n     * @api private\n     */\n    this.defaults = function defaultConfig(appPath) {\n\n      var defaultEnv;\n      // If we're not loading the userconfig hook, which normally takes care\n      // of ensuring that we have an environment, then make sure we set one here.\n      if (_.isObject(sails.config.hooks) && sails.config.hooks.userconfig === false ||\n         (_.isArray(sails.config.loadHooks) && sails.config.loadHooks.indexOf('userconfig') == -1)\n      ) {\n        defaultEnv = sails.config.environment || \"development\";\n      }\n\n      // If `appPath` not specified, unfortunately, this is a fatal error,\n      // since reasonable defaults cannot be assumed\n      if (!appPath) {\n        throw new Error('No `appPath` specified!');\n      }\n\n      // Set up config defaults\n      return {\n\n        environment: defaultEnv,\n\n        // Note: to avoid confusion re: timing, `hooks` configuration may eventually be removed\n        // from `sails.config` in favor of something more flexible / obvious, e.g. the `app` object\n        // itself (i.e. because you can't configure hooks in `userconfig`-- only in `overrides`).\n\n        // Core (default) hooks\n        hooks: _.reduce(DEFAULT_HOOKS, function (memo, hookBundled, hookIdentity) {\n\n          // if `true`, then the core hook is bundled in the `lib/hooks/` directory\n          // as `lib/hooks/HOOK_IDENTITY`.\n          if (hookBundled === true) {\n            memo[hookIdentity] = require('../../hooks/'+hookIdentity);\n          }\n          // if it's a string, then the core hook is an NPM dependency of sails,\n          // so require it (which grabs it from `node_modules/`)\n          else if (_.isString(hookBundled)) {\n            var hook;\n            try {\n              hook = require(hookBundled);\n            }\n            catch (e) {\n              throw new Error('Sails internal error: Could not require(\\''+hookBundled+'\\')');\n            }\n            memo[hookIdentity] = hook;\n          }\n          // otherwise freak out\n          else {\n            throw new Error('Sails internal error: \"'+hookIdentity+'\", a core hook, is invalid!');\n          }\n          return memo;\n        }, {}) || {},\n\n        // Save appPath in implicit defaults\n        // appPath is passed from above in case `sails lift` was used\n        // This is the directory where this Sails process is being initiated from.\n        // (  usually this means `process.cwd()`  )\n        appPath: appPath,\n\n        // Built-in path defaults\n        paths: {\n          tmp: path.resolve(appPath, '.tmp')\n        },\n\n        // Start off `routes` and `middleware` as empty objects\n        routes: {},\n        middleware: {}\n\n      };\n    },\n\n\n\n    /**\n     * Load the configuration modules\n     *\n     * @api private\n     */\n\n    this.load = require('./load')(sails);\n\n\n\n    // Bind the context of all instance methods\n    _.bindAll(this);\n\n  }\n\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/app/configuration/default-hooks.js":"/**\n * Default hooks\n *\n * (order still matters for now for some of these-\n *  but mostly not, due to ouruse of events...\n *  ...but for a few core hooks, e.g. `moduleloader`,\n *  it still does.)\n */\n\nmodule.exports = {\n  'moduleloader': true,\n  'logger': true,\n  'request': true,\n  'orm': 'sails-hook-orm',\n  'views': true,\n  'blueprints': true,\n  'responses': true,\n  'controllers': true,\n  'sockets': 'sails-hook-sockets',\n  'pubsub': true,\n  'policies': true,\n  'services': true,\n  'csrf': true,\n  'cors': true,\n  'i18n': true,\n  'userconfig': true,\n  'session': true,\n  'grunt': true,\n  'http': true,\n  'userhooks': true\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/app/private/loadHooks.js":"var _ = require('@sailshq/lodash');\nvar async = require('async');\nvar __hooks = require('../../hooks');\nvar defaultsDeep = require('merge-defaults');\n\nmodule.exports = function(sails) {\n\n  var Hook = __hooks(sails);\n\n  /**\n   * Resolve the hook definitions and then finish loading them\n   *\n   * @api private\n   */\n  return function initializeHooks(hooks, cb) {\n\n    function prepareHook(id) {\n\n      var hookPrototype = hooks[id];\n\n      // Allow disabling of hooks by setting them to \"false\"\n      if (hookPrototype === false || hookPrototype === 'false' || hooks[id.split('.')[0]] === false) {\n        delete hooks[id];\n        return;\n      }\n\n      // Check for invalid hook config\n      if (hooks.userconfig && !hooks.moduleloader) {\n        return cb('Invalid configuration:: Cannot use the `userconfig` hook w/o the `moduleloader` hook enabled!');\n      }\n\n      // Handle folder-defined modules (default to index.js)\n      // Since a hook definition must be a function\n      if (_.isObject(hookPrototype) && !_.isArray(hookPrototype) && !_.isFunction(hookPrototype)) {\n        hookPrototype = hookPrototype.index;\n      }\n\n      if (!_.isFunction(hookPrototype)) {\n        sails.log.error('Malformed hook! (' + id + ')');\n        sails.log.error('Hooks should be a function with one argument (`sails`)');\n        process.exit(1);\n      }\n\n      // Instantiate the hook\n      var def = hookPrototype(sails);\n\n      // Mix in an `identity` property to hook definition\n      def.identity = id.toLowerCase();\n\n      // If a config key was defined for this hook when it was loaded,\n      // (probably because a user is overridding the default config key)\n      // set it on the hook definition\n      def.configKey = hookPrototype.configKey || def.identity;\n\n      // New up an actual Hook instance\n      hooks[id] = new Hook(def);\n    }\n\n    // Function to apply a hook's \"defaults\" obj or function\n    function applyDefaults(hook) {\n      // Get the hook defaults\n      var defaults = (_.isFunction(hook.defaults) ?\n                hook.defaults(sails.config) :\n                hook.defaults) || {};\n      // Replace the special __configKey__ key with the actual config key\n      if (hook.defaults.__configKey__ && hook.configKey) {\n        hook.defaults[hook.configKey] = hook.defaults.__configKey__;\n        delete hook.defaults.__configKey__;\n      }\n\n      defaultsDeep(sails.config, defaults);\n    }\n\n    // Load a hook (bind its routes, load any modules and initialize it)\n    function loadHook(id, cb) {\n\n      var timeoutInterval = (sails.config[hooks[id].configKey || id] && sails.config[hooks[id].configKey || id]._hookTimeout) || sails.config.hookTimeout || 20000;\n      var hookTimeout;\n      if (id != 'userhooks') {\n        hookTimeout = setTimeout(function tooLong() {\n          var hooksTookTooLongErr = 'The hook `'+id+'` is taking too long to load.\\n' +\n            'Make sure it is triggering its `initialize()` callback, ' +\n            'or else set `sails.config.' + (hooks[id].configKey || id) +\n            '._hookTimeout to a higher value (currently ' + timeoutInterval + ')';\n          var err = new Error(hooksTookTooLongErr);\n          err.code = 'E_HOOK_TIMEOUT';\n          cb(err);\n        }, timeoutInterval);\n      }\n      hooks[id].load(function(err) {\n        if (id != 'userhooks') {\n          clearTimeout(hookTimeout);\n        }\n        if (err) {\n          if (id != 'userhooks') {\n            sails.log.error('A hook (`' + id + '`) failed to load!');\n          }\n          sails.emit('hook:' + id + ':error');\n          return cb(err);\n        }\n\n        sails.log.verbose(id, 'hook loaded successfully.');\n        sails.emit('hook:' + id + ':loaded');\n\n        // Defer to next tick to allow other stuff to happen\n        process.nextTick(cb);\n      });\n    }\n\n    async.series({\n\n        // First load the moduleloader (if any)\n        moduleloader: function(cb) {\n          if (!hooks.moduleloader) {\n            return cb();\n          }\n          prepareHook('moduleloader');\n          applyDefaults(hooks['moduleloader']);\n          hooks['moduleloader'].configure();\n          loadHook('moduleloader', cb);\n        },\n\n        // Next load the user config (if any)\n        userconfig: function(cb) {\n          if (!hooks.userconfig) {\n            return cb();\n          }\n          prepareHook('userconfig');\n          applyDefaults(hooks['userconfig']);\n          hooks['userconfig'].configure();\n          loadHook('userconfig', cb);\n        },\n\n        // Next get the user hooks (if any), which will be\n        // added to the list of hooks to load\n        userhooks: function(cb) {\n          if (!hooks.userhooks) {\n            return cb();\n          }\n          prepareHook('userhooks');\n          applyDefaults(hooks['userhooks']);\n          hooks['userhooks'].configure();\n          loadHook('userhooks', cb);\n        },\n\n        // Prepare all other hooks\n        prepare: function(cb) {\n          async.each(_.without(_.keys(hooks), 'userconfig', 'moduleloader', 'userhooks'), function (id, cb) {\n            prepareHook(id);\n            // Defer to next tick to allow other stuff to happen\n            process.nextTick(cb);\n          }, cb);\n        },\n\n        // Apply the default config for all other hooks\n        defaults: function(cb) {\n          async.each(_.without(_.keys(hooks), 'userconfig', 'moduleloader', 'userhooks'), function (id, cb) {\n            var hook = hooks[id];\n            applyDefaults(hook);\n            // Defer to next tick to allow other stuff to happen\n            process.nextTick(cb);\n          }, cb);\n        },\n\n        // Run configuration method for all other hooks\n        configure: function(cb) {\n          async.each(_.without(_.keys(hooks), 'userconfig', 'moduleloader', 'userhooks'), function (id, cb) {\n            var hook = hooks[id];\n            try {\n              hook.configure();\n            } catch (e) {\n              return cb(e);\n            }\n            // Defer to next tick to allow other stuff to happen\n            process.nextTick(cb);\n          }, cb);\n        },\n\n        // Load all other hooks\n        load: function(cb) {\n          async.each(_.without(_.keys(hooks), 'userconfig', 'moduleloader', 'userhooks'), function (id, cb) {\n            sails.log.silly('Loading hook: ' + id);\n            loadHook(id, cb);\n          }, cb);\n        }\n      },\n\n      function hooksReady(err) {\n        return cb(err);\n      });\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/hooks/index.js":"/**\n * Module dependencies.\n */\n\nvar _ = require('@sailshq/lodash');\nvar async = require('async');\n\n\n\n\nmodule.exports = function(sails) {\n\n\n  /**\n   * Expose hook constructor\n   *\n   * @api private\n   */\n\n  return function Hook(definition) {\n\n    // A few sanity checks to make sure te provided definition does not contain any reserved properties.\n    if (!_.isObject(definition)) {\n      // This particular behavior can be made a bit less genteel in future versions (it is currently\n      // forgiving for backwards compatibility)\n      definition = definition || {};\n    }\n    \n    if (_.isFunction(definition.config)) {\n      throw new Error('Error defining hook: `config` is a reserved property and cannot be used as a custom hook method.');\n    }\n    if (_.isFunction(definition.middleware)) {\n      throw new Error('Error defining hook: `middleware` is a reserved property and cannot be used as a custom hook method.');\n    }\n    \n\n\n    /**\n     * Load the hook asynchronously\n     *\n     * @api private\n     */\n\n    this.load = function(cb) {\n\n      var self = this;\n\n      var routeCallbacks = function(routes) {\n        _.each(routes, function(middleware, route) {\n          middleware._middlewareType = self.identity.toUpperCase() + ' HOOK' + (middleware.name ? (': ' + middleware.name) : '');\n          sails.router.bind(route, middleware);\n        });\n      };\n\n      // Determine if this hook should load based on Sails environment & hook config\n      if (this.config.envs &&\n        this.config.envs.length > 0 &&\n        this.config.envs.indexOf(sails.config.environment) === -1) {\n        return cb();\n      }\n\n      // Convenience config to bind routes before any of the static app routes\n      sails.on('router:before', function() {\n        routeCallbacks(self.routes.before);\n      });\n\n      // Convenience config to bind routes after the static app routes\n      sails.on('router:after', function() {\n        routeCallbacks(self.routes.after);\n      });\n\n      // Run loadModules method if moduleloader is loaded\n      async.auto({\n\n        modules: function(cb) {\n\n            if (sails.config.hooks.moduleloader) {\n\n              return self.loadModules(cb);\n\n            }\n            return cb();\n          }\n\n      }, function(err) {\n        if (err) return cb(err);\n        try {\n          self.initialize(cb);\n        } catch(e) {\n          return cb(e);\n        }\n      });\n\n    };\n\n\n\n    /**\n     * `defaults`\n     *\n     * Default configuration for this hook.\n     *\n     * Hooks may override this function, or use a dictionary instead.\n     *\n     * @type {Function|Dictionary}\n     *       @returns {Dictionary} [default configuration for this hook to be merged into sails.config]\n     */\n    this.defaults = function(config) {\n      return {};\n    };\n\n    /**\n     * `configure`\n     *\n     * If this hook provides this function, the provided implementation should\n     * normalize and validate configuration related to this hook.  That config is\n     * already in `sails.config` at the time this function is called.  Any modifications\n     * should be made in place on `sails.config`\n     *\n     * Hooks may override this function.\n     *\n     * @type {Function}\n     */\n    this.configure = function() {\n\n    };\n\n    /**\n     * `loadModules`\n     *\n     * Load any modules as a dictionary and pass the loaded modules to the callback when finished.\n     *\n     * Hooks may override this function (This runs before `initialize()`!)\n     *\n     * @type {Function}\n     * @async\n     */\n    this.loadModules = function(cb) {\n      return cb();\n    };\n\n\n    /**\n     * `initialize`\n     *\n     * If provided, this implementation should prepare the hook, then trigger the callback.\n     *\n     * Hooks may override this function.\n     *\n     * @type {Function}\n     * @async\n     */\n    this.initialize = function(cb) {\n      return cb();\n    };\n\n\n\n    // Ensure that the hook definition has valid properties\n    _normalize(this);\n    definition = _normalize(definition);\n\n    // Merge default definition with overrides in the definition passed in\n    _.extend(definition.config, this.config, definition.config);\n    _.extend(definition.middleware, this.middleware, definition.middleware);\n    _.extend(definition.routes.before, this.routes.before, definition.routes.before);\n    _.extend(definition.routes.after, this.routes.after, definition.routes.after);\n    _.extend(this, definition);\n\n    // Bind context of new methods from definition\n    _.bindAll(this);\n\n\n\n    /**\n     * Ensure that a hook definition has the required properties.\n     * \n     * @returns {Dictionary} [coerced hook definition]\n     * @api private\n     */\n\n    function _normalize(def) {\n\n      def = def || {};\n\n      // Default hook config\n      def.config = def.config || {};\n\n      // list of environments to run in, if empty defaults to all\n      def.config.envs = def.config.envs || [];\n\n      def.middleware = def.middleware || {};\n\n      // Default hook routes\n      def.routes = def.routes || {};\n      def.routes.before = def.routes.before || {};\n      def.routes.after = def.routes.after || {};\n\n      return def;\n    }\n  };\n\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/app/private/after.js":"/**\n * Module dependencies\n */\n\nvar _ = require('@sailshq/lodash');\nvar async = require('async');\n\n\n//\n// TODO\n// Pull this into a separate module, since it's not specific to Sails.\n//\n\n\n/**\n * Mix-in an `after` function to an EventEmitter.\n *\n * If `events` have already fired, trigger fn immediately (with no args)\n * Otherwise bind a normal one-time event using `EventEmitter.prototype.once()`.\n * Useful for checking whether or not something has finished loading, etc.\n *\n * This is a lot like jQuery's `$(document).ready()`.\n *\n * @param  {EventEmitter} emitter\n */\n\nmodule.exports = function mixinAfter(emitter) {\n\n\n  /**\n   * { emitter.warmEvents }\n   *\n   * Events which have occurred at least once\n   * (Required to support `emitter.after()`)\n   */\n  emitter.warmEvents = {};\n\n\n  /**\n   * emitter.emit()\n   *\n   * Override `EventEmitter.prototype.emit`.\n   * (Required to support `emitter.after()`)\n   */\n\n  var _emit = emitter.emit;\n  emitter.emit = function(evName) {\n    var args = Array.prototype.slice.call(arguments, 0);\n    emitter.warmEvents[evName] = true;\n    _emit.apply(emitter, args);\n  };\n\n\n  /**\n   * `emitter.after()`\n   *\n   * Fires your handler **IF THE SPECIFIED EVENT HAS ALREADY BEEN TRIGGERED** or **WHEN IT IS TRIGGERED**.\n   *\n   * @param  {String|Array} events   [name of the event(s)]\n   * @param  {Function}     fn       [event handler function]\n   * @context {Sails}\n   */\n\n  emitter.after = function(events, fn) {\n\n    // Support a single event or an array of events\n    if (!_.isArray(events)) {\n      events = [events];\n    }\n\n    // Convert named event dependencies into an array\n    // of async-compatible functions.\n    var dependencies = _.reduce(events,\n      function(dependencies, event) {\n\n        var handlerFn = function(cb) {\n          if (emitter.warmEvents[event]) {\n            cb();\n          } else {\n            emitter.once(event, cb);\n          }\n        };\n        dependencies.push(handlerFn);\n        return dependencies;\n      }, []);\n\n    // When all events have fired, call `fn`\n    // (all arguments passed to `emit()` calls are discarded)\n    async.parallel(dependencies, function(err) {\n      if (err) sails.log.error(err);\n      return fn();\n    });\n\n  };\n\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/router/index.js":"/**\n * Module dependencies.\n */\n\nvar Readable = require('stream').Readable;\nvar QS = require('querystring');\nvar _ = require('@sailshq/lodash');\nvar Express = require('@sailshq/express');\n\nvar buildReq = require('./req');\nvar buildRes = require('./res');\nvar defaultHandlers = require('./bindDefaultHandlers');\n\n\n/**\n * Expose new instance of `Router`\n *\n * @api private\n */\nmodule.exports = function(sails) {\n  return new Router({sails: sails});\n};\n\n\n\n/**\n * Initialize a new `Router`\n *\n * @param {Object} options\n * @api private\n */\n\nfunction Router(options) {\n\n  options = options || {};\n  this.sails = options.sails;\n  this.defaultHandlers = defaultHandlers(this.sails);\n\n  // Expose router on `sails` object\n  this.sails.router = this;\n\n  // Required for dynamic NODE_ENV setting via command line args\n  // TODO:\n  // instead, use: https://www.npmjs.org/package/path-to-regexp\n  // (or: https://www.npmjs.org/package/path-match)\n  this._privateRouter = Express();\n\n  // Bind the context of all instance methods\n  this.load = _.bind(this.load, this);\n  this.bind = _.bind(this.bind, this);\n  this.unbind = _.bind(this.unbind, this);\n  this.reset = _.bind(this.reset, this);\n  this.flush = _.bind(this.flush, this);\n  this.route = _.bind(this.route, this);\n}\n\n\n/**\n * _privateRouter\n *\n * This internal \"private\" instance of an Express appobject\n * is used only for routing. (i.e. it will not be used for\n * listening to actual HTTP requests; instead, one or more\n * delegate servers can be attached- see the `http` or\n * `sockets` hooks for examples of attaching a server to\n * Sails)\n *\n * NOTE: Requires calling `load()` before use in order to\n * provide access to the proper NODE_ENV, since Express\n * uses that to determine its environment (development vs.\n * production.)\n */\n\n// Router.prototype._privateRouter;\n\n\n\n/**\n * `sails.router.load()`\n *\n * Expose the router, create the Express private router,\n * then call flush(), which will bind configured routes\n * and emit the appropriate events.\n *\n * @api public\n */\n\nRouter.prototype.load = function(cb) {\n  var sails = this.sails;\n\n  sails.log.verbose('Loading router...');\n\n  // Maintain a reference to the static route config\n  this.explicitRoutes = sails.config.routes;\n\n  // Save reference to sails logger\n  this.log = sails.log;\n\n  var sessionSecret = sails.config.session && sails.config.session.secret;\n  // If a session store is configured, hook it up as `req.session` by passing\n  // it down to the session middleware\n  if (sails.hooks.session) {\n    sails.after('hook:session:loaded', function (){\n      // if (!sails.config.session || !sails.config.session.store || !sails.config.session.secret) {\n      //   return cb(new Error('Consistency violation: expected session store+secret config to exist if the session hook is enabled. Is `sails.config.session` valid?'));\n      // }\n\n      // Set \"resave\" and \"saveUninitialized\" options or else express-session gives you a stern warning.\n      var opts = _.merge({\n        resave: true,\n        saveUninitialized: true\n      }, sails.config.session);\n      sails._privateSessionMiddleware = require('express-session')(opts);\n    });\n  }\n  // Otherwise double check the session secret (if one is provided) since it's usually checked\n  // in the session hook.\n  else {\n    // If available, Sails uses the configured session secret for signing cookies.\n    if (sessionSecret) {\n      // Ensure secret is a string.  This check happens in the session hook as well,\n      // but sails.config.session.secret may still be provided even if the session hook\n      // is turned off, so to be extra anal we'll check here as well.\n      if (!_.isString(sessionSecret)) {\n        return cb(new Error('If provided, sails.config.session.secret should be a string.'));\n      }\n    }\n  }\n  if (sessionSecret) {\n    sails._privateCpMware = require('cookie-parser')(sessionSecret);\n  } else {\n    sails._privateCpMware = require('cookie-parser')();\n  }\n\n  // Wipe any existing routes and bind them anew\n  this.flush();\n\n  // Listen for requests\n  sails.on('router:request', this.route);\n\n  // Listen for unhandled errors and unmatched routes\n  sails.on('router:request:500', this.defaultHandlers[500]);\n  sails.on('router:request:404', this.defaultHandlers[404]);\n\n  cb();\n};\n\n\n\n/**\n * `sails.router.route(partialReq, partialRes)`\n *\n * Interpret the specified (usually partial) request and response objects into\n * streams with all of the expected methods, then routes the fully-formed request\n * using the built-in private router. Useful for creating virtual request/response\n * streams from non-HTTP sources, like Socket.io or unit tests.\n *\n * This method is not always helpful-- it is not called for HTTP requests, for instance,\n * since the true HTTP req/res streams already exist.  In that case, at lift-time, Sails\n * calls `router:bind`, which loads Sails' routes as normal middleware/routes in the http hook.\n * stack will run as usual.\n *\n * On the other hand, Socket.io needs to use this method (i.e. the `router:request` event)\n * to simulate a connect-style router since it can't bind dynamic routes ahead of time.\n *\n * Keep in mind that, if `route` is not used, the implementing server is responsible\n * for routing to Sails' default `next(foo)` handler.\n *\n * @param {Request} req\n * @param {Response} res\n * @api private\n */\n\nRouter.prototype.route = function(req, res) {\n  var sails = this.sails;\n  var _privateRouter = this._privateRouter;\n\n  // If sails is `_exiting`, ignore the request.\n  if (sails._exiting) {\n    return;\n  }\n\n  // Provide access to SailsApp instance as `req._sails`.\n  req._sails = req._sails || sails;\n\n  // Note that, at this point, `req` and `res` are just dictionaries containing\n  // the properties of each object that have been built up _so far_.\n  //\n  // Use base req and res definitions to ensure the specified\n  // objects are at least ducktype-able as standard node HTTP\n  // req and req streams.\n  //\n  // Make sure request and response objects have reasonable defaults\n  // (will use the supplied definitions if possible)\n  req = buildReq(req);\n  res = buildRes(req, res);\n\n  // console.log('\\n\\n\\n\\n=======================\\nReceived request to %s %s\\nwith req.body:\\n',req.method,req.url, req.body);\n\n  // Deprecation error:\n  res._cb = function _cbIsDeprecated(err) {\n    throw new Error('As of v0.10, `_cb()` shim is no longer supported in the Sails router.');\n  };\n\n\n  // Run some basic middleware\n  sails.log.silly('Handling virtual request :: Running virtual querystring parser...');\n  qsParser(req,res, function (err) {\n    if (err) {\n      return res.send(400, err && err.stack);\n    }\n\n    // Parse cookies\n    parseCookies(req, res, function(err){\n      if (err) {\n        return res.send(400, err && err.stack);\n      }\n\n      // console.log('Ran cookie parser');\n      // console.log('res.writeHead= ',res.writeHead);\n\n      // Load session (if relevant)\n      loadSession(req, res, function (err) {\n        if (err) {\n          return res.send(400, err && err.stack);\n        }\n        // console.log('res is now:\\n',res);\n        // console.log('\\n\\n');\n        // console.log('Ran session middleware');\n        // console.log('req.sessionID= ',req.sessionID);\n        // console.log('The loaded req.session= ',req.session);\n\n        sails.log.silly('Handling virtual request :: Running virtual body parser...');\n        bodyParser(req,res, function (err) {\n          if (err) {\n            return res.send(400, err && err.stack);\n          }\n\n          // Use our private router to route the request\n          _privateRouter.router(req, res, function handleUnmatchedNext(err) {\n            //\n            // In the event of an unmatched `next()`, `next('foo')`,\n            // or `next('foo', errorCode)`...\n            //\n\n            // Use the default server error handler\n            if (err) {\n              sails.log.silly('Handling virtual request :: Running final \"error\" handler...');\n              sails.emit('router:request:500', err, req, res);\n              return;\n            }\n\n            // Or the default not found handler\n            sails.log.silly('Handling virtual request :: Running final \"not found\" handler...');\n            sails.emit('router:request:404', req, res);\n            return;\n          });\n        });\n      });\n\n    });\n  });\n\n};\n\n\n\n/**\n * `sails.router.bind()`\n *\n * Bind new route(s)\n *\n * @param {String|RegExp} path\n * @param {String|Object|Array|Function} bindTo\n * @param {String} verb\n * @api private\n */\n\nRouter.prototype.bind = require('./bind');\n\n\n\n/**\n * `sails.router.unbind()`\n *\n * Unbind existing route\n *\n * @param {Object} route\n * @api private\n */\n\nRouter.prototype.unbind = function(route) {\n\n  var sails = this.sails;\n\n  // Inform attached servers that route should be unbound\n  sails.emit('router:unbind', route);\n\n  // Remove route in internal router\n  var newRoutes = [];\n  _.each(this._privateRouter.routes[route.method], function(expressRoute) {\n    if (expressRoute.path !== route.path) {\n      newRoutes.push(expressRoute);\n    }\n  });\n  this._privateRouter.routes[route.method] = newRoutes;\n\n};\n\n\n\n/**\n * `sails.router.reset()`\n *\n * Unbind all routes currently attached to the router\n *\n * @api private\n */\n\nRouter.prototype.reset = function() {\n  var sails = this.sails;\n\n  // Unbind everything\n  _.each(this._privateRouter.routes, function(routes, httpMethod) {\n\n    // Unbind each route for the specified HTTP verb\n    var routesToUnbind = this._privateRouter.routes[httpMethod] || [];\n    _.each(routesToUnbind, this.unbind, this);\n\n  }, this);\n\n\n  // Emit reset event to allow attached servers to\n  // unbind all of their routes as well\n  sails.emit('router:reset');\n\n};\n\n\n\n/**\n * `sails.router.flush()`\n *\n * Unbind all current routes, then re-bind everything, re-emitting the routing\n * lifecycle events (e.g. `router:before` and `router:after`)\n *\n * @param {Object} routes - (optional)\n *  If specified, replaces `this.explicitRoutes` before flushing.\n *\n * @api private\n */\n\nRouter.prototype.flush = function(routes) {\n  var sails = this.sails;\n\n  // Wipe routes\n  this.reset();\n\n  // Fired before static routes are bound\n  sails.emit('router:before');\n\n  // If specified, replace `this.explicitRoutes`\n  if (routes) {\n    this.explicitRoutes = routes;\n  }\n\n  // Use specified path to bind static routes\n  _.each(this.explicitRoutes, function(target, path) {\n    this.bind(path, target);\n  }, this);\n\n\n  // Fired after static routes are bound\n  sails.emit('router:after');\n};\n\n\n\n\n\n\n\n\n\n////////////////////////////////////////////////////////////////////////////////////////////////////\n//\n// ||     Private functions\n// \\/\n//\n////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n\n\n\n// Extremely simple query string parser (`req.query`)\nfunction qsParser(req,res,next) {\n  var queryStringPos = req.url.indexOf('?');\n  if (queryStringPos !== -1) {\n    req.query = _.merge(req.query, QS.parse(req.url.substr(queryStringPos + 1)));\n  }\n  else {\n    req.query = req.query || {};\n  }\n  next();\n}\n// Extremely simple body parser (`req.body`)\nfunction bodyParser (req, res, next) {\n\n  // Set up a mock `req.file()` clarifying that req.file() is not available\n  // outside of the context of Skipper (i.e. in this case, most commonly from\n  // socket.io virtual requests).\n  req.file = function fileUploadsNotAvailable(){\n    return res.send(500, 'Streaming file uploads via `req.file()` are only available over HTTP with Skipper.');\n  };\n\n  var bodyBuffer='';\n  if (req.method === 'GET' || req.method === 'HEAD' || req.method === 'DELETE'){\n    req.body = _.extend({}, req.body);\n    return next();\n  }\n\n  // Ensure that `req` is a readable stream at this point\n  if ( ! req instanceof Readable ) {\n    return next(new Error('Sails Internal Error: `req` should be a Readable stream by the time `route()` is called'));\n  }\n\n  req.on('readable', function() {\n    var chunk;\n    while (null !== (chunk = req.read())) {\n      bodyBuffer += chunk;\n    }\n  });\n  req.on('end', function() {\n\n    var parsedBody;\n    try {\n      parsedBody = JSON.parse(bodyBuffer);\n    } catch (e) {}\n\n    req.body = _.merge(req.body, parsedBody);\n    next();\n  });\n}\n\n\n\n\n\n\n\n/**\n * [parseCookies description]\n * @param  {[type]}   req  [description]\n * @param  {[type]}   res  [description]\n * @param  {Function} next [description]\n * @return {[type]}        [description]\n */\nfunction parseCookies (req, res, next){\n\n  // req._sails.log.verbose('Parsing cookie:',req.headers.cookie);\n\n  if (req._sails._privateCpMware) {\n    // Run the middleware\n    return req._sails._privateCpMware(req, res, next);\n  }\n\n  // Otherwise don't even worry about it.\n  return next();\n}\n\n\n\n/**\n * [loadSession description]\n * @param  {[type]}   req  [description]\n * @param  {[type]}   res  [description]\n * @param  {Function} next [description]\n * @return {[type]}        [description]\n */\nfunction loadSession (req, res, next){\n\n  // If a session store is configured, and we haven't deliberately disabled\n  // session support for this request by setting the \"nosession\" header,\n  // hook up the store up as `req.session` by passing it down to the\n  // session middleware.\n  if (req._sails._privateSessionMiddleware && !req.headers.nosession) {\n\n    // Access store preconfigured session middleware as a private property on the app instance.\n    return req._sails._privateSessionMiddleware(req, res, next);\n  }\n\n  // Otherwise don't even worry about it.\n  return next();\n}\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/router/req.js":"/**\n * Module dependencies\n */\n\nvar _ = require('@sailshq/lodash');\nvar defaultsDeep = require('merge-defaults');\nvar MockReq = require('mock-req');\nvar parseurl = require('parseurl');\n\n/**\n * Factory which builds generic Sails request object (i.e. `req`).\n *\n * This generic implementation of `req` forms the basis for\n * Sails' transport-agnostic support of Connect/Express\n * middleware.  Used by hooks (i.e. sockets) but also for\n * tests-- both at the app-level and in Sails core.\n *\n * @param {Dictionary} _req\n *        the properties of this simulated request object that\n *        have been built up _so far_.\n *\n * @return {Request} simulated HTTP request object\n * @idempotent\n */\n\nmodule.exports = function buildRequest (_req) {\n\n  // Make sure _req is not undefined\n  _req = _req||{};\n\n  // Start our request object, which will be built by inheriting/transforming\n  // properties of _req and adding some spice of our own\n  var req;\n\n  // Attempt to parse the URL in _req, so that we can get the querystring\n  // and path\n  var parsedUrl;\n  try {parsedUrl = parseurl(_req) || {};}\n  catch (e) {parsedUrl = {};}\n\n  // If `_req` appears to be a stream (duck-typing), then don't try\n  // and turn it into a mock stream again.\n  if (typeof _req === 'object' && _req.read) {\n    req = _req;\n  }\n  else {\n\n    // TODO: send a PR to mock-req with a fix for this\n    if (_req.headers && typeof _req.headers === 'object') {\n      // Strip undefined headers\n      _.each(_req.headers, function (headerVal, headerKey) {\n        if (_.isUndefined(headerVal)){\n          delete _req.headers[headerKey];\n        }\n      });\n      // Make sure all remaining headers are strings\n      _req.headers = _.mapValues(_req.headers, function (headerVal, headerKey) { // :TODO 'headerKey' is defined but never used\n        if (typeof headerVal !== 'string') {\n          headerVal = ''+headerVal+'';\n        }\n        return headerVal;\n      });\n    }\n\n    // Create a mock IncomingMessage stream.\n    req = new MockReq({\n      method: _req && (_.isString(_req.method) ? _req.method.toUpperCase() : 'GET'),\n      headers: _req && _req.headers || {},\n      url: _req && _req.url\n    });\n\n    // Add .get() and .header() methods to match express 3\n    req.get = req.header = function (name) {\n      switch (name = name.toLowerCase()) {\n      case 'referer':\n      case 'referrer':\n        return this.headers.referrer || this.headers.referer;\n      default:\n        return this.headers[name];\n      }\n    };\n\n    // Now pump client request body to the mock IncomingMessage stream (req)\n    // Req stream ends automatically if this is a GET or HEAD or DELETE request\n    // (since there is no request body in that case) so no need to do it again.\n    if (req.method !== 'GET' && req.method !== 'HEAD' && req.method !== 'DELETE') {\n\n      // Only write the body if there IS a body.\n      if (req.body) {\n        req.write(req.body);\n      }\n      req.end();\n    }\n  }\n\n  // Track request start time\n  req._startTime = new Date();\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // Note that other core methods _could_ be added here for use w/ the virtual\n  // router.  But as per convo w/ dougwilson, the same _cannot_ be done for HTTP\n  // requests coming out of Express.  They would either have to (a) rely on modifying\n  // the HTTP request (IncomingMessage) prototype, or (B) rely on context (i.e. `this`),\n  // which would require `_.bind()`-ing them to avoid issues when triggered from\n  // userland code. And re: (B) at that point, the performance impact is effectively\n  // the same as if they were attached on the fly on a per-request basis.\n  //\n  // So we only initially attach `req.*` methods & properties here which are _not_\n  // already built-in to the mock request, and which are _not_ already taken care of\n  // by hooks, AND which don't rely on `res` (because it hasn't been built yet).\n  ////////////////////////////////////////////////////////////////////////////////\n\n  // Provide defaults for other request state and methods\n  req = defaultsDeep(req, {\n    params: [],\n    query: (_req && _req.query) || require('querystring').parse(parsedUrl.query) || {},\n    body: (_req && _req.body) || {},\n    param: function(paramName, defaultValue) {\n\n      var key, params = {};\n      for (key in (req.params || {}) ) {\n        params[key] = params[key] || req.params[key];\n      }\n      for (key in (req.query || {}) ) {\n        params[key] = params[key] || req.query[key];\n      }\n      for (key in (req.body || {}) ) {\n        params[key] = params[key] || req.body[key];\n      }\n\n      // Grab the value of the parameter from the appropriate place\n      // and return it\n      if (typeof params[paramName] !== 'undefined') {\n        return params[paramName];\n      } else {\n        return defaultValue;\n      }\n\n    },\n    wantsJSON: (_req && _req.wantsJSON === false) ? false : true,\n    method: 'GET',\n    originalUrl: _req.originalUrl || _req.url,\n    path: _req.path || parsedUrl.pathname\n  }, _req||{});\n\n  return req;\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/router/res.js":"/**\n * Module dependencies\n */\nvar util = require('util');\nvar Transform = require('stream').Transform;\nvar _ = require('@sailshq/lodash');\nvar MockRes = require('mock-res');\n\n\n/**\n * Ensure that response object has a minimum set of reasonable defaults\n * Used primarily as a test fixture.\n *\n * @api private\n * @idempotent\n */\n\nmodule.exports = function _buildResponse (req, _res) {\n  _res = _res||{};\n  req = req||{};\n\n  var res;\n\n  // If `_res` appears to be a stream (duck-typing), then don't try\n  // and turn it into a mock stream again.\n  if (typeof _res === 'object' && _res.end) {\n    res = _res;\n  }\n  else {\n    res = new MockRes();\n    delete res.statusCode;\n  }\n\n\n  // Ensure res.headers and res.locals exist.\n  res = _.extend(res, {locals: {}, headers: {}, _headers: {}});\n  res = _.extend(res, _res);\n\n  // Now that we're sure `res` is a Transform stream, we'll handle the two different\n  // approaches which a user of the virtual request interpreter might have taken:\n\n  // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  // (1) Providing a callback function (`_clientCallback`)\n  //\n  // If a `_clientCallback` function was provided, also pipe `res` into a\n  // fake clientRes stream where the response `body` will be buffered.\n  if (res._clientCallback) {\n\n    // If `res._clientRes` WAS NOT provided, then create one\n    if (!res._clientRes) {\n      res._clientRes = new MockClientResponse();\n    }\n\n    // Session is saved automatically since the virtual request interpreter is\n    // using `express-session` directly as of https://github.com/balderdashy/sails/commit/58e93f5a5f2e667e3fbeddf5b4b356f813e3555e.\n\n    // The stream should trigger the callback when it finishes or errors.\n    res._clientRes.on('finish', function() {\n      return res._clientCallback(res._clientRes);\n    });\n    res._clientRes.on('error', function(err) {\n      err = err || new Error('Error on response stream');\n      res._clientRes.statusCode = 500;\n      res._clientRes.body = err;\n      return res._clientCallback(res._clientRes);\n    });\n\n  }\n  // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  // (2) Providing a Writable stream (`_clientRes`)\n  //\n  // If a `_clientRes` response Transform stream was provided, pipe `res` directly to it.\n  if (res._clientRes) {\n    res.pipe(res._clientRes);\n  }\n  //\n  // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n\n  // Track whether headers have been written\n  // (TODO: pull all this into mock-res via a PR)\n\n  // res.writeHead() is wrapped in closure by the `on-header` module,\n  // but it still needs the underlying impl\n  res.writeHead = function ( /* statusCode, [reasonPhrase], headers */) {\n    // console.log('\\n\\n res.writeHead(%s)', Array.prototype.slice.call(arguments));\n    var statusCode = +arguments[0];\n    //TODO: Analyze this code, reasonPhras not used\n    var reasonPhrase = (function(){\n      if (arguments[2] && _.isString(arguments[1])) {\n        return arguments[1];\n      }\n      return undefined;\n    })();\n    var newHeaders = (function (){\n      if (arguments[2] && _.isObject(arguments[2])) {\n        return arguments[2];\n      }\n      return arguments[1];\n    })();\n\n    if (!statusCode) {\n      throw new Error('`statusCode` must be passed to res.writeHead().');\n    }\n    // Set status code\n    res.statusCode = statusCode;\n\n    // Ensure `._headers` have been merged into `.headers`\n    _.extend(res.headers, res._headers);\n\n    if (newHeaders) {\n      if (!_.isObject(newHeaders)) {\n        throw new Error('`headers` must be passed to res.writeHead() as an object. Got: '+util.inspect(newHeaders, false, null));\n      }\n      // Set new headers\n      _.extend(res.headers, newHeaders);\n    }\n\n    // Set status code and headers on the `_clientRes` stream so they are accessible\n    // to the provider of that stream.\n    // (this has to happen in `send()` because the code/headers might have just changed)\n    if (res._clientRes) {\n      // console.log('Setting headers on clientRes- res.headers = ',res.headers);\n      res._clientRes.headers = res.headers;\n      res._clientRes.statusCode = res.statusCode;\n    }\n\n  };\n\n\n  // Wrap res.write() and res.end() to get them to call writeHead()\n  var prevWrite = res.write;\n  res.write = function (){\n    res.writeHead(res.statusCode, _.extend(res._headers,res.headers));\n    // console.log('res.write():: called writeHead with headers=',_.extend(res._headers,res.headers));\n    prevWrite.apply(res, Array.prototype.slice.call(arguments));\n  };\n  var prevEnd = res.end;\n  res.end = function (){\n    res.writeHead(res.statusCode, _.extend(res._headers,res.headers));\n    // console.log('our res.end() was triggered');\n    // console.log('res.end():: called writeHead with headers=',_.extend(res._headers,res.headers));\n    prevEnd.apply(res, Array.prototype.slice.call(arguments));\n  };\n\n\n  // we get `setHeader` from mock-res\n  // see http://nodejs.org/api/http.html#http_response_setheader_name_value\n  //\n  // Usage:\n  // response.setHeader(\"Set-Cookie\", [\"type=ninja\", \"language=javascript\"]);\n\n  // If we ever need to wrap it...\n  //\n  // var prevSetHeader = res.setHeader;\n  // res.setHeader = function (){\n  //   prevSetHeader.apply(res, Array.prototype.slice.call(arguments));\n  // };\n\n  // res.status()\n  res.status = res.status || function status_shim (statusCode) {\n    res.statusCode = statusCode;\n    return res;\n  };\n\n  // res.send()\n  res.send = res.send || function send_shim () {\n    var args = normalizeResArgs(arguments);\n\n    // Don't allow users to respond/redirect more than once per request\n    // TODO: prbly move this check to our `res.writeHead()` impl\n    try {\n      onlyAllowOneResponse(res);\n    }\n    catch (e) {\n      if (req._sails && req._sails.log && req._sails.log.error) {\n        req._sails.log.error(e);\n        return;\n      }\n      // TODO: use debug()\n      console.error(e);\n      return;\n    }\n\n    // Ensure charset is set\n    res.charset = res.charset || 'utf-8';\n\n    // Ensure headers are set\n    _.extend(res.headers, res._headers);\n\n    // Ensure statusCode is set\n    // (override `this.statusCode` if `statusCode` argument specified)\n    res.statusCode = args.statusCode || res.statusCode || 200;\n\n    // if a `_clientCallback` was specified, we'll skip the streaming stuff for res.send().\n    if (res._clientCallback) {\n\n      // Hard-code `res.body` rather than writing to the stream.\n      // (but don't include body if it is empty)\n      if (args.other) {\n        res.body = args.other;\n        // Then expose on res._clientRes.body\n        res._clientRes.body = res.body;\n      }\n\n      // End the `res` stream (which will in turn end the `res._clientRes` stream)\n      res.end();\n      return;\n    }\n\n    //\n    // Otherwise, the hook using the interpreter must have provided us with a `res._clientRes` stream,\n    // so we'll need to serialize everything to work w/ that stream.\n    //\n\n    // console.log('\\n---\\nwriting to clientRes stream...');\n    // console.log('res.headers =>',res.headers);\n    // console.log('res._headers =>',res._headers);\n\n    // Write body to `res` stream\n    if (args.other) {\n\n      var toWrite = args.other;\n\n      if (typeof toWrite === 'object') {\n        try {\n          toWrite = JSON.stringify(args.other);\n\n          // original way:\n          // toWrite = util.inspect(toWrite);\n        }\n        catch(e) {\n          var failedStringify = new Error(\n            'Failed to stringify specified JSON response body :: ' + util.inspect(args.other) +\n            '\\nError:\\n' + util.inspect(e)\n          );\n          // console.log('failed to stringify!');\n          if (req._sails && req._sails.log && req._sails.log.error) {\n            req._sails.log.error(failedStringify);\n          }\n          else {\n            // todo: use debug()\n            console.error(failedStringify);\n          }\n          toWrite = failedStringify.message;\n          res.statusCode = 500;\n        }\n      }\n      res.write(toWrite);\n    }\n\n    // End the `res` stream.\n    res.end();\n  };\n\n  // res.json()\n  res.json = res.json || function json_shim () {\n    var args = normalizeResArgs(arguments);\n    return res.send(args.other, args.statusCode || res.statusCode || 200);\n  };\n\n  // res.render()\n  res.render = res.render || function render_shim (relativeViewPath, locals, cb) {\n    if (_.isFunction(arguments[1])) {\n      cb = arguments[1];\n      locals = {};\n    }\n\n    if (!req._sails) {\n      return  res.send(500, 'Cannot call res.render() - `req._sails` was not attached');\n    }\n    if (!req._sails.renderView) {\n      return res.send(500, 'Cannot call res.render() - `req._sails.renderView` was not attached (perhaps `views` hook is not enabled?)');\n    }\n\n    // TODO:\n    // Instead of this shim, turn `sails.renderView` into something like\n    // `sails.hooks.views.render()`, and then call it.\n    return res.send(501,'Not implemented in core yet');\n  };\n\n  // res.redirect()\n  res.redirect = res.redirect || function redirect_shim () {\n    var args = normalizeResArgs(arguments);\n\n    var address = args.other;\n\n    // Set location header\n    res.set('Location',address);\n\n    // address = this.get('Location');\n    return res.send(args.statusCode || res.statusCode || 302, 'Redirecting to '+encodeURI(address));\n  };\n\n\n\n  /**\n   * res.set( headerName, value )\n   *\n   * @param {[type]} headerName [description]\n   * @param {[type]} value   [description]\n   */\n  res.set = function (headerName, value) {\n    res.headers = res.headers || {};\n    res.headers[headerName] = value;\n    return this;\n  };\n\n  /**\n   * res.get( headerName )\n   *\n   * @param  {[type]} headerName [description]\n   * @return {[type]}            [description]\n   */\n  res.get = function (headerName) {\n    return res.headers && res.headers[headerName];\n  };\n\n\n\n  return res;\n\n\n};\n\n\n/**\n * As long as one of them is a number (i.e. a status code),\n * allows a 2-nary method to be called with flip-flopped arguments:\n *    method( [statusCode|other], [statusCode|other] )\n *\n * This avoids confusing errors & provides Express 2.x backwards compat.\n *\n * E.g. usage in res.send():\n *    var args    = normalizeResArgs.apply(this, arguments),\n *      body    = args.other,\n *      statusCode  = args.statusCode;\n *\n * @api private\n */\nfunction normalizeResArgs( args ) {\n\n  // Traditional usage:\n  // `method( other [,statusCode] )`\n  var isNumeric = function (x) {\n    return (+x === x);\n  };\n  if (isNumeric(args[0])) {\n    return {\n      statusCode: args[0],\n      other: args[1]\n    };\n  }\n  else return {\n    statusCode: args[1],\n    other: args[0]\n  };\n}\n\n\n/**\n * NOTE: ALL RESPONSES (INCLUDING REDIRECTS) ARE PREVENTED ONCE THE RESPONSE HAS BEEN SENT!!\n * Even though this is not strictly required with sockets, since res.redirect()\n * is an HTTP-oriented method from Express, it's important to maintain consistency.\n *\n * @api private\n */\nfunction onlyAllowOneResponse (res) {\n  if (res._virtualResponseStarted) {\n    throw new Error('Cannot write to response more than once');\n  }\n  res._virtualResponseStarted = true;\n}\n\n\n// The constructor for clientRes stream\n// (just a normal transform stream)\nfunction MockClientResponse() {\n  Transform.call(this);\n}\nutil.inherits(MockClientResponse, Transform);\nMockClientResponse.prototype._transform = function(chunk, encoding, next) {\n  this.push(chunk);\n  next();\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/router/bindDefaultHandlers.js":"/**\n * Module dependencies\n */\n\nvar _ = require('@sailshq/lodash');\n\n\n/**\n * Default 500 and 404 handler.\n * (defers to res.serverError() and res.notFound() whenever possible)\n *\n * With default hook configuration, these handlers apply to both HTTP\n * and virtual requests\n */\nmodule.exports = function(sails) {\n\n\n  return {\n\n    /**\n     * Default 500 handler.\n     * (for errors implicitly thrown in middleware/routes)\n     *\n     * @param  {*} err\n     * @param  {Request} req\n     * @param  {Response} res\n     */\n    500: function(err, req, res) {\n\n      // console.log('* * * FIRED DEFAULT HANDLER (500) * * *');\n      // console.log('args:',arguments);\n      // console.log('* * * </FIRED_DEFAULT_HANDLER_500> * * *');\n      // console.log();\n\n      // First, check for special built-in errors from Express.\n      // We don't necessarily want to treat any error that is thrown with\n      // a `status` property of 400 as if it were intentional.  So we also check\n      // the error message.  In Express 5, hopefully this can be improved a bit\n      // further.\n      if (_.isError(err)) {\n        var msgMatches = err.message.match(/^Failed to decode param \\'([^']+)\\'/);\n        if (err.status === 400 && msgMatches) {\n          sails.log.verbose('Bad request: Could not decode the requested URL ('+req.path+')');\n          // Note for future: The problematic URL section is: `msgMatches[1]`\n          return res.send(400, 'Bad request: Could not decode requested URL.');\n        }\n      }//>-\n\n      // Next, try to use `res.negotiate()`, if it exists and is valid.\n      try {\n\n        if (typeof res.negotiate === 'function') {\n          return res.negotiate(err);\n        }//>-\n\n      } catch (e) { /* ignore any unexpected error encountered when attempting to respond w/ res.negotiate(). */ }\n\n      // Catch-all:\n      // Log a message and try to use `res.send` to respond.\n      try {\n\n        sails.log.error('Server Error:');\n        sails.log.error(err);\n        if (process.env.NODE_ENV === 'production') { return res.send(500); }\n        return res.send(500, err);\n\n      } catch (errorSendingResponse) {\n\n        // Serious error occurred-- unable to send response.\n        //\n        // Note that in the future, we could also emit an `abort` message on the request object\n        // in this case-- then if an attached server is managing this request, it could monitor\n        // for `abort` events and manage its private resources (e.g. TCP sockets) accordingly.\n        // However, such contingencies should really handled by the underlying HTTP hook, so\n        // this might not actually make sense.\n        sails.log.error('But no response could be sent because another error occurred:');\n        sails.log.error(errorSendingResponse);\n\n      }//</catch>\n    },\n\n\n\n    /**\n     * Default 404 handler.\n     * (for unmatched routes)\n     *\n     * @param  {Request} req\n     * @param  {Response} res\n     */\n    404: function(req, res) {\n\n      // Use `notFound` handler if it exists\n      try {\n        if (typeof res.notFound === 'function') {\n          return res.notFound();\n        }\n      } catch (e) {}\n\n      // Catch-all:\n      // Log a message and try to use `res.send` to respond.\n      try {\n        sails.log.verbose('A request (%s) did not match any routes, and no `res.notFound` handler is configured.', req.url);\n        res.send(404);\n        return;\n      }\n\n      // Serious error occurred-- unable to send response.\n      //\n      // Note that in the future, we could also emit an `abort` message on the request object\n      // in this case-- then if an attached server is managing this request, it could monitor\n      // for `abort` events and manage its private resources (e.g. TCP sockets) accordingly.\n      // However, such contingencies should really handled by the underlying HTTP hook, so\n      // this might not actually make sense.\n      catch (e) {\n        sails.log.error('An unmatched route was encountered in a request...');\n        sails.log.error('But no response could be sent because an error occurred:');\n        sails.log.error(e);\n        return;\n      }\n    }\n  };\n\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/router/bind.js":"/**\n * Module dependencies.\n */\n\nvar _ = require('@sailshq/lodash');\nvar sailsUtil = require('sails-util');\n\n\n\n/**\n * Expose `bind` method.\n */\nmodule.exports = bind;\n\n\n\n/**\n * Bind new route(s)\n *\n * @param {String|RegExp} path\n * @param {String|Object|Array|Function} target\n * @param {String} verb (optional)\n * @param {Object} options (optional)\n *\n * @this {SJSRouter}\n * @return {SJSApp}\n *\n * @api private\n */\n\nfunction bind( /* path, target, verb, options */ ) {\n  var sails = this.sails;\n\n  var args = sanitize.apply(this, Array.prototype.slice.call(arguments));\n  var path = args.path;\n  var target = args.target;\n  var verb = args.verb;\n  var options = args.options;\n\n  // Don't allow paths with \"length\" as a route param, because Express chokes on it\n  if (path.match(/\\/:length($|\\/)/)) {\n    throw new Error('Failed to bind route: `'+ path +'`\\n'+\n    'Routes which contain `/:length` in their address URL are not supported by Sails/Express (consider using `/:len`)');\n  }\n\n  // Bind a list of multiple functions in order\n  if (_.isArray(target)) {\n    bindArray.apply(this, [path, target, verb, options]);\n  }\n  // Handle string redirects\n  // (to either public-facingURLs or internal routes)\n  else if (_.isString(target) && target.match(/^(https?:|\\/)/)) {\n    bindRedirect.apply(this, [path, target, verb, options]);\n  }\n\n  // Bind a middleware function directly\n  else if (_.isFunction(target)) {\n    bindFunction.apply(this, [path, target, verb, options]);\n  }\n\n  // If target is an object with a `target`, pull out the rest\n  // of the keys as route options and then bind the target.\n  else if (_.isPlainObject(target) && (target.target || target.fn)) {\n    var _target = target.target || target.fn;\n    options = _.merge(options, _.omit(target, 'target'));\n    bind.apply(this, [path, _target, verb, options]);\n  }\n  else {\n\n    // If we make it here, the router doesn't know how to parse the target.\n    //\n    // This doesn't mean that it's necessarily invalid though--\n    // so we'll emit an event informing any listeners that an unrecognized route\n    // target was encountered.  Then hooks can listen to this event and act\n    // accordingly.  This makes it easier to add functionality to Sails.\n    sails.emit('route:typeUnknown', {\n      path: path,\n      target: target,\n      verb: verb,\n      options: options\n    });\n\n    // Note that, in the future, it would be good to track emissions of \"typeUnknown\" to\n    // avoid logic errors that result in circular routes.\n    // (part of the effort to make a more friendly environment for custom hook developers)\n  }\n\n  // Makes `.bind()` chainable (sort of)\n  return sails;\n\n}\n\n\n\n/**\n * Requests will be redirected to the specified string\n * (which should be a URL or redirectable path.)\n *\n * @api private\n */\nfunction bindRedirect(path, redirectTo, verb, options) {\n  var sails = this.sails;\n\n  bind.apply(this,[path, function(req, res) {\n    sails.log.verbose('Redirecting request (`' + path + '`) to `' + redirectTo + '`...');\n    res.redirect(redirectTo);\n  }, verb, options]);\n}\n\n\n/**\n * Recursively bind an array of targets in order\n *\n * TODO: Use a counter to prevent indefinite loops--\n * only possible if a bad route is bound,\n * but would still potentially be helpful.\n *\n * @api private\n */\nfunction bindArray(path, target, verb, options) {\n  var self = this;\n  var sails = this.sails;\n\n  if (target.length === 0) {\n    sails.log.verbose('Ignoring empty array in `router.bind(' + path + ')`...');\n  } else {\n    // Bind each middleware fn\n    _.each(target, function(fn) {\n      bind.apply(self,[path, fn, verb, options]);\n    });\n  }\n}\n\n\n\n/**\n * Attach middleware function to route.\n *\n * @api private\n */\nfunction bindFunction(path, fn, verb, options) {\n  var sails = this.sails;\n\n  // Regex to check if a URL is an asset (something with a file extension)\n  var skipAssetsRegex = /^[^?]*\\/[^?\\/]+\\.[^?\\/]+(\\?.*)?$/;\n\n  // Make sure (optional) options is a valid plain object ({})\n  options = _.isPlainObject(options) ? _.cloneDeep(options) : {};\n  var _middlewareType = options._middlewareType || fn._middlewareType || (fn.name && ('FUNCTION: ' + fn.name));\n  sails.log.silly('Binding route :: ', verb || '', path, _middlewareType?('('+_middlewareType+')'):'');\n\n\n  /**\n   * `router:route`\n   *\n   * Create a closure that emits the `router:route` event each time the route is hit\n   * before actually triggering the target function.\n   *\n   * NOTE: Modifications to route path parameters (i.e. `req.params`) or to `req.options`\n   * must be made here, since their values can change not only on a per-request, but\n   * also a per-route basis.\n   */\n  var enhancedFn = function routeTargetFnWrapper(req, res, next) {\n\n    // Set req.options, using `options` to supply default values\n    req.options = _.merge({}, options || {}, req.options || {});\n\n    // This event can be tapped into to take control of\n    // (synchronous) logic that should be run before each bound\n    // route handler function runs.\n    sails.emit('router:route', {\n      req: req,\n      res: res,\n      next: next,\n      options: options,\n      fn: fn\n    });\n\n\n    // Trigger original route handler function.\n    fn(req, res, next);\n  };\n\n  /**\n   * Wrap a regex route in a helper function that pulls out regex params\n   *\n   * Example: for route: 'r|/\\\\d+/(.*)/(.*)$|foo,bar', the two parenthesized\n   * groups would be pulled out as req.params[0] and req.params[1] by Express;\n   * the regexRouteWrapper would then map them to req.params['foo'] and req.params['bar']\n   *\n   * @param  {array} params List of params to apply to the req.params object\n   * @return {Function} A middleware function\n   */\n  var regexRouteWrapper = function(params) {\n\n    return function(req, res, next) {\n      // Apply the regex route params\n      params.forEach(function(param, index) {\n        req.params[param] = req.params[index];\n      });\n      // Call enhancedFn\n      enhancedFn(req, res, next);\n    };\n  };\n\n  /**\n   * Wrap a route in a helper function that first checks whether the URL matches\n   * any of a set of regexes, and if so, skips the defined handler.\n   *\n   * @param  {array}   regexes Array of regexes to match the URL against\n   * @param  {Function} fn      Middleware function to run if URL does NOT match regexes\n   * @return {Function} A middleware function\n   */\n  var skipRegexesWrapper = function(regexes, fn) {\n\n    // Remove anything that's not a regex\n    regexes = _.compact(regexes.map(function(regex) {\n      if (regex instanceof RegExp) {\n        return regex;\n      }\n      sails.log.warn('Invalid regex \"' + regex + \"' supplied to skipRegexesWrapper; ignoring.\");\n      return undefined;\n    }));\n\n\n    return function(req, res, next) {\n\n      // Check for matches\n      for (var i = 0; i < regexes.length; i++) {\n        if (req.url.match(regexes[i])) {\n          // If we find one, bail out\n          return next();\n        }\n      }\n\n      // Otherwise continue with the handler\n      return fn(req, res, next);\n\n    };\n\n  };\n\n  // If verb is not specified, default to CRUD methods.\n  // You can still explicitly route to \"all /path\" if you want ALLLLlllll the things.\n  var targetVerb = verb || ['get', 'put', 'post', 'delete', 'patch'];\n\n  // Function to actually bind\n  var targetFn;\n\n  // Regex to check if the route is...a regex.\n  var regExRoute = /^r\\|(.*)\\|(.*)$/;\n\n  // Perform the check\n  var matches = path.match(regExRoute);\n\n  // If it *is* a regex, create a RegExp object that Express can bind,\n  // pull out the params, and wrap the handler in regexRouteWrapper\n  if (matches) {\n    path = new RegExp(matches[1]);\n    var params = matches[2].split(',');\n    targetFn = regexRouteWrapper(params);\n  }\n\n  // Otherwise just bind enhancedFn\n  else {\n    targetFn = enhancedFn;\n  }\n\n  // If options.skipRegex is specified, make sure it's an array\n  if (options.skipRegex) {\n    if (!Array.isArray(options.skipRegex)) {\n      options.skipRegex = [options.skipRegex];\n    }\n  }\n  // Otherwise just make it an empty array\n  else {\n    options.skipRegex = [];\n  }\n\n  // If \"skipAssets\" option is true, add the skipAssets regex\n  // to the options.skipRegex array\n  if (options.skipAssets) {\n    options.skipRegex.push(skipAssetsRegex);\n  }\n\n  // If we have anything in the options.skipRegex array, wrap\n  // the target function again.\n  if (options.skipRegex.length) {\n    targetFn = skipRegexesWrapper(options.skipRegex, targetFn);\n  }\n\n  // Ensure targetVerb is an array\n  if (!Array.isArray(targetVerb)) {targetVerb = [targetVerb];}\n  // Loop through the verbs we want to bind\n  targetVerb.forEach(function(verb) {\n    verb = verb.toLowerCase();\n    // Bind the function to the private router\n    sails.router._privateRouter[verb](path, targetFn);\n    // Emit an event to make hooks aware that a route was bound\n    // This allows hooks to handle routes directly if they want to-\n    // e.g. with Express, the handler for this event looks like:\n    // sails.hooks.http.app[verb || 'all'](path, target);\n    sails.emit('router:bind', {\n      path: path,\n      target: targetFn,\n      verb: verb,\n      options: options,\n      originalFn: fn\n    });\n\n  });\n\n\n}\n\n\n\n/**\n * Sanitize the arguments to `sails.router.bind()`\n *\n * @returns {Object} sanitized arguments\n * @api private\n */\nfunction sanitize(path, target, verb, options) {\n  options = options || {};\n\n  // If trying to bind '*', that's probably not what was intended, so fix it up\n  path = path === '*' ? '/*' : path;\n\n  // If route has an HTTP verb (e.g. `get /foo/bar`, `put /bar/foo`, etc.) parse it out,\n  var detectedVerb = sailsUtil.detectVerb(path);\n  // then prune it from the path\n  path = detectedVerb.original;\n  // Keep track of parsed verb so we know if it was specified later\n  options.detectedVerb = detectedVerb;\n\n  // If a verb override was not specified,\n  // use the detected verb from the string route\n  if (!verb) {\n    verb = detectedVerb.verb;\n  }\n\n  return {\n    path: path,\n    target: target,\n    verb: verb,\n    options: options\n  };\n}\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails-util/index.js":"var _ = require('lodash'),\n\tnodeutil = require('util'),\n\tfs = require('fs'),\n\tsafeStringify = require('json-stringify-safe');\n\t_.str = require('underscore.string');\n\n\n\n\n// Extend util with underscore/lodash\n// and underscore.string methods\n_.extend(exports, _);\n\n\n// Merge in util submodules\nvar CLIUtil = require('./cli');\n_.extend(exports, CLIUtil);\n\n\n// Extend with node util methods\n_.extend(exports, nodeutil);\n\n\n/**\n * Accept things like `FooController` or `FoO`, then transform\n * and lower-case them to things like `foo`\n *\n * @api private\n */\n\nexports.normalizeControllerId = function normalizeControllerId (controllerId) {\n\tif (!_.isString(controllerId)) {\n\t\treturn null;\n\t}\n\tcontrollerId = controllerId.replace(/(.+)Controller$/i, '$1');\n\tcontrollerId = controllerId.toLowerCase();\n\treturn controllerId;\n};\n\n\n\n\n\n/**\n * Accept things like `FooAdapter` or `FoO`, then transform\n * and lower-case them to things like `foo`\n *\n * Works for adapters, controllers, and services\n *\n * @api private\n */\n\nexports.normalizeId = function normalizeId (id) {\n\tif (!_.isString(id)) {\n\t\treturn null;\n\t}\n\tid = id.replace(/(.+)(Controller|Adapter|Service)$/i, '$1');\n\tid = id.toLowerCase();\n\treturn id;\n};\n\n\n\n\n\n/**\n * isValidECMA51Variable\n *\n * @param {String} v\n *\n * @api private\n */\n\nexports.isValidECMA51Variable = function(v) {\n\treturn v.match(/^(?!(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$)[$A-Z\\_a-z\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u08a0\\u08a2-\\u08ac\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0977\\u0979-\\u097f\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c33\\u0c35-\\u0c39\\u0c3d\\u0c58\\u0c59\\u0c60\\u0c61\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d60\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f4\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f0\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1877\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191c\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19c1-\\u19c7\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1ce9-\\u1cec\\u1cee-\\u1cf1\\u1cf5\\u1cf6\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2119-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u212d\\u212f-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u2e2f\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309d-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua697\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua78e\\ua790-\\ua793\\ua7a0-\\ua7aa\\ua7f8-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa80-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uabc0-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc][$A-Z\\_a-z\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u08a0\\u08a2-\\u08ac\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0977\\u0979-\\u097f\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c33\\u0c35-\\u0c39\\u0c3d\\u0c58\\u0c59\\u0c60\\u0c61\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d60\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f4\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f0\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1877\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191c\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19c1-\\u19c7\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1ce9-\\u1cec\\u1cee-\\u1cf1\\u1cf5\\u1cf6\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2119-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u212d\\u212f-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u2e2f\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309d-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua697\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua78e\\ua790-\\ua793\\ua7a0-\\ua7aa\\ua7f8-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa80-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uabc0-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc0-9\\u0300-\\u036f\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u0669\\u0670\\u06d6-\\u06dc\\u06df-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u06f0-\\u06f9\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07c0-\\u07c9\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0859-\\u085b\\u08e4-\\u08fe\\u0900-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09cd\\u09d7\\u09e2\\u09e3\\u09e6-\\u09ef\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2\\u0ae3\\u0ae6-\\u0aef\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c01-\\u0c03\\u0c3e-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0c66-\\u0c6f\\u0c82\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0ce6-\\u0cef\\u0d02\\u0d03\\u0d3e-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4d\\u0d57\\u0d62\\u0d63\\u0d66-\\u0d6f\\u0d82\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0df2\\u0df3\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0e50-\\u0e59\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e\\u0f3f\\u0f71-\\u0f84\\u0f86\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102b-\\u103e\\u1040-\\u1049\\u1056-\\u1059\\u105e-\\u1060\\u1062-\\u1064\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b4-\\u17d3\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u18a9\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u194f\\u19b0-\\u19c0\\u19c8\\u19c9\\u19d0-\\u19d9\\u1a17-\\u1a1b\\u1a55-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1b00-\\u1b04\\u1b34-\\u1b44\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1b82\\u1ba1-\\u1bad\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c24-\\u1c37\\u1c40-\\u1c49\\u1c50-\\u1c59\\u1cd0-\\u1cd2\\u1cd4-\\u1ce8\\u1ced\\u1cf2-\\u1cf4\\u1dc0-\\u1de6\\u1dfc-\\u1dff\\u200c\\u200d\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2cef-\\u2cf1\\u2d7f\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua620-\\ua629\\ua66f\\ua674-\\ua67d\\ua69f\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua823-\\ua827\\ua880\\ua881\\ua8b4-\\ua8c4\\ua8d0-\\ua8d9\\ua8e0-\\ua8f1\\ua900-\\ua909\\ua926-\\ua92d\\ua947-\\ua953\\ua980-\\ua983\\ua9b3-\\ua9c0\\ua9d0-\\ua9d9\\uaa29-\\uaa36\\uaa43\\uaa4c\\uaa4d\\uaa50-\\uaa59\\uaa7b\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uaaeb-\\uaaef\\uaaf5\\uaaf6\\uabe3-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe26\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f]*$/);\n};\n\n\n\n\n\n\n/**\n * defaultsDeep\n *\n * Implement a deep version of `_.defaults`.\n *\n * @api private\n */\n\nexports.defaultsDeep = _.partialRight(_.merge, _.defaults);\n\n\n\n\n\n\n/**\n * Normalize an error or array of errors into an array of proper, readable Errors\n *\n * @param {String|Object|Error|Array} errOrErrs\n * @returns {Array[Error]}\n *\n * @api private\n */\n\nexports.normalizeErrors = function normalizeErrors(errOrErrs) {\n\n\t// If `errOrErrs` is not an array already, make it one\n\tvar errorsToDisplay = _.isArray(errOrErrs) ? errOrErrs : [errOrErrs];\n\n\t// Ensure that each error is formatted correctly\n\treturn _.map(errorsToDisplay, function (e, i) {\n\t\tvar displayError;\n\n\t\t// Make error easier to read, and normalize its type\n\t\tif (e instanceof Error) {\n\t\t\tdisplayError = e;\n\t\t}\n\n\t\t// Create an error ad hoc\n\t\t// (but save reference to original)\n\t\telse {\n\t\t\tdisplayError = new Error( nodeutil.inspect(e) );\n\t\t\tdisplayError.original = e;\n\t\t}\n\n\t\treturn displayError;\n\t});\n};\n\n\n\n\n\n\n/**\n * Detect HTTP verb in an expression like:\n * `get baz`    or     `get /foo/baz`\n *\n * @api private\n */\n\nexports.detectVerb = function (haystack) {\n\tvar verbExpr = /^(all|get|post|put|delete|trace|options|connect|patch|head)\\s+/i;\n\tvar verbSpecified = _.last(haystack.match(verbExpr) || []) || '';\n\tverbSpecified = verbSpecified.toLowerCase();\n\n\t// If a verb was specified, eliminate the verb from the original string\n\tif (verbSpecified) {\n\t\thaystack = haystack.replace(verbExpr,'');\n\t}\n\n\treturn {\n\t\tverb: verbSpecified,\n\t\toriginal: haystack,\n\t\tpath: haystack\n\t};\n};\n\n\n\n\n\n\n\n/**\n * pluralize\n *\n * Run a method meant for a single object on a single instance OR array.\n * For a list, run the method on each item return the resulting array.\n * For anything else, return it silently.\n *\n * @api private\n */\n\nexports.pluralize = function pluralize(collection, application) {\n\tif(_.isArray(collection)) {\n\t\treturn _.map(collection, application);\n\t}\n\treturn application(collection);\n};\n\n\n\n\n\n\n/**\n * Detect if a string is \"safe\" to eval()\n *\n * @api private\n */\n\nexports.safeToEval = function(someString) {\n\ttry {\n\t\t!(/[^,:{}\\[\\]0-9.\\-+Eaeflnr-u \\n\\r\\t]/.test(someString.replace(/\"(\\\\.|[^\"\\\\])*\"/g, ''))) && eval('(' + someString + ')');\n\t} catch(e) {\n\t\treturn false;\n\t}\n\treturn true;\n};\n\n\n\n\n\n\n/**\n * Return whether the specified item is an object, but NOT an array or function\n *\n * TODO:\treplace usages of this method with `instanceof`\n *\t\t\tand `_.isPlainObject()`\n *\n * @api private\n *\n * @api private\n */\nexports.isDictionary = function isDictionary(thing) {\n\treturn _.isObject(thing) && !_.isArray(thing) && !_.isFunction(thing);\n};\n\n\n\n\n\n\n\n\n/**\n * optional\n *\n * Wrap a callback function to make it optional\n *\n * @api private\n */\n\nexports.optional = function wrapOptionalCallback (cb) {\n\tif ( _.isFunction(cb) ) return cb;\n\treturn function _noOp (){};\n\n\t// return function optionalCallback () {\n\t// \tif (!cb) return;\n\t// \tvar args = Array.prototype.slice.call(arguments);\n\t// \treturn cb.apply(this, args);\n\t// };\n};\n\n\n\n\n/**\n * Get the domain out of the origin header--\n * compare it to the host\n *\n * @api private\n */\n\nexports.isSameOrigin = function isSameOrigin(req, strict) {\n\n\t// If there's no origin header, consider it same origin unless\n\t// we're in strict mode\n\tif (!req.headers.origin) {\n\t\treturn !strict;\n\t}\n\n\t// Get the domain and port out of the origin header\n\tvar matches = req.headers.origin.match(/^https?:\\/\\/([^:]+)(:(\\d+))?$/);\n\t// If the origin doesn't match the regex, consider it okay if we're not\n\t// in strict mode--this will allow non-http origins like \"chrome-extension://\"\n\tif (matches === null) {\n\t\treturn !strict;\n\t}\n\tvar domain = matches[1];\n\tvar port = matches[3];\n\n\t// Compare it to the host\n\treturn (req.host == domain && (!port || req.port == port));\n};\n\n\n\n\n/**\n * Return whether the given object is an instance of Error\n *\n * @api private\n */\n\nexports.isError = function (e) {\n\treturn e instanceof Error;\n};\n\n\n\n\n\n/**\n * Extract the file extension suffix from a filename or path\n *\n * @api private\n */\n\nexports.fileExtension = function(str) {\n\tif(str === null) return '';\n\tvar pieces = String(str).split('.');\n\treturn pieces.length > 1 ? _.last(pieces) : '';\n};\n\n\n\n\n/**\n * Return the abbreviated ordinal string for a given integer\n *\n * http://en.wikipedia.org/wiki/Ordinal_number_(linguistics)\n * i.e. prettier rendering of things like: 1st, 2nd, 3rd, 4th\n *\n * @api private\n */\n\nexports.ordinal = function(integer) {\n\tif(_.isFinite(+integer) && Math.floor(+integer) === +integer) {\n\t\tvar lastDigit = +integer % 10;\n\t\tvar lastTwoDigits = +integer % 100;\n\t\tvar response = integer + \"\";\n\n\t\t// Handle n-teen case\n\t\tif(lastTwoDigits >= 11 && lastTwoDigits <= 13) {\n\t\t\treturn response + \"th\";\n\t\t}\n\n\t\t// Handle general case\n\t\tswitch(lastDigit) {\n\t\tcase 1:\n\t\t\treturn response + \"st\";\n\t\tcase 2:\n\t\t\treturn response + \"nd\";\n\t\tcase 3:\n\t\t\treturn response + \"rd\";\n\t\tdefault:\n\t\t\treturn response + \"th\";\n\t\t}\n\t}\n\tthrow new Error(\"sails.util.ordinal() only works on integers!\");\n};\n\n\n\n\n\n/**\n * Get the names of a function's arguments\n *\n * @param {Function} func\n * @returns array of argument names, e.g. ['req', 'res']\n *\n * @api private\n */\nexports.getParamNames = function(func) {\n\n\tvar STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg;\n\tvar fnStr = func.toString().replace(STRIP_COMMENTS, '');\n\tvar result = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).match(/([^\\s,]+)/g);\n\tif (result === null)\n\t\tresult = [];\n\treturn result;\n};\n\n\n\n\n/**\n * parseJSONFile\n *\n * Read a json file at the specified path.\n * If an error occurs, call cb(err), and dont throw!\n *\n * @api private\n */\n\nexports.parseJSONFile = function ( path, cb ) {\n\tif (!cb) throw new Error('Callback required!');\n\tif (cb === 'sync') {\n\t\tvar jsonString;\n\t\ttry {\n\t\t\tjsonString = fs.readFileSync(path, 'utf-8');\n\t\t}\n\t\tcatch (e) {\n\t\t\treturn false;\n\t\t}\n\t\treturn andThen(jsonString);\n\t}\n\tfs.readFile(path, 'utf-8', function (err, file) {\n\t\tif (err) return cb(err);\n\t\tandThen(file);\n\t});\n\n\t// Attempt to parse JSON, then return\n\tfunction andThen( json ) {\n\t\tvar err;\n\t\ttry {\n\t\t\tjson = JSON.parse(json);\n\t\t} catch (e) {\n\t\t\terr = e;\n\t\t\tjson = false;\n\t\t}\n\n\t\t// Parse failed:\n\t\tif (err) {\n\t\t\tif (cb==='sync') return false;\n\t\t\telse return cb(err);\n\t\t}\n\n\t\t// Success:\n\t\tif ( cb === 'sync' ) return json;\n\t\treturn cb(null, json);\n\t}\n};\n\n/**\n * getJSONFileSync\n *\n * Synchronous version of getJSONFile()\n * Returns false if json file cannot be read or parsed.\n *\n * @api private\n */\n\nexports.parseJSONFileSync = function ( path ) {\n\treturn exports.parseJSONFile(path, 'sync');\n};\n\n\n\n\n/**\n * getPackage\n *\n * Read package.json file in the directory at the specified\n * path.  If an error occurs, call cb(err), and dont throw!\n *\n * @api private\n */\n\nexports.getPackage = function (path, cb) {\n\tpath = _.str.rtrim(path, '/');\n\tpath += '/package.json';\n\n\texports.parseJSONFile(path, function (err, json) {\n\t\tif (err) return cb(err);\n\n\t\t// Success:\n\t\t// Ensure dependencies are at least an empty object\n\t\tjson.dependencies = json.dependencies || {};\n\t\tif ( cb === 'sync' ) return json;\n\t\treturn cb(null, json);\n\t});\n};\n\n\n\n\n\n\n/**\n * getPackageSync\n *\n * Synchronous version of getPackage()\n * Returns false if package.json cannot be read or parsed.\n *\n * @api private\n */\n\nexports.getPackageSync = function (path) {\n\tpath = _.str.rtrim(path, '/');\n\tpath += '/package.json';\n\n\t// Success:\n\t// Ensure dependencies are at least an empty object\n\tvar json = exports.parseJSONFileSync(path, 'sync');\n\tif (!json) return json;\n\tjson.dependencies = json.dependencies || {};\n\treturn json;\n};\n\n\n\n\n/**\n * Get path to the home directory in an OS-agnostic way\n *\n * @api private\n */\n\nexports.homeDirectory = function () {\n\treturn process.env[\n\t\t(process.platform == 'win32') ?\n\t\t'USERPROFILE' :\n\t\t'HOME'\n\t];\n};\n\n\n\n\n\n/**\n * tolerantParse\n *\n * Parse specified JSON, but if it fails,\n * return false instead of throwing.\n *\n * @api private\n */\n\nexports.tolerantParse = function ( json ) {\n\tvar args = Array.prototype.slice.call(arguments);\n\ttry {\n\t\treturn JSON.parse.apply(this, args);\n\t} catch (e) {\n\t\treturn false;\n\t}\n};\n\n\n\n\n\n/**\n * Wrapper for @isaacs' `json-stringify-safe`\n *\n * Automatically handles circular references.\n * See: https://github.com/isaacs/json-stringify-safe\n *\n * If stringification doesn't work, instead of throwing,\n * return false.\n *\n * @api private\n */\nexports.stringify = function ( json, serializer, indent, decycler ) {\n\tvar args = Array.prototype.slice.call(arguments);\n\ttry {\n\t\treturn safeStringify.apply(this, args);\n\t}\n\tcatch (e) {\n\t\treturn false;\n\t}\n};\n\n\n\n\n\n\n\n// Underscore extensions for objects\n_.extend(exports,{\n\n\n\n\t/**\n\t * _.objMap\n\t *\n\t * _.map for objects, keeps key/value associations\n\t *\n\t * @api private\n\t */\n\n\tobjMap: function(input, mapper, context) {\n\t\treturn _.reduce(input, function(obj, v, k) {\n\t\t\tobj[k] = mapper.call(context, v, k, input);\n\t\t\treturn obj;\n\t\t}, {}, context);\n\t},\n\n\n\n\n\t/**\n\t * _.objFilter\n\t *\n\t * _.filter for objects, keeps key/value associations\n\t * but only includes the properties that pass test().\n\t *\n\t * @api private\n\t */\n\n\tobjFilter: function(input, test, context) {\n\t\treturn _.reduce(input, function(obj, v, k) {\n\t\t\tif(test.call(context, v, k, input)) {\n\t\t\t\tobj[k] = v;\n\t\t\t}\n\t\t\treturn obj;\n\t\t}, {}, context);\n\t},\n\n\n\n\n\t/**\n\t * _.objReject\n\t *\n\t * _.reject for objects, keeps key/value associations\n\t * but does not include the properties that pass test().\n\t *\n\t * @api private\n\t */\n\n\tobjReject: function(input, test, context) {\n\t\treturn _.reduce(input, function(obj, v, k) {\n\t\t\tif(!test.call(context, v, k, input)) {\n\t\t\t\tobj[k] = v;\n\t\t\t}\n\t\t\treturn obj;\n\t\t}, {}, context);\n\t},\n\n\n\n\t/**\n\t * _.objInvoke\n\t *\n\t * Usage:\n\t *\tobj -> the object\n\t *\targuments* -> other arguments can be specified to be invoked on each of the functions\n\t *\n\t * @api private\n\t */\n\n\tobjInvoke: function(obj) {\n\t\tvar args = _.toArray(arguments).shift();\n\t\treturn exports.objMap(obj, function(fn) {\n\t\t\treturn fn(args);\n\t\t});\n\t},\n\n\t/**\n\t * _.objCompact\n\t *\n\t * _.compact for objects; keeps only keys whose values are not undefined\n\t *\tobj -> the object\n\t *\tstrict -> if \"true\", only keep keys whose values are falsy\n\t *\n\t * @api private\n\t */\n\tobjCompact: function(obj, strict) {\n\t\tobj = _.reduce(obj, function(memo, value, paramName) {\n\t\t\tif (strict) {\n\t\t\t\tif (value !== undefined && value !== null && value !== false && value !== '') {\n\t\t\t\t\tmemo[paramName] = value;\n\t\t\t\t}\n\t\t\t} else if (value !== undefined) {\n        \t\tmemo[paramName] = value;\n      \t\t}\n      \t\treturn memo;\n    \t}, {});\n    \treturn obj;\n\t},\n\n\t/**\n\t * _.objDeref\n\t *\n\t * Safely dereference an object given a path\n\t * @param  {object} obj  The object to dereference\n\t * @param  {string} path The dot-delimited path to use\n\t * @return {mixed}      The value of the object at that path, or undefined\n\t */\n\tobjDeref: function(obj, path) {\n\t\treturn path.split('.').reduce(_objDeref, obj);\n\t}\n\n});\n\nfunction _objDeref(obj,i) {return (typeof obj == 'object' && obj !== null) ? obj[i] : undefined;}","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails-util/node_modules/underscore.string/lib/underscore.string.js":"//  Underscore.string\n//  (c) 2010 Esa-Matti Suuronen <esa-matti aet suuronen dot org>\n//  Underscore.string is freely distributable under the terms of the MIT license.\n//  Documentation: https://github.com/epeli/underscore.string\n//  Some code is borrowed from MooTools and Alexandru Marasteanu.\n//  Version '2.3.2'\n\n!function(root, String){\n  'use strict';\n\n  // Defining helper functions.\n\n  var nativeTrim = String.prototype.trim;\n  var nativeTrimRight = String.prototype.trimRight;\n  var nativeTrimLeft = String.prototype.trimLeft;\n\n  var parseNumber = function(source) { return source * 1 || 0; };\n\n  var strRepeat = function(str, qty){\n    if (qty < 1) return '';\n    var result = '';\n    while (qty > 0) {\n      if (qty & 1) result += str;\n      qty >>= 1, str += str;\n    }\n    return result;\n  };\n\n  var slice = [].slice;\n\n  var defaultToWhiteSpace = function(characters) {\n    if (characters == null)\n      return '\\\\s';\n    else if (characters.source)\n      return characters.source;\n    else\n      return '[' + _s.escapeRegExp(characters) + ']';\n  };\n\n  // Helper for toBoolean\n  function boolMatch(s, matchers) {\n    var i, matcher, down = s.toLowerCase();\n    matchers = [].concat(matchers);\n    for (i = 0; i < matchers.length; i += 1) {\n      matcher = matchers[i];\n      if (!matcher) continue;\n      if (matcher.test && matcher.test(s)) return true;\n      if (matcher.toLowerCase() === down) return true;\n    }\n  }\n\n  var escapeChars = {\n    lt: '<',\n    gt: '>',\n    quot: '\"',\n    amp: '&',\n    apos: \"'\"\n  };\n\n  var reversedEscapeChars = {};\n  for(var key in escapeChars) reversedEscapeChars[escapeChars[key]] = key;\n  reversedEscapeChars[\"'\"] = '#39';\n\n  // sprintf() for JavaScript 0.7-beta1\n  // http://www.diveintojavascript.com/projects/javascript-sprintf\n  //\n  // Copyright (c) Alexandru Marasteanu <alexaholic [at) gmail (dot] com>\n  // All rights reserved.\n\n  var sprintf = (function() {\n    function get_type(variable) {\n      return Object.prototype.toString.call(variable).slice(8, -1).toLowerCase();\n    }\n\n    var str_repeat = strRepeat;\n\n    var str_format = function() {\n      if (!str_format.cache.hasOwnProperty(arguments[0])) {\n        str_format.cache[arguments[0]] = str_format.parse(arguments[0]);\n      }\n      return str_format.format.call(null, str_format.cache[arguments[0]], arguments);\n    };\n\n    str_format.format = function(parse_tree, argv) {\n      var cursor = 1, tree_length = parse_tree.length, node_type = '', arg, output = [], i, k, match, pad, pad_character, pad_length;\n      for (i = 0; i < tree_length; i++) {\n        node_type = get_type(parse_tree[i]);\n        if (node_type === 'string') {\n          output.push(parse_tree[i]);\n        }\n        else if (node_type === 'array') {\n          match = parse_tree[i]; // convenience purposes only\n          if (match[2]) { // keyword argument\n            arg = argv[cursor];\n            for (k = 0; k < match[2].length; k++) {\n              if (!arg.hasOwnProperty(match[2][k])) {\n                throw new Error(sprintf('[_.sprintf] property \"%s\" does not exist', match[2][k]));\n              }\n              arg = arg[match[2][k]];\n            }\n          } else if (match[1]) { // positional argument (explicit)\n            arg = argv[match[1]];\n          }\n          else { // positional argument (implicit)\n            arg = argv[cursor++];\n          }\n\n          if (/[^s]/.test(match[8]) && (get_type(arg) != 'number')) {\n            throw new Error(sprintf('[_.sprintf] expecting number but found %s', get_type(arg)));\n          }\n          switch (match[8]) {\n            case 'b': arg = arg.toString(2); break;\n            case 'c': arg = String.fromCharCode(arg); break;\n            case 'd': arg = parseInt(arg, 10); break;\n            case 'e': arg = match[7] ? arg.toExponential(match[7]) : arg.toExponential(); break;\n            case 'f': arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg); break;\n            case 'o': arg = arg.toString(8); break;\n            case 's': arg = ((arg = String(arg)) && match[7] ? arg.substring(0, match[7]) : arg); break;\n            case 'u': arg = Math.abs(arg); break;\n            case 'x': arg = arg.toString(16); break;\n            case 'X': arg = arg.toString(16).toUpperCase(); break;\n          }\n          arg = (/[def]/.test(match[8]) && match[3] && arg >= 0 ? '+'+ arg : arg);\n          pad_character = match[4] ? match[4] == '0' ? '0' : match[4].charAt(1) : ' ';\n          pad_length = match[6] - String(arg).length;\n          pad = match[6] ? str_repeat(pad_character, pad_length) : '';\n          output.push(match[5] ? arg + pad : pad + arg);\n        }\n      }\n      return output.join('');\n    };\n\n    str_format.cache = {};\n\n    str_format.parse = function(fmt) {\n      var _fmt = fmt, match = [], parse_tree = [], arg_names = 0;\n      while (_fmt) {\n        if ((match = /^[^\\x25]+/.exec(_fmt)) !== null) {\n          parse_tree.push(match[0]);\n        }\n        else if ((match = /^\\x25{2}/.exec(_fmt)) !== null) {\n          parse_tree.push('%');\n        }\n        else if ((match = /^\\x25(?:([1-9]\\d*)\\$|\\(([^\\)]+)\\))?(\\+)?(0|'[^$])?(-)?(\\d+)?(?:\\.(\\d+))?([b-fosuxX])/.exec(_fmt)) !== null) {\n          if (match[2]) {\n            arg_names |= 1;\n            var field_list = [], replacement_field = match[2], field_match = [];\n            if ((field_match = /^([a-z_][a-z_\\d]*)/i.exec(replacement_field)) !== null) {\n              field_list.push(field_match[1]);\n              while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {\n                if ((field_match = /^\\.([a-z_][a-z_\\d]*)/i.exec(replacement_field)) !== null) {\n                  field_list.push(field_match[1]);\n                }\n                else if ((field_match = /^\\[(\\d+)\\]/.exec(replacement_field)) !== null) {\n                  field_list.push(field_match[1]);\n                }\n                else {\n                  throw new Error('[_.sprintf] huh?');\n                }\n              }\n            }\n            else {\n              throw new Error('[_.sprintf] huh?');\n            }\n            match[2] = field_list;\n          }\n          else {\n            arg_names |= 2;\n          }\n          if (arg_names === 3) {\n            throw new Error('[_.sprintf] mixing positional and named placeholders is not (yet) supported');\n          }\n          parse_tree.push(match);\n        }\n        else {\n          throw new Error('[_.sprintf] huh?');\n        }\n        _fmt = _fmt.substring(match[0].length);\n      }\n      return parse_tree;\n    };\n\n    return str_format;\n  })();\n\n\n\n  // Defining underscore.string\n\n  var _s = {\n\n    VERSION: '2.3.0',\n\n    isBlank: function(str){\n      if (str == null) str = '';\n      return (/^\\s*$/).test(str);\n    },\n\n    stripTags: function(str){\n      if (str == null) return '';\n      return String(str).replace(/<\\/?[^>]+>/g, '');\n    },\n\n    capitalize : function(str){\n      str = str == null ? '' : String(str);\n      return str.charAt(0).toUpperCase() + str.slice(1);\n    },\n\n    chop: function(str, step){\n      if (str == null) return [];\n      str = String(str);\n      step = ~~step;\n      return step > 0 ? str.match(new RegExp('.{1,' + step + '}', 'g')) : [str];\n    },\n\n    clean: function(str){\n      return _s.strip(str).replace(/\\s+/g, ' ');\n    },\n\n    count: function(str, substr){\n      if (str == null || substr == null) return 0;\n\n      str = String(str);\n      substr = String(substr);\n\n      var count = 0,\n        pos = 0,\n        length = substr.length;\n\n      while (true) {\n        pos = str.indexOf(substr, pos);\n        if (pos === -1) break;\n        count++;\n        pos += length;\n      }\n\n      return count;\n    },\n\n    chars: function(str) {\n      if (str == null) return [];\n      return String(str).split('');\n    },\n\n    swapCase: function(str) {\n      if (str == null) return '';\n      return String(str).replace(/\\S/g, function(c){\n        return c === c.toUpperCase() ? c.toLowerCase() : c.toUpperCase();\n      });\n    },\n\n    escapeHTML: function(str) {\n      if (str == null) return '';\n      return String(str).replace(/[&<>\"']/g, function(m){ return '&' + reversedEscapeChars[m] + ';'; });\n    },\n\n    unescapeHTML: function(str) {\n      if (str == null) return '';\n      return String(str).replace(/\\&([^;]+);/g, function(entity, entityCode){\n        var match;\n\n        if (entityCode in escapeChars) {\n          return escapeChars[entityCode];\n        } else if (match = entityCode.match(/^#x([\\da-fA-F]+)$/)) {\n          return String.fromCharCode(parseInt(match[1], 16));\n        } else if (match = entityCode.match(/^#(\\d+)$/)) {\n          return String.fromCharCode(~~match[1]);\n        } else {\n          return entity;\n        }\n      });\n    },\n\n    escapeRegExp: function(str){\n      if (str == null) return '';\n      return String(str).replace(/([.*+?^=!:${}()|[\\]\\/\\\\])/g, '\\\\$1');\n    },\n\n    splice: function(str, i, howmany, substr){\n      var arr = _s.chars(str);\n      arr.splice(~~i, ~~howmany, substr);\n      return arr.join('');\n    },\n\n    insert: function(str, i, substr){\n      return _s.splice(str, i, 0, substr);\n    },\n\n    include: function(str, needle){\n      if (needle === '') return true;\n      if (str == null) return false;\n      return String(str).indexOf(needle) !== -1;\n    },\n\n    join: function() {\n      var args = slice.call(arguments),\n        separator = args.shift();\n\n      if (separator == null) separator = '';\n\n      return args.join(separator);\n    },\n\n    lines: function(str) {\n      if (str == null) return [];\n      return String(str).split(\"\\n\");\n    },\n\n    reverse: function(str){\n      return _s.chars(str).reverse().join('');\n    },\n\n    startsWith: function(str, starts){\n      if (starts === '') return true;\n      if (str == null || starts == null) return false;\n      str = String(str); starts = String(starts);\n      return str.length >= starts.length && str.slice(0, starts.length) === starts;\n    },\n\n    endsWith: function(str, ends){\n      if (ends === '') return true;\n      if (str == null || ends == null) return false;\n      str = String(str); ends = String(ends);\n      return str.length >= ends.length && str.slice(str.length - ends.length) === ends;\n    },\n\n    succ: function(str){\n      if (str == null) return '';\n      str = String(str);\n      return str.slice(0, -1) + String.fromCharCode(str.charCodeAt(str.length-1) + 1);\n    },\n\n    titleize: function(str){\n      if (str == null) return '';\n      str  = String(str).toLowerCase();\n      return str.replace(/(?:^|\\s|-)\\S/g, function(c){ return c.toUpperCase(); });\n    },\n\n    camelize: function(str){\n      return _s.trim(str).replace(/[-_\\s]+(.)?/g, function(match, c){ return c ? c.toUpperCase() : \"\"; });\n    },\n\n    underscored: function(str){\n      return _s.trim(str).replace(/([a-z\\d])([A-Z]+)/g, '$1_$2').replace(/[-\\s]+/g, '_').toLowerCase();\n    },\n\n    dasherize: function(str){\n      return _s.trim(str).replace(/([A-Z])/g, '-$1').replace(/[-_\\s]+/g, '-').toLowerCase();\n    },\n\n    classify: function(str){\n      return _s.titleize(String(str).replace(/[\\W_]/g, ' ')).replace(/\\s/g, '');\n    },\n\n    humanize: function(str){\n      return _s.capitalize(_s.underscored(str).replace(/_id$/,'').replace(/_/g, ' '));\n    },\n\n    trim: function(str, characters){\n      if (str == null) return '';\n      if (!characters && nativeTrim) return nativeTrim.call(str);\n      characters = defaultToWhiteSpace(characters);\n      return String(str).replace(new RegExp('\\^' + characters + '+|' + characters + '+$', 'g'), '');\n    },\n\n    ltrim: function(str, characters){\n      if (str == null) return '';\n      if (!characters && nativeTrimLeft) return nativeTrimLeft.call(str);\n      characters = defaultToWhiteSpace(characters);\n      return String(str).replace(new RegExp('^' + characters + '+'), '');\n    },\n\n    rtrim: function(str, characters){\n      if (str == null) return '';\n      if (!characters && nativeTrimRight) return nativeTrimRight.call(str);\n      characters = defaultToWhiteSpace(characters);\n      return String(str).replace(new RegExp(characters + '+$'), '');\n    },\n\n    truncate: function(str, length, truncateStr){\n      if (str == null) return '';\n      str = String(str); truncateStr = truncateStr || '...';\n      length = ~~length;\n      return str.length > length ? str.slice(0, length) + truncateStr : str;\n    },\n\n    /**\n     * _s.prune: a more elegant version of truncate\n     * prune extra chars, never leaving a half-chopped word.\n     * @author github.com/rwz\n     */\n    prune: function(str, length, pruneStr){\n      if (str == null) return '';\n\n      str = String(str); length = ~~length;\n      pruneStr = pruneStr != null ? String(pruneStr) : '...';\n\n      if (str.length <= length) return str;\n\n      var tmpl = function(c){ return c.toUpperCase() !== c.toLowerCase() ? 'A' : ' '; },\n        template = str.slice(0, length+1).replace(/.(?=\\W*\\w*$)/g, tmpl); // 'Hello, world' -> 'HellAA AAAAA'\n\n      if (template.slice(template.length-2).match(/\\w\\w/))\n        template = template.replace(/\\s*\\S+$/, '');\n      else\n        template = _s.rtrim(template.slice(0, template.length-1));\n\n      return (template+pruneStr).length > str.length ? str : str.slice(0, template.length)+pruneStr;\n    },\n\n    words: function(str, delimiter) {\n      if (_s.isBlank(str)) return [];\n      return _s.trim(str, delimiter).split(delimiter || /\\s+/);\n    },\n\n    pad: function(str, length, padStr, type) {\n      str = str == null ? '' : String(str);\n      length = ~~length;\n\n      var padlen  = 0;\n\n      if (!padStr)\n        padStr = ' ';\n      else if (padStr.length > 1)\n        padStr = padStr.charAt(0);\n\n      switch(type) {\n        case 'right':\n          padlen = length - str.length;\n          return str + strRepeat(padStr, padlen);\n        case 'both':\n          padlen = length - str.length;\n          return strRepeat(padStr, Math.ceil(padlen/2)) + str\n                  + strRepeat(padStr, Math.floor(padlen/2));\n        default: // 'left'\n          padlen = length - str.length;\n          return strRepeat(padStr, padlen) + str;\n        }\n    },\n\n    lpad: function(str, length, padStr) {\n      return _s.pad(str, length, padStr);\n    },\n\n    rpad: function(str, length, padStr) {\n      return _s.pad(str, length, padStr, 'right');\n    },\n\n    lrpad: function(str, length, padStr) {\n      return _s.pad(str, length, padStr, 'both');\n    },\n\n    sprintf: sprintf,\n\n    vsprintf: function(fmt, argv){\n      argv.unshift(fmt);\n      return sprintf.apply(null, argv);\n    },\n\n    toNumber: function(str, decimals) {\n      if (!str) return 0;\n      str = _s.trim(str);\n      if (!str.match(/^-?\\d+(?:\\.\\d+)?$/)) return NaN;\n      return parseNumber(parseNumber(str).toFixed(~~decimals));\n    },\n\n    numberFormat : function(number, dec, dsep, tsep) {\n      if (isNaN(number) || number == null) return '';\n\n      number = number.toFixed(~~dec);\n      tsep = typeof tsep == 'string' ? tsep : ',';\n\n      var parts = number.split('.'), fnums = parts[0],\n        decimals = parts[1] ? (dsep || '.') + parts[1] : '';\n\n      return fnums.replace(/(\\d)(?=(?:\\d{3})+$)/g, '$1' + tsep) + decimals;\n    },\n\n    strRight: function(str, sep){\n      if (str == null) return '';\n      str = String(str); sep = sep != null ? String(sep) : sep;\n      var pos = !sep ? -1 : str.indexOf(sep);\n      return ~pos ? str.slice(pos+sep.length, str.length) : str;\n    },\n\n    strRightBack: function(str, sep){\n      if (str == null) return '';\n      str = String(str); sep = sep != null ? String(sep) : sep;\n      var pos = !sep ? -1 : str.lastIndexOf(sep);\n      return ~pos ? str.slice(pos+sep.length, str.length) : str;\n    },\n\n    strLeft: function(str, sep){\n      if (str == null) return '';\n      str = String(str); sep = sep != null ? String(sep) : sep;\n      var pos = !sep ? -1 : str.indexOf(sep);\n      return ~pos ? str.slice(0, pos) : str;\n    },\n\n    strLeftBack: function(str, sep){\n      if (str == null) return '';\n      str += ''; sep = sep != null ? ''+sep : sep;\n      var pos = str.lastIndexOf(sep);\n      return ~pos ? str.slice(0, pos) : str;\n    },\n\n    toSentence: function(array, separator, lastSeparator, serial) {\n      separator = separator || ', ';\n      lastSeparator = lastSeparator || ' and ';\n      var a = array.slice(), lastMember = a.pop();\n\n      if (array.length > 2 && serial) lastSeparator = _s.rtrim(separator) + lastSeparator;\n\n      return a.length ? a.join(separator) + lastSeparator + lastMember : lastMember;\n    },\n\n    toSentenceSerial: function() {\n      var args = slice.call(arguments);\n      args[3] = true;\n      return _s.toSentence.apply(_s, args);\n    },\n\n    slugify: function(str) {\n      if (str == null) return '';\n\n      var from  = \"\",\n          to    = \"aaaaaaaaaceeeeeiiiilnoooooosstuuuunczz\",\n          regex = new RegExp(defaultToWhiteSpace(from), 'g');\n\n      str = String(str).toLowerCase().replace(regex, function(c){\n        var index = from.indexOf(c);\n        return to.charAt(index) || '-';\n      });\n\n      return _s.dasherize(str.replace(/[^\\w\\s-]/g, ''));\n    },\n\n    surround: function(str, wrapper) {\n      return [wrapper, str, wrapper].join('');\n    },\n\n    quote: function(str, quoteChar) {\n      return _s.surround(str, quoteChar || '\"');\n    },\n\n    unquote: function(str, quoteChar) {\n      quoteChar = quoteChar || '\"';\n      if (str[0] === quoteChar && str[str.length-1] === quoteChar)\n        return str.slice(1,str.length-1);\n      else return str;\n    },\n\n    exports: function() {\n      var result = {};\n\n      for (var prop in this) {\n        if (!this.hasOwnProperty(prop) || prop.match(/^(?:include|contains|reverse)$/)) continue;\n        result[prop] = this[prop];\n      }\n\n      return result;\n    },\n\n    repeat: function(str, qty, separator){\n      if (str == null) return '';\n\n      qty = ~~qty;\n\n      // using faster implementation if separator is not needed;\n      if (separator == null) return strRepeat(String(str), qty);\n\n      // this one is about 300x slower in Google Chrome\n      for (var repeat = []; qty > 0; repeat[--qty] = str) {}\n      return repeat.join(separator);\n    },\n\n    naturalCmp: function(str1, str2){\n      if (str1 == str2) return 0;\n      if (!str1) return -1;\n      if (!str2) return 1;\n\n      var cmpRegex = /(\\.\\d+)|(\\d+)|(\\D+)/g,\n        tokens1 = String(str1).toLowerCase().match(cmpRegex),\n        tokens2 = String(str2).toLowerCase().match(cmpRegex),\n        count = Math.min(tokens1.length, tokens2.length);\n\n      for(var i = 0; i < count; i++) {\n        var a = tokens1[i], b = tokens2[i];\n\n        if (a !== b){\n          var num1 = parseInt(a, 10);\n          if (!isNaN(num1)){\n            var num2 = parseInt(b, 10);\n            if (!isNaN(num2) && num1 - num2)\n              return num1 - num2;\n          }\n          return a < b ? -1 : 1;\n        }\n      }\n\n      if (tokens1.length === tokens2.length)\n        return tokens1.length - tokens2.length;\n\n      return str1 < str2 ? -1 : 1;\n    },\n\n    levenshtein: function(str1, str2) {\n      if (str1 == null && str2 == null) return 0;\n      if (str1 == null) return String(str2).length;\n      if (str2 == null) return String(str1).length;\n\n      str1 = String(str1); str2 = String(str2);\n\n      var current = [], prev, value;\n\n      for (var i = 0; i <= str2.length; i++)\n        for (var j = 0; j <= str1.length; j++) {\n          if (i && j)\n            if (str1.charAt(j - 1) === str2.charAt(i - 1))\n              value = prev;\n            else\n              value = Math.min(current[j], current[j - 1], prev) + 1;\n          else\n            value = i + j;\n\n          prev = current[j];\n          current[j] = value;\n        }\n\n      return current.pop();\n    },\n\n    toBoolean: function(str, trueValues, falseValues) {\n      if (typeof str === \"number\") str = \"\" + str;\n      if (typeof str !== \"string\") return !!str;\n      str = _s.trim(str);\n      if (boolMatch(str, trueValues || [\"true\", \"1\"])) return true;\n      if (boolMatch(str, falseValues || [\"false\", \"0\"])) return false;\n    }\n  };\n\n  // Aliases\n\n  _s.strip    = _s.trim;\n  _s.lstrip   = _s.ltrim;\n  _s.rstrip   = _s.rtrim;\n  _s.center   = _s.lrpad;\n  _s.rjust    = _s.lpad;\n  _s.ljust    = _s.rpad;\n  _s.contains = _s.include;\n  _s.q        = _s.quote;\n  _s.toBool   = _s.toBoolean;\n\n  // Exporting\n\n  // CommonJS module is defined\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports)\n      module.exports = _s;\n\n    exports._s = _s;\n  }\n\n  // Register as a named module with AMD.\n  if (typeof define === 'function' && define.amd)\n    define('underscore.string', [], function(){ return _s; });\n\n\n  // Integrate with Underscore.js if defined\n  // or create our own underscore object.\n  root._ = root._ || {};\n  root._.string = root._.str = _s;\n}(this, String);\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails-util/cli.js":"\n/**\n * Module dependencies.\n */\n\nvar _\t\t\t= require('lodash'),\n\targv\t\t= require('optimist').argv;\n\n\n\n// Start building object to export\nvar util = {};\n\n\n/**\n * Expose `fs`, but monkey-patched to make sure existsSync()\n * doesn't crash older versions of Node\n *\n * @api private\n */\n\nvar fs = require('fs-extra');\nfs.existsSync = fs.existsSync || require('path').existsSync;\nutil.fs = fs;\n\n\n\n\n\n/**\n * Convert command-line arguments into configuration\n * options for the Sails core\n *\n * @param argv\n *\n * @api private\n */\n\nutil.getCLIConfig = function ( argv ) {\n\n\treturn {\n\t\t\n\t\t// `--silent` command-line argument\n\t\t// `--verbose` command-line argument\n\t\t// `--silly` command-line argument\n\t\tlog:\targv.verbose ? {level: 'verbose'} : \n\t\t\t\targv.silly ? {level: 'silly'} :\n\t\t\t\targv.silent ? {level: 'silent'} :\n\t\t\t\tundefined,\n\n\t\t// `--port=?` command-line argument\n\t\tport: argv.port || undefined,\n\n\t\t// `--prod` command-line argument\n\t\tenvironment: argv.prod ? 'production' : undefined\n\n\t};\n};\n\n\n\n\n/**\n * Methods which return a string with usage information\n * for the Sails CLI\n */\n\nutil.usage = {\n\n\tsails: function () {\n\t\tvar usage = 'Usage: sails <command>\\n\\n';\n\t\t// (if node_modules/sails exists, it will be used instead of the global install)\\n';\n\t\tusage += _tab('sails lift') + 'Run the Sails app in the current directory:\\n';\n\t\tusage += _tab('  [--prod]') + '  - in production mode \\n';\n\t\tusage += _tab('  [--port 3000]') + '  - on port 3000 \\n';\n\t\tusage += _tab('  [--verbose]') + '  - with verbose logging enabled \\n';\n\t\tusage += '\\n';\n\t\tusage += _tab('sails new <appName>') + 'Create a new Sails project in a folder called <appName>:\\n';\n\t\tusage += _tab('  [--no-linker]') + '  - disable auto-<link> of assets in HTML files via Grunt\\n';\n\t\tusage += '\\n';\n\t\tusage += _tab('sails generate model <foo>') + 'Generate a model (`api/models/Foo.js`)\\n';\n\t\tusage += _tab('sails generate controller <foo>') + 'Generate a controller (`api/controllers/FooController.js`)\\n';\n\t\tusage += _tab('sails generate <foo>') + 'Generate both.\\n';\n\t\tusage += _tab('  [--dry]') + 'Don\\'t actually create the module file.\\n';\n\t\tusage += '\\n';\n\t\tusage += _tab('sails console') + 'Run Sails in interactive mode (REPL)\\n';\n\t\tusage += _tab('sails version') + 'Get the current globally installed Sails version\\n';\n\t\tusage += _tab('sails run <command>') + 'Run a management command (exported by YOUR_APP/commands/index.js)';\n\n\t\treturn usage;\n\t},\n\n\n\tgenerate: {\n\t\tmodel: function () {\n\t\t\tvar usage = 'Usage:\\n';\n\t\t\tusage += 'sails generate model <foo> [attribute0Name:type] [attribute1Name:attribute1Type] [...]' + '\\n';\n\t\t\tusage += '\\n';\n\t\t\tusage += 'E.g., to generate api/models/Cockatiel.js:' + '\\n';\n\t\t\tusage += 'sails generate model cockatiel' + '\\n';\n\t\t\tusage += '\\n';\n\t\t\tusage += 'With some attributes:' + '\\n';\n\t\t\tusage += 'sails generate model cockatiel name:string weight:float birthdate:date color:string';\n\t\t}\n\t}\n};\n\n\n\n\n\n\n\n/**\n * Generate a file\n *\n * @api private\n */\n\nutil.generateFile = function(boilerplatePath, newPath) {\n\tvar fullBpPath = __dirname + '/boilerplates/' + (boilerplatePath || '');\n\tvar file = fs.readFileSync(fullBpPath, 'utf8');\n\tvar newFilePath = (newPath || '');\n\tutil.verifyDoesntExist(newFilePath, 'A file/directory already exists at ' + newFilePath);\n\n\t// Touch output file to make sure the path to it exists\n\tif (fs.createFileSync(newFilePath)) {\n\t\tlog.error('Could not create file, ' + newFilePath + '!');\n\t\tprocess.exit(1);\n\t}\n\tfs.writeFileSync(newFilePath, file);\n};\n\n\n\n/**\n * Generate a directory\n *\n * @api private\n */\n\nutil.generateDir = function(newPath, gitkeep) {\n\tif (!newPath) {\n\t\tlog.verbose('Creating directory in pwd...');\n\t} else {\n\t\tlog.verbose('Creating directory directory in ' + newPath + '...');\n\t}\n\tvar newDirPath = (newPath || '');\n\tutil.verifyDoesntExist(newDirPath, 'A file/directory already exists at ' + newDirPath);\n\tfs.mkdirSync(newDirPath);\n\t// If directory will be empty, create a .gitkeep in it\n\tif (gitkeep) {\n\t\tgenerateFile('.gitkeep', newPath + '/.gitkeep');\n\t}\n};\n\n\n/**\n * Verify that a file doesn't exist\n *\n * @api private\n */\n\nutil.verifyDoesntExist = function(path, msg) {\n\tif (util.fileExists(path)) {\n\t\tlog.error(msg);\n\t\tprocess.exit(1);\n\t}\n};\n\n\n\n/** \n * Check if a file or directory exists\n *\n * @api private\n */\n\nutil.fileExists = function(path) {\n\ttry {\n\t\t// Query the entry\n\t\tvar stats = fs.lstatSync(path);\n\n\t\t// Is it a directory?\n\t\tif (stats.isDirectory() || stats.isFile()) {\n\t\t\treturn true;\n\t\t}\n\t} catch (e) {\n\t\t// ...\n\t}\n\n\treturn false;\n};\n\n\n\n/** \n * Read an EJS template representing a Sails module,\n * then send back the return string.\n *\n * @api private\n */\n\n// util.renderBoilerplateTemplate = function(path, data) {\n// \tvar boilerplatePath = __dirname + '/boilerplates/templates/' + boilerplate;\n// \tutil.verifyExists(boilerplatePath, \"Boilerplate (\" + boilerplate + \") doesn't exist!\");\n// \tvar file = fs.readFileSync(boilerplatePath, 'utf8');\n// \treturn ejs.render(file, data);\n// };\n\n\n\n/** \n *\n *\n * @api private\n */\n\nutil.verifyExists = function(path, msg) {\n\tif (!util.fileExists(path)) {\n\t\tlog.error(msg);\n\t\tprocess.exit(1);\n\t}\n};\n\n\n\n/** \n * Copy a boilerplate directory or file\n *\n * @api private\n */\n\nutil.copyBoilerplate = function(boilerplate, destination, cb) {\n\tvar boilerplatePath = __dirname + '/boilerplates/' + boilerplate;\n\tfs.copy(boilerplatePath, destination, function(err) {\n\t\treturn cb && cb(err);\n\t});\n};\n\n\n\n/** \n * Copy global sails module into current project as a local dependency\n * (currently unusued)\n *\n * @api private\n */\n\nutil.copySails = function(destination, cb) {\n\ttry {\n\t\tfs.mkdirSync(destination);\n\t} catch (e) {\n\t\treturn cb && cb(e);\n\t}\n\n\t// Progress notifications\n\tvar stopShowingProgressNotifications,\n\t\terrorCopying,\n\t\tinterval = 150;\n\n\n\t// Draw progress notification\n\t// Returns progress function\n\tlog.verbose('Copying modules into ' + destination + '...');\n\tvar canvas = turtle();\n\n\tasync.until(\n\n\tfunction checkIfDone() {\n\t\tcanvas.tick();\n\t\treturn stopShowingProgressNotifications;\n\t},\n\n\tfunction setAlarm(cb) {\n\t\tsetTimeout(cb, interval);\n\t},\n\n\tfunction done(err) {\n\t\t// If an error occurred, send it back\n\t\terr = err || errorCopying;\n\t\treturn cb && cb(err);\n\t});\n\n\tasync.each(['lib', 'package.json', 'node_modules'], function(fileOrDir, cb) {\n\t\tfs.copy(__dirname + '/../' + fileOrDir, destination + '/' + fileOrDir, cb);\n\t}, function doneCopying(err) {\n\n\t\t// Hold onto error if there is one\n\t\terrorCopying = err;\n\n\t\t// When finished copying, mark done\n\t\t// progress notifications will trigger the callback\n\t\tstopShowingProgressNotifications = true;\n\t});\n};\n\n\n\n/** \n * Copy a core Sails dependency to the top-level node_modules directory\n * of the current application---- in a smart way\n *\n * @api private\n */\n\nutil.copySailsDependency = function(moduleName, pathToNewNodeModules, cb) {\n\tvar path = __dirname + '/../node_modules/' + moduleName;\n\tfs.copy(path, pathToNewNodeModules + '/' + moduleName, function(err) {\n\t\tif (err) return cb && cb(err);\n\n\t\t// Parse the module's package.json\n\t\tvar packageJSONPath = path + '/package.json';\n\t\tvar packageJSON;\n\t\ttry {\n\t\t\tpackageJSON = JSON.parse(fs.readFileSync(packageJSONPath, 'utf-8'));\n\t\t} catch (e) {\n\n\t\t\t// Ignore missing package.json\n\t\t\tpackageJSON = {\n\t\t\t\tdependencies: {}\n\t\t\t};\n\t\t}\n\n\t\t// Get actual dependencies in this module's node_modules directory\n\t\tvar dependencies;\n\t\ttry {\n\t\t\tdependencies = fs.readdirSync(path + '/node_modules');\n\n\t\t\t// Remove hidden files\n\t\t\t_.without(dependencies, function(val) {\n\t\t\t\treturn val.match(/\\..+/);\n\t\t\t});\n\t\t} catch (e) {\n\t\t\t// Assume empty dependencies\n\t\t\tdependencies = {};\n\t\t}\n\n\t\t// If there are any missing dependencies which are being pulled from Sails,\n\t\t// copy them from Sails' main node_modules directory\n\t\tvar missingModules = _.difference(_.keys(packageJSON.dependencies || {}), _.values(dependencies));\n\t\t_.each(missingModules, function(missingModuleName) {\n\t\t\tlog.verbose('Resolving ' + moduleName + '\\'s missing dependency (' + missingModuleName + ') using the version in Sails.');\n\t\t\tutil.copySailsDependency(missingModuleName, pathToNewNodeModules + '/' + moduleName + '/node_modules/');\n\t\t});\n\n\t\treturn cb && cb(err);\n\t});\n};\n\n\n\n\n/**\n * Return a tabbed-over version of the string,\n * adjusting for spacing\n *\n * @api private\n */\nfunction _tab (str) {\n\tvar n = (33 - str.length);\n\treturn str + _.str.repeat(' ', n);\n}\n\n\n\n// Export `util` object\nmodule.exports = _.cloneDeep(util);\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails-util/node_modules/fs-extra/lib/index.js":"\"use strict\"\n\nvar fs = null\n  , path = require('path')\n  , jsonFile = require('jsonfile')\n  , json = require('./json')\n  , fse = {};\n\ntry {\n  // optional dependency\n  fs = require(\"graceful-fs\")\n} catch (er) {\n  fs = require(\"fs\")\n}\n\nObject.keys(fs).forEach(function(key) {\n  var func = fs[key];\n  if (typeof func == 'function')\n    fse[key] = func;\n});\n\nfs = fse;\n\n// copy\n\nfs.copy = require('./copy').copy;\nfs.copySync = require('./copy').copySync;\n\n// remove\n\nvar remove = require('./remove');\nfs.remove = remove.remove;\nfs.removeSync = remove.removeSync;\nfs['delete'] = fs.remove\nfs.deleteSync = fs.removeSync\n\n// mkdir\n\nvar mkdir = require('./mkdir')\nfs.mkdirs = mkdir.mkdirs\nfs.mkdirsSync = mkdir.mkdirsSync\nfs.mkdirp = mkdir.mkdirs\nfs.mkdirpSync = mkdir.mkdirsSync\n\n// create\n\nvar create = require('./create')\nfs.createFile = create.createFile;\nfs.createFileSync = create.createFileSync;\n\n//deprecated\nfs.touch = function touch() {\n  console.log('fs.touch() is deprecated. Please use fs.createFile().')\n  fs.createFile.apply(null, arguments)\n}\n\nfs.touchSync = function touchSync() {\n  console.log('fs.touchSync() is deprecated. Please use fs.createFileSync().')\n  fs.createFileSync.apply(null, arguments)\n}\n\n// output\n\nvar output = require('./output');\nfs.outputFile = output.outputFile;\nfs.outputFileSync = output.outputFileSync;\n\n// read\n\n/*fs.readTextFile = function(file, callback) {\n  return fs.readFile(file, 'utf8', callback)\n}\n\nfs.readTextFileSync = function(file, callback) {\n  return fs.readFileSync(file, 'utf8')\n}*/\n\n// json files\n\nfs.readJsonFile = jsonFile.readFile;\nfs.readJSONFile = jsonFile.readFile;\nfs.readJsonFileSync = jsonFile.readFileSync;\nfs.readJSONFileSync = jsonFile.readFileSync;\n\nfs.readJson = jsonFile.readFile;\nfs.readJSON = jsonFile.readFile;\nfs.readJsonSync = jsonFile.readFileSync;\nfs.readJSONSync = jsonFile.readFileSync;\n\nfs.outputJsonSync = json.outputJsonSync;\nfs.outputJSONSync = json.outputJsonSync;\nfs.outputJson = json.outputJson;\nfs.outputJSON = json.outputJson;\n\nfs.writeJsonFile = jsonFile.writeFile;\nfs.writeJSONFile = jsonFile.writeFile;\nfs.writeJsonFileSync = jsonFile.writeFileSync;\nfs.writeJSONFileSync = jsonFile.writeFileSync;\n\nfs.writeJson = jsonFile.writeFile;\nfs.writeJSON = jsonFile.writeFile;\nfs.writeJsonSync = jsonFile.writeFileSync;\nfs.writeJSONSync = jsonFile.writeFileSync;\n\n\nmodule.exports = fs\n\njsonFile.spaces = 2; //set to 2\nmodule.exports.jsonfile = jsonFile; //so users of fs-extra can modify jsonFile.spaces;\n\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails-util/node_modules/jsonfile/lib/jsonfile.js":"var fs = require('fs');\n\nvar me = module.exports;\n\nme.spaces = 2;\n\nme.readFile = function(file, callback) {\n  fs.readFile(file, 'utf8', function(err, data) {\n    if (err) return callback(err, null);\n\n    var obj = null;\n    try {\n      obj = JSON.parse(data);\n    } catch (err2) {\n      callback(err2, null);\n      return;\n    }\n    callback(null, obj);\n  })\n}\n\nme.readFileSync = function(file) {\n  return JSON.parse(fs.readFileSync(file, 'utf8'));\n}\n\nme.writeFile = function(file, obj, options, callback) {\n  if (callback == null) { // odd little swap because options is optional\n    callback = options;\n    options = null;\n  }\n\n  var str = '';\n  try {\n    str = JSON.stringify(obj, null, module.exports.spaces);\n  } catch (err) {\n    if (callback) {\n      callback(err, null);\n    }\n    return;\n  }\n  fs.writeFile(file, str, options, callback);\n}\n\nme.writeFileSync = function(file, obj, options) {\n  var str = JSON.stringify(obj, null, module.exports.spaces);\n  return fs.writeFileSync(file, str, options); //not sure if fs.writeFileSync returns anything, but just in case\n}","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails-util/node_modules/fs-extra/lib/json.js":"\"use strict\"\n\nvar jsonFile = require('jsonfile')\n  , fs = require('fs')\n  , mkdir = require('./mkdir')\n  , path = require('path')\n\nvar me = module.exports\n\nme.outputJsonSync = function(file, data) {\n  var dir = path.dirname(file)\n\n  if (!fs.existsSync(dir))\n    mkdir.mkdirsSync(dir)\n\n  jsonFile.writeFileSync(file, data)\n}\n\nme.outputJson = function(file, data, callback) {\n  var dir = path.dirname(file)\n\n  fs.exists(dir, function(itDoes) {\n    if (itDoes) return jsonFile.writeFile(file, data, callback)\n\n    mkdir.mkdirs(dir, function(err) {\n      if (err) return callback(err)\n      jsonFile.writeFile(file, data, callback)\n    })\n  })\n}","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails-util/node_modules/fs-extra/lib/mkdir.js":"\"use strict\"\n\nvar mkdirp = require('mkdirp');\n\nmodule.exports.mkdirs = mkdirp;\nmodule.exports.mkdirsSync = mkdirp.sync;\n\n\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails-util/node_modules/mkdirp/index.js":"var path = require('path');\nvar fs = require('fs');\n\nmodule.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;\n\nfunction mkdirP (p, mode, f, made) {\n    if (typeof mode === 'function' || mode === undefined) {\n        f = mode;\n        mode = 0777 & (~process.umask());\n    }\n    if (!made) made = null;\n\n    var cb = f || function () {};\n    if (typeof mode === 'string') mode = parseInt(mode, 8);\n    p = path.resolve(p);\n\n    fs.mkdir(p, mode, function (er) {\n        if (!er) {\n            made = made || p;\n            return cb(null, made);\n        }\n        switch (er.code) {\n            case 'ENOENT':\n                mkdirP(path.dirname(p), mode, function (er, made) {\n                    if (er) cb(er, made);\n                    else mkdirP(p, mode, cb, made);\n                });\n                break;\n\n            // In the case of any other error, just see if there's a dir\n            // there already.  If so, then hooray!  If not, then something\n            // is borked.\n            default:\n                fs.stat(p, function (er2, stat) {\n                    // if the stat fails, then that's super weird.\n                    // let the original error be the failure reason.\n                    if (er2 || !stat.isDirectory()) cb(er, made)\n                    else cb(null, made);\n                });\n                break;\n        }\n    });\n}\n\nmkdirP.sync = function sync (p, mode, made) {\n    if (mode === undefined) {\n        mode = 0777 & (~process.umask());\n    }\n    if (!made) made = null;\n\n    if (typeof mode === 'string') mode = parseInt(mode, 8);\n    p = path.resolve(p);\n\n    try {\n        fs.mkdirSync(p, mode);\n        made = made || p;\n    }\n    catch (err0) {\n        switch (err0.code) {\n            case 'ENOENT' :\n                made = sync(path.dirname(p), mode, made);\n                sync(p, mode, made);\n                break;\n\n            // In the case of any other error, just see if there's a dir\n            // there already.  If so, then hooray!  If not, then something\n            // is borked.\n            default:\n                var stat;\n                try {\n                    stat = fs.statSync(p);\n                }\n                catch (err1) {\n                    throw err0;\n                }\n                if (!stat.isDirectory()) throw err0;\n                break;\n        }\n    }\n\n    return made;\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails-util/node_modules/fs-extra/lib/copy.js":"\"use strict\"\n\nvar fs = require('fs')\n  , ncp = require('ncp').ncp\n  , path = require('path')\n  , mkdir = require('./mkdir'),\n    create = require('./create')\n\nmodule.exports.copy = copy;\nmodule.exports.copySync = copySync;\n\nvar BUF_LENGTH = 64 * 1024\nvar _buff = new Buffer(BUF_LENGTH)\n\nvar copyFileSync = function(srcFile, destFile) {\n  var bytesRead, fdr, fdw, pos;\n  fdr = fs.openSync(srcFile, 'r');\n  fdw = fs.openSync(destFile, 'w');\n  bytesRead = 1;\n  pos = 0;\n  while (bytesRead > 0) {\n    bytesRead = fs.readSync(fdr, _buff, 0, BUF_LENGTH, pos);\n    fs.writeSync(fdw, _buff, 0, bytesRead);\n    pos += bytesRead;\n  }\n  fs.closeSync(fdr);\n  return fs.closeSync(fdw);\n}\n\nfunction copy(src, dest, filter, callback) {\n  if( typeof filter === \"function\" && !callback) {\n      callback = filter;\n      filter = null;\n  }\n  callback = callback || function(){}\n\n  fs.lstat(src, function(err, stats) {\n    if (err) return callback(err)\n\n    var dir = null\n    if (stats.isDirectory()) {\n      var parts = dest.split(path.sep)\n      parts.pop()\n      dir = parts.join(path.sep)\n    } else {\n      dir = path.dirname(dest)\n    }\n\n    fs.exists(dir, function(dirExists) {\n      if (dirExists) return ncp(src, dest, {filter: filter}, callback);\n      mkdir.mkdirs(dir, function(err) {\n        if (err) return callback(err)\n        ncp(src, dest, {filter: filter}, callback);\n      })\n    })\n  })\n}\n\nfunction copySync(src, dest, filter) {\n  filter = filter || function () { return true; };\n  var stats = fs.lstatSync(src),\n      destExists = fs.exists(dest),\n      performCopy = false;\n  if (stats.isFile()) {\n    if (filter instanceof RegExp) performCopy = filter.test(src);\n    else if (typeof filter === \"function\") performCopy = filter(src);\n    if(performCopy) {\n      if (!destExists) create.createFileSync(dest);\n      copyFileSync(src, dest);\n    }\n  }\n  else if (stats.isDirectory()) {\n    if (!destExists) mkdir.mkdirsSync(dest);\n    var contents = fs.readdirSync(src);\n    contents.forEach(function (content) {\n      copySync(src + \"/\" + content, dest + \"/\" + content);\n    });\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails-util/node_modules/fs-extra/lib/create.js":"\"use strict\"\n\nvar mkdir = require('./mkdir')\n  , path = require('path')\n  , fs = require('fs')\n  , exists = fs.exists || path.exists\n  , existsSync = fs.existsSync || path.existsSync\n\nfunction createFile (file, callback) {\n  function makeFile() {\n    fs.writeFile(file, '', function(err) {\n      if (err)\n        callback(err)\n      else\n        callback(null);\n    })\n  }\n\n  exists(file, function(fileExists) {\n    if (fileExists)\n      return callback(null);\n    else {\n      var dir = path.dirname(file);\n\n      exists(dir, function(dirExists) {\n        if (!dirExists) {\n          mkdir.mkdirs(dir, function(err) {\n            if (err)\n              callback(err)\n            else\n              makeFile();\n          })\n        } else {\n          makeFile();\n        }\n      })\n    }\n  })\n}\n\n\nfunction createFileSync (file) {\n  if (existsSync(file))\n    return;\n\n  var dir = path.dirname(file);\n  if (!existsSync(dir))\n    mkdir.mkdirsSync(dir);\n\n  fs.writeFileSync(file, '');\n}\n\n\nmodule.exports.createFile = createFile;\nmodule.exports.createFileSync = createFileSync;","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails-util/node_modules/fs-extra/lib/remove.js":"\"use strict\"\n\nvar rimraf = require('rimraf')\n  , fs = require('fs');\n\nfunction rmrfSync(dir) {\n    return rimraf.sync(dir);\n}\n\nfunction rmrf(dir, cb) {\n    if (cb != null) {\n        return rimraf(dir, cb);\n    } else {\n        return rimraf(dir, (function() {}));\n    }\n}\n\nmodule.exports.remove = rmrf;\nmodule.exports.removeSync = rmrfSync;\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails-util/node_modules/fs-extra/lib/output.js":"\"use strict\"\n\nvar mkdir = require('./mkdir')\n  , path = require('path')\n  , fs = require('fs')\n  , exists = fs.exists || path.exists\n  , existsSync = fs.existsSync || path.existsSync\n\nfunction outputFile (file, data, encoding, callback) {\n  if (typeof encoding === 'function') {\n    callback = encoding\n    encoding = 'utf8'\n  }\n\n  var dir = path.dirname(file)\n  exists(dir, function(itDoes) {\n    if (itDoes) return fs.writeFile(file, data, encoding, callback)\n\n    mkdir.mkdirs(dir, function(err) {\n      if (err) return callback(err)\n\n      fs.writeFile(file, data, encoding, callback)\n    })\n  })\n}\n\n\nfunction outputFileSync (file, data, encoding) {\n  var dir = path.dirname(file)\n  if (existsSync(dir)) return fs.writeFileSync.apply(fs, arguments)\n  mkdir.mkdirsSync(dir)\n  fs.writeFileSync.apply(fs, arguments)\n}\n\n\nmodule.exports.outputFile = outputFile;\nmodule.exports.outputFileSync = outputFileSync;","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/app/lift.js":"/**\n * Module dependencies.\n */\n\nvar async = require('async');\nvar _ = require('@sailshq/lodash');\nvar chalk = require('chalk');\n\n/**\n * Sails.prototype.lift()\n *\n * Loads the app, then starts all attached servers.\n *\n * @api public\n */\n\nmodule.exports = function lift(configOverride, cb) {\n  var sails = this;\n\n  // configOverride is optional\n  if (_.isFunction(configOverride)) {\n    cb = configOverride;\n    configOverride = {};\n  }\n\n  // Callback is optional\n  cb = cb || function(err) {\n    if (err) return sails.log.error(err);\n  };\n\n  async.series([\n\n    function(cb) {\n      sails.load(configOverride, cb);\n    },\n\n    sails.initialize\n\n  ], function sailsReady(err, async_data) { //TODO: unused variable async_data\n    if (err) {\n      return sails.lower(function (errorLoweringSails){\n        if (errorLoweringSails) {\n          sails.log.error('When trying to lower the app as a result of a failed lift, encountered an error:',errorLoweringSails);\n        }\n        cb(err);\n      });\n    }\n\n    _printSuccessMsg(sails);\n\n    // try {console.timeEnd('core_lift');}catch(e){}\n\n    sails.emit('lifted');\n    sails.isLifted = true;\n    return cb(null, sails);\n  });\n};\n\n\n\n// Gather app meta-info and log startup message (the boat).\nfunction _printSuccessMsg(sails) {\n\n  // If `config.noShip` is set, skip the startup message.\n  if (!(sails.config.log && sails.config.log.noShip)) {\n\n    sails.log.ship && sails.log.ship();\n    sails.log.info(('Server lifted in `' + sails.config.appPath + '`'));\n    sails.log.info(chalk.underline('To see your app, visit ' + (sails._getBaseUrl() || '')));\n    sails.log.info(('To shut down Sails, press <CTRL> + C at any time.'));\n    sails.log.blank();\n    sails.log(chalk.grey(Array(56).join('-')));\n    sails.log(chalk.grey(':: ' + new Date()));\n    sails.log.blank();\n    sails.log('Environment : ' + sails.config.environment);\n\n    // Only log the host if an explicit host is set\n    if (sails.getHost()) {\n      sails.log('Host        : ' + sails.getHost()); // 12 - 4 = 8 spaces\n    }\n    sails.log('Port        : ' + sails.config.port); // 12 - 4 = 8 spaces\n    sails.log(chalk.grey(Array(56).join('-')));\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/app/lower.js":"/**\n * Module dependencies.\n */\n\nvar async = require('async');\nvar _ = require('@sailshq/lodash');\n\n\n/**\n * Sails.prototype.lower()\n *\n * The inverse of `lift()`, this method\n * shuts down all attached servers.\n *\n * It also unbinds listeners and terminates child processes.\n *\n * @api public\n */\n\nmodule.exports = function lower(options, cb) {\n  var sails = this;\n\n  sails.log.verbose('Lowering sails...');\n\n  // `options` is optional.\n  if ('function' === typeof options) {\n    cb = options;\n    options = null;\n  }\n\n  // Callback is optional\n  cb = cb || function(err) {\n    if (err)  { return sails.log.error(err); }\n  };\n\n  options = options || {};\n  options.delay = options.delay || 100;\n\n  // Flag `sails._exiting` as soon as the app has begun to shutdown.\n  // This may be used by core hooks and other parts of core.\n  // (e.g. to stop handling HTTP requests and prevent ugly error msgs)\n  sails._exiting = true;\n\n  var beforeShutdown = (sails.config && sails.config.beforeShutdown) || function(cb) {\n    return cb();\n  };\n\n  // Wait until beforeShutdown logic runs\n  beforeShutdown(function(err) {\n\n    // If an error occurred, don't stop-- still go ahead and take care of other teardown tasks.\n    if (err) {\n      sails.log.error(err);\n    }\n\n    // Try to kill all child processes\n    _.each(sails.childProcesses, function kill(childProcess) {\n      sails.log.verbose('Sent kill signal to child process (' + childProcess.pid + ')...');\n      try {\n        childProcess.kill('SIGINT');\n      } catch (e) {\n        sails.log.error('While lowering Sails app: received error killing child process: ', e.stack);\n      }\n    });\n\n    // Shut down HTTP server\n    sails.emit('lower');\n    // (Note for future: would be cleaner to provide a way to defer this to the http\n    // and sockets hooks-- i.e. having hooks expose a `teardown(cb)` interceptor. Keep\n    // in mind we'd need a way to distinguish between a graceful shutdown and a force\n    // kill.  In a force kill situation, it's never ok for the process to hang.)\n\n    async.series([\n\n      function shutdownSockets(cb) {\n\n        // If the sockets hook is disabled, skip this.\n        // Also skip if the socket server is piggybacking on the main HTTP server, to avoid\n        // the onClose event possibly being called multiple times (because you can't tell\n        // socket.io to close without it trying to close the http server).  If we're piggybacking\n        // we'll call sails.io.close in the main \"shutdownHTTP\" code below.\n        if (!_.isObject(sails.hooks) || !sails.hooks.sockets || (sails.io && sails.io.httpServer && sails.hooks.http.server === sails.io.httpServer)) {\n          return cb();\n        }\n\n        var timeOut;\n\n        try {\n          sails.log.verbose('Shutting down socket server...');\n          timeOut = setTimeout(function() {\n            sails.io.httpServer.removeListener('close', onClose);\n            return cb();\n          }, 100);\n          sails.io.httpServer.unref();\n          sails.io.httpServer.once('close', onClose);\n          sails.io.close();\n        } catch (e) {\n          sails.log.verbose('Error occurred closing socket server: ', e);\n          clearTimeout(timeOut);\n          cb();\n        }\n\n        function onClose() {\n          sails.log.verbose('Socket server shut down successfully.');\n          clearTimeout(timeOut);\n          cb();\n        }\n\n      },\n\n      function shutdownHTTP(cb) {\n        if (!_.isObject(sails.hooks) || !sails.hooks.http) {\n          return cb();\n        }\n\n        var timeOut;\n\n        try {\n          sails.log.verbose('Shutting down HTTP server...');\n\n          // Allow process to exit once this server is closed\n          sails.hooks.http.server.unref();\n\n          // If we have a socket server and it's piggybacking on the main HTTP server, tell\n          // socket.io to close now.  This may call `.close()` on the HTTP server, which will\n          // happen again below, but the second synchronous call to .close() will have no\n          // additional effect.  Leaving this as-is in case future versions of socket.io\n          // DON'T automatically close the http server for you.\n          if (sails.io && sails.io.httpServer && sails.hooks.http.server === sails.io.httpServer) {\n            sails.io.close();\n          }\n\n          // If the \"hard shutdown\" option is on, destroy the server immediately,\n          // severing all connections\n          if (options.hardShutdown) {\n            sails.hooks.http.destroy();\n          }\n          // Otherwise just stop the server from accepting new connections,\n          // and wait options.delay for the existing connections to close\n          // gracefully before destroying.\n          else {\n            timeOut = setTimeout(sails.hooks.http.destroy, options.delay);\n            sails.hooks.http.server.close();\n          }\n\n          // Wait for the existing connections to close\n          sails.hooks.http.server.once('close', function () {\n            sails.log.verbose('HTTP server shut down successfully.');\n            clearTimeout(timeOut);\n            cb();\n          });\n\n        } catch (e) {\n          sails.log.verbose('Error occurred closing HTTP server: ', e);\n          clearTimeout(timeOut);\n          cb();\n        }\n      },\n\n      function removeListeners(cb) {\n        // Manually remove all event listeners\n        _.each(_.keys(sails._events)||[], function (eventName){\n          sails.removeAllListeners(eventName);\n        });\n\n        var listeners = sails._processListeners;\n        if (listeners) {\n          process.removeListener('SIGUSR2', listeners.sigusr2);\n          process.removeListener('SIGINT', listeners.sigint);\n          process.removeListener('SIGTERM', listeners.sigterm);\n          process.removeListener('exit', listeners.exit);\n        }\n        sails._processListeners = null;\n\n        // If `sails.config.process.removeAllListeners` is set, do that.\n        // This is no longer necessary due to https://github.com/balderdashy/sails/pull/2693\n        // Deprecating for v0.12.\n        if (sails.config && sails.config.process && sails.config.process.removeAllListeners) {\n          sails.log.debug('sails.config.process.removeAllListeners is deprecated; please remove listeners indivually!');\n          process.removeAllListeners();\n        }\n\n        cb();\n      },\n    ], function (err) {\n      if (err) {\n        // This should never happen because `err` is never passed in any of the async\n        // functions above.  Still, just to be safe, we set up an error log.\n        sails.log.error('While lowering Sails app: received unexpected error:', err.stack);\n        return cb(err);\n      }\n\n      // If `sails._setNodeEnvAutomatically` is set, then we should revert it to what it was\n      // beforehand (`sails._originalNodeEnv`), even if it wasn't set at all.\n      // (see load.js for more background)\n      if (sails._setNodeEnvAutomatically) {\n        process.env['NODE_ENV'] = sails._originalNodeEnv;\n      }\n\n      return cb();\n\n    });//</async.series>\n\n  });//</beforeShutdown()>\n\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/app/getBaseurl.js":"/**\n * Module dependencies\n */\n\nvar _ = require('@sailshq/lodash');\n\n\n\n\n/**\n * Calculate the base URL (useful in emails, etc.)\n * @return {String} [description]\n */\n\nmodule.exports = function getBaseurl() {\n  var sails = this;\n\n  var usingSSL = sails.config.ssl === true || (sails.config.ssl && ((sails.config.ssl.key && sails.config.ssl.cert) || sails.config.ssl.pfx));\n  var host = sails.getHost() || 'localhost';\n  var port = sails.config.proxyPort || sails.config.port;\n  var probablyUsingSSL = (port === 443);\n\n  // If host doesn't contain `http*` already, include the protocol string.\n  var protocolString = '';\n  if (!_.contains(host,'http')) {\n    protocolString = ((usingSSL || probablyUsingSSL) ? 'https' : 'http') + '://';\n  }\n  var portString = (port === 80 || port === 443 ? '' : ':' + port);\n  var localAppURL = protocolString + host + portString;\n\n  return localAppURL;\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/app/get-route-for.js":"/**\n * Module dependencies\n */\n\nvar util = require('util');\nvar _ = require('@sailshq/lodash');\nvar sailsUtil = require('sails-util');\n\n\n/**\n * getRouteFor()\n *\n * Look up more information about the first explicit route defined in this app\n * which has the given route target.\n *\n * Note that this function _only searches explicit routes_ which have been configured\n * manually (e.g. in `config/routes.js`).  For more info, see:\n * https://github.com/balderdashy/sails/issues/3402#issuecomment-171633341\n *\n * @this {SailsApp}\n * ----------------------------------------------------------------------------------------\n *\n * Usage:\n *\n * ```\n * getRouteFor('DuckController.quack');\n * getRouteFor({ target: 'DuckController.quack' });\n * // =>\n * // {\n * //   url: '/ducks/:id/quack',\n * //   method: 'post'\n * // }\n * ```\n */\nmodule.exports = function getRouteFor(routeQuery){\n\n  // Get reference to sails app instance.\n  var sails = this;\n\n  // Validate and normalize usage.\n  var routeTargetToLookup;\n  if ( _.isString(routeQuery) ) {\n    routeTargetToLookup = routeQuery;\n  }\n  else if ( _.isObject(routeQuery) && _.isString(routeQuery.target) ) {\n    routeTargetToLookup = routeQuery.target;\n  }\n  else {\n    var invalidUsageErr = new Error('Usage error: `sails.getRouteFor()` expects a string route target (e.g. \"DuckController.quack\") or a dictionary with a target property (e.g. `{target: \"DuckController.quack\"}`).  But instead, it received a `'+typeof routeQuery+'`: '+util.inspect(routeQuery, {depth: null}) );\n    invalidUsageErr.code = 'E_USAGE';\n    throw invalidUsageErr;\n  }\n\n  // Split the provided route target string to look up on its dot, getting its controller and action parts.\n  var routeTargetToLookupPieces = routeTargetToLookup.split('.');\n\n  // If it doesn't have a dot, throw a usage error.\n  if ( routeTargetToLookupPieces.length < 2 ) {\n    var ambiguousUsageErr = new Error('Usage error: Ambiguous usage- target specified to `sails.getRouteFor()` is not a valid route target string (e.g. \"DuckController.quack\") because there is no dot (\".\")');\n    ambiguousUsageErr.code = 'E_USAGE';\n    throw ambiguousUsageErr;\n  }\n\n  // Now look up the first route with this target (`routeTargetToLookup`).\n  var firstMatchingRouteAddress;\n  _.any(sails.router.explicitRoutes, function (routeTarget, key) {\n    // If route target syntax is a string, compare it directly with the provided `routeTargetToLookup`.\n    if ( _.isString(routeTarget) ) {\n      if (routeTarget===routeTargetToLookup ) {\n        firstMatchingRouteAddress = key;\n        return true;\n      }\n      else {\n        // TODO: If that check fails, try removing \"Controller\" suffix from both `routeTargetToLookup` and the controller in the `routeTarget` and comparing those. Note that this means you _should not define `ControllerController.js`_!\n        // * * * ACTUALLY, see: https://github.com/balderdashy/sails/issues/3402#issuecomment-173255376   * * *\n      }\n    }\n    else if ( _.isObject(routeTarget) ) {\n      // If route target syntax itself contains a string `target` key, compare it directly with the provided `routeTargetToLookup`.\n      if ( _.isString(routeTarget.target) && routeTarget.target===routeTargetToLookup ) {\n        // TODO: If that check fails, try removing \"Controller\" suffix from both `routeTargetToLookup` and the controller in the `routeTarget` and comparing those. Note that this means you _should not define `ControllerController.js`_!\n        // * * * ACTUALLY, see: https://github.com/balderdashy/sails/issues/3402#issuecomment-173255376   * * *\n        firstMatchingRouteAddress = key;\n        return true;\n      }\n      // If route target syntax contains `controller`+`action` keys, then check those against the relevant pieces of the provided `routeTargetToLookup`.\n      else if ( _.isString(routeTarget.controller) && _.isString(routeTarget.action) && routeTarget.controller===routeTargetToLookupPieces[0] && routeTarget.action===routeTargetToLookupPieces[1] ) {\n        // TODO: If that check fails, try removing \"Controller\" suffix from both `routeTargetToLookup` and the controller in the `routeTarget` and comparing those. Note that this means you _should not define `ControllerController.js`_!\n        // * * * ACTUALLY, see: https://github.com/balderdashy/sails/issues/3402#issuecomment-173255376   * * *\n        firstMatchingRouteAddress = key;\n        return true;\n      }\n      // If route target syntax contains only `controller`, compare assuming the \"index\" action against the relevant pieces of the provided `routeTargetToLookup`.\n      else if ( _.isString(routeTarget.controller) && !routeTarget.action && routeTarget.controller===routeTargetToLookupPieces[0] && 'index'===routeTargetToLookupPieces[1] ) {\n        // TODO: If that check fails, try removing \"Controller\" suffix from both `routeTargetToLookup` and the controller in the `routeTarget` and comparing those. Note that this means you _should not define `ControllerController.js`_!\n        // * * * ACTUALLY, see: https://github.com/balderdashy/sails/issues/3402#issuecomment-173255376   * * *\n        firstMatchingRouteAddress = key;\n        return true;\n      }\n      // Note that we ignore non-matches or anything utterly insane.\n    }\n  });\n\n\n  // If no route was found, throw an error.\n  if (!firstMatchingRouteAddress) {\n    var unrecognizedTargetErr = new Error('Route not found: No explicit route could be found in this app with the specified target (`'+routeTargetToLookup+'`).');\n    unrecognizedTargetErr.code = 'E_NOT_FOUND';\n    throw unrecognizedTargetErr;\n  }\n\n  // Now that the raw route address been located, we'll normalize it:\n  //\n  // If route address is '*', it will be automatically corrected to `/*` when bound, so also reflect that here.\n  firstMatchingRouteAddress = firstMatchingRouteAddress === '*' ? '/*' : firstMatchingRouteAddress;\n\n  // Then we parse it into its HTTP method and URL pattern parts.\n  var parsedAddress = sailsUtil.detectVerb(firstMatchingRouteAddress);\n\n  // At this point we being building the final return value- the route info dictionary.\n  var routeInfo = {};\n  routeInfo.method = parsedAddress.verb || '';\n  routeInfo.url = parsedAddress.path;\n\n\n  // And finally return the route info.\n  return routeInfo;\n\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/app/get-url-for.js":"/**\n * Module dependencies\n */\n\n// N/A\n\n\n/**\n * getUrlFor()\n *\n * Look up the URL of this app's first explicit route with the given route target.\n *\n * Note that this function _only searches explicit routes_ which have been configured\n * manually (e.g. in `config/routes.js`).  For more info, see:\n * https://github.com/balderdashy/sails/issues/3402#issuecomment-171633341\n *\n *\n * @this {SailsApp}\n * ----------------------------------------------------------------------------------------\n *\n * Usage:\n *\n * ```\n * getUrlFor('DuckController.quack');\n * // => '/ducks/:id/quack'\n *\n * getUrlFor({ target: 'DuckController.quack' });\n * // => '/ducks/:id/quack'\n * ```\n */\nmodule.exports = function getUrlFor(routeQuery){\n\n  // Get reference to sails app instance.\n  var sails = this;\n\n  // Now attempt to look up the first route that matches the specified argument\n  // and if it works, then return its URL.\n  return sails.getRouteFor(routeQuery).url;\n\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/app/request.js":"/**\n * Module dependencies.\n */\n\nvar _ = require('@sailshq/lodash');\nvar util = require('util');\nvar QS = require('querystring');\nvar Transform = require('stream').Transform;\n\n\n/**\n * Originate a new client request instance and lob it at this Sails\n * app at the specified route `address`.\n *\n * Particularly useful for running unit/integration tests without\n * actually having to bind the HTTP and/or WebSocket servers to\n * a TCP port.\n *\n * @param  {String} address\n * @param  {Object} body\n * @param  {Function} cb\n * @return {Stream.Readable}\n *\n * @api public\n */\n\nmodule.exports = function request( /* address, body, cb */ ) {\n\n  var sails = this;\n\n  //\n  // Body params may be passed in to DELETE, HEAD, and GET requests,\n  // even though these types of requests don't normally contain a body.\n  // (this method just serializes them as if they were sent in the querystring)\n  //\n\n\n  // Normalize usage\n  var address = arguments[0];\n  var body;\n  var cb;\n\n  var method;\n  var headers;\n  var url;\n\n  // Usage:\n  // sails.request(opts, cb)\n  //  opts.url\n  //  opts.method\n  //  opts.params\n  //  opts.headers\n  //\n  // (`opts.url` is required)\n  if (_.isObject(arguments[0]) && arguments[0].url) {\n    url = arguments[0].url;\n    method = arguments[0].method;\n    headers = arguments[0].headers || {};\n    body = arguments[0].params || arguments[0].data || {};\n  }\n  // console.log('called sails.request() ');\n  // console.log('headers: ',headers);\n  // console.log('method: ',method);\n\n\n  // Usage:\n  // sails.request(address, [params], cb)\n  if (arguments[2]) {\n    cb = arguments[2];\n    body = arguments[1];\n  }\n  if (_.isFunction(arguments[1])) {\n    cb = arguments[1];\n  } else if (arguments[1]) {\n    body = arguments[1];\n  }\n\n  // If route has an HTTP verb (e.g. `get /foo/bar`, `put /bar/foo`, etc.) parse it out,\n  // (unless method or url was explicitly defined)\n  method = method || sails.util.detectVerb(address).verb;\n  method = method ? method.toUpperCase() : 'GET';\n  url = url || sails.util.detectVerb(address).original;\n\n  // Parse query string (`req.query`)\n  var queryStringPos = url.indexOf('?');\n\n  // If this is a GET, HEAD, or DELETE request, treat the \"body\"\n  // as parameters which should be serialized into the querystring.\n  if (_.isObject(body) && _.contains(['GET', 'HEAD', 'DELETE'], method)) {\n\n    var stringifiedParams = QS.stringify(body);\n\n    if (queryStringPos === -1) {\n      url += '?' + stringifiedParams;\n    } else {\n      url = url.substring(0, queryStringPos) + '?' + stringifiedParams;\n    }\n  }\n\n\n\n  // Build HTTP Client Response stream\n  var clientRes = new MockClientResponse();\n  clientRes.on('finish', function() {\n\n    // console.log('clientRes finished. Headers:',clientRes.headers);\n\n    // Only dump the buffer if a callback was supplied\n    if (cb) {\n\n      // Attempt to read the response buffer into a string\n      try {\n        clientRes.body = clientRes.read();\n        if (clientRes.body !== null) {\n          clientRes.body = clientRes.body.toString();\n          clientRes.body = JSON.parse(clientRes.body);\n        }\n      } catch (e) {}\n\n      // Don't include body if it is empty\n      if (!clientRes.body) {delete clientRes.body;}\n\n      // If status code is indicative of an error, send the\n      // response body or status code as the first error argument.\n      if (clientRes.statusCode < 200 || clientRes.statusCode >= 400) {\n        var error = new Error(util.inspect(clientRes.body || clientRes.statusCode));\n        if (clientRes.body) {error.body = clientRes.body;}\n        error.status = clientRes.statusCode;\n        return cb(error);\n      }\n      else {\n        return cb(null, clientRes, clientRes.body);\n      }\n    }\n  });\n  clientRes.on('error', function(err) {\n    err = err || new Error('Error on response stream');\n    if (cb) return cb(err);\n    else return clientRes.emit('error', err);\n  });\n\n  // To kick things off, pass `opts` (as req) and `res` to the Sails router\n  sails.router.route({\n    method: method,\n    url: url,\n    body: body,\n    headers: headers || {}\n  }, {\n    _clientRes: clientRes\n  });\n\n  // Return clientRes stream\n  return clientRes;\n\n};\n\n\n\nfunction MockClientResponse() {\n  Transform.call(this);\n}\nutil.inherits(MockClientResponse, Transform);\nMockClientResponse.prototype._transform = function(chunk, encoding, next) {\n  this.push(chunk);\n  next();\n};\n\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/app/private/initialize.js":"/**\n * Module dependencies\n */\n\nvar util = require('util');\nvar _ = require('@sailshq/lodash');\nvar async = require('async');\n\n\n\n\n/**\n * Sails.prototype.initialize()\n *\n * Start the Sails server\n * NOTE: sails.load() should be run first.\n *\n * @param {Function?} callback  [optional]\n *\n * @api private\n */\n\nmodule.exports = function initialize(cb) {\n\n  var sails = this;\n\n  // Callback is optional\n  cb = cb || function(err) {\n    if (err) { sails.log.error(err); }\n  };\n\n  // Indicate that server is starting\n  sails.log.verbose('Starting app at ' + sails.config.appPath + '...');\n\n  var listeners = {\n    sigusr2: function() {\n      sails.lower(function() {\n        process.kill(process.pid, 'SIGUSR2');\n      });\n    },\n    sigint: function() {\n      sails.lower(function (){\n        process.exit();\n      });\n    },\n    sigterm: function() {\n      sails.lower(function (){\n        process.exit();\n      });\n    },\n    exit: function() {\n      if (!sails._exiting) {\n        sails.lower();\n      }\n    }\n  };\n\n  // Add \"beforeShutdown\" events\n  process.once('SIGUSR2', listeners.sigusr2);\n\n  process.on('SIGINT', listeners.sigint);\n  process.on('SIGTERM', listeners.sigterm);\n  process.on('exit', listeners.exit);\n\n  sails._processListeners = listeners;\n\n  // Run the app bootstrap\n  sails.runBootstrap(function afterBootstrap(err) {\n    if (err) {\n      sails.log.error('Bootstrap encountered an error: (see below)');\n      return cb(err);\n    }\n\n    // Fire the `ready` event for backwards-compatibility.\n    // (this will be removed in a future version of Sails!)\n    sails.emit('ready');\n\n\n    // Now loop over each hook, and if it exposes a `handleLift` function, then run it.\n    // (this is used by attached servers, etc.)\n    if (!_.isObject(sails.hooks)) { return cb(new Error('Consistency violation: `sails.hooks` should be a dictionary.')); }\n    async.each(Object.keys(sails.hooks), function (hookName, next){\n      if (!_.isFunction(sails.hooks[hookName].handleLift)) {\n        return next();\n      }\n      return sails.hooks[hookName].handleLift(next);\n    }, function (err){\n      if (err) { return cb(err); }\n      return cb(null, sails);\n    });\n\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/app/private/exposeGlobals.js":"/**\n * Module dependencies.\n */\n\nvar _ = require('@sailshq/lodash');\nvar async = require('async');\n\n\n/**\n * exposeGlobals()\n *\n * Expose certain global variables\n * (if config says so)\n *\n * @api private\n */\n\nmodule.exports = function exposeGlobals() {\n  var sails = this;\n\n\n  // Globals explicitly disabled\n  if (sails.config.globals === false) {\n    sails.log.verbose('No global variables will be exposed.');\n    return;\n  }\n\n  sails.log.verbose('Exposing global variables... (you can customize/disable this by modifying the properties in `sails.config.globals`.  Set it to `false` to disable all globals.)');\n\n  sails.config.globals = sails.config.globals || {};\n\n  // Provide global access (if allowed in config)\n  if (sails.config.globals._ !== false) {\n    global['_'] = _;\n  }\n  if (sails.config.globals.async !== false) {\n    global['async'] = async;\n  }\n  if (sails.config.globals.sails !== false) {\n    global['sails'] = sails;\n  }\n\n  // `services` hook takes care of globalizing services (if enabled)\n\n  // `orm` hook takes care of globalizing models and adapters (if enabled)\n\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/app/private/bootstrap.js":"/**\n * Module dependencies\n */\n\nvar util = require('util');\n\n\n/**\n * runBootstrap\n *\n * TODO: move this into a new `bootstrap` hook so that it may be flipped\n * on and off explicitly w/o loading/depending on user config\n *\n * @param  {Function} cb [description]\n *\n * @api private\n */\n\nmodule.exports = function runBootstrap(cb) {\n\n  var sails = this;\n\n  // Run bootstrap script if specified\n  // Otherwise, do nothing and continue\n  if (!sails.config.bootstrap) {\n    return cb();\n  }\n\n  sails.log.verbose('Running the setup logic in `sails.config.bootstrap(cb)`...');\n\n  // IF bootstrap takes too long, display warning message\n  // (just in case user forgot to call their bootstrap's `cb`)\n  var timeoutMs = sails.config.bootstrapTimeout || 2000;\n  var timer = setTimeout(function bootstrapTookTooLong() {\n    sails.log.warn(util.format(\n    'Bootstrap is taking unusually long to execute its callback (%d milliseconds).\\n'+\n    'Perhaps you forgot to call it?  The callback is the first argument of the function, `cb`.',\n    timeoutMs));\n  }, timeoutMs);\n\n  var ranBootstrapFn = false;\n\n  try {\n    return sails.config.bootstrap(function bootstrapDone(err) {\n      if (ranBootstrapFn) {\n        sails.log.error('You called the callback in `sails.config.bootstrap` more than once!');\n        return;\n      }\n      ranBootstrapFn = true;\n      clearTimeout(timer);\n      return cb(err);\n    });\n  }\n  catch (e) {\n    if (ranBootstrapFn) {\n      sails.log.error('The bootstrap function threw an error after its callback was called ::',e);\n      return;\n    }\n    ranBootstrapFn = true;\n    clearTimeout(timer);\n    return cb(e);\n  }\n\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/app/private/getHost.js":"/**\n * Sails.prototype.getHost()\n *\n * @return {String} the configured hostname of the server\n * (IMPORTANT: returns undefined if not specifically configured)\n */\n\nmodule.exports = function getHost() {\n  var sails = this;\n\n  var hasExplicitHost = sails.config.hooks.http && sails.config.explicitHost;\n  var host = sails.config.proxyHost || hasExplicitHost || sails.config.host;\n  return host;\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/app/private/isLocalSailsValid.js":"/**\n * Module dependencies\n */\n\nvar fs = require('fs');\nvar CaptainsLog = require('captains-log');\nvar sailsutil = require('sails-util');\nvar semver = require('semver');\nvar Err = require('../../../errors');\n\n\n\n/**\n * Check if the specified installation of Sails is valid for the specified project.\n *\n * @param sailsPath\n * @param appPath\n */\n\nmodule.exports = function isLocalSailsValid(sailsPath, appPath) {\n\n  var sails = this;\n\n  // Has no package.json file\n  if (!fs.existsSync(appPath + '/package.json')) {\n    Err.warn.noPackageJSON();\n  }\n\n  // Load this app's package.json and dependencies\n  var appPackageJSON = sailsutil.getPackageSync(appPath);\n  var appDependencies = appPackageJSON.dependencies;\n\n\n  // Package.json exists, but doesn't list Sails as a dependency\n  if (!(appDependencies && appDependencies.sails)) {\n    Err.warn.notSailsApp();\n    return;\n  }\n\n  // Ensure the target Sails exists\n  if (!fs.existsSync(sailsPath)) {\n    return false;\n  }\n\n  // Read the package.json in the local installation of Sails\n  var sailsPackageJSON = sailsutil.getPackageSync(sailsPath);\n\n  // Local Sails has a corrupted package.json\n  if (!sailsPackageJSON) {\n    Err.warn.badLocalDependency(sailsPath, appDependencies.sails);\n    return;\n  }\n\n\n  // Lookup sails dependency requirement in app's package.json\n  var requiredSailsVersion = appDependencies.sails;\n\n  //\n  // TODO: use npm's built-in version comparator instead of taking care of\n  // all these edge cases:\n  //\n\n  // If you're using a `git://` sails dependency, you probably know\n  // what you're doing, but we'll let you know just in case.\n  var expectsGitVersion = requiredSailsVersion.match(/^git:\\/\\/.+/);\n  if (expectsGitVersion) {\n    var log = sails.log ? sails.log : CaptainsLog();\n\n    log.blank();\n    log.debug('NOTE:');\n    log.debug('This app depends on an unreleased version of Sails:');\n    log.debug(requiredSailsVersion);\n    log.blank();\n  }\n\n  // Ignore `latest` and `beta` (kind of like how we handle specified git:// deps)\n  var expectsLatest = requiredSailsVersion === 'latest';\n  if (expectsLatest) {\n    // ...\n  }\n  var expectsBeta = requiredSailsVersion === 'beta';\n  if (expectsBeta) {\n    // ...\n  }\n\n  // Error out if it has the wrong version in its package.json\n  if (!expectsLatest && !expectsBeta && !expectsGitVersion) {\n\n    // Use semver for version comparison\n    if (!semver.satisfies(sailsPackageJSON.version, requiredSailsVersion)) {\n      Err.warn.incompatibleLocalSails(requiredSailsVersion, sailsPackageJSON.version);\n    }\n  }\n\n  // If we made it this far, the target Sails installation must be OK\n  return true;\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/errors/index.js":"// Merge together error sub-modules\nmodule.exports = {\n  fatal: require('./fatal'),\n  warn: require('./warn')\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/errors/fatal.js":"/**\n * Module dependencies\n */\nvar nodeutil = require('util');\nvar nodepath = require('path');\nvar chalk = require('chalk');\n\n// Build logger using best-available information\n// when this module is initially required.\nvar log = require('captains-log')(require('../lib/app/configuration/rc'));\n\n/**\n * Fatal Errors\n */\nmodule.exports = {\n\n  // Lift-time and load-time errors\n  failedToLoadSails: function(err) {\n    log.error(err);\n    log.error('Could not load Sails.');\n    log.error('Are you using the latest stable version?');\n    _terminateProcess(1);\n  },\n\n  noPackageJSON: function() {\n    log.error('Cannot read package.json in the current directory (' + process.cwd() + ')');\n    log.error('Are you sure this is a Sails app?');\n    _terminateProcess(1);\n  },\n\n  notSailsApp: function() {\n    log.error('The package.json in the current directory does not list Sails as a dependency...');\n    log.error('Are you sure `' + process.cwd() + '` is a Sails app?');\n    _terminateProcess(1);\n  },\n\n  badLocalDependency: function(pathTo_localSails, requiredVersion) {\n    log.error(\n      'The local Sails dependency installed at `' + pathTo.localSails + '` ' +\n      'has a corrupted, missing, or un-parsable package.json file.'\n    );\n    log.error('You may consider running:');\n    log.error('rm -rf ' + pathTo_localSails + ' && npm install sails@' + app.dependencies.sails);\n    _terminateProcess(1);\n  },\n\n  // TODO: replace the inline version of this error\n  // app/loadHooks.js:42\n  malformedHook: function() {\n    log.error('Malformed hook! (' + id + ')');\n    log.error('Hooks should be a function with one argument (`sails`)');\n    _terminateProcess(1);\n  },\n\n  // TODO: replace the inline version of this error\n  // app/load.js:146\n  hooksTookTooLong: function() {\n    var hooksTookTooLongErr = 'Hooks are taking way too long to get ready...  ' +\n      'Something might be amiss.\\nAre you using any custom hooks?\\nIf so, make sure the hook\\'s ' +\n      '`initialize()` method is triggering its callback.';\n    log.error(hooksTookTooLongErr);\n    process.exit(1);\n  },\n\n\n\n  // Invalid user module errors\n  invalidCustomResponse: function(responseIdentity) {\n    log.error('Cannot define custom response `' + responseIdentity + '`.');\n    log.error('`res.' + responseIdentity + '` has special meaning in Connect/Express/Sails.');\n    log.error('Please remove the `' + responseIdentity + '` file from the `responses` directory.');\n    _terminateProcess(1);\n  },\n\n\n\n  // This doesn't technically _need_ to be a fatal error- it just is\n  // because certain grunt modules (e.g. grunt-contrib-watch) don't restart\n  // when an error occurs.\n  __GruntAborted__: function(consoleMsg, stackTrace) {\n\n    var gruntErr =\n      '\\n------------------------------------------------------------------------\\n' +\n      consoleMsg + '\\n' + (stackTrace || '') +\n      '\\n------------------------------------------------------------------------';\n    log.error(gruntErr);\n    log.blank();\n\n    log.error('Looks like a Grunt error occurred--');\n    log.error('Please fix it, then **restart Sails** to continue running tasks (e.g. watching for changes in assets)');\n    log.error('Or if you\\'re stuck, check out the troubleshooting tips below.');\n    log.blank();\n\n    log.error(chalk.underline('Troubleshooting tips:'));\n    var relativePublicPath = (nodepath.resolve(process.cwd(), './.tmp'));\n    var uid = process.getuid && process.getuid() || 'YOUR_COMPUTER_USER_NAME';\n    log.error();\n    log.error(' *-> Are \"grunt\" and related grunt task modules installed locally?  Run `npm install` if you\\'re not sure.');\n    log.error();\n    log.error(' *-> You might have a malformed LESS, SASS, CoffeeScript file, etc.');\n    log.error();\n    log.error(' *-> Or maybe you don\\'t have permissions to access the `.tmp` directory?');\n    log.error('     e.g., `' + relativePublicPath + '`', '?');\n    log.error();\n    log.error('     If you think this might be the case, try running:');\n    log.error('     sudo chown -R', uid, relativePublicPath);\n    log.blank();\n\n    // See note above this function - for now, this will not\n    // actually terminate the process.  The rest of Sails should\n    // continue to run.\n    // return _terminateProcess(1);\n  },\n\n\n  __UnknownPolicy__: function(policy, source, pathToPolicies) {\n    source = source || 'config.policies';\n\n    log.error('Unknown policy, \"' + policy + '\", referenced in `' + source + '`.');\n    log.error('Are you sure that policy exists?');\n    log.error('It would be located at: `' + pathToPolicies + '/' + policy + '.js`');\n    return _terminateProcess(1);\n  },\n\n  __InvalidConnection__: function(connection, sourceModelId) {\n    log.error('In model (' + sourceModelId + '), invalid connection ::', connection);\n    log.error('Must contain an `adapter` key referencing the adapter to use.');\n    return _terminateProcess(1);\n  },\n\n  __UnknownConnection__: function(connectionId, sourceModelId) {\n    log.error('Unknown connection, \"' + connectionId + '\", referenced in model `' + sourceModelId + '`.');\n    log.error('Are you sure that connection exists?  It should be defined in `sails.config.connections`.');\n\n    // var probableAdapterModuleName = connectionId.toLowerCase();\n    // if ( ! probableAdapterModuleName.match(/^(sails-|waterline-)/) ) {\n    // \tprobableAdapterModuleName = 'sails-' + probableAdapterModuleName;\n    // }\n    // log.error('Otherwise, if you\\'re trying to use an adapter named `' + connectionId + '`, please run ' +\n    // \t'`npm install ' + probableAdapterModuleName + '@' + sails.majorVersion + '.' + sails.minorVersion + '.x`');\n    return _terminateProcess(1);\n  },\n\n\n  __ModelIsMissingConnection__: function(sourceModelId) {\n    log.error(nodeutil.format('One of your models (%s) doesn\\'t have a connection.', sourceModelId));\n    log.error('Do you have a default `connection` in your `config/models.js` file?');\n    return _terminateProcess(1);\n  },\n\n  __UnknownAdapter__: function(adapterId, sourceModelId, sailsMajorV, sailsMinorV) {\n    log.error('Trying to use unknown adapter, \"' + adapterId + '\", in model `' + sourceModelId + '`.');\n    log.error('Are you sure that adapter is installed in this Sails app?');\n    log.error('If you wrote a custom adapter with identity=\"' + adapterId + '\", it should be in this app\\'s adapters directory.');\n\n    var probableAdapterModuleName = adapterId.toLowerCase();\n    if (!probableAdapterModuleName.match(/^(sails-|waterline-)/)) {\n      probableAdapterModuleName = 'sails-' + probableAdapterModuleName;\n    }\n    log.error('Otherwise, if you\\'re trying to use an adapter named `' + adapterId + '`, please run ' +\n      '`npm install ' + probableAdapterModuleName + ' --save'/*'@' + sailsMajorV + '.' + sailsMinorV + '.x`'*/);\n    return _terminateProcess(1);\n  },\n\n  __InvalidAdapter__: function(attemptedModuleName, supplementalErrMsg) {\n    log.error('There was an error attempting to require(\"' + attemptedModuleName + '\")');\n    log.error('Is this a valid Sails/Waterline adapter?  The following error was encountered ::');\n    log.error(supplementalErrMsg);\n\n    return _terminateProcess(1);\n  }\n};\n\n\n\n/**\n *\n * TODO: Make all of this more elegant.\n * ========================================================\n * + Ideally we don't call `process.exit()` at all.\n * We should consistently use `sails.lower()` for unhandleable core\n * errors and just trigger the appropriate callback w/ an error for\n * core lift/load and any CLI errors.\n *\n * + Then we won't have to worry as much about dangling child processes\n * and things like that. Plus it's more testable that way.\n *\n * In practice, the best way to do this may be an error domain or an\n * event emitted on the sails object (or both!)\n * ========================================================\n *\n *\n *\n * TODO: Merge w/ app/teardown.js\n * ========================================================\n * (probably achievable by doing the aforementioned cleanup)\n * ========================================================\n */\n\n\n\n/**\n * _terminateProcess\n *\n * Terminate the process as elegantly as possible.\n * If process.env is 'test', throw instead.\n *\n * @param  {[type]} code [console error code]\n * @param  {[type]} opts [currently unused]\n */\nfunction _terminateProcess(code, opts) {\n  if (process.env.NODE_ENV === 'test') {\n    var Signal = new Error({\n      type: 'terminate',\n      code: code,\n      options: {\n        todo: 'put the stuff from the original errors in here'\n      }\n    });\n    throw Signal;\n  }\n\n  return process.exit(code);\n}\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/app/configuration/rc.js":"/**\n * Module dependencies\n */\n\nvar rc = require('rc');\n\n\n/**\n * Locate and load a .sailsrc file if one exists.\n *\n * NOTE: this occurs almost immediately when sails is required,\n * and since `rc` is synchronous, the examination of env variables,\n * cmdline opts, and .sailsrc files is immediate, and happens only once.\n *\n * @type {Object}\n */\nmodule.exports = rc('sails');\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/errors/warn.js":"/**\n * Module dependencies\n */\n\nvar nodepath = require('path');\n\n// Build logger using best-available information\n// when this module is initially required.\nvar log = require('captains-log')(require('../lib/app/configuration/rc'));\n\n\n/**\n * Warnings\n */\nmodule.exports = {\n\n  incompatibleLocalSails: function(requiredVersion, localVersion) {\n    log.warn('Trying to lift app using a local copy of `sails`');\n    log.warn('(located in ' + nodepath.resolve(process.cwd(), 'node_modules/sails') + ')');\n    log.warn();\n    log.warn('But the package.json in the current directory indicates a dependency');\n    log.warn('on Sails `' + requiredVersion + '`, and the locally installed Sails is `' + localVersion + '`!');\n    log.warn();\n    log.warn('If you run into compatibility issues, try installing ' + requiredVersion + ' locally:');\n    log.warn('    $ npm install sails@' + requiredVersion);\n    log.warn();\n    log.blank();\n  },\n\n\n\n  // Verbose-only warnings:\n\n  noPackageJSON: function() {\n    log.warn('Cannot read package.json in the current directory (' + process.cwd() + ')');\n    log.warn('Are you sure this is a Sails app?');\n    log.warn();\n  },\n\n  notSailsApp: function() {\n    log.warn('The package.json in the current directory does not list Sails as a dependency...');\n    log.warn('Are you sure `' + process.cwd() + '` is a Sails app?');\n    log.warn();\n  },\n\n  badLocalDependency: function(pathTo_localSails, requiredVersion) {\n    log.warn(\n      'The local Sails dependency installed at `' + pathTo_localSails + '` ' +\n      'has a corrupted, missing, or un-parsable package.json file.'\n    );\n    log.warn('You may consider running:');\n    log.warn('rm -rf ' + pathTo_localSails + ' && npm install sails@' + requiredVersion);\n    log.warn();\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/app/private/isSailsAppSync.js":"/**\n * Module dependencies\n */\n\nvar fs = require('fs'),\n  path = require('path'),\n  sailsutil = require('sails-util');\n\n\n\n/**\n * Check if the specified appPath contains something that looks like a Sails app.\n *\n * @param {String} appPath\n */\n\nmodule.exports = function isSailsAppSync(appPath) {\n\n  // Has no package.json file\n  if (!fs.existsSync(path.join(appPath, 'package.json'))) {\n    return false;\n  }\n\n  // Package.json exists, but doesn't list Sails as a dependency\n  var appPackageJSON = sailsutil.getPackageSync(appPath);\n  var appDependencies = appPackageJSON.dependencies;\n  if (!(appDependencies && appDependencies.sails)) {\n    return false;\n  }\n\n  return true;\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/app/private/inspect.js":"/**\n * Module dependencies\n */\n\nvar util = require('util');\nvar _ = require('@sailshq/lodash');\n\n\n\n/**\n * Sails.prototype.inspect()\n *\n * The string that should be returned when this `Sails` instance\n * is passed to `util.inspect()` (i.e. when logged w/ `console.log()`)\n *\n * @return {String}\n */\n\nmodule.exports = function inspect () {\n  var sails = this;\n\n  return util.format('\\n'+\n  '  |>   %s', this.toString()) + '\\n' +\n  '\\\\___/  For help, see: http://sailsjs.org/documentation/concepts/'+\n  '\\n\\n' +\n  'Tip: Use `sails.config` to access your app\\'s runtime configuration.'+\n  '\\n\\n' +\n  util.format('%d Models:\\n', _(sails.models).toArray().value().length) +\n  _(sails.models).toArray().filter(function (it) {return !it.junctionTable;}).pluck('globalId').value() +\n  '\\n\\n' +\n  util.format('%d Controllers:\\n', _(sails.controllers).toArray().value().length)+\n  _(sails.controllers).toArray().pluck('globalId').map(function (it) {return it+'Controller';}).value() +\n  '\\n\\n' +\n  // 'Routes:\\n'+\n  // _(sails.routes).toArray().filter(function (it) {return !it.junctionTable;}).pluck('globalId').map(function (it) {return it+'Controller';}).value() +\n  // '\\n\\n' +\n  util.format('%d Hooks:\\n', _(sails.hooks).toArray().value().length)+\n  _(sails.hooks).toArray().pluck('identity').value() +\n  '\\n' +\n  '';\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/app/private/toString.js":"/**\n * Module dependencies\n */\n\nvar util = require('util');\n\n\n/**\n * Sails.prototype.toString()\n *\n * e.g.\n * ('This is how `sails` looks when toString()ed: ' + sails)\n *\n * @return {String}\n */\nmodule.exports = function toString () {\n  return util.format('[a %sSails app%s]', this.isLifted ? 'lifted ' : '', this.isLifted && this.config.port ? ' on port '+this.config.port : '');\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/app/private/toJSON.js":"/**\n * Module dependencies\n */\n\nvar _ = require('@sailshq/lodash');\n\n\n/**\n * [exports description]\n * @return {[type]} [description]\n */\n\nmodule.exports = function toJSON () {\n  return _.reduce(this, function (pojo, val, key) {\n    if (key === 'config') {\n      pojo[key] = val;\n    }\n    if (key === 'hooks') {\n      pojo[key] = _.reduce(val, function (memo, hook, ident) {\n        memo.push(ident);\n        return memo;\n      }, []);\n    }\n    if (key === 'models') {\n      pojo[key] = _.reduce(val, function (memo, model, ident) { //TODO: unused variable ident\n        if (!model.junctionTable) {\n          memo.push({\n            attributes: model.attributes,\n            identity: model.identity,\n            globalId: model.globalId,\n            connection: model.connection,\n            schema: model.schema,\n            tableName: model.tableName\n          });\n        }\n        return memo;\n      }, []);\n    }\n\n    return pojo;\n  }, {});\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/app/configuration/load.js":"/**\n * Module dependencies.\n */\n\nvar _ = require('@sailshq/lodash');\nvar async = require('async');\nvar CaptainsLog = require('captains-log');\nvar path = require('path');\n\n\nmodule.exports = function(sails) {\n\n  /**\n   * Expose Configuration loader\n   *\n   * Load command-line overrides\n   *\n   * TODO: consider merging this into the `app` directory\n   *\n   * For reference, config priority is:\n   * --> implicit defaults\n   * --> environment variables\n   * --> user config files\n   * --> local config file\n   * --> configOverride ( in call to sails.lift() )\n   * --> --cmdline args\n   */\n\n  return function loadConfig(cb) {\n\n    // Save reference to context for use in closures\n    var self = this;\n\n    // Commence with loading/validating/defaulting all the rest of the config\n    async.auto({\n\n        /**\n         * Until this point this point, `sails.config` is composed only of\n         * configuration overrides passed into `sails.lift(overrides)`\n         * (or `sails.load(overrides)`-- same thing)\n         *\n         * This step clones this into an \"overrides\" object, negotiating cmdline\n         * shortcuts into the properly namespced sails configuration options.\n         */\n        mapOverrides: function(cb) {\n\n          // Clone the `overrides` that were passed in.\n          var overrides = _.cloneDeep(sails.config || {});\n\n          // TODO: bring the rconf stuff from bin/sails-lift in here\n\n          // Command-line arguments take highest precedence\n          // overrides = _.merge(overrides, argv);\n\n          // Map Sails options from overrides\n          overrides = _.merge(overrides, {\n\n            // `--verbose` command-line argument\n            // `--silly` command-line argument\n            // `--silent` command-line argument\n            log: overrides.verbose ? {\n              level: 'verbose'\n            } : overrides.silly ? {\n              level: 'silly'\n            } : overrides.silent ? {\n              level: 'silent'\n            } : undefined,\n\n            // `--port=?` command-line argument\n            port: overrides.port || undefined,\n\n            // `--prod` command-line argument\n            environment: overrides.prod ? 'production' : (overrides.dev ? 'development' : undefined)\n\n          });\n\n\n          // Pass on overrides object\n          cb(null, overrides);\n        },\n\n\n\n        /**\n         * Immediately instantiate the default logger in case a log-worthy event occurs\n         * Even though the app might actually use its own custom logger, we don't know\n         * all of the user configurations yet.\n         *\n         * Makes sails.log accessible for the first time\n         */\n        logger: ['mapOverrides',\n          function(cb, async_data) {\n            var logConfigSoFar = async_data.mapOverrides.log;\n            sails.log = new CaptainsLog(logConfigSoFar);\n            cb();\n          }\n        ],\n\n\n        /**\n         * Expose version/dependency info for the currently-running\n         * Sails on the `sails` object (from its `package.json`)\n         */\n        versionAndDependencyInfo: function(cb) {\n\n          var pathToThisVersionOfSails = path.join(__dirname, '../../..');\n          sails.util.getPackage(pathToThisVersionOfSails, function(err, json) {\n            if (err) return cb(err);\n\n            sails.version = json.version;\n            sails.majorVersion = sails.version.split('.')[0].replace(/[^0-9]/g, '');\n            sails.minorVersion = sails.version.split('.')[1].replace(/[^0-9]/g, '');\n            sails.patchVersion = sails.version.split('.')[2].replace(/[^0-9]/g, '');\n            sails.dependencies = json.dependencies;\n\n            cb();\n          });\n        },\n\n\n        /**\n         * Ensure that environment variables are applied to important configs\n         */\n        mixinDefaults: ['mapOverrides',\n          function(cb, results) {\n\n            // Get overrides\n            var overrides = results.mapOverrides; //_.cloneDeep(results.mapOverrides);\n\n            // Apply environment variables\n            // (if the config values are not set in overrides)\n            overrides.environment = overrides.environment || process.env.NODE_ENV;\n            overrides.port = overrides.port || process.env.PORT;\n\n            // Generate implicit, built-in framework defaults for the app\n            var implicitDefaults = self.defaults(overrides.appPath || process.cwd());\n\n            // Extend copy of implicit defaults with user config\n            var mergedConfig = _.merge(_.cloneDeep(implicitDefaults), overrides);\n\n\n            // Set the NODE_ENV environment variable so express and other modules\n            // which expect NODE_ENV to be set mirror the configured Sails environment\n            // setting (i.e. `sails.config.environment`).\n            //\n            // Note:\n            // Setting an environment var explicitly to \"undefined\" sets it to the\n            // *string* \"undefined\".  So we only bother setting it if it is truthy.\n            sails.log.verbose('Setting Node environment...');\n            if (mergedConfig.environment) {\n              // If we end up setting NODE_ENV, we first save the original value of NODE_ENV\n              // as `sails._originalNodeEnv`, so that we can potentially revert to it when\n              // lowering the app.  This way if a Sails app is loaded subsequently in the same\n              // process (e.g. tests), it does not end up using an unexpected environment due\n              // to NODE_ENV being set from previous lifts/loads. See the implementation of\n              // `.lower()` for further explanation.\n              sails._originalNodeEnv = process.env['NODE_ENV'];\n              // Note that we also set a flag indicating that we set the `NODE_ENV` at all.\n              // (we could just compare the current NODE_ENV with _originalNodeEnv in `.lower()`,\n              //  but it's not guaranteed to be accurate, since NODE_ENV could have been set again\n              //  for some reason at runtime; e.g. multiple test apps lifting/lowering/popping/locking)\n              sails._setNodeEnvAutomatically = true;\n              process.env['NODE_ENV'] = mergedConfig.environment;\n            }\n\n            cb(null, mergedConfig);\n          }\n        ]\n\n      },\n\n\n      function configLoaded(err, results) {\n        if (err) {\n          sails.log.error('Error encountered loading config ::\\n', err);\n          return cb(err);\n        }\n\n        // Override the previous contents of sails.config with the new, validated\n        // config w/ defaults and overrides mixed in the appropriate order.\n        sails.config = results.mixinDefaults;\n\n        cb();\n      });\n  };\n\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/bin/_commander.js":"/**\n * Module dependencies\n */\n\nvar _ = require('@sailshq/lodash');\nvar program = require('commander');\n\n\n//\n//\n// Monkey-patch commander\n//\n//\n\n// Allow us to display help(), but omit the wildcard (*) command.\nprogram.Command.prototype.usageMinusWildcard = program.usageMinusWildcard = function() {\n  program.commands = _.reject(program.commands, {\n    _name: '*'\n  });\n  program.help();\n};\n\n// Force commander to display version information.\nprogram.Command.prototype.versionInformation = program.versionInformation = function() {\n  program.emit('version');\n};\n\nmodule.exports = program;\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/bin/sails-console.js":"#!/usr/bin/env node\n\n\n/**\n * Module dependencies\n */\n\nvar nodepath = require('path');\nvar REPL = require('repl');\nvar fs = require('fs');\nvar _ = require('@sailshq/lodash');\nvar chalk = require('chalk');\nvar CaptainsLog = require('captains-log');\nvar Sails = require('../lib/app');\nvar rconf = require('../lib/app/configuration/rc');\nvar Err = require('../errors');\nvar package = require('../package.json');\n\n\n\n/**\n * `sails console`\n *\n * Enter the interactive console (aka REPL) for the app\n * in our working directory.  This is just like the default\n * Node REPL except that it starts with the Sails app in the\n * current directory lifted, and with console history enabled\n * (i.e. so you can press up arrow to browse and potentially\n *  replay commands from past runs)\n *\n * @stability 3\n * @see http://sailsjs.org/documentation/reference/command-line-interface/sails-console\n * ------------------------------------------------------------------------\n * This lifts the Sails app in the current working directory, then uses\n * the `repl` package to spin up an interactive console.\n *\n * Note that, if `--dontLift` was set, then `sails.load()` will be used\n * instead. (By default, the `sails console` cmd runs `sails.lift()`.)\n * ------------------------------------------------------------------------\n */\n\nmodule.exports = function() {\n\n  // Get a logger\n  var log = CaptainsLog(rconf.log);\n\n  // Build initial scope, mixing-in rc config\n  var scope = _.merge({\n    rootPath: process.cwd(),\n    sailsPackageJSON: package\n  }, rconf, {\n\n    // Disable ASCII ship to keep from dirtying things up\n    log: {\n      noShip: true\n    }\n  });\n\n  // Assume the current working directory to be the root of the app\n  var appPath = process.cwd();\n\n  // Determine whether to use the local or global Sails install.\n  var sailsApp = (function _determineAppropriateSailsAppInstance(){\n    // Use the app's local Sails in `node_modules` if it's extant and valid\n    var localSailsPath = nodepath.resolve(appPath, 'node_modules/sails');\n    if (Sails.isLocalSailsValid(localSailsPath, appPath)) {\n      return require(localSailsPath);\n    } else {\n      // Otherwise, if no workable local Sails exists, run the app\n      // using the currently running version of Sails.  This is\n      // probably always the global install.\n      log.info('No local Sails install detected; using globally-installed Sails.');\n      return Sails();\n    }\n  })();\n\n  console.log();\n  log.info(chalk.blue('Starting app in interactive mode...'));\n  console.log();\n\n\n  // Lift (or load) Sails\n  (function _ifThenFinally(done){\n    // If `--dontLift` was set, then use `.load()` instead.\n    if (!_.isUndefined(scope.dontLift)) {\n      sailsApp.load(scope, done);\n    }\n    // Otherwise, go with the default behavior (`.lift()`)\n    else {\n      sailsApp.lift(scope, done);\n    }\n  })(function afterwards(err){\n    if (err) {\n      return Err.fatal.failedToLoadSails(err);\n    }\n\n    log.info('Welcome to the Sails console.');\n    log.info(chalk.grey('( to exit, type ' + '<CTRL>+<C>' + ' )'));\n    console.log();\n\n    // Start a REPL\n    var repl = REPL.start({prompt: 'sails> ', useGlobal: true});\n    try {\n      history(repl, nodepath.join(sails.config.paths.tmp, '.node_history'));\n    } catch (e) {\n      log.verbose('Console history cannot be found.  Proceeding without it. This is due to error:', e);\n    }\n    repl.on('exit', function(err) {\n      if (err) {\n        log.error(err);\n        process.exit(1);\n      }\n      process.exit(0);\n    });\n\n  });//</_ifThenFinally()>\n};\n\n\n\n\n\n\n/**\n * REPL History\n * Pulled directly from https://github.com/tmpvar/repl.history\n * with the slight tweak of setting historyIndex to -1 so that\n * it works as expected.\n */\n\nfunction history(repl, file) {\n\n  try {\n    var stat = fs.statSync(file);\n    repl.rli.history = fs.readFileSync(file, 'utf-8').split('\\n').reverse();\n    repl.rli.history.shift();\n    repl.rli.historyIndex = -1;\n  } catch (e) {}\n\n  var fd = fs.openSync(file, 'a'),\n    reval = repl.eval;\n\n  repl.rli.addListener('line', function(code) {\n    if (code && code !== '.history') {\n      fs.write(fd, code + '\\n');\n    } else {\n      repl.rli.historyIndex++;\n      repl.rli.history.pop();\n    }\n  });\n\n  process.on('exit', function() {\n    fs.closeSync(fd);\n  });\n\n  repl.commands['.history'] = {\n    help: 'Show the history',\n    action: function() {\n      var out = [];\n      repl.rli.history.forEach(function(v, k) {\n        out.push(v);\n      });\n      repl.outputStream.write(out.reverse().join('\\n') + '\\n');\n      repl.displayPrompt();\n    }\n  };\n}\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/bin/sails-debug.js":"#!/usr/bin/env node\n\n\n/**\n * Module dependencies\n */\n\nvar path = require('path');\nvar Womb = require('child_process');\nvar CaptainsLog = require('captains-log');\nvar chalk = require('chalk');\nvar Sails = require('../lib/app');\n\n\n/**\n * `sails debug`\n *\n * Attach the Node debugger and lift a Sails app.\n * You can then use Node inspector to debug your app as it runs.\n *\n * @stability 2\n * @see http://sailsjs.org/documentation/reference/command-line-interface/sails-debug\n */\nmodule.exports = function() {\n  var log = CaptainsLog();\n\n  // Use the app's local Sails in `node_modules` if one exists\n  // But first make sure it'll work...\n  var appPath = process.cwd();\n  var pathToSails = path.resolve(appPath, '/node_modules/sails');\n  if (!Sails.isLocalSailsValid(pathToSails, appPath)) {\n    // otherwise, use the currently-running instance of Sails\n    pathToSails = path.resolve(__dirname, './sails.js');\n  }\n\n  console.log();\n  log.info('Running app in debug mode...');\n\n  // Check whether node-inspector is running\n  Womb.exec('ps', function(error, stdout, stderr) {\n\n    // If not, suggest that they run it\n    if (error || stderr || !stdout.toString().match(/node-inspector/)) {\n      log.info('You probably want to install / run node-inspector to help with debugging!');\n      log.info('https://github.com/node-inspector/node-inspector');\n      console.log();\n    }\n\n    log.info(chalk.grey('( to exit, type ' + '<CTRL>+<C>' + ' )'));\n    console.log();\n\n    // Spin up child process for Sails\n    Womb.spawn('node', ['--debug', pathToSails, 'lift'], {\n      stdio: 'inherit'\n    });\n  });\n\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/bin/sails-deploy.js":"#!/usr/bin/env node\n\n\n/**\n * Module dependencies\n */\n\nvar _ = require('@sailshq/lodash');\nvar util = require('util');\nvar path = require('path');\nvar rconf = require('../lib/app/configuration/rc');\n\n/**\n * `sails deploy`\n *\n * Deploy the Sails app in the current directory to a hosting provider.\n *\n * @stability 1\n */\n\nmodule.exports = function() {\n\n  var commands = rconf.commands;\n  var deploy = commands && commands.deploy;\n  var modulePath = deploy && deploy.module;\n  var module;\n\n  // If no module path was specified, bail out\n  if (!modulePath) {\n    console.error('No module specified for the `deploy` command.');\n    console.error('To use `sails deploy`, set a `commands.deploy.module` setting in your .sailsrc file');\n    return;\n  }\n\n  // Attempt to require the specified module from the project node_modules folder\n  try {\n    module = require(path.resolve(process.cwd(), 'node_modules', modulePath));\n  }\n\n  // If the module couldn't be required, bail out\n  catch (e) {\n    console.error('Could not require module at path: ' + modulePath + '.  Please check the path and try again.');\n  }\n\n  try {\n    // Attempt to run the deploy command\n    module({config: rconf}, function(err, result) {\n      // If there were any issues, log them to the console.\n      if (err) {\n        console.error('=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-');\n        console.error('Deployment failed!  Details below:');\n        console.error('=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-');\n        console.error(err);\n      }\n    });\n  }\n  // Chances are we won't catch any errors internal to the deploy command here;\n  // this would probably be an error at the top level of the deploy script.\n  catch(e) {\n    console.error('=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-');\n    console.error('Could not run deploy!  Details below:');\n    console.error('=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-');\n    console.error(e);\n  }\n\n\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/bin/sails-generate.js":"#!/usr/bin/env node\n\n\n/**\n * Module dependencies\n */\n\nvar _ = require('@sailshq/lodash');\nvar util = require('util');\nvar path = require('path');\nvar async = require('async');\nvar reportback = require('reportback')();\nvar sailsgen = require('sails-generate');\nvar package = require('../package.json');\nvar rconf = require('../lib/app/configuration/rc');\n\n\n/**\n * `sails generate`\n *\n * Generate one or more file(s) in our working directory.\n * This runs an appropriate generator.\n *\n * @stability 2\n * @see http://sailsjs.org/documentation/reference/command-line-interface/sails-generate\n */\n\nmodule.exports = function() {\n\n  // Build initial scope\n  var scope = {\n    rootPath: process.cwd(),\n    sailsRoot: path.resolve(__dirname, '..'),\n    modules: {},\n    sailsPackageJSON: package,\n  };\n\n  // Mix-in rc config\n  _.merge(scope, rconf.generators);\n\n  // TODO: just do a top-level merge and reference\n  // `scope.generators.modules` as needed (simpler)\n  _.merge(scope, rconf);\n\n\n  // Pass the original CLI arguments down to the generator\n  // (but first, remove commander's extra argument)\n  // (also peel off the `generatorType` arg)\n  var cliArguments = _.initial(arguments);\n  scope.generatorType = cliArguments.shift();\n  scope.args = cliArguments;\n\n  // Create a new reportback\n  var cb = reportback.extend();\n\n  // Show usage if no generator type is defined\n  if (!scope.generatorType) {\n    return cb.log.error('Usage: sails generate [something]');\n  }\n\n  // Set the \"invalid\" exit to forward to \"error\"\n  cb.error = function(msg) {\n    var log = this.log || cb.log;\n    log.error(msg);\n    process.exit(1);\n  };\n\n  cb.invalid = 'error';\n\n  cb.success = function() {\n\n    // Infer the `outputPath` if necessary/possible.\n    if (!scope.outputPath && scope.filename && scope.destDir) {\n      scope.outputPath = scope.destDir + scope.filename;\n    }\n\n    // Humanize the output path\n    var humanizedPath;\n    if (scope.outputPath) {\n      humanizedPath = ' at ' + scope.outputPath;\n    }\n    else if (scope.destDir) {\n      humanizedPath = ' in ' + scope.destDir;\n    }\n    else {\n      humanizedPath = '';\n    }\n\n    // Humanize the module identity\n    var humanizedId;\n    if (scope.id) {\n      humanizedId = util.format(' (\"%s\")',scope.id);\n    }\n    else humanizedId = '';\n\n    if (scope.generatorType != 'new') {\n\n      cb.log.info(util.format(\n        'Created a new %s%s%s!',\n        scope.generatorType, humanizedId, humanizedPath\n      ));\n\n    }\n\n  };\n\n  return sailsgen(scope, cb);\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails-generate/lib/index.js":"/**\n * Module dependencies\n */\n\nvar generate = require('./generate');\nvar path = require('path');\nvar reportback = require('reportback')();\n\n\n\n/**\n * Generate module(s)\n *\n * @param  {Object}   scope [description]\n * @param  {Function} cb    [description]\n * @return {[type]}         [description]\n */\nmodule.exports = function(scope, cb) {\n  cb = cb || {};\n  cb = reportback.extend(cb, {\n    error: cb.error,\n    invalid: cb.invalid,\n    success: function(output) {\n      cb.log.info('ok!');\n    },\n    notSailsApp: function() {\n      cb.log.error('Not a sails app.');\n    },\n    alreadyExists: function() {\n      return cb.error();\n    }\n  });\n\n  if (!scope.generatorType) {\n    return cb.error('Sorry, `scope.generatorType` must be defined.');\n  }\n\n  // Use configured module name for this generatorType if applicable.\n  var module =\n    (scope.modules && scope.modules[scope.generatorType]) ||\n    'sails-generate-' + scope.generatorType;\n\n  var Generator;\n  var requirePath;\n  var requireError;\n\n  function throwIfModuleNotFoundError (e, module) {\n    var isModuleNotFoundError = e && e.code === 'MODULE_NOT_FOUND' && e.message.match(new RegExp(module));\n    if (!isModuleNotFoundError) {\n      cb.log.error('Error in \"'+scope.generatorType+'\" generator (loaded from '+module+')');\n      throw e;\n    }\n    else return e;\n  }\n\n\n  // Allow `scope.generator` to be specified as an inline generator\n  // ... todo ...\n\n  // Try requiring from node_modules\n  try {\n    Generator = require(module);\n  } catch (e) {\n    requireError = throwIfModuleNotFoundError(e, module);\n  }\n\n  // Try requiring it directly as a path resolved from process.cwd()\n  if (!Generator) {\n    try {\n      requirePath = path.resolve(process.cwd(), module);\n      Generator = require(requirePath);\n    } catch (e) {\n      requireError = throwIfModuleNotFoundError(e, module);\n    }\n  }\n\n\n  // Try requiring the generator from the rootPath\n  if (!Generator) {\n    try {\n      requirePath = path.resolve(scope.rootPath, 'node_modules', module);\n      Generator = require(requirePath);\n    } catch (e) {\n      requireError = throwIfModuleNotFoundError(e, module);\n    }\n  }\n\n  // If that doesn't work, try `require()`ing it from console user's cwd\n  if (!Generator) {\n    try {\n      requirePath = path.resolve(process.cwd(), 'node_modules', module);\n      Generator = require(requirePath);\n    } catch (e) {\n      requireError = throwIfModuleNotFoundError(e, module);\n    }\n  }\n\n  // Finally, try to load the generator module from sails-generate's dependencies\n  if (!Generator) {\n    try {\n      Generator = require(path.resolve(scope.rootPath || process.cwd(), module));\n    } catch (e) {\n      requireError = throwIfModuleNotFoundError(e, module);\n    }\n  }\n\n\n  if (!Generator) {\n    return cb.log.error(\"No generator called `\" + scope.generatorType + \"` found; perhaps you meant `sails generate api \" + scope.generatorType + \"`?\");\n  }\n\n  generate(Generator, scope, cb);\n\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails-generate/lib/generate.js":"/**\n * Module dependencies\n */\n\nvar util = require('util');\nvar _ = require('lodash');\n_.defaults = require('merge-defaults');\nvar async = require('async');\nvar path = require('path');\nvar reportback = require('reportback')();\nvar pathRegexp = require('./util').pathRegexp;\nvar rootGenerator = require('./rootGenerator');\nvar rootScope = require('./rootScope');\nvar generateTarget = require('./target');\n\n\n\n/**\n * Run a generator given an existing scope.\n *\n * @param  {Object} Generator\n * @param  {Object} scope\n * @param  {Switchback} cb\n */\n\nfunction generate(Generator, scope, cb) {\n\n  var sb = reportback.extend(cb, {\n    error: cb.error,\n    invalid: cb.invalid,\n    alreadyExists: 'error'\n  });\n\n  // Merge with root scope\n  _.defaults(scope, rootScope);\n\n  // TODO: validate args more thoroughly\n  if (!_.isArray(scope.args)) {\n    return sb(new Error('Invalid `scope.args` passed to generator: ' + util.inspect(scope.args)));\n  }\n\n  // Ensure that `rootPath` exists\n  // TODO: Ensure that `rootPath` is reasonable\n  // (i.e. within highest acceptable path-- prevents accidental smashing of file-system, etc.)\n  if (!scope.rootPath) {\n    return sb(new Error('Invalid `scope.rootPath` passed to generator: ' + util.inspect(scope.rootPath)));\n  }\n\n  // TODO: deprecate this:\n  //\n  // Alias first handful of arguments on scope object\n  // for easy access and use as :params in `targets` keys\n  // _.defaults(scope, {\n  // \targ0: scope.args[0],\n  // \targ1: scope.args[1],\n  // \targ2: scope.args[2],\n  // \targ3: scope.args[3]\n  // });\n\n  // Resolve string shorthand for generator defs\n  // to `{ generator: 'originalDef' }`\n  if (typeof Generator === 'string') {\n    var generatorName = Generator;\n    Generator = {\n      generator: generatorName\n    };\n  }\n\n  // Merge with root generator\n  _.defaults(Generator, rootGenerator);\n\n  // Run the generator's `before()` method proceeding\n  Generator.before(scope, reportback.extend({\n    error: sb.error,\n    invalid: sb.invalid,\n    success: function() {\n\n      // Emit output\n      sb.log.verbose('Generating ' + util.inspect(Generator) + ' at ' + scope.rootPath + '...');\n\n      // Process all of the generator's targets concurrently\n      async.each(Object.keys(Generator.targets), function(keyPath, async_each_cb) {\n          var async_each_sb = reportback.extend(async_each_cb);\n\n\n          // Create a new scope object for this target,\n          // with references to the important bits of the original.\n          // (depth will be passed-by-value, but that's what we want)\n          //\n          // Then generate the target, passing along a reference to\n          // the base `generate` method to allow for recursive generators.\n          var target = Generator.targets[keyPath];\n          if (!target) return async_each_sb(new Error('Generator error: Invalid target: {\"' + keyPath + '\": ' + util.inspect(target) + '}'));\n\n          // Input tolerance\n          if (keyPath === '') keyPath = '.';\n\n          // Interpret `keyPath` using express's parameterized route conventions,\n          // first parsing params, then replacing them with their proper values from scope.\n          var params = [];\n          pathRegexp(keyPath, params);\n          var err;\n          var parsedKeyPath = _.reduce(params, function(memoKeyPath, param, i) {\n            if (err) return false;\n\n            try {\n              var paramMatchExpr = ':' + param.name;\n              var actualParamValue = scope[param.name];\n              if (!actualParamValue) {\n                err = new Error(\n                  'Generator error:\\n' +\n                  'A scope variable (`' + param.name + '`) was referenced in target: `' + memoKeyPath + '`,\\n' +\n                  'but `' + param.name + '` does not exist in the generator\\'s scope.'\n                );\n                return false;\n              }\n              actualParamValue = String(actualParamValue);\n\n              return memoKeyPath.replace(paramMatchExpr, actualParamValue);\n            } catch (e) {\n              err = new Error('Generator error: Could not parse target key: ' + memoKeyPath);\n              err.message = e;\n              return false;\n            }\n          }, keyPath);\n          if (!parsedKeyPath) return async_each_sb(err);\n\n          // Create path from `rootPath` to `keyPath` to use as the `rootPath`\n          // for any generators or helpers in this target.\n          // (use a copy so that child generators don't mutate the scope)\n          var targetScope = _.merge({}, scope, {\n            rootPath: path.resolve(scope.rootPath, parsedKeyPath),\n            // Include reference to original keypath for error reporting\n            keyPath: keyPath\n          });\n\n\n\n          // If `target` is an array, run each item\n          if (_.isArray(target)) {\n            async.eachSeries(target, function(targetItem, async_eachSeries_cb) {\n\n              generateTarget({\n                target: targetItem,\n                parent: Generator,\n                scope: _.cloneDeep(targetScope),\n                recursiveGenerate: generate\n              }, async_eachSeries_cb);\n\n            }, async_each_sb);\n            return;\n          }\n\n          // Otherwise, just run the single target generator/helper\n          generateTarget({\n            target: target,\n            parent: Generator,\n            scope: targetScope,\n            recursiveGenerate: generate\n          }, async_each_sb);\n\n        }, // </async.each.iterator>\n\n        function done(err) {\n\n          // Expose a `error` handler in generators\n          if (err) {\n            var errorFn = Generator.error || function defaultError(err, scope, _cb) {\n                return _cb(err);\n              };\n            return errorFn(err, scope, sb);\n          }\n\n          // Expose a `after` handler in generators (on success only)\n          var afterFn = Generator.after || function defaultAfter(scope, _cb) {\n              return _cb();\n            };\n          return afterFn(scope, sb);\n\n        }); // </async.each>\n\n    } // </Generator.before -> success>\n  })); // </Generator.before>\n}\n\n\nmodule.exports = generate;\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails-generate/node_modules/lodash/dist/lodash.js":"/**\n * @license\n * Lo-Dash 2.4.2 (Custom Build) <https://lodash.com/>\n * Build: `lodash modern -o ./dist/lodash.js`\n * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <https://lodash.com/license>\n */\n;(function() {\n\n  /** Used as a safe reference for `undefined` in pre ES5 environments */\n  var undefined;\n\n  /** Used to pool arrays and objects used internally */\n  var arrayPool = [],\n      objectPool = [];\n\n  /** Used to generate unique IDs */\n  var idCounter = 0;\n\n  /** Used to prefix keys to avoid issues with `__proto__` and properties on `Object.prototype` */\n  var keyPrefix = +new Date + '';\n\n  /** Used as the size when optimizations are enabled for large arrays */\n  var largeArraySize = 75;\n\n  /** Used as the max size of the `arrayPool` and `objectPool` */\n  var maxPoolSize = 40;\n\n  /** Used to detect and test whitespace */\n  var whitespace = (\n    // whitespace\n    ' \\t\\x0B\\f\\xA0\\ufeff' +\n\n    // line terminators\n    '\\n\\r\\u2028\\u2029' +\n\n    // unicode category \"Zs\" space separators\n    '\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000'\n  );\n\n  /** Used to match empty string literals in compiled template source */\n  var reEmptyStringLeading = /\\b__p \\+= '';/g,\n      reEmptyStringMiddle = /\\b(__p \\+=) '' \\+/g,\n      reEmptyStringTrailing = /(__e\\(.*?\\)|\\b__t\\)) \\+\\n'';/g;\n\n  /**\n   * Used to match ES6 template delimiters\n   * http://people.mozilla.org/~jorendorff/es6-draft.html#sec-literals-string-literals\n   */\n  var reEsTemplate = /\\$\\{([^\\\\}]*(?:\\\\.[^\\\\}]*)*)\\}/g;\n\n  /** Used to match regexp flags from their coerced string values */\n  var reFlags = /\\w*$/;\n\n  /** Used to detected named functions */\n  var reFuncName = /^\\s*function[ \\n\\r\\t]+\\w/;\n\n  /** Used to match \"interpolate\" template delimiters */\n  var reInterpolate = /<%=([\\s\\S]+?)%>/g;\n\n  /** Used to match leading whitespace and zeros to be removed */\n  var reLeadingSpacesAndZeros = RegExp('^[' + whitespace + ']*0+(?=.$)');\n\n  /** Used to ensure capturing order of template delimiters */\n  var reNoMatch = /($^)/;\n\n  /** Used to detect functions containing a `this` reference */\n  var reThis = /\\bthis\\b/;\n\n  /** Used to match unescaped characters in compiled string literals */\n  var reUnescapedString = /['\\n\\r\\t\\u2028\\u2029\\\\]/g;\n\n  /** Used to assign default `context` object properties */\n  var contextProps = [\n    'Array', 'Boolean', 'Date', 'Function', 'Math', 'Number', 'Object',\n    'RegExp', 'String', '_', 'attachEvent', 'clearTimeout', 'isFinite', 'isNaN',\n    'parseInt', 'setTimeout'\n  ];\n\n  /** Used to make template sourceURLs easier to identify */\n  var templateCounter = 0;\n\n  /** `Object#toString` result shortcuts */\n  var argsClass = '[object Arguments]',\n      arrayClass = '[object Array]',\n      boolClass = '[object Boolean]',\n      dateClass = '[object Date]',\n      funcClass = '[object Function]',\n      numberClass = '[object Number]',\n      objectClass = '[object Object]',\n      regexpClass = '[object RegExp]',\n      stringClass = '[object String]';\n\n  /** Used to identify object classifications that `_.clone` supports */\n  var cloneableClasses = {};\n  cloneableClasses[funcClass] = false;\n  cloneableClasses[argsClass] = cloneableClasses[arrayClass] =\n  cloneableClasses[boolClass] = cloneableClasses[dateClass] =\n  cloneableClasses[numberClass] = cloneableClasses[objectClass] =\n  cloneableClasses[regexpClass] = cloneableClasses[stringClass] = true;\n\n  /** Used as an internal `_.debounce` options object */\n  var debounceOptions = {\n    'leading': false,\n    'maxWait': 0,\n    'trailing': false\n  };\n\n  /** Used as the property descriptor for `__bindData__` */\n  var descriptor = {\n    'configurable': false,\n    'enumerable': false,\n    'value': null,\n    'writable': false\n  };\n\n  /** Used to determine if values are of the language type Object */\n  var objectTypes = {\n    'boolean': false,\n    'function': true,\n    'object': true,\n    'number': false,\n    'string': false,\n    'undefined': false\n  };\n\n  /** Used to escape characters for inclusion in compiled string literals */\n  var stringEscapes = {\n    '\\\\': '\\\\',\n    \"'\": \"'\",\n    '\\n': 'n',\n    '\\r': 'r',\n    '\\t': 't',\n    '\\u2028': 'u2028',\n    '\\u2029': 'u2029'\n  };\n\n  /** Used as a reference to the global object */\n  var root = (objectTypes[typeof window] && window) || this;\n\n  /** Detect free variable `exports` */\n  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;\n\n  /** Detect free variable `module` */\n  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;\n\n  /** Detect the popular CommonJS extension `module.exports` */\n  var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;\n\n  /** Detect free variable `global` from Node.js or Browserified code and use it as `root` */\n  var freeGlobal = objectTypes[typeof global] && global;\n  if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {\n    root = freeGlobal;\n  }\n\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * The base implementation of `_.indexOf` without support for binary searches\n   * or `fromIndex` constraints.\n   *\n   * @private\n   * @param {Array} array The array to search.\n   * @param {*} value The value to search for.\n   * @param {number} [fromIndex=0] The index to search from.\n   * @returns {number} Returns the index of the matched value or `-1`.\n   */\n  function baseIndexOf(array, value, fromIndex) {\n    var index = (fromIndex || 0) - 1,\n        length = array ? array.length : 0;\n\n    while (++index < length) {\n      if (array[index] === value) {\n        return index;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * An implementation of `_.contains` for cache objects that mimics the return\n   * signature of `_.indexOf` by returning `0` if the value is found, else `-1`.\n   *\n   * @private\n   * @param {Object} cache The cache object to inspect.\n   * @param {*} value The value to search for.\n   * @returns {number} Returns `0` if `value` is found, else `-1`.\n   */\n  function cacheIndexOf(cache, value) {\n    var type = typeof value;\n    cache = cache.cache;\n\n    if (type == 'boolean' || value == null) {\n      return cache[value] ? 0 : -1;\n    }\n    if (type != 'number' && type != 'string') {\n      type = 'object';\n    }\n    var key = type == 'number' ? value : keyPrefix + value;\n    cache = (cache = cache[type]) && cache[key];\n\n    return type == 'object'\n      ? (cache && baseIndexOf(cache, value) > -1 ? 0 : -1)\n      : (cache ? 0 : -1);\n  }\n\n  /**\n   * Adds a given value to the corresponding cache object.\n   *\n   * @private\n   * @param {*} value The value to add to the cache.\n   */\n  function cachePush(value) {\n    var cache = this.cache,\n        type = typeof value;\n\n    if (type == 'boolean' || value == null) {\n      cache[value] = true;\n    } else {\n      if (type != 'number' && type != 'string') {\n        type = 'object';\n      }\n      var key = type == 'number' ? value : keyPrefix + value,\n          typeCache = cache[type] || (cache[type] = {});\n\n      if (type == 'object') {\n        (typeCache[key] || (typeCache[key] = [])).push(value);\n      } else {\n        typeCache[key] = true;\n      }\n    }\n  }\n\n  /**\n   * Used by `_.max` and `_.min` as the default callback when a given\n   * collection is a string value.\n   *\n   * @private\n   * @param {string} value The character to inspect.\n   * @returns {number} Returns the code unit of given character.\n   */\n  function charAtCallback(value) {\n    return value.charCodeAt(0);\n  }\n\n  /**\n   * Used by `sortBy` to compare transformed `collection` elements, stable sorting\n   * them in ascending order.\n   *\n   * @private\n   * @param {Object} a The object to compare to `b`.\n   * @param {Object} b The object to compare to `a`.\n   * @returns {number} Returns the sort order indicator of `1` or `-1`.\n   */\n  function compareAscending(a, b) {\n    var ac = a.criteria,\n        bc = b.criteria,\n        index = -1,\n        length = ac.length;\n\n    while (++index < length) {\n      var value = ac[index],\n          other = bc[index];\n\n      if (value !== other) {\n        if (value > other || typeof value == 'undefined') {\n          return 1;\n        }\n        if (value < other || typeof other == 'undefined') {\n          return -1;\n        }\n      }\n    }\n    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications\n    // that causes it, under certain circumstances, to return the same value for\n    // `a` and `b`. See https://github.com/jashkenas/underscore/pull/1247\n    //\n    // This also ensures a stable sort in V8 and other engines.\n    // See http://code.google.com/p/v8/issues/detail?id=90\n    return a.index - b.index;\n  }\n\n  /**\n   * Creates a cache object to optimize linear searches of large arrays.\n   *\n   * @private\n   * @param {Array} [array=[]] The array to search.\n   * @returns {null|Object} Returns the cache object or `null` if caching should not be used.\n   */\n  function createCache(array) {\n    var index = -1,\n        length = array.length,\n        first = array[0],\n        mid = array[(length / 2) | 0],\n        last = array[length - 1];\n\n    if (first && typeof first == 'object' &&\n        mid && typeof mid == 'object' && last && typeof last == 'object') {\n      return false;\n    }\n    var cache = getObject();\n    cache['false'] = cache['null'] = cache['true'] = cache['undefined'] = false;\n\n    var result = getObject();\n    result.array = array;\n    result.cache = cache;\n    result.push = cachePush;\n\n    while (++index < length) {\n      result.push(array[index]);\n    }\n    return result;\n  }\n\n  /**\n   * Used by `template` to escape characters for inclusion in compiled\n   * string literals.\n   *\n   * @private\n   * @param {string} match The matched character to escape.\n   * @returns {string} Returns the escaped character.\n   */\n  function escapeStringChar(match) {\n    return '\\\\' + stringEscapes[match];\n  }\n\n  /**\n   * Gets an array from the array pool or creates a new one if the pool is empty.\n   *\n   * @private\n   * @returns {Array} The array from the pool.\n   */\n  function getArray() {\n    return arrayPool.pop() || [];\n  }\n\n  /**\n   * Gets an object from the object pool or creates a new one if the pool is empty.\n   *\n   * @private\n   * @returns {Object} The object from the pool.\n   */\n  function getObject() {\n    return objectPool.pop() || {\n      'array': null,\n      'cache': null,\n      'criteria': null,\n      'false': false,\n      'index': 0,\n      'null': false,\n      'number': null,\n      'object': null,\n      'push': null,\n      'string': null,\n      'true': false,\n      'undefined': false,\n      'value': null\n    };\n  }\n\n  /**\n   * Releases the given array back to the array pool.\n   *\n   * @private\n   * @param {Array} [array] The array to release.\n   */\n  function releaseArray(array) {\n    array.length = 0;\n    if (arrayPool.length < maxPoolSize) {\n      arrayPool.push(array);\n    }\n  }\n\n  /**\n   * Releases the given object back to the object pool.\n   *\n   * @private\n   * @param {Object} [object] The object to release.\n   */\n  function releaseObject(object) {\n    var cache = object.cache;\n    if (cache) {\n      releaseObject(cache);\n    }\n    object.array = object.cache = object.criteria = object.object = object.number = object.string = object.value = null;\n    if (objectPool.length < maxPoolSize) {\n      objectPool.push(object);\n    }\n  }\n\n  /**\n   * Slices the `collection` from the `start` index up to, but not including,\n   * the `end` index.\n   *\n   * Note: This function is used instead of `Array#slice` to support node lists\n   * in IE < 9 and to ensure dense arrays are returned.\n   *\n   * @private\n   * @param {Array|Object|string} collection The collection to slice.\n   * @param {number} start The start index.\n   * @param {number} end The end index.\n   * @returns {Array} Returns the new array.\n   */\n  function slice(array, start, end) {\n    start || (start = 0);\n    if (typeof end == 'undefined') {\n      end = array ? array.length : 0;\n    }\n    var index = -1,\n        length = end - start || 0,\n        result = Array(length < 0 ? 0 : length);\n\n    while (++index < length) {\n      result[index] = array[start + index];\n    }\n    return result;\n  }\n\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * Create a new `lodash` function using the given context object.\n   *\n   * @static\n   * @memberOf _\n   * @category Utilities\n   * @param {Object} [context=root] The context object.\n   * @returns {Function} Returns the `lodash` function.\n   */\n  function runInContext(context) {\n    // Avoid issues with some ES3 environments that attempt to use values, named\n    // after built-in constructors like `Object`, for the creation of literals.\n    // ES5 clears this up by stating that literals must use built-in constructors.\n    // See http://es5.github.io/#x11.1.5.\n    context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;\n\n    /** Native constructor references */\n    var Array = context.Array,\n        Boolean = context.Boolean,\n        Date = context.Date,\n        Function = context.Function,\n        Math = context.Math,\n        Number = context.Number,\n        Object = context.Object,\n        RegExp = context.RegExp,\n        String = context.String,\n        TypeError = context.TypeError;\n\n    /**\n     * Used for `Array` method references.\n     *\n     * Normally `Array.prototype` would suffice, however, using an array literal\n     * avoids issues in Narwhal.\n     */\n    var arrayRef = [];\n\n    /** Used for native method references */\n    var objectProto = Object.prototype;\n\n    /** Used to restore the original `_` reference in `noConflict` */\n    var oldDash = context._;\n\n    /** Used to resolve the internal [[Class]] of values */\n    var toString = objectProto.toString;\n\n    /** Used to detect if a method is native */\n    var reNative = RegExp('^' +\n      String(toString)\n        .replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')\n        .replace(/toString| for [^\\]]+/g, '.*?') + '$'\n    );\n\n    /** Native method shortcuts */\n    var ceil = Math.ceil,\n        clearTimeout = context.clearTimeout,\n        floor = Math.floor,\n        fnToString = Function.prototype.toString,\n        getPrototypeOf = isNative(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf,\n        hasOwnProperty = objectProto.hasOwnProperty,\n        push = arrayRef.push,\n        setTimeout = context.setTimeout,\n        splice = arrayRef.splice,\n        unshift = arrayRef.unshift;\n\n    /** Used to set meta data on functions */\n    var defineProperty = (function() {\n      // IE 8 only accepts DOM elements\n      try {\n        var o = {},\n            func = isNative(func = Object.defineProperty) && func,\n            result = func(o, o, o) && func;\n      } catch(e) { }\n      return result;\n    }());\n\n    /* Native method shortcuts for methods with the same name as other `lodash` methods */\n    var nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate,\n        nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray,\n        nativeIsFinite = context.isFinite,\n        nativeIsNaN = context.isNaN,\n        nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys,\n        nativeMax = Math.max,\n        nativeMin = Math.min,\n        nativeParseInt = context.parseInt,\n        nativeRandom = Math.random;\n\n    /** Used to lookup a built-in constructor by [[Class]] */\n    var ctorByClass = {};\n    ctorByClass[arrayClass] = Array;\n    ctorByClass[boolClass] = Boolean;\n    ctorByClass[dateClass] = Date;\n    ctorByClass[funcClass] = Function;\n    ctorByClass[objectClass] = Object;\n    ctorByClass[numberClass] = Number;\n    ctorByClass[regexpClass] = RegExp;\n    ctorByClass[stringClass] = String;\n\n    /*--------------------------------------------------------------------------*/\n\n    /**\n     * Creates a `lodash` object which wraps the given value to enable intuitive\n     * method chaining.\n     *\n     * In addition to Lo-Dash methods, wrappers also have the following `Array` methods:\n     * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`, `splice`,\n     * and `unshift`\n     *\n     * Chaining is supported in custom builds as long as the `value` method is\n     * implicitly or explicitly included in the build.\n     *\n     * The chainable wrapper functions are:\n     * `after`, `assign`, `bind`, `bindAll`, `bindKey`, `chain`, `compact`,\n     * `compose`, `concat`, `countBy`, `create`, `createCallback`, `curry`,\n     * `debounce`, `defaults`, `defer`, `delay`, `difference`, `filter`, `flatten`,\n     * `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`,\n     * `functions`, `groupBy`, `indexBy`, `initial`, `intersection`, `invert`,\n     * `invoke`, `keys`, `map`, `max`, `memoize`, `merge`, `min`, `object`, `omit`,\n     * `once`, `pairs`, `partial`, `partialRight`, `pick`, `pluck`, `pull`, `push`,\n     * `range`, `reject`, `remove`, `rest`, `reverse`, `shuffle`, `slice`, `sort`,\n     * `sortBy`, `splice`, `tap`, `throttle`, `times`, `toArray`, `transform`,\n     * `union`, `uniq`, `unshift`, `unzip`, `values`, `where`, `without`, `wrap`,\n     * and `zip`\n     *\n     * The non-chainable wrapper functions are:\n     * `clone`, `cloneDeep`, `contains`, `escape`, `every`, `find`, `findIndex`,\n     * `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `has`, `identity`,\n     * `indexOf`, `isArguments`, `isArray`, `isBoolean`, `isDate`, `isElement`,\n     * `isEmpty`, `isEqual`, `isFinite`, `isFunction`, `isNaN`, `isNull`, `isNumber`,\n     * `isObject`, `isPlainObject`, `isRegExp`, `isString`, `isUndefined`, `join`,\n     * `lastIndexOf`, `mixin`, `noConflict`, `parseInt`, `pop`, `random`, `reduce`,\n     * `reduceRight`, `result`, `shift`, `size`, `some`, `sortedIndex`, `runInContext`,\n     * `template`, `unescape`, `uniqueId`, and `value`\n     *\n     * The wrapper functions `first` and `last` return wrapped values when `n` is\n     * provided, otherwise they return unwrapped values.\n     *\n     * Explicit chaining can be enabled by using the `_.chain` method.\n     *\n     * @name _\n     * @constructor\n     * @category Chaining\n     * @param {*} value The value to wrap in a `lodash` instance.\n     * @returns {Object} Returns a `lodash` instance.\n     * @example\n     *\n     * var wrapped = _([1, 2, 3]);\n     *\n     * // returns an unwrapped value\n     * wrapped.reduce(function(sum, num) {\n     *   return sum + num;\n     * });\n     * // => 6\n     *\n     * // returns a wrapped value\n     * var squares = wrapped.map(function(num) {\n     *   return num * num;\n     * });\n     *\n     * _.isArray(squares);\n     * // => false\n     *\n     * _.isArray(squares.value());\n     * // => true\n     */\n    function lodash(value) {\n      // don't wrap if already wrapped, even if wrapped by a different `lodash` constructor\n      return (value && typeof value == 'object' && !isArray(value) && hasOwnProperty.call(value, '__wrapped__'))\n       ? value\n       : new lodashWrapper(value);\n    }\n\n    /**\n     * A fast path for creating `lodash` wrapper objects.\n     *\n     * @private\n     * @param {*} value The value to wrap in a `lodash` instance.\n     * @param {boolean} chainAll A flag to enable chaining for all methods\n     * @returns {Object} Returns a `lodash` instance.\n     */\n    function lodashWrapper(value, chainAll) {\n      this.__chain__ = !!chainAll;\n      this.__wrapped__ = value;\n    }\n    // ensure `new lodashWrapper` is an instance of `lodash`\n    lodashWrapper.prototype = lodash.prototype;\n\n    /**\n     * An object used to flag environments features.\n     *\n     * @static\n     * @memberOf _\n     * @type Object\n     */\n    var support = lodash.support = {};\n\n    /**\n     * Detect if functions can be decompiled by `Function#toString`\n     * (all but PS3 and older Opera mobile browsers & avoided in Windows 8 apps).\n     *\n     * @memberOf _.support\n     * @type boolean\n     */\n    support.funcDecomp = !isNative(context.WinRTError) && reThis.test(runInContext);\n\n    /**\n     * Detect if `Function#name` is supported (all but IE).\n     *\n     * @memberOf _.support\n     * @type boolean\n     */\n    support.funcNames = typeof Function.name == 'string';\n\n    /**\n     * By default, the template delimiters used by Lo-Dash are similar to those in\n     * embedded Ruby (ERB). Change the following template settings to use alternative\n     * delimiters.\n     *\n     * @static\n     * @memberOf _\n     * @type Object\n     */\n    lodash.templateSettings = {\n\n      /**\n       * Used to detect `data` property values to be HTML-escaped.\n       *\n       * @memberOf _.templateSettings\n       * @type RegExp\n       */\n      'escape': /<%-([\\s\\S]+?)%>/g,\n\n      /**\n       * Used to detect code to be evaluated.\n       *\n       * @memberOf _.templateSettings\n       * @type RegExp\n       */\n      'evaluate': /<%([\\s\\S]+?)%>/g,\n\n      /**\n       * Used to detect `data` property values to inject.\n       *\n       * @memberOf _.templateSettings\n       * @type RegExp\n       */\n      'interpolate': reInterpolate,\n\n      /**\n       * Used to reference the data object in the template text.\n       *\n       * @memberOf _.templateSettings\n       * @type string\n       */\n      'variable': '',\n\n      /**\n       * Used to import variables into the compiled template.\n       *\n       * @memberOf _.templateSettings\n       * @type Object\n       */\n      'imports': {\n\n        /**\n         * A reference to the `lodash` function.\n         *\n         * @memberOf _.templateSettings.imports\n         * @type Function\n         */\n        '_': lodash\n      }\n    };\n\n    /*--------------------------------------------------------------------------*/\n\n    /**\n     * The base implementation of `_.bind` that creates the bound function and\n     * sets its meta data.\n     *\n     * @private\n     * @param {Array} bindData The bind data array.\n     * @returns {Function} Returns the new bound function.\n     */\n    function baseBind(bindData) {\n      var func = bindData[0],\n          partialArgs = bindData[2],\n          thisArg = bindData[4];\n\n      function bound() {\n        // `Function#bind` spec\n        // http://es5.github.io/#x15.3.4.5\n        if (partialArgs) {\n          // avoid `arguments` object deoptimizations by using `slice` instead\n          // of `Array.prototype.slice.call` and not assigning `arguments` to a\n          // variable as a ternary expression\n          var args = slice(partialArgs);\n          push.apply(args, arguments);\n        }\n        // mimic the constructor's `return` behavior\n        // http://es5.github.io/#x13.2.2\n        if (this instanceof bound) {\n          // ensure `new bound` is an instance of `func`\n          var thisBinding = baseCreate(func.prototype),\n              result = func.apply(thisBinding, args || arguments);\n          return isObject(result) ? result : thisBinding;\n        }\n        return func.apply(thisArg, args || arguments);\n      }\n      setBindData(bound, bindData);\n      return bound;\n    }\n\n    /**\n     * The base implementation of `_.clone` without argument juggling or support\n     * for `thisArg` binding.\n     *\n     * @private\n     * @param {*} value The value to clone.\n     * @param {boolean} [isDeep=false] Specify a deep clone.\n     * @param {Function} [callback] The function to customize cloning values.\n     * @param {Array} [stackA=[]] Tracks traversed source objects.\n     * @param {Array} [stackB=[]] Associates clones with source counterparts.\n     * @returns {*} Returns the cloned value.\n     */\n    function baseClone(value, isDeep, callback, stackA, stackB) {\n      if (callback) {\n        var result = callback(value);\n        if (typeof result != 'undefined') {\n          return result;\n        }\n      }\n      // inspect [[Class]]\n      var isObj = isObject(value);\n      if (isObj) {\n        var className = toString.call(value);\n        if (!cloneableClasses[className]) {\n          return value;\n        }\n        var ctor = ctorByClass[className];\n        switch (className) {\n          case boolClass:\n          case dateClass:\n            return new ctor(+value);\n\n          case numberClass:\n          case stringClass:\n            return new ctor(value);\n\n          case regexpClass:\n            result = ctor(value.source, reFlags.exec(value));\n            result.lastIndex = value.lastIndex;\n            return result;\n        }\n      } else {\n        return value;\n      }\n      var isArr = isArray(value);\n      if (isDeep) {\n        // check for circular references and return corresponding clone\n        var initedStack = !stackA;\n        stackA || (stackA = getArray());\n        stackB || (stackB = getArray());\n\n        var length = stackA.length;\n        while (length--) {\n          if (stackA[length] == value) {\n            return stackB[length];\n          }\n        }\n        result = isArr ? ctor(value.length) : {};\n      }\n      else {\n        result = isArr ? slice(value) : assign({}, value);\n      }\n      // add array properties assigned by `RegExp#exec`\n      if (isArr) {\n        if (hasOwnProperty.call(value, 'index')) {\n          result.index = value.index;\n        }\n        if (hasOwnProperty.call(value, 'input')) {\n          result.input = value.input;\n        }\n      }\n      // exit for shallow clone\n      if (!isDeep) {\n        return result;\n      }\n      // add the source value to the stack of traversed objects\n      // and associate it with its clone\n      stackA.push(value);\n      stackB.push(result);\n\n      // recursively populate clone (susceptible to call stack limits)\n      (isArr ? forEach : forOwn)(value, function(objValue, key) {\n        result[key] = baseClone(objValue, isDeep, callback, stackA, stackB);\n      });\n\n      if (initedStack) {\n        releaseArray(stackA);\n        releaseArray(stackB);\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.create` without support for assigning\n     * properties to the created object.\n     *\n     * @private\n     * @param {Object} prototype The object to inherit from.\n     * @returns {Object} Returns the new object.\n     */\n    function baseCreate(prototype, properties) {\n      return isObject(prototype) ? nativeCreate(prototype) : {};\n    }\n    // fallback for browsers without `Object.create`\n    if (!nativeCreate) {\n      baseCreate = (function() {\n        function Object() {}\n        return function(prototype) {\n          if (isObject(prototype)) {\n            Object.prototype = prototype;\n            var result = new Object;\n            Object.prototype = null;\n          }\n          return result || context.Object();\n        };\n      }());\n    }\n\n    /**\n     * The base implementation of `_.createCallback` without support for creating\n     * \"_.pluck\" or \"_.where\" style callbacks.\n     *\n     * @private\n     * @param {*} [func=identity] The value to convert to a callback.\n     * @param {*} [thisArg] The `this` binding of the created callback.\n     * @param {number} [argCount] The number of arguments the callback accepts.\n     * @returns {Function} Returns a callback function.\n     */\n    function baseCreateCallback(func, thisArg, argCount) {\n      if (typeof func != 'function') {\n        return identity;\n      }\n      // exit early for no `thisArg` or already bound by `Function#bind`\n      if (typeof thisArg == 'undefined' || !('prototype' in func)) {\n        return func;\n      }\n      var bindData = func.__bindData__;\n      if (typeof bindData == 'undefined') {\n        if (support.funcNames) {\n          bindData = !func.name;\n        }\n        bindData = bindData || !support.funcDecomp;\n        if (!bindData) {\n          var source = fnToString.call(func);\n          if (!support.funcNames) {\n            bindData = !reFuncName.test(source);\n          }\n          if (!bindData) {\n            // checks if `func` references the `this` keyword and stores the result\n            bindData = reThis.test(source);\n            setBindData(func, bindData);\n          }\n        }\n      }\n      // exit early if there are no `this` references or `func` is bound\n      if (bindData === false || (bindData !== true && bindData[1] & 1)) {\n        return func;\n      }\n      switch (argCount) {\n        case 1: return function(value) {\n          return func.call(thisArg, value);\n        };\n        case 2: return function(a, b) {\n          return func.call(thisArg, a, b);\n        };\n        case 3: return function(value, index, collection) {\n          return func.call(thisArg, value, index, collection);\n        };\n        case 4: return function(accumulator, value, index, collection) {\n          return func.call(thisArg, accumulator, value, index, collection);\n        };\n      }\n      return bind(func, thisArg);\n    }\n\n    /**\n     * The base implementation of `createWrapper` that creates the wrapper and\n     * sets its meta data.\n     *\n     * @private\n     * @param {Array} bindData The bind data array.\n     * @returns {Function} Returns the new function.\n     */\n    function baseCreateWrapper(bindData) {\n      var func = bindData[0],\n          bitmask = bindData[1],\n          partialArgs = bindData[2],\n          partialRightArgs = bindData[3],\n          thisArg = bindData[4],\n          arity = bindData[5];\n\n      var isBind = bitmask & 1,\n          isBindKey = bitmask & 2,\n          isCurry = bitmask & 4,\n          isCurryBound = bitmask & 8,\n          key = func;\n\n      function bound() {\n        var thisBinding = isBind ? thisArg : this;\n        if (partialArgs) {\n          var args = slice(partialArgs);\n          push.apply(args, arguments);\n        }\n        if (partialRightArgs || isCurry) {\n          args || (args = slice(arguments));\n          if (partialRightArgs) {\n            push.apply(args, partialRightArgs);\n          }\n          if (isCurry && args.length < arity) {\n            bitmask |= 16 & ~32;\n            return baseCreateWrapper([func, (isCurryBound ? bitmask : bitmask & ~3), args, null, thisArg, arity]);\n          }\n        }\n        args || (args = arguments);\n        if (isBindKey) {\n          func = thisBinding[key];\n        }\n        if (this instanceof bound) {\n          thisBinding = baseCreate(func.prototype);\n          var result = func.apply(thisBinding, args);\n          return isObject(result) ? result : thisBinding;\n        }\n        return func.apply(thisBinding, args);\n      }\n      setBindData(bound, bindData);\n      return bound;\n    }\n\n    /**\n     * The base implementation of `_.difference` that accepts a single array\n     * of values to exclude.\n     *\n     * @private\n     * @param {Array} array The array to process.\n     * @param {Array} [values] The array of values to exclude.\n     * @returns {Array} Returns a new array of filtered values.\n     */\n    function baseDifference(array, values) {\n      var index = -1,\n          indexOf = getIndexOf(),\n          length = array ? array.length : 0,\n          isLarge = length >= largeArraySize && indexOf === baseIndexOf,\n          result = [];\n\n      if (isLarge) {\n        var cache = createCache(values);\n        if (cache) {\n          indexOf = cacheIndexOf;\n          values = cache;\n        } else {\n          isLarge = false;\n        }\n      }\n      while (++index < length) {\n        var value = array[index];\n        if (indexOf(values, value) < 0) {\n          result.push(value);\n        }\n      }\n      if (isLarge) {\n        releaseObject(values);\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.flatten` without support for callback\n     * shorthands or `thisArg` binding.\n     *\n     * @private\n     * @param {Array} array The array to flatten.\n     * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.\n     * @param {boolean} [isStrict=false] A flag to restrict flattening to arrays and `arguments` objects.\n     * @param {number} [fromIndex=0] The index to start from.\n     * @returns {Array} Returns a new flattened array.\n     */\n    function baseFlatten(array, isShallow, isStrict, fromIndex) {\n      var index = (fromIndex || 0) - 1,\n          length = array ? array.length : 0,\n          result = [];\n\n      while (++index < length) {\n        var value = array[index];\n\n        if (value && typeof value == 'object' && typeof value.length == 'number'\n            && (isArray(value) || isArguments(value))) {\n          // recursively flatten arrays (susceptible to call stack limits)\n          if (!isShallow) {\n            value = baseFlatten(value, isShallow, isStrict);\n          }\n          var valIndex = -1,\n              valLength = value.length,\n              resIndex = result.length;\n\n          result.length += valLength;\n          while (++valIndex < valLength) {\n            result[resIndex++] = value[valIndex];\n          }\n        } else if (!isStrict) {\n          result.push(value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.isEqual`, without support for `thisArg` binding,\n     * that allows partial \"_.where\" style comparisons.\n     *\n     * @private\n     * @param {*} a The value to compare.\n     * @param {*} b The other value to compare.\n     * @param {Function} [callback] The function to customize comparing values.\n     * @param {Function} [isWhere=false] A flag to indicate performing partial comparisons.\n     * @param {Array} [stackA=[]] Tracks traversed `a` objects.\n     * @param {Array} [stackB=[]] Tracks traversed `b` objects.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     */\n    function baseIsEqual(a, b, callback, isWhere, stackA, stackB) {\n      // used to indicate that when comparing objects, `a` has at least the properties of `b`\n      if (callback) {\n        var result = callback(a, b);\n        if (typeof result != 'undefined') {\n          return !!result;\n        }\n      }\n      // exit early for identical values\n      if (a === b) {\n        // treat `+0` vs. `-0` as not equal\n        return a !== 0 || (1 / a == 1 / b);\n      }\n      var type = typeof a,\n          otherType = typeof b;\n\n      // exit early for unlike primitive values\n      if (a === a &&\n          !(a && objectTypes[type]) &&\n          !(b && objectTypes[otherType])) {\n        return false;\n      }\n      // exit early for `null` and `undefined` avoiding ES3's Function#call behavior\n      // http://es5.github.io/#x15.3.4.4\n      if (a == null || b == null) {\n        return a === b;\n      }\n      // compare [[Class]] names\n      var className = toString.call(a),\n          otherClass = toString.call(b);\n\n      if (className == argsClass) {\n        className = objectClass;\n      }\n      if (otherClass == argsClass) {\n        otherClass = objectClass;\n      }\n      if (className != otherClass) {\n        return false;\n      }\n      switch (className) {\n        case boolClass:\n        case dateClass:\n          // coerce dates and booleans to numbers, dates to milliseconds and booleans\n          // to `1` or `0` treating invalid dates coerced to `NaN` as not equal\n          return +a == +b;\n\n        case numberClass:\n          // treat `NaN` vs. `NaN` as equal\n          return (a != +a)\n            ? b != +b\n            // but treat `+0` vs. `-0` as not equal\n            : (a == 0 ? (1 / a == 1 / b) : a == +b);\n\n        case regexpClass:\n        case stringClass:\n          // coerce regexes to strings (http://es5.github.io/#x15.10.6.4)\n          // treat string primitives and their corresponding object instances as equal\n          return a == String(b);\n      }\n      var isArr = className == arrayClass;\n      if (!isArr) {\n        // unwrap any `lodash` wrapped values\n        var aWrapped = hasOwnProperty.call(a, '__wrapped__'),\n            bWrapped = hasOwnProperty.call(b, '__wrapped__');\n\n        if (aWrapped || bWrapped) {\n          return baseIsEqual(aWrapped ? a.__wrapped__ : a, bWrapped ? b.__wrapped__ : b, callback, isWhere, stackA, stackB);\n        }\n        // exit for functions and DOM nodes\n        if (className != objectClass) {\n          return false;\n        }\n        // in older versions of Opera, `arguments` objects have `Array` constructors\n        var ctorA = a.constructor,\n            ctorB = b.constructor;\n\n        // non `Object` object instances with different constructors are not equal\n        if (ctorA != ctorB &&\n              !(isFunction(ctorA) && ctorA instanceof ctorA && isFunction(ctorB) && ctorB instanceof ctorB) &&\n              ('constructor' in a && 'constructor' in b)\n            ) {\n          return false;\n        }\n      }\n      // assume cyclic structures are equal\n      // the algorithm for detecting cyclic structures is adapted from ES 5.1\n      // section 15.12.3, abstract operation `JO` (http://es5.github.io/#x15.12.3)\n      var initedStack = !stackA;\n      stackA || (stackA = getArray());\n      stackB || (stackB = getArray());\n\n      var length = stackA.length;\n      while (length--) {\n        if (stackA[length] == a) {\n          return stackB[length] == b;\n        }\n      }\n      var size = 0;\n      result = true;\n\n      // add `a` and `b` to the stack of traversed objects\n      stackA.push(a);\n      stackB.push(b);\n\n      // recursively compare objects and arrays (susceptible to call stack limits)\n      if (isArr) {\n        // compare lengths to determine if a deep comparison is necessary\n        length = a.length;\n        size = b.length;\n        result = size == length;\n\n        if (result || isWhere) {\n          // deep compare the contents, ignoring non-numeric properties\n          while (size--) {\n            var index = length,\n                value = b[size];\n\n            if (isWhere) {\n              while (index--) {\n                if ((result = baseIsEqual(a[index], value, callback, isWhere, stackA, stackB))) {\n                  break;\n                }\n              }\n            } else if (!(result = baseIsEqual(a[size], value, callback, isWhere, stackA, stackB))) {\n              break;\n            }\n          }\n        }\n      }\n      else {\n        // deep compare objects using `forIn`, instead of `forOwn`, to avoid `Object.keys`\n        // which, in this case, is more costly\n        forIn(b, function(value, key, b) {\n          if (hasOwnProperty.call(b, key)) {\n            // count the number of properties.\n            size++;\n            // deep compare each property value.\n            return (result = hasOwnProperty.call(a, key) && baseIsEqual(a[key], value, callback, isWhere, stackA, stackB));\n          }\n        });\n\n        if (result && !isWhere) {\n          // ensure both objects have the same number of properties\n          forIn(a, function(value, key, a) {\n            if (hasOwnProperty.call(a, key)) {\n              // `size` will be `-1` if `a` has more properties than `b`\n              return (result = --size > -1);\n            }\n          });\n        }\n      }\n      stackA.pop();\n      stackB.pop();\n\n      if (initedStack) {\n        releaseArray(stackA);\n        releaseArray(stackB);\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.merge` without argument juggling or support\n     * for `thisArg` binding.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @param {Function} [callback] The function to customize merging properties.\n     * @param {Array} [stackA=[]] Tracks traversed source objects.\n     * @param {Array} [stackB=[]] Associates values with source counterparts.\n     */\n    function baseMerge(object, source, callback, stackA, stackB) {\n      (isArray(source) ? forEach : forOwn)(source, function(source, key) {\n        var found,\n            isArr,\n            result = source,\n            value = object[key];\n\n        if (source && ((isArr = isArray(source)) || isPlainObject(source))) {\n          // avoid merging previously merged cyclic sources\n          var stackLength = stackA.length;\n          while (stackLength--) {\n            if ((found = stackA[stackLength] == source)) {\n              value = stackB[stackLength];\n              break;\n            }\n          }\n          if (!found) {\n            var isShallow;\n            if (callback) {\n              result = callback(value, source);\n              if ((isShallow = typeof result != 'undefined')) {\n                value = result;\n              }\n            }\n            if (!isShallow) {\n              value = isArr\n                ? (isArray(value) ? value : [])\n                : (isPlainObject(value) ? value : {});\n            }\n            // add `source` and associated `value` to the stack of traversed objects\n            stackA.push(source);\n            stackB.push(value);\n\n            // recursively merge objects and arrays (susceptible to call stack limits)\n            if (!isShallow) {\n              baseMerge(value, source, callback, stackA, stackB);\n            }\n          }\n        }\n        else {\n          if (callback) {\n            result = callback(value, source);\n            if (typeof result == 'undefined') {\n              result = source;\n            }\n          }\n          if (typeof result != 'undefined') {\n            value = result;\n          }\n        }\n        object[key] = value;\n      });\n    }\n\n    /**\n     * The base implementation of `_.random` without argument juggling or support\n     * for returning floating-point numbers.\n     *\n     * @private\n     * @param {number} min The minimum possible value.\n     * @param {number} max The maximum possible value.\n     * @returns {number} Returns a random number.\n     */\n    function baseRandom(min, max) {\n      return min + floor(nativeRandom() * (max - min + 1));\n    }\n\n    /**\n     * The base implementation of `_.uniq` without support for callback shorthands\n     * or `thisArg` binding.\n     *\n     * @private\n     * @param {Array} array The array to process.\n     * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.\n     * @param {Function} [callback] The function called per iteration.\n     * @returns {Array} Returns a duplicate-value-free array.\n     */\n    function baseUniq(array, isSorted, callback) {\n      var index = -1,\n          indexOf = getIndexOf(),\n          length = array ? array.length : 0,\n          result = [];\n\n      var isLarge = !isSorted && length >= largeArraySize && indexOf === baseIndexOf,\n          seen = (callback || isLarge) ? getArray() : result;\n\n      if (isLarge) {\n        var cache = createCache(seen);\n        indexOf = cacheIndexOf;\n        seen = cache;\n      }\n      while (++index < length) {\n        var value = array[index],\n            computed = callback ? callback(value, index, array) : value;\n\n        if (isSorted\n              ? !index || seen[seen.length - 1] !== computed\n              : indexOf(seen, computed) < 0\n            ) {\n          if (callback || isLarge) {\n            seen.push(computed);\n          }\n          result.push(value);\n        }\n      }\n      if (isLarge) {\n        releaseArray(seen.array);\n        releaseObject(seen);\n      } else if (callback) {\n        releaseArray(seen);\n      }\n      return result;\n    }\n\n    /**\n     * Creates a function that aggregates a collection, creating an object composed\n     * of keys generated from the results of running each element of the collection\n     * through a callback. The given `setter` function sets the keys and values\n     * of the composed object.\n     *\n     * @private\n     * @param {Function} setter The setter function.\n     * @returns {Function} Returns the new aggregator function.\n     */\n    function createAggregator(setter) {\n      return function(collection, callback, thisArg) {\n        var result = {};\n        callback = lodash.createCallback(callback, thisArg, 3);\n\n        var index = -1,\n            length = collection ? collection.length : 0;\n\n        if (typeof length == 'number') {\n          while (++index < length) {\n            var value = collection[index];\n            setter(result, value, callback(value, index, collection), collection);\n          }\n        } else {\n          forOwn(collection, function(value, key, collection) {\n            setter(result, value, callback(value, key, collection), collection);\n          });\n        }\n        return result;\n      };\n    }\n\n    /**\n     * Creates a function that, when called, either curries or invokes `func`\n     * with an optional `this` binding and partially applied arguments.\n     *\n     * @private\n     * @param {Function|string} func The function or method name to reference.\n     * @param {number} bitmask The bitmask of method flags to compose.\n     *  The bitmask may be composed of the following flags:\n     *  1 - `_.bind`\n     *  2 - `_.bindKey`\n     *  4 - `_.curry`\n     *  8 - `_.curry` (bound)\n     *  16 - `_.partial`\n     *  32 - `_.partialRight`\n     * @param {Array} [partialArgs] An array of arguments to prepend to those\n     *  provided to the new function.\n     * @param {Array} [partialRightArgs] An array of arguments to append to those\n     *  provided to the new function.\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @param {number} [arity] The arity of `func`.\n     * @returns {Function} Returns the new function.\n     */\n    function createWrapper(func, bitmask, partialArgs, partialRightArgs, thisArg, arity) {\n      var isBind = bitmask & 1,\n          isBindKey = bitmask & 2,\n          isCurry = bitmask & 4,\n          isCurryBound = bitmask & 8,\n          isPartial = bitmask & 16,\n          isPartialRight = bitmask & 32;\n\n      if (!isBindKey && !isFunction(func)) {\n        throw new TypeError;\n      }\n      if (isPartial && !partialArgs.length) {\n        bitmask &= ~16;\n        isPartial = partialArgs = false;\n      }\n      if (isPartialRight && !partialRightArgs.length) {\n        bitmask &= ~32;\n        isPartialRight = partialRightArgs = false;\n      }\n      var bindData = func && func.__bindData__;\n      if (bindData && bindData !== true) {\n        // clone `bindData`\n        bindData = slice(bindData);\n        if (bindData[2]) {\n          bindData[2] = slice(bindData[2]);\n        }\n        if (bindData[3]) {\n          bindData[3] = slice(bindData[3]);\n        }\n        // set `thisBinding` is not previously bound\n        if (isBind && !(bindData[1] & 1)) {\n          bindData[4] = thisArg;\n        }\n        // set if previously bound but not currently (subsequent curried functions)\n        if (!isBind && bindData[1] & 1) {\n          bitmask |= 8;\n        }\n        // set curried arity if not yet set\n        if (isCurry && !(bindData[1] & 4)) {\n          bindData[5] = arity;\n        }\n        // append partial left arguments\n        if (isPartial) {\n          push.apply(bindData[2] || (bindData[2] = []), partialArgs);\n        }\n        // append partial right arguments\n        if (isPartialRight) {\n          unshift.apply(bindData[3] || (bindData[3] = []), partialRightArgs);\n        }\n        // merge flags\n        bindData[1] |= bitmask;\n        return createWrapper.apply(null, bindData);\n      }\n      // fast path for `_.bind`\n      var creater = (bitmask == 1 || bitmask === 17) ? baseBind : baseCreateWrapper;\n      return creater([func, bitmask, partialArgs, partialRightArgs, thisArg, arity]);\n    }\n\n    /**\n     * Used by `escape` to convert characters to HTML entities.\n     *\n     * @private\n     * @param {string} match The matched character to escape.\n     * @returns {string} Returns the escaped character.\n     */\n    function escapeHtmlChar(match) {\n      return htmlEscapes[match];\n    }\n\n    /**\n     * Gets the appropriate \"indexOf\" function. If the `_.indexOf` method is\n     * customized, this method returns the custom method, otherwise it returns\n     * the `baseIndexOf` function.\n     *\n     * @private\n     * @returns {Function} Returns the \"indexOf\" function.\n     */\n    function getIndexOf() {\n      var result = (result = lodash.indexOf) === indexOf ? baseIndexOf : result;\n      return result;\n    }\n\n    /**\n     * Checks if `value` is a native function.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the `value` is a native function, else `false`.\n     */\n    function isNative(value) {\n      return typeof value == 'function' && reNative.test(value);\n    }\n\n    /**\n     * Sets `this` binding data on a given function.\n     *\n     * @private\n     * @param {Function} func The function to set data on.\n     * @param {Array} value The data array to set.\n     */\n    var setBindData = !defineProperty ? noop : function(func, value) {\n      descriptor.value = value;\n      defineProperty(func, '__bindData__', descriptor);\n      descriptor.value = null;\n    };\n\n    /**\n     * A fallback implementation of `isPlainObject` which checks if a given value\n     * is an object created by the `Object` constructor, assuming objects created\n     * by the `Object` constructor have no inherited enumerable properties and that\n     * there are no `Object.prototype` extensions.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n     */\n    function shimIsPlainObject(value) {\n      var ctor,\n          result;\n\n      // avoid non Object objects, `arguments` objects, and DOM elements\n      if (!(value && toString.call(value) == objectClass) ||\n          (ctor = value.constructor, isFunction(ctor) && !(ctor instanceof ctor))) {\n        return false;\n      }\n      // In most environments an object's own properties are iterated before\n      // its inherited properties. If the last iterated property is an object's\n      // own property then there are no inherited enumerable properties.\n      forIn(value, function(value, key) {\n        result = key;\n      });\n      return typeof result == 'undefined' || hasOwnProperty.call(value, result);\n    }\n\n    /**\n     * Used by `unescape` to convert HTML entities to characters.\n     *\n     * @private\n     * @param {string} match The matched character to unescape.\n     * @returns {string} Returns the unescaped character.\n     */\n    function unescapeHtmlChar(match) {\n      return htmlUnescapes[match];\n    }\n\n    /*--------------------------------------------------------------------------*/\n\n    /**\n     * Checks if `value` is an `arguments` object.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the `value` is an `arguments` object, else `false`.\n     * @example\n     *\n     * (function() { return _.isArguments(arguments); })(1, 2, 3);\n     * // => true\n     *\n     * _.isArguments([1, 2, 3]);\n     * // => false\n     */\n    function isArguments(value) {\n      return value && typeof value == 'object' && typeof value.length == 'number' &&\n        toString.call(value) == argsClass || false;\n    }\n\n    /**\n     * Checks if `value` is an array.\n     *\n     * @static\n     * @memberOf _\n     * @type Function\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the `value` is an array, else `false`.\n     * @example\n     *\n     * (function() { return _.isArray(arguments); })();\n     * // => false\n     *\n     * _.isArray([1, 2, 3]);\n     * // => true\n     */\n    var isArray = nativeIsArray || function(value) {\n      return value && typeof value == 'object' && typeof value.length == 'number' &&\n        toString.call(value) == arrayClass || false;\n    };\n\n    /**\n     * A fallback implementation of `Object.keys` which produces an array of the\n     * given object's own enumerable property names.\n     *\n     * @private\n     * @type Function\n     * @param {Object} object The object to inspect.\n     * @returns {Array} Returns an array of property names.\n     */\n    var shimKeys = function(object) {\n      var index, iterable = object, result = [];\n      if (!iterable) return result;\n      if (!(objectTypes[typeof object])) return result;\n        for (index in iterable) {\n          if (hasOwnProperty.call(iterable, index)) {\n            result.push(index);\n          }\n        }\n      return result\n    };\n\n    /**\n     * Creates an array composed of the own enumerable property names of an object.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The object to inspect.\n     * @returns {Array} Returns an array of property names.\n     * @example\n     *\n     * _.keys({ 'one': 1, 'two': 2, 'three': 3 });\n     * // => ['one', 'two', 'three'] (property order is not guaranteed across environments)\n     */\n    var keys = !nativeKeys ? shimKeys : function(object) {\n      if (!isObject(object)) {\n        return [];\n      }\n      return nativeKeys(object);\n    };\n\n    /**\n     * Used to convert characters to HTML entities:\n     *\n     * Though the `>` character is escaped for symmetry, characters like `>` and `/`\n     * don't require escaping in HTML and have no special meaning unless they're part\n     * of a tag or an unquoted attribute value.\n     * http://mathiasbynens.be/notes/ambiguous-ampersands (under \"semi-related fun fact\")\n     */\n    var htmlEscapes = {\n      '&': '&amp;',\n      '<': '&lt;',\n      '>': '&gt;',\n      '\"': '&quot;',\n      \"'\": '&#39;'\n    };\n\n    /** Used to convert HTML entities to characters */\n    var htmlUnescapes = invert(htmlEscapes);\n\n    /** Used to match HTML entities and HTML characters */\n    var reEscapedHtml = RegExp('(' + keys(htmlUnescapes).join('|') + ')', 'g'),\n        reUnescapedHtml = RegExp('[' + keys(htmlEscapes).join('') + ']', 'g');\n\n    /*--------------------------------------------------------------------------*/\n\n    /**\n     * Assigns own enumerable properties of source object(s) to the destination\n     * object. Subsequent sources will overwrite property assignments of previous\n     * sources. If a callback is provided it will be executed to produce the\n     * assigned values. The callback is bound to `thisArg` and invoked with two\n     * arguments; (objectValue, sourceValue).\n     *\n     * @static\n     * @memberOf _\n     * @type Function\n     * @alias extend\n     * @category Objects\n     * @param {Object} object The destination object.\n     * @param {...Object} [source] The source objects.\n     * @param {Function} [callback] The function to customize assigning values.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Object} Returns the destination object.\n     * @example\n     *\n     * _.assign({ 'name': 'fred' }, { 'employer': 'slate' });\n     * // => { 'name': 'fred', 'employer': 'slate' }\n     *\n     * var defaults = _.partialRight(_.assign, function(a, b) {\n     *   return typeof a == 'undefined' ? b : a;\n     * });\n     *\n     * var object = { 'name': 'barney' };\n     * defaults(object, { 'name': 'fred', 'employer': 'slate' });\n     * // => { 'name': 'barney', 'employer': 'slate' }\n     */\n    var assign = function(object, source, guard) {\n      var index, iterable = object, result = iterable;\n      if (!iterable) return result;\n      var args = arguments,\n          argsIndex = 0,\n          argsLength = typeof guard == 'number' ? 2 : args.length;\n      if (argsLength > 3 && typeof args[argsLength - 2] == 'function') {\n        var callback = baseCreateCallback(args[--argsLength - 1], args[argsLength--], 2);\n      } else if (argsLength > 2 && typeof args[argsLength - 1] == 'function') {\n        callback = args[--argsLength];\n      }\n      while (++argsIndex < argsLength) {\n        iterable = args[argsIndex];\n        if (iterable && objectTypes[typeof iterable]) {\n        var ownIndex = -1,\n            ownProps = objectTypes[typeof iterable] && keys(iterable),\n            length = ownProps ? ownProps.length : 0;\n\n        while (++ownIndex < length) {\n          index = ownProps[ownIndex];\n          result[index] = callback ? callback(result[index], iterable[index]) : iterable[index];\n        }\n        }\n      }\n      return result\n    };\n\n    /**\n     * Creates a clone of `value`. If `isDeep` is `true` nested objects will also\n     * be cloned, otherwise they will be assigned by reference. If a callback\n     * is provided it will be executed to produce the cloned values. If the\n     * callback returns `undefined` cloning will be handled by the method instead.\n     * The callback is bound to `thisArg` and invoked with one argument; (value).\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to clone.\n     * @param {boolean} [isDeep=false] Specify a deep clone.\n     * @param {Function} [callback] The function to customize cloning values.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {*} Returns the cloned value.\n     * @example\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36 },\n     *   { 'name': 'fred',   'age': 40 }\n     * ];\n     *\n     * var shallow = _.clone(characters);\n     * shallow[0] === characters[0];\n     * // => true\n     *\n     * var deep = _.clone(characters, true);\n     * deep[0] === characters[0];\n     * // => false\n     *\n     * _.mixin({\n     *   'clone': _.partialRight(_.clone, function(value) {\n     *     return _.isElement(value) ? value.cloneNode(false) : undefined;\n     *   })\n     * });\n     *\n     * var clone = _.clone(document.body);\n     * clone.childNodes.length;\n     * // => 0\n     */\n    function clone(value, isDeep, callback, thisArg) {\n      // allows working with \"Collections\" methods without using their `index`\n      // and `collection` arguments for `isDeep` and `callback`\n      if (typeof isDeep != 'boolean' && isDeep != null) {\n        thisArg = callback;\n        callback = isDeep;\n        isDeep = false;\n      }\n      return baseClone(value, isDeep, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));\n    }\n\n    /**\n     * Creates a deep clone of `value`. If a callback is provided it will be\n     * executed to produce the cloned values. If the callback returns `undefined`\n     * cloning will be handled by the method instead. The callback is bound to\n     * `thisArg` and invoked with one argument; (value).\n     *\n     * Note: This method is loosely based on the structured clone algorithm. Functions\n     * and DOM nodes are **not** cloned. The enumerable properties of `arguments` objects and\n     * objects created by constructors other than `Object` are cloned to plain `Object` objects.\n     * See http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to deep clone.\n     * @param {Function} [callback] The function to customize cloning values.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {*} Returns the deep cloned value.\n     * @example\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36 },\n     *   { 'name': 'fred',   'age': 40 }\n     * ];\n     *\n     * var deep = _.cloneDeep(characters);\n     * deep[0] === characters[0];\n     * // => false\n     *\n     * var view = {\n     *   'label': 'docs',\n     *   'node': element\n     * };\n     *\n     * var clone = _.cloneDeep(view, function(value) {\n     *   return _.isElement(value) ? value.cloneNode(true) : undefined;\n     * });\n     *\n     * clone.node == view.node;\n     * // => false\n     */\n    function cloneDeep(value, callback, thisArg) {\n      return baseClone(value, true, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));\n    }\n\n    /**\n     * Creates an object that inherits from the given `prototype` object. If a\n     * `properties` object is provided its own enumerable properties are assigned\n     * to the created object.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} prototype The object to inherit from.\n     * @param {Object} [properties] The properties to assign to the object.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * function Shape() {\n     *   this.x = 0;\n     *   this.y = 0;\n     * }\n     *\n     * function Circle() {\n     *   Shape.call(this);\n     * }\n     *\n     * Circle.prototype = _.create(Shape.prototype, { 'constructor': Circle });\n     *\n     * var circle = new Circle;\n     * circle instanceof Circle;\n     * // => true\n     *\n     * circle instanceof Shape;\n     * // => true\n     */\n    function create(prototype, properties) {\n      var result = baseCreate(prototype);\n      return properties ? assign(result, properties) : result;\n    }\n\n    /**\n     * Assigns own enumerable properties of source object(s) to the destination\n     * object for all destination properties that resolve to `undefined`. Once a\n     * property is set, additional defaults of the same property will be ignored.\n     *\n     * @static\n     * @memberOf _\n     * @type Function\n     * @category Objects\n     * @param {Object} object The destination object.\n     * @param {...Object} [source] The source objects.\n     * @param- {Object} [guard] Allows working with `_.reduce` without using its\n     *  `key` and `object` arguments as sources.\n     * @returns {Object} Returns the destination object.\n     * @example\n     *\n     * var object = { 'name': 'barney' };\n     * _.defaults(object, { 'name': 'fred', 'employer': 'slate' });\n     * // => { 'name': 'barney', 'employer': 'slate' }\n     */\n    var defaults = function(object, source, guard) {\n      var index, iterable = object, result = iterable;\n      if (!iterable) return result;\n      var args = arguments,\n          argsIndex = 0,\n          argsLength = typeof guard == 'number' ? 2 : args.length;\n      while (++argsIndex < argsLength) {\n        iterable = args[argsIndex];\n        if (iterable && objectTypes[typeof iterable]) {\n        var ownIndex = -1,\n            ownProps = objectTypes[typeof iterable] && keys(iterable),\n            length = ownProps ? ownProps.length : 0;\n\n        while (++ownIndex < length) {\n          index = ownProps[ownIndex];\n          if (typeof result[index] == 'undefined') result[index] = iterable[index];\n        }\n        }\n      }\n      return result\n    };\n\n    /**\n     * This method is like `_.findIndex` except that it returns the key of the\n     * first element that passes the callback check, instead of the element itself.\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The object to search.\n     * @param {Function|Object|string} [callback=identity] The function called per\n     *  iteration. If a property name or object is provided it will be used to\n     *  create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {string|undefined} Returns the key of the found element, else `undefined`.\n     * @example\n     *\n     * var characters = {\n     *   'barney': {  'age': 36, 'blocked': false },\n     *   'fred': {    'age': 40, 'blocked': true },\n     *   'pebbles': { 'age': 1,  'blocked': false }\n     * };\n     *\n     * _.findKey(characters, function(chr) {\n     *   return chr.age < 40;\n     * });\n     * // => 'barney' (property order is not guaranteed across environments)\n     *\n     * // using \"_.where\" callback shorthand\n     * _.findKey(characters, { 'age': 1 });\n     * // => 'pebbles'\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.findKey(characters, 'blocked');\n     * // => 'fred'\n     */\n    function findKey(object, callback, thisArg) {\n      var result;\n      callback = lodash.createCallback(callback, thisArg, 3);\n      forOwn(object, function(value, key, object) {\n        if (callback(value, key, object)) {\n          result = key;\n          return false;\n        }\n      });\n      return result;\n    }\n\n    /**\n     * This method is like `_.findKey` except that it iterates over elements\n     * of a `collection` in the opposite order.\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The object to search.\n     * @param {Function|Object|string} [callback=identity] The function called per\n     *  iteration. If a property name or object is provided it will be used to\n     *  create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {string|undefined} Returns the key of the found element, else `undefined`.\n     * @example\n     *\n     * var characters = {\n     *   'barney': {  'age': 36, 'blocked': true },\n     *   'fred': {    'age': 40, 'blocked': false },\n     *   'pebbles': { 'age': 1,  'blocked': true }\n     * };\n     *\n     * _.findLastKey(characters, function(chr) {\n     *   return chr.age < 40;\n     * });\n     * // => returns `pebbles`, assuming `_.findKey` returns `barney`\n     *\n     * // using \"_.where\" callback shorthand\n     * _.findLastKey(characters, { 'age': 40 });\n     * // => 'fred'\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.findLastKey(characters, 'blocked');\n     * // => 'pebbles'\n     */\n    function findLastKey(object, callback, thisArg) {\n      var result;\n      callback = lodash.createCallback(callback, thisArg, 3);\n      forOwnRight(object, function(value, key, object) {\n        if (callback(value, key, object)) {\n          result = key;\n          return false;\n        }\n      });\n      return result;\n    }\n\n    /**\n     * Iterates over own and inherited enumerable properties of an object,\n     * executing the callback for each property. The callback is bound to `thisArg`\n     * and invoked with three arguments; (value, key, object). Callbacks may exit\n     * iteration early by explicitly returning `false`.\n     *\n     * @static\n     * @memberOf _\n     * @type Function\n     * @category Objects\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [callback=identity] The function called per iteration.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * function Shape() {\n     *   this.x = 0;\n     *   this.y = 0;\n     * }\n     *\n     * Shape.prototype.move = function(x, y) {\n     *   this.x += x;\n     *   this.y += y;\n     * };\n     *\n     * _.forIn(new Shape, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => logs 'x', 'y', and 'move' (property order is not guaranteed across environments)\n     */\n    var forIn = function(collection, callback, thisArg) {\n      var index, iterable = collection, result = iterable;\n      if (!iterable) return result;\n      if (!objectTypes[typeof iterable]) return result;\n      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);\n        for (index in iterable) {\n          if (callback(iterable[index], index, collection) === false) return result;\n        }\n      return result\n    };\n\n    /**\n     * This method is like `_.forIn` except that it iterates over elements\n     * of a `collection` in the opposite order.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [callback=identity] The function called per iteration.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * function Shape() {\n     *   this.x = 0;\n     *   this.y = 0;\n     * }\n     *\n     * Shape.prototype.move = function(x, y) {\n     *   this.x += x;\n     *   this.y += y;\n     * };\n     *\n     * _.forInRight(new Shape, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => logs 'move', 'y', and 'x' assuming `_.forIn ` logs 'x', 'y', and 'move'\n     */\n    function forInRight(object, callback, thisArg) {\n      var pairs = [];\n\n      forIn(object, function(value, key) {\n        pairs.push(key, value);\n      });\n\n      var length = pairs.length;\n      callback = baseCreateCallback(callback, thisArg, 3);\n      while (length--) {\n        if (callback(pairs[length--], pairs[length], object) === false) {\n          break;\n        }\n      }\n      return object;\n    }\n\n    /**\n     * Iterates over own enumerable properties of an object, executing the callback\n     * for each property. The callback is bound to `thisArg` and invoked with three\n     * arguments; (value, key, object). Callbacks may exit iteration early by\n     * explicitly returning `false`.\n     *\n     * @static\n     * @memberOf _\n     * @type Function\n     * @category Objects\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [callback=identity] The function called per iteration.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * _.forOwn({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {\n     *   console.log(key);\n     * });\n     * // => logs '0', '1', and 'length' (property order is not guaranteed across environments)\n     */\n    var forOwn = function(collection, callback, thisArg) {\n      var index, iterable = collection, result = iterable;\n      if (!iterable) return result;\n      if (!objectTypes[typeof iterable]) return result;\n      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);\n        var ownIndex = -1,\n            ownProps = objectTypes[typeof iterable] && keys(iterable),\n            length = ownProps ? ownProps.length : 0;\n\n        while (++ownIndex < length) {\n          index = ownProps[ownIndex];\n          if (callback(iterable[index], index, collection) === false) return result;\n        }\n      return result\n    };\n\n    /**\n     * This method is like `_.forOwn` except that it iterates over elements\n     * of a `collection` in the opposite order.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [callback=identity] The function called per iteration.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * _.forOwnRight({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {\n     *   console.log(key);\n     * });\n     * // => logs 'length', '1', and '0' assuming `_.forOwn` logs '0', '1', and 'length'\n     */\n    function forOwnRight(object, callback, thisArg) {\n      var props = keys(object),\n          length = props.length;\n\n      callback = baseCreateCallback(callback, thisArg, 3);\n      while (length--) {\n        var key = props[length];\n        if (callback(object[key], key, object) === false) {\n          break;\n        }\n      }\n      return object;\n    }\n\n    /**\n     * Creates a sorted array of property names of all enumerable properties,\n     * own and inherited, of `object` that have function values.\n     *\n     * @static\n     * @memberOf _\n     * @alias methods\n     * @category Objects\n     * @param {Object} object The object to inspect.\n     * @returns {Array} Returns an array of property names that have function values.\n     * @example\n     *\n     * _.functions(_);\n     * // => ['all', 'any', 'bind', 'bindAll', 'clone', 'compact', 'compose', ...]\n     */\n    function functions(object) {\n      var result = [];\n      forIn(object, function(value, key) {\n        if (isFunction(value)) {\n          result.push(key);\n        }\n      });\n      return result.sort();\n    }\n\n    /**\n     * Checks if the specified property name exists as a direct property of `object`,\n     * instead of an inherited property.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The object to inspect.\n     * @param {string} key The name of the property to check.\n     * @returns {boolean} Returns `true` if key is a direct property, else `false`.\n     * @example\n     *\n     * _.has({ 'a': 1, 'b': 2, 'c': 3 }, 'b');\n     * // => true\n     */\n    function has(object, key) {\n      return object ? hasOwnProperty.call(object, key) : false;\n    }\n\n    /**\n     * Creates an object composed of the inverted keys and values of the given object.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The object to invert.\n     * @returns {Object} Returns the created inverted object.\n     * @example\n     *\n     * _.invert({ 'first': 'fred', 'second': 'barney' });\n     * // => { 'fred': 'first', 'barney': 'second' }\n     */\n    function invert(object) {\n      var index = -1,\n          props = keys(object),\n          length = props.length,\n          result = {};\n\n      while (++index < length) {\n        var key = props[index];\n        result[object[key]] = key;\n      }\n      return result;\n    }\n\n    /**\n     * Checks if `value` is a boolean value.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the `value` is a boolean value, else `false`.\n     * @example\n     *\n     * _.isBoolean(null);\n     * // => false\n     */\n    function isBoolean(value) {\n      return value === true || value === false ||\n        value && typeof value == 'object' && toString.call(value) == boolClass || false;\n    }\n\n    /**\n     * Checks if `value` is a date.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the `value` is a date, else `false`.\n     * @example\n     *\n     * _.isDate(new Date);\n     * // => true\n     */\n    function isDate(value) {\n      return value && typeof value == 'object' && toString.call(value) == dateClass || false;\n    }\n\n    /**\n     * Checks if `value` is a DOM element.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the `value` is a DOM element, else `false`.\n     * @example\n     *\n     * _.isElement(document.body);\n     * // => true\n     */\n    function isElement(value) {\n      return value && value.nodeType === 1 || false;\n    }\n\n    /**\n     * Checks if `value` is empty. Arrays, strings, or `arguments` objects with a\n     * length of `0` and objects with no own enumerable properties are considered\n     * \"empty\".\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Array|Object|string} value The value to inspect.\n     * @returns {boolean} Returns `true` if the `value` is empty, else `false`.\n     * @example\n     *\n     * _.isEmpty([1, 2, 3]);\n     * // => false\n     *\n     * _.isEmpty({});\n     * // => true\n     *\n     * _.isEmpty('');\n     * // => true\n     */\n    function isEmpty(value) {\n      var result = true;\n      if (!value) {\n        return result;\n      }\n      var className = toString.call(value),\n          length = value.length;\n\n      if ((className == arrayClass || className == stringClass || className == argsClass ) ||\n          (className == objectClass && typeof length == 'number' && isFunction(value.splice))) {\n        return !length;\n      }\n      forOwn(value, function() {\n        return (result = false);\n      });\n      return result;\n    }\n\n    /**\n     * Performs a deep comparison between two values to determine if they are\n     * equivalent to each other. If a callback is provided it will be executed\n     * to compare values. If the callback returns `undefined` comparisons will\n     * be handled by the method instead. The callback is bound to `thisArg` and\n     * invoked with two arguments; (a, b).\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} a The value to compare.\n     * @param {*} b The other value to compare.\n     * @param {Function} [callback] The function to customize comparing values.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     * @example\n     *\n     * var object = { 'name': 'fred' };\n     * var copy = { 'name': 'fred' };\n     *\n     * object == copy;\n     * // => false\n     *\n     * _.isEqual(object, copy);\n     * // => true\n     *\n     * var words = ['hello', 'goodbye'];\n     * var otherWords = ['hi', 'goodbye'];\n     *\n     * _.isEqual(words, otherWords, function(a, b) {\n     *   var reGreet = /^(?:hello|hi)$/i,\n     *       aGreet = _.isString(a) && reGreet.test(a),\n     *       bGreet = _.isString(b) && reGreet.test(b);\n     *\n     *   return (aGreet || bGreet) ? (aGreet == bGreet) : undefined;\n     * });\n     * // => true\n     */\n    function isEqual(a, b, callback, thisArg) {\n      return baseIsEqual(a, b, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 2));\n    }\n\n    /**\n     * Checks if `value` is, or can be coerced to, a finite number.\n     *\n     * Note: This is not the same as native `isFinite` which will return true for\n     * booleans and empty strings. See http://es5.github.io/#x15.1.2.5.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the `value` is finite, else `false`.\n     * @example\n     *\n     * _.isFinite(-101);\n     * // => true\n     *\n     * _.isFinite('10');\n     * // => true\n     *\n     * _.isFinite(true);\n     * // => false\n     *\n     * _.isFinite('');\n     * // => false\n     *\n     * _.isFinite(Infinity);\n     * // => false\n     */\n    function isFinite(value) {\n      return nativeIsFinite(value) && !nativeIsNaN(parseFloat(value));\n    }\n\n    /**\n     * Checks if `value` is a function.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the `value` is a function, else `false`.\n     * @example\n     *\n     * _.isFunction(_);\n     * // => true\n     */\n    function isFunction(value) {\n      return typeof value == 'function';\n    }\n\n    /**\n     * Checks if `value` is the language type of Object.\n     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the `value` is an object, else `false`.\n     * @example\n     *\n     * _.isObject({});\n     * // => true\n     *\n     * _.isObject([1, 2, 3]);\n     * // => true\n     *\n     * _.isObject(1);\n     * // => false\n     */\n    function isObject(value) {\n      // check if the value is the ECMAScript language type of Object\n      // http://es5.github.io/#x8\n      // and avoid a V8 bug\n      // http://code.google.com/p/v8/issues/detail?id=2291\n      return !!(value && objectTypes[typeof value]);\n    }\n\n    /**\n     * Checks if `value` is `NaN`.\n     *\n     * Note: This is not the same as native `isNaN` which will return `true` for\n     * `undefined` and other non-numeric values. See http://es5.github.io/#x15.1.2.4.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the `value` is `NaN`, else `false`.\n     * @example\n     *\n     * _.isNaN(NaN);\n     * // => true\n     *\n     * _.isNaN(new Number(NaN));\n     * // => true\n     *\n     * isNaN(undefined);\n     * // => true\n     *\n     * _.isNaN(undefined);\n     * // => false\n     */\n    function isNaN(value) {\n      // `NaN` as a primitive is the only value that is not equal to itself\n      // (perform the [[Class]] check first to avoid errors with some host objects in IE)\n      return isNumber(value) && value != +value;\n    }\n\n    /**\n     * Checks if `value` is `null`.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the `value` is `null`, else `false`.\n     * @example\n     *\n     * _.isNull(null);\n     * // => true\n     *\n     * _.isNull(undefined);\n     * // => false\n     */\n    function isNull(value) {\n      return value === null;\n    }\n\n    /**\n     * Checks if `value` is a number.\n     *\n     * Note: `NaN` is considered a number. See http://es5.github.io/#x8.5.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the `value` is a number, else `false`.\n     * @example\n     *\n     * _.isNumber(8.4 * 5);\n     * // => true\n     */\n    function isNumber(value) {\n      return typeof value == 'number' ||\n        value && typeof value == 'object' && toString.call(value) == numberClass || false;\n    }\n\n    /**\n     * Checks if `value` is an object created by the `Object` constructor.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n     * @example\n     *\n     * function Shape() {\n     *   this.x = 0;\n     *   this.y = 0;\n     * }\n     *\n     * _.isPlainObject(new Shape);\n     * // => false\n     *\n     * _.isPlainObject([1, 2, 3]);\n     * // => false\n     *\n     * _.isPlainObject({ 'x': 0, 'y': 0 });\n     * // => true\n     */\n    var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function(value) {\n      if (!(value && toString.call(value) == objectClass)) {\n        return false;\n      }\n      var valueOf = value.valueOf,\n          objProto = isNative(valueOf) && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);\n\n      return objProto\n        ? (value == objProto || getPrototypeOf(value) == objProto)\n        : shimIsPlainObject(value);\n    };\n\n    /**\n     * Checks if `value` is a regular expression.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the `value` is a regular expression, else `false`.\n     * @example\n     *\n     * _.isRegExp(/fred/);\n     * // => true\n     */\n    function isRegExp(value) {\n      return value && typeof value == 'object' && toString.call(value) == regexpClass || false;\n    }\n\n    /**\n     * Checks if `value` is a string.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the `value` is a string, else `false`.\n     * @example\n     *\n     * _.isString('fred');\n     * // => true\n     */\n    function isString(value) {\n      return typeof value == 'string' ||\n        value && typeof value == 'object' && toString.call(value) == stringClass || false;\n    }\n\n    /**\n     * Checks if `value` is `undefined`.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the `value` is `undefined`, else `false`.\n     * @example\n     *\n     * _.isUndefined(void 0);\n     * // => true\n     */\n    function isUndefined(value) {\n      return typeof value == 'undefined';\n    }\n\n    /**\n     * Creates an object with the same keys as `object` and values generated by\n     * running each own enumerable property of `object` through the callback.\n     * The callback is bound to `thisArg` and invoked with three arguments;\n     * (value, key, object).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The object to iterate over.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Array} Returns a new object with values of the results of each `callback` execution.\n     * @example\n     *\n     * _.mapValues({ 'a': 1, 'b': 2, 'c': 3} , function(num) { return num * 3; });\n     * // => { 'a': 3, 'b': 6, 'c': 9 }\n     *\n     * var characters = {\n     *   'fred': { 'name': 'fred', 'age': 40 },\n     *   'pebbles': { 'name': 'pebbles', 'age': 1 }\n     * };\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.mapValues(characters, 'age');\n     * // => { 'fred': 40, 'pebbles': 1 }\n     */\n    function mapValues(object, callback, thisArg) {\n      var result = {};\n      callback = lodash.createCallback(callback, thisArg, 3);\n\n      forOwn(object, function(value, key, object) {\n        result[key] = callback(value, key, object);\n      });\n      return result;\n    }\n\n    /**\n     * Recursively merges own enumerable properties of the source object(s), that\n     * don't resolve to `undefined` into the destination object. Subsequent sources\n     * will overwrite property assignments of previous sources. If a callback is\n     * provided it will be executed to produce the merged values of the destination\n     * and source properties. If the callback returns `undefined` merging will\n     * be handled by the method instead. The callback is bound to `thisArg` and\n     * invoked with two arguments; (objectValue, sourceValue).\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The destination object.\n     * @param {...Object} [source] The source objects.\n     * @param {Function} [callback] The function to customize merging properties.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Object} Returns the destination object.\n     * @example\n     *\n     * var names = {\n     *   'characters': [\n     *     { 'name': 'barney' },\n     *     { 'name': 'fred' }\n     *   ]\n     * };\n     *\n     * var ages = {\n     *   'characters': [\n     *     { 'age': 36 },\n     *     { 'age': 40 }\n     *   ]\n     * };\n     *\n     * _.merge(names, ages);\n     * // => { 'characters': [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred', 'age': 40 }] }\n     *\n     * var food = {\n     *   'fruits': ['apple'],\n     *   'vegetables': ['beet']\n     * };\n     *\n     * var otherFood = {\n     *   'fruits': ['banana'],\n     *   'vegetables': ['carrot']\n     * };\n     *\n     * _.merge(food, otherFood, function(a, b) {\n     *   return _.isArray(a) ? a.concat(b) : undefined;\n     * });\n     * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot] }\n     */\n    function merge(object) {\n      var args = arguments,\n          length = 2;\n\n      if (!isObject(object)) {\n        return object;\n      }\n      // allows working with `_.reduce` and `_.reduceRight` without using\n      // their `index` and `collection` arguments\n      if (typeof args[2] != 'number') {\n        length = args.length;\n      }\n      if (length > 3 && typeof args[length - 2] == 'function') {\n        var callback = baseCreateCallback(args[--length - 1], args[length--], 2);\n      } else if (length > 2 && typeof args[length - 1] == 'function') {\n        callback = args[--length];\n      }\n      var sources = slice(arguments, 1, length),\n          index = -1,\n          stackA = getArray(),\n          stackB = getArray();\n\n      while (++index < length) {\n        baseMerge(object, sources[index], callback, stackA, stackB);\n      }\n      releaseArray(stackA);\n      releaseArray(stackB);\n      return object;\n    }\n\n    /**\n     * Creates a shallow clone of `object` excluding the specified properties.\n     * Property names may be specified as individual arguments or as arrays of\n     * property names. If a callback is provided it will be executed for each\n     * property of `object` omitting the properties the callback returns truey\n     * for. The callback is bound to `thisArg` and invoked with three arguments;\n     * (value, key, object).\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The source object.\n     * @param {Function|...string|string[]} [callback] The properties to omit or the\n     *  function called per iteration.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Object} Returns an object without the omitted properties.\n     * @example\n     *\n     * _.omit({ 'name': 'fred', 'age': 40 }, 'age');\n     * // => { 'name': 'fred' }\n     *\n     * _.omit({ 'name': 'fred', 'age': 40 }, function(value) {\n     *   return typeof value == 'number';\n     * });\n     * // => { 'name': 'fred' }\n     */\n    function omit(object, callback, thisArg) {\n      var result = {};\n      if (typeof callback != 'function') {\n        var props = [];\n        forIn(object, function(value, key) {\n          props.push(key);\n        });\n        props = baseDifference(props, baseFlatten(arguments, true, false, 1));\n\n        var index = -1,\n            length = props.length;\n\n        while (++index < length) {\n          var key = props[index];\n          result[key] = object[key];\n        }\n      } else {\n        callback = lodash.createCallback(callback, thisArg, 3);\n        forIn(object, function(value, key, object) {\n          if (!callback(value, key, object)) {\n            result[key] = value;\n          }\n        });\n      }\n      return result;\n    }\n\n    /**\n     * Creates a two dimensional array of an object's key-value pairs,\n     * i.e. `[[key1, value1], [key2, value2]]`.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The object to inspect.\n     * @returns {Array} Returns new array of key-value pairs.\n     * @example\n     *\n     * _.pairs({ 'barney': 36, 'fred': 40 });\n     * // => [['barney', 36], ['fred', 40]] (property order is not guaranteed across environments)\n     */\n    function pairs(object) {\n      var index = -1,\n          props = keys(object),\n          length = props.length,\n          result = Array(length);\n\n      while (++index < length) {\n        var key = props[index];\n        result[index] = [key, object[key]];\n      }\n      return result;\n    }\n\n    /**\n     * Creates a shallow clone of `object` composed of the specified properties.\n     * Property names may be specified as individual arguments or as arrays of\n     * property names. If a callback is provided it will be executed for each\n     * property of `object` picking the properties the callback returns truey\n     * for. The callback is bound to `thisArg` and invoked with three arguments;\n     * (value, key, object).\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The source object.\n     * @param {Function|...string|string[]} [callback] The function called per\n     *  iteration or property names to pick, specified as individual property\n     *  names or arrays of property names.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Object} Returns an object composed of the picked properties.\n     * @example\n     *\n     * _.pick({ 'name': 'fred', '_userid': 'fred1' }, 'name');\n     * // => { 'name': 'fred' }\n     *\n     * _.pick({ 'name': 'fred', '_userid': 'fred1' }, function(value, key) {\n     *   return key.charAt(0) != '_';\n     * });\n     * // => { 'name': 'fred' }\n     */\n    function pick(object, callback, thisArg) {\n      var result = {};\n      if (typeof callback != 'function') {\n        var index = -1,\n            props = baseFlatten(arguments, true, false, 1),\n            length = isObject(object) ? props.length : 0;\n\n        while (++index < length) {\n          var key = props[index];\n          if (key in object) {\n            result[key] = object[key];\n          }\n        }\n      } else {\n        callback = lodash.createCallback(callback, thisArg, 3);\n        forIn(object, function(value, key, object) {\n          if (callback(value, key, object)) {\n            result[key] = value;\n          }\n        });\n      }\n      return result;\n    }\n\n    /**\n     * An alternative to `_.reduce` this method transforms `object` to a new\n     * `accumulator` object which is the result of running each of its own\n     * enumerable properties through a callback, with each callback execution\n     * potentially mutating the `accumulator` object. The callback is bound to\n     * `thisArg` and invoked with four arguments; (accumulator, value, key, object).\n     * Callbacks may exit iteration early by explicitly returning `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Array|Object} object The object to iterate over.\n     * @param {Function} [callback=identity] The function called per iteration.\n     * @param {*} [accumulator] The custom accumulator value.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {*} Returns the accumulated value.\n     * @example\n     *\n     * var squares = _.transform([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], function(result, num) {\n     *   num *= num;\n     *   if (num % 2) {\n     *     return result.push(num) < 3;\n     *   }\n     * });\n     * // => [1, 9, 25]\n     *\n     * var mapped = _.transform({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {\n     *   result[key] = num * 3;\n     * });\n     * // => { 'a': 3, 'b': 6, 'c': 9 }\n     */\n    function transform(object, callback, accumulator, thisArg) {\n      var isArr = isArray(object);\n      if (accumulator == null) {\n        if (isArr) {\n          accumulator = [];\n        } else {\n          var ctor = object && object.constructor,\n              proto = ctor && ctor.prototype;\n\n          accumulator = baseCreate(proto);\n        }\n      }\n      if (callback) {\n        callback = lodash.createCallback(callback, thisArg, 4);\n        (isArr ? forEach : forOwn)(object, function(value, index, object) {\n          return callback(accumulator, value, index, object);\n        });\n      }\n      return accumulator;\n    }\n\n    /**\n     * Creates an array composed of the own enumerable property values of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The object to inspect.\n     * @returns {Array} Returns an array of property values.\n     * @example\n     *\n     * _.values({ 'one': 1, 'two': 2, 'three': 3 });\n     * // => [1, 2, 3] (property order is not guaranteed across environments)\n     */\n    function values(object) {\n      var index = -1,\n          props = keys(object),\n          length = props.length,\n          result = Array(length);\n\n      while (++index < length) {\n        result[index] = object[props[index]];\n      }\n      return result;\n    }\n\n    /*--------------------------------------------------------------------------*/\n\n    /**\n     * Creates an array of elements from the specified indexes, or keys, of the\n     * `collection`. Indexes may be specified as individual arguments or as arrays\n     * of indexes.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {...(number|number[]|string|string[])} [index] The indexes of `collection`\n     *   to retrieve, specified as individual indexes or arrays of indexes.\n     * @returns {Array} Returns a new array of elements corresponding to the\n     *  provided indexes.\n     * @example\n     *\n     * _.at(['a', 'b', 'c', 'd', 'e'], [0, 2, 4]);\n     * // => ['a', 'c', 'e']\n     *\n     * _.at(['fred', 'barney', 'pebbles'], 0, 2);\n     * // => ['fred', 'pebbles']\n     */\n    function at(collection) {\n      var args = arguments,\n          index = -1,\n          props = baseFlatten(args, true, false, 1),\n          length = (args[2] && args[2][args[1]] === collection) ? 1 : props.length,\n          result = Array(length);\n\n      while(++index < length) {\n        result[index] = collection[props[index]];\n      }\n      return result;\n    }\n\n    /**\n     * Checks if a given value is present in a collection using strict equality\n     * for comparisons, i.e. `===`. If `fromIndex` is negative, it is used as the\n     * offset from the end of the collection.\n     *\n     * @static\n     * @memberOf _\n     * @alias include\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {*} target The value to check for.\n     * @param {number} [fromIndex=0] The index to search from.\n     * @returns {boolean} Returns `true` if the `target` element is found, else `false`.\n     * @example\n     *\n     * _.contains([1, 2, 3], 1);\n     * // => true\n     *\n     * _.contains([1, 2, 3], 1, 2);\n     * // => false\n     *\n     * _.contains({ 'name': 'fred', 'age': 40 }, 'fred');\n     * // => true\n     *\n     * _.contains('pebbles', 'eb');\n     * // => true\n     */\n    function contains(collection, target, fromIndex) {\n      var index = -1,\n          indexOf = getIndexOf(),\n          length = collection ? collection.length : 0,\n          result = false;\n\n      fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex) || 0;\n      if (isArray(collection)) {\n        result = indexOf(collection, target, fromIndex) > -1;\n      } else if (typeof length == 'number') {\n        result = (isString(collection) ? collection.indexOf(target, fromIndex) : indexOf(collection, target, fromIndex)) > -1;\n      } else {\n        forOwn(collection, function(value) {\n          if (++index >= fromIndex) {\n            return !(result = value === target);\n          }\n        });\n      }\n      return result;\n    }\n\n    /**\n     * Creates an object composed of keys generated from the results of running\n     * each element of `collection` through the callback. The corresponding value\n     * of each key is the number of times the key was returned by the callback.\n     * The callback is bound to `thisArg` and invoked with three arguments;\n     * (value, index|key, collection).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Object} Returns the composed aggregate object.\n     * @example\n     *\n     * _.countBy([4.3, 6.1, 6.4], function(num) { return Math.floor(num); });\n     * // => { '4': 1, '6': 2 }\n     *\n     * _.countBy([4.3, 6.1, 6.4], function(num) { return this.floor(num); }, Math);\n     * // => { '4': 1, '6': 2 }\n     *\n     * _.countBy(['one', 'two', 'three'], 'length');\n     * // => { '3': 2, '5': 1 }\n     */\n    var countBy = createAggregator(function(result, value, key) {\n      (hasOwnProperty.call(result, key) ? result[key]++ : result[key] = 1);\n    });\n\n    /**\n     * Checks if the given callback returns truey value for **all** elements of\n     * a collection. The callback is bound to `thisArg` and invoked with three\n     * arguments; (value, index|key, collection).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @alias all\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {boolean} Returns `true` if all elements passed the callback check,\n     *  else `false`.\n     * @example\n     *\n     * _.every([true, 1, null, 'yes']);\n     * // => false\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36 },\n     *   { 'name': 'fred',   'age': 40 }\n     * ];\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.every(characters, 'age');\n     * // => true\n     *\n     * // using \"_.where\" callback shorthand\n     * _.every(characters, { 'age': 36 });\n     * // => false\n     */\n    function every(collection, callback, thisArg) {\n      var result = true;\n      callback = lodash.createCallback(callback, thisArg, 3);\n\n      var index = -1,\n          length = collection ? collection.length : 0;\n\n      if (typeof length == 'number') {\n        while (++index < length) {\n          if (!(result = !!callback(collection[index], index, collection))) {\n            break;\n          }\n        }\n      } else {\n        forOwn(collection, function(value, index, collection) {\n          return (result = !!callback(value, index, collection));\n        });\n      }\n      return result;\n    }\n\n    /**\n     * Iterates over elements of a collection, returning an array of all elements\n     * the callback returns truey for. The callback is bound to `thisArg` and\n     * invoked with three arguments; (value, index|key, collection).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @alias select\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Array} Returns a new array of elements that passed the callback check.\n     * @example\n     *\n     * var evens = _.filter([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });\n     * // => [2, 4, 6]\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36, 'blocked': false },\n     *   { 'name': 'fred',   'age': 40, 'blocked': true }\n     * ];\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.filter(characters, 'blocked');\n     * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]\n     *\n     * // using \"_.where\" callback shorthand\n     * _.filter(characters, { 'age': 36 });\n     * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]\n     */\n    function filter(collection, callback, thisArg) {\n      var result = [];\n      callback = lodash.createCallback(callback, thisArg, 3);\n\n      var index = -1,\n          length = collection ? collection.length : 0;\n\n      if (typeof length == 'number') {\n        while (++index < length) {\n          var value = collection[index];\n          if (callback(value, index, collection)) {\n            result.push(value);\n          }\n        }\n      } else {\n        forOwn(collection, function(value, index, collection) {\n          if (callback(value, index, collection)) {\n            result.push(value);\n          }\n        });\n      }\n      return result;\n    }\n\n    /**\n     * Iterates over elements of a collection, returning the first element that\n     * the callback returns truey for. The callback is bound to `thisArg` and\n     * invoked with three arguments; (value, index|key, collection).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @alias detect, findWhere\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {*} Returns the found element, else `undefined`.\n     * @example\n     *\n     * var characters = [\n     *   { 'name': 'barney',  'age': 36, 'blocked': false },\n     *   { 'name': 'fred',    'age': 40, 'blocked': true },\n     *   { 'name': 'pebbles', 'age': 1,  'blocked': false }\n     * ];\n     *\n     * _.find(characters, function(chr) {\n     *   return chr.age < 40;\n     * });\n     * // => { 'name': 'barney', 'age': 36, 'blocked': false }\n     *\n     * // using \"_.where\" callback shorthand\n     * _.find(characters, { 'age': 1 });\n     * // =>  { 'name': 'pebbles', 'age': 1, 'blocked': false }\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.find(characters, 'blocked');\n     * // => { 'name': 'fred', 'age': 40, 'blocked': true }\n     */\n    function find(collection, callback, thisArg) {\n      callback = lodash.createCallback(callback, thisArg, 3);\n\n      var index = -1,\n          length = collection ? collection.length : 0;\n\n      if (typeof length == 'number') {\n        while (++index < length) {\n          var value = collection[index];\n          if (callback(value, index, collection)) {\n            return value;\n          }\n        }\n      } else {\n        var result;\n        forOwn(collection, function(value, index, collection) {\n          if (callback(value, index, collection)) {\n            result = value;\n            return false;\n          }\n        });\n        return result;\n      }\n    }\n\n    /**\n     * This method is like `_.find` except that it iterates over elements\n     * of a `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {*} Returns the found element, else `undefined`.\n     * @example\n     *\n     * _.findLast([1, 2, 3, 4], function(num) {\n     *   return num % 2 == 1;\n     * });\n     * // => 3\n     */\n    function findLast(collection, callback, thisArg) {\n      var result;\n      callback = lodash.createCallback(callback, thisArg, 3);\n      forEachRight(collection, function(value, index, collection) {\n        if (callback(value, index, collection)) {\n          result = value;\n          return false;\n        }\n      });\n      return result;\n    }\n\n    /**\n     * Iterates over elements of a collection, executing the callback for each\n     * element. The callback is bound to `thisArg` and invoked with three arguments;\n     * (value, index|key, collection). Callbacks may exit iteration early by\n     * explicitly returning `false`.\n     *\n     * Note: As with other \"Collections\" methods, objects with a `length` property\n     * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`\n     * may be used for object iteration.\n     *\n     * @static\n     * @memberOf _\n     * @alias each\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function} [callback=identity] The function called per iteration.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Array|Object|string} Returns `collection`.\n     * @example\n     *\n     * _([1, 2, 3]).forEach(function(num) { console.log(num); }).join(',');\n     * // => logs each number and returns '1,2,3'\n     *\n     * _.forEach({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { console.log(num); });\n     * // => logs each number and returns the object (property order is not guaranteed across environments)\n     */\n    function forEach(collection, callback, thisArg) {\n      var index = -1,\n          length = collection ? collection.length : 0;\n\n      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);\n      if (typeof length == 'number') {\n        while (++index < length) {\n          if (callback(collection[index], index, collection) === false) {\n            break;\n          }\n        }\n      } else {\n        forOwn(collection, callback);\n      }\n      return collection;\n    }\n\n    /**\n     * This method is like `_.forEach` except that it iterates over elements\n     * of a `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @alias eachRight\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function} [callback=identity] The function called per iteration.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Array|Object|string} Returns `collection`.\n     * @example\n     *\n     * _([1, 2, 3]).forEachRight(function(num) { console.log(num); }).join(',');\n     * // => logs each number from right to left and returns '3,2,1'\n     */\n    function forEachRight(collection, callback, thisArg) {\n      var length = collection ? collection.length : 0;\n      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);\n      if (typeof length == 'number') {\n        while (length--) {\n          if (callback(collection[length], length, collection) === false) {\n            break;\n          }\n        }\n      } else {\n        var props = keys(collection);\n        length = props.length;\n        forOwn(collection, function(value, key, collection) {\n          key = props ? props[--length] : --length;\n          return callback(collection[key], key, collection);\n        });\n      }\n      return collection;\n    }\n\n    /**\n     * Creates an object composed of keys generated from the results of running\n     * each element of a collection through the callback. The corresponding value\n     * of each key is an array of the elements responsible for generating the key.\n     * The callback is bound to `thisArg` and invoked with three arguments;\n     * (value, index|key, collection).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Object} Returns the composed aggregate object.\n     * @example\n     *\n     * _.groupBy([4.2, 6.1, 6.4], function(num) { return Math.floor(num); });\n     * // => { '4': [4.2], '6': [6.1, 6.4] }\n     *\n     * _.groupBy([4.2, 6.1, 6.4], function(num) { return this.floor(num); }, Math);\n     * // => { '4': [4.2], '6': [6.1, 6.4] }\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.groupBy(['one', 'two', 'three'], 'length');\n     * // => { '3': ['one', 'two'], '5': ['three'] }\n     */\n    var groupBy = createAggregator(function(result, value, key) {\n      (hasOwnProperty.call(result, key) ? result[key] : result[key] = []).push(value);\n    });\n\n    /**\n     * Creates an object composed of keys generated from the results of running\n     * each element of the collection through the given callback. The corresponding\n     * value of each key is the last element responsible for generating the key.\n     * The callback is bound to `thisArg` and invoked with three arguments;\n     * (value, index|key, collection).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Object} Returns the composed aggregate object.\n     * @example\n     *\n     * var keys = [\n     *   { 'dir': 'left', 'code': 97 },\n     *   { 'dir': 'right', 'code': 100 }\n     * ];\n     *\n     * _.indexBy(keys, 'dir');\n     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }\n     *\n     * _.indexBy(keys, function(key) { return String.fromCharCode(key.code); });\n     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }\n     *\n     * _.indexBy(characters, function(key) { this.fromCharCode(key.code); }, String);\n     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }\n     */\n    var indexBy = createAggregator(function(result, value, key) {\n      result[key] = value;\n    });\n\n    /**\n     * Invokes the method named by `methodName` on each element in the `collection`\n     * returning an array of the results of each invoked method. Additional arguments\n     * will be provided to each invoked method. If `methodName` is a function it\n     * will be invoked for, and `this` bound to, each element in the `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|string} methodName The name of the method to invoke or\n     *  the function invoked per iteration.\n     * @param {...*} [arg] Arguments to invoke the method with.\n     * @returns {Array} Returns a new array of the results of each invoked method.\n     * @example\n     *\n     * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');\n     * // => [[1, 5, 7], [1, 2, 3]]\n     *\n     * _.invoke([123, 456], String.prototype.split, '');\n     * // => [['1', '2', '3'], ['4', '5', '6']]\n     */\n    function invoke(collection, methodName) {\n      var args = slice(arguments, 2),\n          index = -1,\n          isFunc = typeof methodName == 'function',\n          length = collection ? collection.length : 0,\n          result = Array(typeof length == 'number' ? length : 0);\n\n      forEach(collection, function(value) {\n        result[++index] = (isFunc ? methodName : value[methodName]).apply(value, args);\n      });\n      return result;\n    }\n\n    /**\n     * Creates an array of values by running each element in the collection\n     * through the callback. The callback is bound to `thisArg` and invoked with\n     * three arguments; (value, index|key, collection).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @alias collect\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Array} Returns a new array of the results of each `callback` execution.\n     * @example\n     *\n     * _.map([1, 2, 3], function(num) { return num * 3; });\n     * // => [3, 6, 9]\n     *\n     * _.map({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { return num * 3; });\n     * // => [3, 6, 9] (property order is not guaranteed across environments)\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36 },\n     *   { 'name': 'fred',   'age': 40 }\n     * ];\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.map(characters, 'name');\n     * // => ['barney', 'fred']\n     */\n    function map(collection, callback, thisArg) {\n      var index = -1,\n          length = collection ? collection.length : 0;\n\n      callback = lodash.createCallback(callback, thisArg, 3);\n      if (typeof length == 'number') {\n        var result = Array(length);\n        while (++index < length) {\n          result[index] = callback(collection[index], index, collection);\n        }\n      } else {\n        result = [];\n        forOwn(collection, function(value, key, collection) {\n          result[++index] = callback(value, key, collection);\n        });\n      }\n      return result;\n    }\n\n    /**\n     * Retrieves the maximum value of a collection. If the collection is empty or\n     * falsey `-Infinity` is returned. If a callback is provided it will be executed\n     * for each value in the collection to generate the criterion by which the value\n     * is ranked. The callback is bound to `thisArg` and invoked with three\n     * arguments; (value, index, collection).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {*} Returns the maximum value.\n     * @example\n     *\n     * _.max([4, 2, 8, 6]);\n     * // => 8\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36 },\n     *   { 'name': 'fred',   'age': 40 }\n     * ];\n     *\n     * _.max(characters, function(chr) { return chr.age; });\n     * // => { 'name': 'fred', 'age': 40 };\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.max(characters, 'age');\n     * // => { 'name': 'fred', 'age': 40 };\n     */\n    function max(collection, callback, thisArg) {\n      var computed = -Infinity,\n          result = computed;\n\n      // allows working with functions like `_.map` without using\n      // their `index` argument as a callback\n      if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {\n        callback = null;\n      }\n      if (callback == null && isArray(collection)) {\n        var index = -1,\n            length = collection.length;\n\n        while (++index < length) {\n          var value = collection[index];\n          if (value > result) {\n            result = value;\n          }\n        }\n      } else {\n        callback = (callback == null && isString(collection))\n          ? charAtCallback\n          : lodash.createCallback(callback, thisArg, 3);\n\n        forEach(collection, function(value, index, collection) {\n          var current = callback(value, index, collection);\n          if (current > computed) {\n            computed = current;\n            result = value;\n          }\n        });\n      }\n      return result;\n    }\n\n    /**\n     * Retrieves the minimum value of a collection. If the collection is empty or\n     * falsey `Infinity` is returned. If a callback is provided it will be executed\n     * for each value in the collection to generate the criterion by which the value\n     * is ranked. The callback is bound to `thisArg` and invoked with three\n     * arguments; (value, index, collection).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {*} Returns the minimum value.\n     * @example\n     *\n     * _.min([4, 2, 8, 6]);\n     * // => 2\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36 },\n     *   { 'name': 'fred',   'age': 40 }\n     * ];\n     *\n     * _.min(characters, function(chr) { return chr.age; });\n     * // => { 'name': 'barney', 'age': 36 };\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.min(characters, 'age');\n     * // => { 'name': 'barney', 'age': 36 };\n     */\n    function min(collection, callback, thisArg) {\n      var computed = Infinity,\n          result = computed;\n\n      // allows working with functions like `_.map` without using\n      // their `index` argument as a callback\n      if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {\n        callback = null;\n      }\n      if (callback == null && isArray(collection)) {\n        var index = -1,\n            length = collection.length;\n\n        while (++index < length) {\n          var value = collection[index];\n          if (value < result) {\n            result = value;\n          }\n        }\n      } else {\n        callback = (callback == null && isString(collection))\n          ? charAtCallback\n          : lodash.createCallback(callback, thisArg, 3);\n\n        forEach(collection, function(value, index, collection) {\n          var current = callback(value, index, collection);\n          if (current < computed) {\n            computed = current;\n            result = value;\n          }\n        });\n      }\n      return result;\n    }\n\n    /**\n     * Retrieves the value of a specified property from all elements in the collection.\n     *\n     * @static\n     * @memberOf _\n     * @type Function\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {string} property The name of the property to pluck.\n     * @returns {Array} Returns a new array of property values.\n     * @example\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36 },\n     *   { 'name': 'fred',   'age': 40 }\n     * ];\n     *\n     * _.pluck(characters, 'name');\n     * // => ['barney', 'fred']\n     */\n    var pluck = map;\n\n    /**\n     * Reduces a collection to a value which is the accumulated result of running\n     * each element in the collection through the callback, where each successive\n     * callback execution consumes the return value of the previous execution. If\n     * `accumulator` is not provided the first element of the collection will be\n     * used as the initial `accumulator` value. The callback is bound to `thisArg`\n     * and invoked with four arguments; (accumulator, value, index|key, collection).\n     *\n     * @static\n     * @memberOf _\n     * @alias foldl, inject\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function} [callback=identity] The function called per iteration.\n     * @param {*} [accumulator] Initial value of the accumulator.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {*} Returns the accumulated value.\n     * @example\n     *\n     * var sum = _.reduce([1, 2, 3], function(sum, num) {\n     *   return sum + num;\n     * });\n     * // => 6\n     *\n     * var mapped = _.reduce({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {\n     *   result[key] = num * 3;\n     *   return result;\n     * }, {});\n     * // => { 'a': 3, 'b': 6, 'c': 9 }\n     */\n    function reduce(collection, callback, accumulator, thisArg) {\n      if (!collection) return accumulator;\n      var noaccum = arguments.length < 3;\n      callback = lodash.createCallback(callback, thisArg, 4);\n\n      var index = -1,\n          length = collection.length;\n\n      if (typeof length == 'number') {\n        if (noaccum) {\n          accumulator = collection[++index];\n        }\n        while (++index < length) {\n          accumulator = callback(accumulator, collection[index], index, collection);\n        }\n      } else {\n        forOwn(collection, function(value, index, collection) {\n          accumulator = noaccum\n            ? (noaccum = false, value)\n            : callback(accumulator, value, index, collection)\n        });\n      }\n      return accumulator;\n    }\n\n    /**\n     * This method is like `_.reduce` except that it iterates over elements\n     * of a `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @alias foldr\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function} [callback=identity] The function called per iteration.\n     * @param {*} [accumulator] Initial value of the accumulator.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {*} Returns the accumulated value.\n     * @example\n     *\n     * var list = [[0, 1], [2, 3], [4, 5]];\n     * var flat = _.reduceRight(list, function(a, b) { return a.concat(b); }, []);\n     * // => [4, 5, 2, 3, 0, 1]\n     */\n    function reduceRight(collection, callback, accumulator, thisArg) {\n      var noaccum = arguments.length < 3;\n      callback = lodash.createCallback(callback, thisArg, 4);\n      forEachRight(collection, function(value, index, collection) {\n        accumulator = noaccum\n          ? (noaccum = false, value)\n          : callback(accumulator, value, index, collection);\n      });\n      return accumulator;\n    }\n\n    /**\n     * The opposite of `_.filter` this method returns the elements of a\n     * collection that the callback does **not** return truey for.\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Array} Returns a new array of elements that failed the callback check.\n     * @example\n     *\n     * var odds = _.reject([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });\n     * // => [1, 3, 5]\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36, 'blocked': false },\n     *   { 'name': 'fred',   'age': 40, 'blocked': true }\n     * ];\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.reject(characters, 'blocked');\n     * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]\n     *\n     * // using \"_.where\" callback shorthand\n     * _.reject(characters, { 'age': 36 });\n     * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]\n     */\n    function reject(collection, callback, thisArg) {\n      callback = lodash.createCallback(callback, thisArg, 3);\n      return filter(collection, function(value, index, collection) {\n        return !callback(value, index, collection);\n      });\n    }\n\n    /**\n     * Retrieves a random element or `n` random elements from a collection.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to sample.\n     * @param {number} [n] The number of elements to sample.\n     * @param- {Object} [guard] Allows working with functions like `_.map`\n     *  without using their `index` arguments as `n`.\n     * @returns {Array} Returns the random sample(s) of `collection`.\n     * @example\n     *\n     * _.sample([1, 2, 3, 4]);\n     * // => 2\n     *\n     * _.sample([1, 2, 3, 4], 2);\n     * // => [3, 1]\n     */\n    function sample(collection, n, guard) {\n      if (collection && typeof collection.length != 'number') {\n        collection = values(collection);\n      }\n      if (n == null || guard) {\n        return collection ? collection[baseRandom(0, collection.length - 1)] : undefined;\n      }\n      var result = shuffle(collection);\n      result.length = nativeMin(nativeMax(0, n), result.length);\n      return result;\n    }\n\n    /**\n     * Creates an array of shuffled values, using a version of the Fisher-Yates\n     * shuffle. See http://en.wikipedia.org/wiki/Fisher-Yates_shuffle.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to shuffle.\n     * @returns {Array} Returns a new shuffled collection.\n     * @example\n     *\n     * _.shuffle([1, 2, 3, 4, 5, 6]);\n     * // => [4, 1, 6, 3, 5, 2]\n     */\n    function shuffle(collection) {\n      var index = -1,\n          length = collection ? collection.length : 0,\n          result = Array(typeof length == 'number' ? length : 0);\n\n      forEach(collection, function(value) {\n        var rand = baseRandom(0, ++index);\n        result[index] = result[rand];\n        result[rand] = value;\n      });\n      return result;\n    }\n\n    /**\n     * Gets the size of the `collection` by returning `collection.length` for arrays\n     * and array-like objects or the number of own enumerable properties for objects.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to inspect.\n     * @returns {number} Returns `collection.length` or number of own enumerable properties.\n     * @example\n     *\n     * _.size([1, 2]);\n     * // => 2\n     *\n     * _.size({ 'one': 1, 'two': 2, 'three': 3 });\n     * // => 3\n     *\n     * _.size('pebbles');\n     * // => 7\n     */\n    function size(collection) {\n      var length = collection ? collection.length : 0;\n      return typeof length == 'number' ? length : keys(collection).length;\n    }\n\n    /**\n     * Checks if the callback returns a truey value for **any** element of a\n     * collection. The function returns as soon as it finds a passing value and\n     * does not iterate over the entire collection. The callback is bound to\n     * `thisArg` and invoked with three arguments; (value, index|key, collection).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @alias any\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {boolean} Returns `true` if any element passed the callback check,\n     *  else `false`.\n     * @example\n     *\n     * _.some([null, 0, 'yes', false], Boolean);\n     * // => true\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36, 'blocked': false },\n     *   { 'name': 'fred',   'age': 40, 'blocked': true }\n     * ];\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.some(characters, 'blocked');\n     * // => true\n     *\n     * // using \"_.where\" callback shorthand\n     * _.some(characters, { 'age': 1 });\n     * // => false\n     */\n    function some(collection, callback, thisArg) {\n      var result;\n      callback = lodash.createCallback(callback, thisArg, 3);\n\n      var index = -1,\n          length = collection ? collection.length : 0;\n\n      if (typeof length == 'number') {\n        while (++index < length) {\n          if ((result = callback(collection[index], index, collection))) {\n            break;\n          }\n        }\n      } else {\n        forOwn(collection, function(value, index, collection) {\n          return !(result = callback(value, index, collection));\n        });\n      }\n      return !!result;\n    }\n\n    /**\n     * Creates an array of elements, sorted in ascending order by the results of\n     * running each element in a collection through the callback. This method\n     * performs a stable sort, that is, it will preserve the original sort order\n     * of equal elements. The callback is bound to `thisArg` and invoked with\n     * three arguments; (value, index|key, collection).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an array of property names is provided for `callback` the collection\n     * will be sorted by each property value.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Array|Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Array} Returns a new array of sorted elements.\n     * @example\n     *\n     * _.sortBy([1, 2, 3], function(num) { return Math.sin(num); });\n     * // => [3, 1, 2]\n     *\n     * _.sortBy([1, 2, 3], function(num) { return this.sin(num); }, Math);\n     * // => [3, 1, 2]\n     *\n     * var characters = [\n     *   { 'name': 'barney',  'age': 36 },\n     *   { 'name': 'fred',    'age': 40 },\n     *   { 'name': 'barney',  'age': 26 },\n     *   { 'name': 'fred',    'age': 30 }\n     * ];\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.map(_.sortBy(characters, 'age'), _.values);\n     * // => [['barney', 26], ['fred', 30], ['barney', 36], ['fred', 40]]\n     *\n     * // sorting by multiple properties\n     * _.map(_.sortBy(characters, ['name', 'age']), _.values);\n     * // = > [['barney', 26], ['barney', 36], ['fred', 30], ['fred', 40]]\n     */\n    function sortBy(collection, callback, thisArg) {\n      var index = -1,\n          isArr = isArray(callback),\n          length = collection ? collection.length : 0,\n          result = Array(typeof length == 'number' ? length : 0);\n\n      if (!isArr) {\n        callback = lodash.createCallback(callback, thisArg, 3);\n      }\n      forEach(collection, function(value, key, collection) {\n        var object = result[++index] = getObject();\n        if (isArr) {\n          object.criteria = map(callback, function(key) { return value[key]; });\n        } else {\n          (object.criteria = getArray())[0] = callback(value, key, collection);\n        }\n        object.index = index;\n        object.value = value;\n      });\n\n      length = result.length;\n      result.sort(compareAscending);\n      while (length--) {\n        var object = result[length];\n        result[length] = object.value;\n        if (!isArr) {\n          releaseArray(object.criteria);\n        }\n        releaseObject(object);\n      }\n      return result;\n    }\n\n    /**\n     * Converts the `collection` to an array.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to convert.\n     * @returns {Array} Returns the new converted array.\n     * @example\n     *\n     * (function() { return _.toArray(arguments).slice(1); })(1, 2, 3, 4);\n     * // => [2, 3, 4]\n     */\n    function toArray(collection) {\n      if (collection && typeof collection.length == 'number') {\n        return slice(collection);\n      }\n      return values(collection);\n    }\n\n    /**\n     * Performs a deep comparison of each element in a `collection` to the given\n     * `properties` object, returning an array of all elements that have equivalent\n     * property values.\n     *\n     * @static\n     * @memberOf _\n     * @type Function\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Object} props The object of property values to filter by.\n     * @returns {Array} Returns a new array of elements that have the given properties.\n     * @example\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36, 'pets': ['hoppy'] },\n     *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }\n     * ];\n     *\n     * _.where(characters, { 'age': 36 });\n     * // => [{ 'name': 'barney', 'age': 36, 'pets': ['hoppy'] }]\n     *\n     * _.where(characters, { 'pets': ['dino'] });\n     * // => [{ 'name': 'fred', 'age': 40, 'pets': ['baby puss', 'dino'] }]\n     */\n    var where = filter;\n\n    /*--------------------------------------------------------------------------*/\n\n    /**\n     * Creates an array with all falsey values removed. The values `false`, `null`,\n     * `0`, `\"\"`, `undefined`, and `NaN` are all falsey.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to compact.\n     * @returns {Array} Returns a new array of filtered values.\n     * @example\n     *\n     * _.compact([0, 1, false, 2, '', 3]);\n     * // => [1, 2, 3]\n     */\n    function compact(array) {\n      var index = -1,\n          length = array ? array.length : 0,\n          result = [];\n\n      while (++index < length) {\n        var value = array[index];\n        if (value) {\n          result.push(value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Creates an array excluding all values of the provided arrays using strict\n     * equality for comparisons, i.e. `===`.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to process.\n     * @param {...Array} [values] The arrays of values to exclude.\n     * @returns {Array} Returns a new array of filtered values.\n     * @example\n     *\n     * _.difference([1, 2, 3, 4, 5], [5, 2, 10]);\n     * // => [1, 3, 4]\n     */\n    function difference(array) {\n      return baseDifference(array, baseFlatten(arguments, true, true, 1));\n    }\n\n    /**\n     * This method is like `_.find` except that it returns the index of the first\n     * element that passes the callback check, instead of the element itself.\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to search.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {number} Returns the index of the found element, else `-1`.\n     * @example\n     *\n     * var characters = [\n     *   { 'name': 'barney',  'age': 36, 'blocked': false },\n     *   { 'name': 'fred',    'age': 40, 'blocked': true },\n     *   { 'name': 'pebbles', 'age': 1,  'blocked': false }\n     * ];\n     *\n     * _.findIndex(characters, function(chr) {\n     *   return chr.age < 20;\n     * });\n     * // => 2\n     *\n     * // using \"_.where\" callback shorthand\n     * _.findIndex(characters, { 'age': 36 });\n     * // => 0\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.findIndex(characters, 'blocked');\n     * // => 1\n     */\n    function findIndex(array, callback, thisArg) {\n      var index = -1,\n          length = array ? array.length : 0;\n\n      callback = lodash.createCallback(callback, thisArg, 3);\n      while (++index < length) {\n        if (callback(array[index], index, array)) {\n          return index;\n        }\n      }\n      return -1;\n    }\n\n    /**\n     * This method is like `_.findIndex` except that it iterates over elements\n     * of a `collection` from right to left.\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to search.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {number} Returns the index of the found element, else `-1`.\n     * @example\n     *\n     * var characters = [\n     *   { 'name': 'barney',  'age': 36, 'blocked': true },\n     *   { 'name': 'fred',    'age': 40, 'blocked': false },\n     *   { 'name': 'pebbles', 'age': 1,  'blocked': true }\n     * ];\n     *\n     * _.findLastIndex(characters, function(chr) {\n     *   return chr.age > 30;\n     * });\n     * // => 1\n     *\n     * // using \"_.where\" callback shorthand\n     * _.findLastIndex(characters, { 'age': 36 });\n     * // => 0\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.findLastIndex(characters, 'blocked');\n     * // => 2\n     */\n    function findLastIndex(array, callback, thisArg) {\n      var length = array ? array.length : 0;\n      callback = lodash.createCallback(callback, thisArg, 3);\n      while (length--) {\n        if (callback(array[length], length, array)) {\n          return length;\n        }\n      }\n      return -1;\n    }\n\n    /**\n     * Gets the first element or first `n` elements of an array. If a callback\n     * is provided elements at the beginning of the array are returned as long\n     * as the callback returns truey. The callback is bound to `thisArg` and\n     * invoked with three arguments; (value, index, array).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @alias head, take\n     * @category Arrays\n     * @param {Array} array The array to query.\n     * @param {Function|Object|number|string} [callback] The function called\n     *  per element or the number of elements to return. If a property name or\n     *  object is provided it will be used to create a \"_.pluck\" or \"_.where\"\n     *  style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {*} Returns the first element(s) of `array`.\n     * @example\n     *\n     * _.first([1, 2, 3]);\n     * // => 1\n     *\n     * _.first([1, 2, 3], 2);\n     * // => [1, 2]\n     *\n     * _.first([1, 2, 3], function(num) {\n     *   return num < 3;\n     * });\n     * // => [1, 2]\n     *\n     * var characters = [\n     *   { 'name': 'barney',  'blocked': true,  'employer': 'slate' },\n     *   { 'name': 'fred',    'blocked': false, 'employer': 'slate' },\n     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }\n     * ];\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.first(characters, 'blocked');\n     * // => [{ 'name': 'barney', 'blocked': true, 'employer': 'slate' }]\n     *\n     * // using \"_.where\" callback shorthand\n     * _.pluck(_.first(characters, { 'employer': 'slate' }), 'name');\n     * // => ['barney', 'fred']\n     */\n    function first(array, callback, thisArg) {\n      var n = 0,\n          length = array ? array.length : 0;\n\n      if (typeof callback != 'number' && callback != null) {\n        var index = -1;\n        callback = lodash.createCallback(callback, thisArg, 3);\n        while (++index < length && callback(array[index], index, array)) {\n          n++;\n        }\n      } else {\n        n = callback;\n        if (n == null || thisArg) {\n          return array ? array[0] : undefined;\n        }\n      }\n      return slice(array, 0, nativeMin(nativeMax(0, n), length));\n    }\n\n    /**\n     * Flattens a nested array (the nesting can be to any depth). If `isShallow`\n     * is truey, the array will only be flattened a single level. If a callback\n     * is provided each element of the array is passed through the callback before\n     * flattening. The callback is bound to `thisArg` and invoked with three\n     * arguments; (value, index, array).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to flatten.\n     * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Array} Returns a new flattened array.\n     * @example\n     *\n     * _.flatten([1, [2], [3, [[4]]]]);\n     * // => [1, 2, 3, 4];\n     *\n     * _.flatten([1, [2], [3, [[4]]]], true);\n     * // => [1, 2, 3, [[4]]];\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 30, 'pets': ['hoppy'] },\n     *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }\n     * ];\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.flatten(characters, 'pets');\n     * // => ['hoppy', 'baby puss', 'dino']\n     */\n    function flatten(array, isShallow, callback, thisArg) {\n      // juggle arguments\n      if (typeof isShallow != 'boolean' && isShallow != null) {\n        thisArg = callback;\n        callback = (typeof isShallow != 'function' && thisArg && thisArg[isShallow] === array) ? null : isShallow;\n        isShallow = false;\n      }\n      if (callback != null) {\n        array = map(array, callback, thisArg);\n      }\n      return baseFlatten(array, isShallow);\n    }\n\n    /**\n     * Gets the index at which the first occurrence of `value` is found using\n     * strict equality for comparisons, i.e. `===`. If the array is already sorted\n     * providing `true` for `fromIndex` will run a faster binary search.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to search.\n     * @param {*} value The value to search for.\n     * @param {boolean|number} [fromIndex=0] The index to search from or `true`\n     *  to perform a binary search on a sorted array.\n     * @returns {number} Returns the index of the matched value or `-1`.\n     * @example\n     *\n     * _.indexOf([1, 2, 3, 1, 2, 3], 2);\n     * // => 1\n     *\n     * _.indexOf([1, 2, 3, 1, 2, 3], 2, 3);\n     * // => 4\n     *\n     * _.indexOf([1, 1, 2, 2, 3, 3], 2, true);\n     * // => 2\n     */\n    function indexOf(array, value, fromIndex) {\n      if (typeof fromIndex == 'number') {\n        var length = array ? array.length : 0;\n        fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex || 0);\n      } else if (fromIndex) {\n        var index = sortedIndex(array, value);\n        return array[index] === value ? index : -1;\n      }\n      return baseIndexOf(array, value, fromIndex);\n    }\n\n    /**\n     * Gets all but the last element or last `n` elements of an array. If a\n     * callback is provided elements at the end of the array are excluded from\n     * the result as long as the callback returns truey. The callback is bound\n     * to `thisArg` and invoked with three arguments; (value, index, array).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to query.\n     * @param {Function|Object|number|string} [callback=1] The function called\n     *  per element or the number of elements to exclude. If a property name or\n     *  object is provided it will be used to create a \"_.pluck\" or \"_.where\"\n     *  style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Array} Returns a slice of `array`.\n     * @example\n     *\n     * _.initial([1, 2, 3]);\n     * // => [1, 2]\n     *\n     * _.initial([1, 2, 3], 2);\n     * // => [1]\n     *\n     * _.initial([1, 2, 3], function(num) {\n     *   return num > 1;\n     * });\n     * // => [1]\n     *\n     * var characters = [\n     *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },\n     *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },\n     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }\n     * ];\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.initial(characters, 'blocked');\n     * // => [{ 'name': 'barney',  'blocked': false, 'employer': 'slate' }]\n     *\n     * // using \"_.where\" callback shorthand\n     * _.pluck(_.initial(characters, { 'employer': 'na' }), 'name');\n     * // => ['barney', 'fred']\n     */\n    function initial(array, callback, thisArg) {\n      var n = 0,\n          length = array ? array.length : 0;\n\n      if (typeof callback != 'number' && callback != null) {\n        var index = length;\n        callback = lodash.createCallback(callback, thisArg, 3);\n        while (index-- && callback(array[index], index, array)) {\n          n++;\n        }\n      } else {\n        n = (callback == null || thisArg) ? 1 : callback || n;\n      }\n      return slice(array, 0, nativeMin(nativeMax(0, length - n), length));\n    }\n\n    /**\n     * Creates an array of unique values present in all provided arrays using\n     * strict equality for comparisons, i.e. `===`.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {...Array} [array] The arrays to inspect.\n     * @returns {Array} Returns an array of shared values.\n     * @example\n     *\n     * _.intersection([1, 2, 3], [5, 2, 1, 4], [2, 1]);\n     * // => [1, 2]\n     */\n    function intersection() {\n      var args = [],\n          argsIndex = -1,\n          argsLength = arguments.length,\n          caches = getArray(),\n          indexOf = getIndexOf(),\n          trustIndexOf = indexOf === baseIndexOf,\n          seen = getArray();\n\n      while (++argsIndex < argsLength) {\n        var value = arguments[argsIndex];\n        if (isArray(value) || isArguments(value)) {\n          args.push(value);\n          caches.push(trustIndexOf && value.length >= largeArraySize &&\n            createCache(argsIndex ? args[argsIndex] : seen));\n        }\n      }\n      var array = args[0],\n          index = -1,\n          length = array ? array.length : 0,\n          result = [];\n\n      outer:\n      while (++index < length) {\n        var cache = caches[0];\n        value = array[index];\n\n        if ((cache ? cacheIndexOf(cache, value) : indexOf(seen, value)) < 0) {\n          argsIndex = argsLength;\n          (cache || seen).push(value);\n          while (--argsIndex) {\n            cache = caches[argsIndex];\n            if ((cache ? cacheIndexOf(cache, value) : indexOf(args[argsIndex], value)) < 0) {\n              continue outer;\n            }\n          }\n          result.push(value);\n        }\n      }\n      while (argsLength--) {\n        cache = caches[argsLength];\n        if (cache) {\n          releaseObject(cache);\n        }\n      }\n      releaseArray(caches);\n      releaseArray(seen);\n      return result;\n    }\n\n    /**\n     * Gets the last element or last `n` elements of an array. If a callback is\n     * provided elements at the end of the array are returned as long as the\n     * callback returns truey. The callback is bound to `thisArg` and invoked\n     * with three arguments; (value, index, array).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to query.\n     * @param {Function|Object|number|string} [callback] The function called\n     *  per element or the number of elements to return. If a property name or\n     *  object is provided it will be used to create a \"_.pluck\" or \"_.where\"\n     *  style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {*} Returns the last element(s) of `array`.\n     * @example\n     *\n     * _.last([1, 2, 3]);\n     * // => 3\n     *\n     * _.last([1, 2, 3], 2);\n     * // => [2, 3]\n     *\n     * _.last([1, 2, 3], function(num) {\n     *   return num > 1;\n     * });\n     * // => [2, 3]\n     *\n     * var characters = [\n     *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },\n     *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },\n     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }\n     * ];\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.pluck(_.last(characters, 'blocked'), 'name');\n     * // => ['fred', 'pebbles']\n     *\n     * // using \"_.where\" callback shorthand\n     * _.last(characters, { 'employer': 'na' });\n     * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]\n     */\n    function last(array, callback, thisArg) {\n      var n = 0,\n          length = array ? array.length : 0;\n\n      if (typeof callback != 'number' && callback != null) {\n        var index = length;\n        callback = lodash.createCallback(callback, thisArg, 3);\n        while (index-- && callback(array[index], index, array)) {\n          n++;\n        }\n      } else {\n        n = callback;\n        if (n == null || thisArg) {\n          return array ? array[length - 1] : undefined;\n        }\n      }\n      return slice(array, nativeMax(0, length - n));\n    }\n\n    /**\n     * Gets the index at which the last occurrence of `value` is found using strict\n     * equality for comparisons, i.e. `===`. If `fromIndex` is negative, it is used\n     * as the offset from the end of the collection.\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to search.\n     * @param {*} value The value to search for.\n     * @param {number} [fromIndex=array.length-1] The index to search from.\n     * @returns {number} Returns the index of the matched value or `-1`.\n     * @example\n     *\n     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2);\n     * // => 4\n     *\n     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2, 3);\n     * // => 1\n     */\n    function lastIndexOf(array, value, fromIndex) {\n      var index = array ? array.length : 0;\n      if (typeof fromIndex == 'number') {\n        index = (fromIndex < 0 ? nativeMax(0, index + fromIndex) : nativeMin(fromIndex, index - 1)) + 1;\n      }\n      while (index--) {\n        if (array[index] === value) {\n          return index;\n        }\n      }\n      return -1;\n    }\n\n    /**\n     * Removes all provided values from the given array using strict equality for\n     * comparisons, i.e. `===`.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to modify.\n     * @param {...*} [value] The values to remove.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = [1, 2, 3, 1, 2, 3];\n     * _.pull(array, 2, 3);\n     * console.log(array);\n     * // => [1, 1]\n     */\n    function pull(array) {\n      var args = arguments,\n          argsIndex = 0,\n          argsLength = args.length,\n          length = array ? array.length : 0;\n\n      while (++argsIndex < argsLength) {\n        var index = -1,\n            value = args[argsIndex];\n        while (++index < length) {\n          if (array[index] === value) {\n            splice.call(array, index--, 1);\n            length--;\n          }\n        }\n      }\n      return array;\n    }\n\n    /**\n     * Creates an array of numbers (positive and/or negative) progressing from\n     * `start` up to but not including `end`. If `start` is less than `stop` a\n     * zero-length range is created unless a negative `step` is specified.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {number} [start=0] The start of the range.\n     * @param {number} end The end of the range.\n     * @param {number} [step=1] The value to increment or decrement by.\n     * @returns {Array} Returns a new range array.\n     * @example\n     *\n     * _.range(4);\n     * // => [0, 1, 2, 3]\n     *\n     * _.range(1, 5);\n     * // => [1, 2, 3, 4]\n     *\n     * _.range(0, 20, 5);\n     * // => [0, 5, 10, 15]\n     *\n     * _.range(0, -4, -1);\n     * // => [0, -1, -2, -3]\n     *\n     * _.range(1, 4, 0);\n     * // => [1, 1, 1]\n     *\n     * _.range(0);\n     * // => []\n     */\n    function range(start, end, step) {\n      start = +start || 0;\n      step = typeof step == 'number' ? step : (+step || 1);\n\n      if (end == null) {\n        end = start;\n        start = 0;\n      }\n      // use `Array(length)` so engines like Chakra and V8 avoid slower modes\n      // http://youtu.be/XAqIpGU8ZZk#t=17m25s\n      var index = -1,\n          length = nativeMax(0, ceil((end - start) / (step || 1))),\n          result = Array(length);\n\n      while (++index < length) {\n        result[index] = start;\n        start += step;\n      }\n      return result;\n    }\n\n    /**\n     * Removes all elements from an array that the callback returns truey for\n     * and returns an array of removed elements. The callback is bound to `thisArg`\n     * and invoked with three arguments; (value, index, array).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to modify.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Array} Returns a new array of removed elements.\n     * @example\n     *\n     * var array = [1, 2, 3, 4, 5, 6];\n     * var evens = _.remove(array, function(num) { return num % 2 == 0; });\n     *\n     * console.log(array);\n     * // => [1, 3, 5]\n     *\n     * console.log(evens);\n     * // => [2, 4, 6]\n     */\n    function remove(array, callback, thisArg) {\n      var index = -1,\n          length = array ? array.length : 0,\n          result = [];\n\n      callback = lodash.createCallback(callback, thisArg, 3);\n      while (++index < length) {\n        var value = array[index];\n        if (callback(value, index, array)) {\n          result.push(value);\n          splice.call(array, index--, 1);\n          length--;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The opposite of `_.initial` this method gets all but the first element or\n     * first `n` elements of an array. If a callback function is provided elements\n     * at the beginning of the array are excluded from the result as long as the\n     * callback returns truey. The callback is bound to `thisArg` and invoked\n     * with three arguments; (value, index, array).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @alias drop, tail\n     * @category Arrays\n     * @param {Array} array The array to query.\n     * @param {Function|Object|number|string} [callback=1] The function called\n     *  per element or the number of elements to exclude. If a property name or\n     *  object is provided it will be used to create a \"_.pluck\" or \"_.where\"\n     *  style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Array} Returns a slice of `array`.\n     * @example\n     *\n     * _.rest([1, 2, 3]);\n     * // => [2, 3]\n     *\n     * _.rest([1, 2, 3], 2);\n     * // => [3]\n     *\n     * _.rest([1, 2, 3], function(num) {\n     *   return num < 3;\n     * });\n     * // => [3]\n     *\n     * var characters = [\n     *   { 'name': 'barney',  'blocked': true,  'employer': 'slate' },\n     *   { 'name': 'fred',    'blocked': false,  'employer': 'slate' },\n     *   { 'name': 'pebbles', 'blocked': true, 'employer': 'na' }\n     * ];\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.pluck(_.rest(characters, 'blocked'), 'name');\n     * // => ['fred', 'pebbles']\n     *\n     * // using \"_.where\" callback shorthand\n     * _.rest(characters, { 'employer': 'slate' });\n     * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]\n     */\n    function rest(array, callback, thisArg) {\n      if (typeof callback != 'number' && callback != null) {\n        var n = 0,\n            index = -1,\n            length = array ? array.length : 0;\n\n        callback = lodash.createCallback(callback, thisArg, 3);\n        while (++index < length && callback(array[index], index, array)) {\n          n++;\n        }\n      } else {\n        n = (callback == null || thisArg) ? 1 : nativeMax(0, callback);\n      }\n      return slice(array, n);\n    }\n\n    /**\n     * Uses a binary search to determine the smallest index at which a value\n     * should be inserted into a given sorted array in order to maintain the sort\n     * order of the array. If a callback is provided it will be executed for\n     * `value` and each element of `array` to compute their sort ranking. The\n     * callback is bound to `thisArg` and invoked with one argument; (value).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     * @example\n     *\n     * _.sortedIndex([20, 30, 50], 40);\n     * // => 2\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.sortedIndex([{ 'x': 20 }, { 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');\n     * // => 2\n     *\n     * var dict = {\n     *   'wordToNumber': { 'twenty': 20, 'thirty': 30, 'fourty': 40, 'fifty': 50 }\n     * };\n     *\n     * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {\n     *   return dict.wordToNumber[word];\n     * });\n     * // => 2\n     *\n     * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {\n     *   return this.wordToNumber[word];\n     * }, dict);\n     * // => 2\n     */\n    function sortedIndex(array, value, callback, thisArg) {\n      var low = 0,\n          high = array ? array.length : low;\n\n      // explicitly reference `identity` for better inlining in Firefox\n      callback = callback ? lodash.createCallback(callback, thisArg, 1) : identity;\n      value = callback(value);\n\n      while (low < high) {\n        var mid = (low + high) >>> 1;\n        (callback(array[mid]) < value)\n          ? low = mid + 1\n          : high = mid;\n      }\n      return low;\n    }\n\n    /**\n     * Creates an array of unique values, in order, of the provided arrays using\n     * strict equality for comparisons, i.e. `===`.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {...Array} [array] The arrays to inspect.\n     * @returns {Array} Returns an array of combined values.\n     * @example\n     *\n     * _.union([1, 2, 3], [5, 2, 1, 4], [2, 1]);\n     * // => [1, 2, 3, 5, 4]\n     */\n    function union() {\n      return baseUniq(baseFlatten(arguments, true, true));\n    }\n\n    /**\n     * Creates a duplicate-value-free version of an array using strict equality\n     * for comparisons, i.e. `===`. If the array is sorted, providing\n     * `true` for `isSorted` will use a faster algorithm. If a callback is provided\n     * each element of `array` is passed through the callback before uniqueness\n     * is computed. The callback is bound to `thisArg` and invoked with three\n     * arguments; (value, index, array).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @alias unique\n     * @category Arrays\n     * @param {Array} array The array to process.\n     * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Array} Returns a duplicate-value-free array.\n     * @example\n     *\n     * _.uniq([1, 2, 1, 3, 1]);\n     * // => [1, 2, 3]\n     *\n     * _.uniq([1, 1, 2, 2, 3], true);\n     * // => [1, 2, 3]\n     *\n     * _.uniq(['A', 'b', 'C', 'a', 'B', 'c'], function(letter) { return letter.toLowerCase(); });\n     * // => ['A', 'b', 'C']\n     *\n     * _.uniq([1, 2.5, 3, 1.5, 2, 3.5], function(num) { return this.floor(num); }, Math);\n     * // => [1, 2.5, 3]\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');\n     * // => [{ 'x': 1 }, { 'x': 2 }]\n     */\n    function uniq(array, isSorted, callback, thisArg) {\n      // juggle arguments\n      if (typeof isSorted != 'boolean' && isSorted != null) {\n        thisArg = callback;\n        callback = (typeof isSorted != 'function' && thisArg && thisArg[isSorted] === array) ? null : isSorted;\n        isSorted = false;\n      }\n      if (callback != null) {\n        callback = lodash.createCallback(callback, thisArg, 3);\n      }\n      return baseUniq(array, isSorted, callback);\n    }\n\n    /**\n     * Creates an array excluding all provided values using strict equality for\n     * comparisons, i.e. `===`.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to filter.\n     * @param {...*} [value] The values to exclude.\n     * @returns {Array} Returns a new array of filtered values.\n     * @example\n     *\n     * _.without([1, 2, 1, 0, 3, 1, 4], 0, 1);\n     * // => [2, 3, 4]\n     */\n    function without(array) {\n      return baseDifference(array, slice(arguments, 1));\n    }\n\n    /**\n     * Creates an array that is the symmetric difference of the provided arrays.\n     * See http://en.wikipedia.org/wiki/Symmetric_difference.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {...Array} [array] The arrays to inspect.\n     * @returns {Array} Returns an array of values.\n     * @example\n     *\n     * _.xor([1, 2, 3], [5, 2, 1, 4]);\n     * // => [3, 5, 4]\n     *\n     * _.xor([1, 2, 5], [2, 3, 5], [3, 4, 5]);\n     * // => [1, 4, 5]\n     */\n    function xor() {\n      var index = -1,\n          length = arguments.length;\n\n      while (++index < length) {\n        var array = arguments[index];\n        if (isArray(array) || isArguments(array)) {\n          var result = result\n            ? baseUniq(baseDifference(result, array).concat(baseDifference(array, result)))\n            : array;\n        }\n      }\n      return result || [];\n    }\n\n    /**\n     * Creates an array of grouped elements, the first of which contains the first\n     * elements of the given arrays, the second of which contains the second\n     * elements of the given arrays, and so on.\n     *\n     * @static\n     * @memberOf _\n     * @alias unzip\n     * @category Arrays\n     * @param {...Array} [array] Arrays to process.\n     * @returns {Array} Returns a new array of grouped elements.\n     * @example\n     *\n     * _.zip(['fred', 'barney'], [30, 40], [true, false]);\n     * // => [['fred', 30, true], ['barney', 40, false]]\n     */\n    function zip() {\n      var array = arguments.length > 1 ? arguments : arguments[0],\n          index = -1,\n          length = array ? max(pluck(array, 'length')) : 0,\n          result = Array(length < 0 ? 0 : length);\n\n      while (++index < length) {\n        result[index] = pluck(array, index);\n      }\n      return result;\n    }\n\n    /**\n     * Creates an object composed from arrays of `keys` and `values`. Provide\n     * either a single two dimensional array, i.e. `[[key1, value1], [key2, value2]]`\n     * or two arrays, one of `keys` and one of corresponding `values`.\n     *\n     * @static\n     * @memberOf _\n     * @alias object\n     * @category Arrays\n     * @param {Array} keys The array of keys.\n     * @param {Array} [values=[]] The array of values.\n     * @returns {Object} Returns an object composed of the given keys and\n     *  corresponding values.\n     * @example\n     *\n     * _.zipObject(['fred', 'barney'], [30, 40]);\n     * // => { 'fred': 30, 'barney': 40 }\n     */\n    function zipObject(keys, values) {\n      var index = -1,\n          length = keys ? keys.length : 0,\n          result = {};\n\n      if (!values && length && !isArray(keys[0])) {\n        values = [];\n      }\n      while (++index < length) {\n        var key = keys[index];\n        if (values) {\n          result[key] = values[index];\n        } else if (key) {\n          result[key[0]] = key[1];\n        }\n      }\n      return result;\n    }\n\n    /*--------------------------------------------------------------------------*/\n\n    /**\n     * Creates a function that executes `func`, with  the `this` binding and\n     * arguments of the created function, only after being called `n` times.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {number} n The number of times the function must be called before\n     *  `func` is executed.\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new restricted function.\n     * @example\n     *\n     * var saves = ['profile', 'settings'];\n     *\n     * var done = _.after(saves.length, function() {\n     *   console.log('Done saving!');\n     * });\n     *\n     * _.forEach(saves, function(type) {\n     *   asyncSave({ 'type': type, 'complete': done });\n     * });\n     * // => logs 'Done saving!', after all saves have completed\n     */\n    function after(n, func) {\n      if (!isFunction(func)) {\n        throw new TypeError;\n      }\n      return function() {\n        if (--n < 1) {\n          return func.apply(this, arguments);\n        }\n      };\n    }\n\n    /**\n     * Creates a function that, when called, invokes `func` with the `this`\n     * binding of `thisArg` and prepends any additional `bind` arguments to those\n     * provided to the bound function.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {Function} func The function to bind.\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @param {...*} [arg] Arguments to be partially applied.\n     * @returns {Function} Returns the new bound function.\n     * @example\n     *\n     * var func = function(greeting) {\n     *   return greeting + ' ' + this.name;\n     * };\n     *\n     * func = _.bind(func, { 'name': 'fred' }, 'hi');\n     * func();\n     * // => 'hi fred'\n     */\n    function bind(func, thisArg) {\n      return arguments.length > 2\n        ? createWrapper(func, 17, slice(arguments, 2), null, thisArg)\n        : createWrapper(func, 1, null, null, thisArg);\n    }\n\n    /**\n     * Binds methods of an object to the object itself, overwriting the existing\n     * method. Method names may be specified as individual arguments or as arrays\n     * of method names. If no method names are provided all the function properties\n     * of `object` will be bound.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {Object} object The object to bind and assign the bound methods to.\n     * @param {...string} [methodName] The object method names to\n     *  bind, specified as individual method names or arrays of method names.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var view = {\n     *   'label': 'docs',\n     *   'onClick': function() { console.log('clicked ' + this.label); }\n     * };\n     *\n     * _.bindAll(view);\n     * jQuery('#docs').on('click', view.onClick);\n     * // => logs 'clicked docs', when the button is clicked\n     */\n    function bindAll(object) {\n      var funcs = arguments.length > 1 ? baseFlatten(arguments, true, false, 1) : functions(object),\n          index = -1,\n          length = funcs.length;\n\n      while (++index < length) {\n        var key = funcs[index];\n        object[key] = createWrapper(object[key], 1, null, null, object);\n      }\n      return object;\n    }\n\n    /**\n     * Creates a function that, when called, invokes the method at `object[key]`\n     * and prepends any additional `bindKey` arguments to those provided to the bound\n     * function. This method differs from `_.bind` by allowing bound functions to\n     * reference methods that will be redefined or don't yet exist.\n     * See http://michaux.ca/articles/lazy-function-definition-pattern.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {Object} object The object the method belongs to.\n     * @param {string} key The key of the method.\n     * @param {...*} [arg] Arguments to be partially applied.\n     * @returns {Function} Returns the new bound function.\n     * @example\n     *\n     * var object = {\n     *   'name': 'fred',\n     *   'greet': function(greeting) {\n     *     return greeting + ' ' + this.name;\n     *   }\n     * };\n     *\n     * var func = _.bindKey(object, 'greet', 'hi');\n     * func();\n     * // => 'hi fred'\n     *\n     * object.greet = function(greeting) {\n     *   return greeting + 'ya ' + this.name + '!';\n     * };\n     *\n     * func();\n     * // => 'hiya fred!'\n     */\n    function bindKey(object, key) {\n      return arguments.length > 2\n        ? createWrapper(key, 19, slice(arguments, 2), null, object)\n        : createWrapper(key, 3, null, null, object);\n    }\n\n    /**\n     * Creates a function that is the composition of the provided functions,\n     * where each function consumes the return value of the function that follows.\n     * For example, composing the functions `f()`, `g()`, and `h()` produces `f(g(h()))`.\n     * Each function is executed with the `this` binding of the composed function.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {...Function} [func] Functions to compose.\n     * @returns {Function} Returns the new composed function.\n     * @example\n     *\n     * var realNameMap = {\n     *   'pebbles': 'penelope'\n     * };\n     *\n     * var format = function(name) {\n     *   name = realNameMap[name.toLowerCase()] || name;\n     *   return name.charAt(0).toUpperCase() + name.slice(1).toLowerCase();\n     * };\n     *\n     * var greet = function(formatted) {\n     *   return 'Hiya ' + formatted + '!';\n     * };\n     *\n     * var welcome = _.compose(greet, format);\n     * welcome('pebbles');\n     * // => 'Hiya Penelope!'\n     */\n    function compose() {\n      var funcs = arguments,\n          length = funcs.length;\n\n      while (length--) {\n        if (!isFunction(funcs[length])) {\n          throw new TypeError;\n        }\n      }\n      return function() {\n        var args = arguments,\n            length = funcs.length;\n\n        while (length--) {\n          args = [funcs[length].apply(this, args)];\n        }\n        return args[0];\n      };\n    }\n\n    /**\n     * Creates a function which accepts one or more arguments of `func` that when\n     * invoked either executes `func` returning its result, if all `func` arguments\n     * have been provided, or returns a function that accepts one or more of the\n     * remaining `func` arguments, and so on. The arity of `func` can be specified\n     * if `func.length` is not sufficient.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {Function} func The function to curry.\n     * @param {number} [arity=func.length] The arity of `func`.\n     * @returns {Function} Returns the new curried function.\n     * @example\n     *\n     * var curried = _.curry(function(a, b, c) {\n     *   console.log(a + b + c);\n     * });\n     *\n     * curried(1)(2)(3);\n     * // => 6\n     *\n     * curried(1, 2)(3);\n     * // => 6\n     *\n     * curried(1, 2, 3);\n     * // => 6\n     */\n    function curry(func, arity) {\n      arity = typeof arity == 'number' ? arity : (+arity || func.length);\n      return createWrapper(func, 4, null, null, null, arity);\n    }\n\n    /**\n     * Creates a function that will delay the execution of `func` until after\n     * `wait` milliseconds have elapsed since the last time it was invoked.\n     * Provide an options object to indicate that `func` should be invoked on\n     * the leading and/or trailing edge of the `wait` timeout. Subsequent calls\n     * to the debounced function will return the result of the last `func` call.\n     *\n     * Note: If `leading` and `trailing` options are `true` `func` will be called\n     * on the trailing edge of the timeout only if the the debounced function is\n     * invoked more than once during the `wait` timeout.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {Function} func The function to debounce.\n     * @param {number} wait The number of milliseconds to delay.\n     * @param {Object} [options] The options object.\n     * @param {boolean} [options.leading=false] Specify execution on the leading edge of the timeout.\n     * @param {number} [options.maxWait] The maximum time `func` is allowed to be delayed before it's called.\n     * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.\n     * @returns {Function} Returns the new debounced function.\n     * @example\n     *\n     * // avoid costly calculations while the window size is in flux\n     * var lazyLayout = _.debounce(calculateLayout, 150);\n     * jQuery(window).on('resize', lazyLayout);\n     *\n     * // execute `sendMail` when the click event is fired, debouncing subsequent calls\n     * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {\n     *   'leading': true,\n     *   'trailing': false\n     * });\n     *\n     * // ensure `batchLog` is executed once after 1 second of debounced calls\n     * var source = new EventSource('/stream');\n     * source.addEventListener('message', _.debounce(batchLog, 250, {\n     *   'maxWait': 1000\n     * }, false);\n     */\n    function debounce(func, wait, options) {\n      var args,\n          maxTimeoutId,\n          result,\n          stamp,\n          thisArg,\n          timeoutId,\n          trailingCall,\n          lastCalled = 0,\n          maxWait = false,\n          trailing = true;\n\n      if (!isFunction(func)) {\n        throw new TypeError;\n      }\n      wait = nativeMax(0, wait) || 0;\n      if (options === true) {\n        var leading = true;\n        trailing = false;\n      } else if (isObject(options)) {\n        leading = options.leading;\n        maxWait = 'maxWait' in options && (nativeMax(wait, options.maxWait) || 0);\n        trailing = 'trailing' in options ? options.trailing : trailing;\n      }\n      var delayed = function() {\n        var remaining = wait - (now() - stamp);\n        if (remaining <= 0) {\n          if (maxTimeoutId) {\n            clearTimeout(maxTimeoutId);\n          }\n          var isCalled = trailingCall;\n          maxTimeoutId = timeoutId = trailingCall = undefined;\n          if (isCalled) {\n            lastCalled = now();\n            result = func.apply(thisArg, args);\n            if (!timeoutId && !maxTimeoutId) {\n              args = thisArg = null;\n            }\n          }\n        } else {\n          timeoutId = setTimeout(delayed, remaining);\n        }\n      };\n\n      var maxDelayed = function() {\n        if (timeoutId) {\n          clearTimeout(timeoutId);\n        }\n        maxTimeoutId = timeoutId = trailingCall = undefined;\n        if (trailing || (maxWait !== wait)) {\n          lastCalled = now();\n          result = func.apply(thisArg, args);\n          if (!timeoutId && !maxTimeoutId) {\n            args = thisArg = null;\n          }\n        }\n      };\n\n      return function() {\n        args = arguments;\n        stamp = now();\n        thisArg = this;\n        trailingCall = trailing && (timeoutId || !leading);\n\n        if (maxWait === false) {\n          var leadingCall = leading && !timeoutId;\n        } else {\n          if (!maxTimeoutId && !leading) {\n            lastCalled = stamp;\n          }\n          var remaining = maxWait - (stamp - lastCalled),\n              isCalled = remaining <= 0;\n\n          if (isCalled) {\n            if (maxTimeoutId) {\n              maxTimeoutId = clearTimeout(maxTimeoutId);\n            }\n            lastCalled = stamp;\n            result = func.apply(thisArg, args);\n          }\n          else if (!maxTimeoutId) {\n            maxTimeoutId = setTimeout(maxDelayed, remaining);\n          }\n        }\n        if (isCalled && timeoutId) {\n          timeoutId = clearTimeout(timeoutId);\n        }\n        else if (!timeoutId && wait !== maxWait) {\n          timeoutId = setTimeout(delayed, wait);\n        }\n        if (leadingCall) {\n          isCalled = true;\n          result = func.apply(thisArg, args);\n        }\n        if (isCalled && !timeoutId && !maxTimeoutId) {\n          args = thisArg = null;\n        }\n        return result;\n      };\n    }\n\n    /**\n     * Defers executing the `func` function until the current call stack has cleared.\n     * Additional arguments will be provided to `func` when it is invoked.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {Function} func The function to defer.\n     * @param {...*} [arg] Arguments to invoke the function with.\n     * @returns {number} Returns the timer id.\n     * @example\n     *\n     * _.defer(function(text) { console.log(text); }, 'deferred');\n     * // logs 'deferred' after one or more milliseconds\n     */\n    function defer(func) {\n      if (!isFunction(func)) {\n        throw new TypeError;\n      }\n      var args = slice(arguments, 1);\n      return setTimeout(function() { func.apply(undefined, args); }, 1);\n    }\n\n    /**\n     * Executes the `func` function after `wait` milliseconds. Additional arguments\n     * will be provided to `func` when it is invoked.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {Function} func The function to delay.\n     * @param {number} wait The number of milliseconds to delay execution.\n     * @param {...*} [arg] Arguments to invoke the function with.\n     * @returns {number} Returns the timer id.\n     * @example\n     *\n     * _.delay(function(text) { console.log(text); }, 1000, 'later');\n     * // => logs 'later' after one second\n     */\n    function delay(func, wait) {\n      if (!isFunction(func)) {\n        throw new TypeError;\n      }\n      var args = slice(arguments, 2);\n      return setTimeout(function() { func.apply(undefined, args); }, wait);\n    }\n\n    /**\n     * Creates a function that memoizes the result of `func`. If `resolver` is\n     * provided it will be used to determine the cache key for storing the result\n     * based on the arguments provided to the memoized function. By default, the\n     * first argument provided to the memoized function is used as the cache key.\n     * The `func` is executed with the `this` binding of the memoized function.\n     * The result cache is exposed as the `cache` property on the memoized function.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {Function} func The function to have its output memoized.\n     * @param {Function} [resolver] A function used to resolve the cache key.\n     * @returns {Function} Returns the new memoizing function.\n     * @example\n     *\n     * var fibonacci = _.memoize(function(n) {\n     *   return n < 2 ? n : fibonacci(n - 1) + fibonacci(n - 2);\n     * });\n     *\n     * fibonacci(9)\n     * // => 34\n     *\n     * var data = {\n     *   'fred': { 'name': 'fred', 'age': 40 },\n     *   'pebbles': { 'name': 'pebbles', 'age': 1 }\n     * };\n     *\n     * // modifying the result cache\n     * var get = _.memoize(function(name) { return data[name]; }, _.identity);\n     * get('pebbles');\n     * // => { 'name': 'pebbles', 'age': 1 }\n     *\n     * get.cache.pebbles.name = 'penelope';\n     * get('pebbles');\n     * // => { 'name': 'penelope', 'age': 1 }\n     */\n    function memoize(func, resolver) {\n      if (!isFunction(func)) {\n        throw new TypeError;\n      }\n      var memoized = function() {\n        var cache = memoized.cache,\n            key = resolver ? resolver.apply(this, arguments) : keyPrefix + arguments[0];\n\n        return hasOwnProperty.call(cache, key)\n          ? cache[key]\n          : (cache[key] = func.apply(this, arguments));\n      }\n      memoized.cache = {};\n      return memoized;\n    }\n\n    /**\n     * Creates a function that is restricted to execute `func` once. Repeat calls to\n     * the function will return the value of the first call. The `func` is executed\n     * with the `this` binding of the created function.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new restricted function.\n     * @example\n     *\n     * var initialize = _.once(createApplication);\n     * initialize();\n     * initialize();\n     * // `initialize` executes `createApplication` once\n     */\n    function once(func) {\n      var ran,\n          result;\n\n      if (!isFunction(func)) {\n        throw new TypeError;\n      }\n      return function() {\n        if (ran) {\n          return result;\n        }\n        ran = true;\n        result = func.apply(this, arguments);\n\n        // clear the `func` variable so the function may be garbage collected\n        func = null;\n        return result;\n      };\n    }\n\n    /**\n     * Creates a function that, when called, invokes `func` with any additional\n     * `partial` arguments prepended to those provided to the new function. This\n     * method is similar to `_.bind` except it does **not** alter the `this` binding.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {Function} func The function to partially apply arguments to.\n     * @param {...*} [arg] Arguments to be partially applied.\n     * @returns {Function} Returns the new partially applied function.\n     * @example\n     *\n     * var greet = function(greeting, name) { return greeting + ' ' + name; };\n     * var hi = _.partial(greet, 'hi');\n     * hi('fred');\n     * // => 'hi fred'\n     */\n    function partial(func) {\n      return createWrapper(func, 16, slice(arguments, 1));\n    }\n\n    /**\n     * This method is like `_.partial` except that `partial` arguments are\n     * appended to those provided to the new function.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {Function} func The function to partially apply arguments to.\n     * @param {...*} [arg] Arguments to be partially applied.\n     * @returns {Function} Returns the new partially applied function.\n     * @example\n     *\n     * var defaultsDeep = _.partialRight(_.merge, _.defaults);\n     *\n     * var options = {\n     *   'variable': 'data',\n     *   'imports': { 'jq': $ }\n     * };\n     *\n     * defaultsDeep(options, _.templateSettings);\n     *\n     * options.variable\n     * // => 'data'\n     *\n     * options.imports\n     * // => { '_': _, 'jq': $ }\n     */\n    function partialRight(func) {\n      return createWrapper(func, 32, null, slice(arguments, 1));\n    }\n\n    /**\n     * Creates a function that, when executed, will only call the `func` function\n     * at most once per every `wait` milliseconds. Provide an options object to\n     * indicate that `func` should be invoked on the leading and/or trailing edge\n     * of the `wait` timeout. Subsequent calls to the throttled function will\n     * return the result of the last `func` call.\n     *\n     * Note: If `leading` and `trailing` options are `true` `func` will be called\n     * on the trailing edge of the timeout only if the the throttled function is\n     * invoked more than once during the `wait` timeout.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {Function} func The function to throttle.\n     * @param {number} wait The number of milliseconds to throttle executions to.\n     * @param {Object} [options] The options object.\n     * @param {boolean} [options.leading=true] Specify execution on the leading edge of the timeout.\n     * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.\n     * @returns {Function} Returns the new throttled function.\n     * @example\n     *\n     * // avoid excessively updating the position while scrolling\n     * var throttled = _.throttle(updatePosition, 100);\n     * jQuery(window).on('scroll', throttled);\n     *\n     * // execute `renewToken` when the click event is fired, but not more than once every 5 minutes\n     * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {\n     *   'trailing': false\n     * }));\n     */\n    function throttle(func, wait, options) {\n      var leading = true,\n          trailing = true;\n\n      if (!isFunction(func)) {\n        throw new TypeError;\n      }\n      if (options === false) {\n        leading = false;\n      } else if (isObject(options)) {\n        leading = 'leading' in options ? options.leading : leading;\n        trailing = 'trailing' in options ? options.trailing : trailing;\n      }\n      debounceOptions.leading = leading;\n      debounceOptions.maxWait = wait;\n      debounceOptions.trailing = trailing;\n\n      return debounce(func, wait, debounceOptions);\n    }\n\n    /**\n     * Creates a function that provides `value` to the wrapper function as its\n     * first argument. Additional arguments provided to the function are appended\n     * to those provided to the wrapper function. The wrapper is executed with\n     * the `this` binding of the created function.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {*} value The value to wrap.\n     * @param {Function} wrapper The wrapper function.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var p = _.wrap(_.escape, function(func, text) {\n     *   return '<p>' + func(text) + '</p>';\n     * });\n     *\n     * p('Fred, Wilma, & Pebbles');\n     * // => '<p>Fred, Wilma, &amp; Pebbles</p>'\n     */\n    function wrap(value, wrapper) {\n      return createWrapper(wrapper, 16, [value]);\n    }\n\n    /*--------------------------------------------------------------------------*/\n\n    /**\n     * Creates a function that returns `value`.\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @param {*} value The value to return from the new function.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var object = { 'name': 'fred' };\n     * var getter = _.constant(object);\n     * getter() === object;\n     * // => true\n     */\n    function constant(value) {\n      return function() {\n        return value;\n      };\n    }\n\n    /**\n     * Produces a callback bound to an optional `thisArg`. If `func` is a property\n     * name the created callback will return the property value for a given element.\n     * If `func` is an object the created callback will return `true` for elements\n     * that contain the equivalent object properties, otherwise it will return `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @param {*} [func=identity] The value to convert to a callback.\n     * @param {*} [thisArg] The `this` binding of the created callback.\n     * @param {number} [argCount] The number of arguments the callback accepts.\n     * @returns {Function} Returns a callback function.\n     * @example\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36 },\n     *   { 'name': 'fred',   'age': 40 }\n     * ];\n     *\n     * // wrap to create custom callback shorthands\n     * _.createCallback = _.wrap(_.createCallback, function(func, callback, thisArg) {\n     *   var match = /^(.+?)__([gl]t)(.+)$/.exec(callback);\n     *   return !match ? func(callback, thisArg) : function(object) {\n     *     return match[2] == 'gt' ? object[match[1]] > match[3] : object[match[1]] < match[3];\n     *   };\n     * });\n     *\n     * _.filter(characters, 'age__gt38');\n     * // => [{ 'name': 'fred', 'age': 40 }]\n     */\n    function createCallback(func, thisArg, argCount) {\n      var type = typeof func;\n      if (func == null || type == 'function') {\n        return baseCreateCallback(func, thisArg, argCount);\n      }\n      // handle \"_.pluck\" style callback shorthands\n      if (type != 'object') {\n        return property(func);\n      }\n      var props = keys(func),\n          key = props[0],\n          a = func[key];\n\n      // handle \"_.where\" style callback shorthands\n      if (props.length == 1 && a === a && !isObject(a)) {\n        // fast path the common case of providing an object with a single\n        // property containing a primitive value\n        return function(object) {\n          var b = object[key];\n          return a === b && (a !== 0 || (1 / a == 1 / b));\n        };\n      }\n      return function(object) {\n        var length = props.length,\n            result = false;\n\n        while (length--) {\n          if (!(result = baseIsEqual(object[props[length]], func[props[length]], null, true))) {\n            break;\n          }\n        }\n        return result;\n      };\n    }\n\n    /**\n     * Converts the characters `&`, `<`, `>`, `\"`, and `'` in `string` to their\n     * corresponding HTML entities.\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @param {string} string The string to escape.\n     * @returns {string} Returns the escaped string.\n     * @example\n     *\n     * _.escape('Fred, Wilma, & Pebbles');\n     * // => 'Fred, Wilma, &amp; Pebbles'\n     */\n    function escape(string) {\n      return string == null ? '' : String(string).replace(reUnescapedHtml, escapeHtmlChar);\n    }\n\n    /**\n     * This method returns the first argument provided to it.\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @param {*} value Any value.\n     * @returns {*} Returns `value`.\n     * @example\n     *\n     * var object = { 'name': 'fred' };\n     * _.identity(object) === object;\n     * // => true\n     */\n    function identity(value) {\n      return value;\n    }\n\n    /**\n     * Adds function properties of a source object to the destination object.\n     * If `object` is a function methods will be added to its prototype as well.\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @param {Function|Object} [object=lodash] object The destination object.\n     * @param {Object} source The object of functions to add.\n     * @param {Object} [options] The options object.\n     * @param {boolean} [options.chain=true] Specify whether the functions added are chainable.\n     * @example\n     *\n     * function capitalize(string) {\n     *   return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();\n     * }\n     *\n     * _.mixin({ 'capitalize': capitalize });\n     * _.capitalize('fred');\n     * // => 'Fred'\n     *\n     * _('fred').capitalize().value();\n     * // => 'Fred'\n     *\n     * _.mixin({ 'capitalize': capitalize }, { 'chain': false });\n     * _('fred').capitalize();\n     * // => 'Fred'\n     */\n    function mixin(object, source, options) {\n      var chain = true,\n          methodNames = source && functions(source);\n\n      if (!source || (!options && !methodNames.length)) {\n        if (options == null) {\n          options = source;\n        }\n        ctor = lodashWrapper;\n        source = object;\n        object = lodash;\n        methodNames = functions(source);\n      }\n      if (options === false) {\n        chain = false;\n      } else if (isObject(options) && 'chain' in options) {\n        chain = options.chain;\n      }\n      var ctor = object,\n          isFunc = isFunction(ctor);\n\n      forEach(methodNames, function(methodName) {\n        var func = object[methodName] = source[methodName];\n        if (isFunc) {\n          ctor.prototype[methodName] = function() {\n            var chainAll = this.__chain__,\n                value = this.__wrapped__,\n                args = [value];\n\n            push.apply(args, arguments);\n            var result = func.apply(object, args);\n            if (chain || chainAll) {\n              if (value === result && isObject(result)) {\n                return this;\n              }\n              result = new ctor(result);\n              result.__chain__ = chainAll;\n            }\n            return result;\n          };\n        }\n      });\n    }\n\n    /**\n     * Reverts the '_' variable to its previous value and returns a reference to\n     * the `lodash` function.\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @returns {Function} Returns the `lodash` function.\n     * @example\n     *\n     * var lodash = _.noConflict();\n     */\n    function noConflict() {\n      context._ = oldDash;\n      return this;\n    }\n\n    /**\n     * A no-operation function.\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @example\n     *\n     * var object = { 'name': 'fred' };\n     * _.noop(object) === undefined;\n     * // => true\n     */\n    function noop() {\n      // no operation performed\n    }\n\n    /**\n     * Gets the number of milliseconds that have elapsed since the Unix epoch\n     * (1 January 1970 00:00:00 UTC).\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @example\n     *\n     * var stamp = _.now();\n     * _.defer(function() { console.log(_.now() - stamp); });\n     * // => logs the number of milliseconds it took for the deferred function to be called\n     */\n    var now = isNative(now = Date.now) && now || function() {\n      return new Date().getTime();\n    };\n\n    /**\n     * Converts the given value into an integer of the specified radix.\n     * If `radix` is `undefined` or `0` a `radix` of `10` is used unless the\n     * `value` is a hexadecimal, in which case a `radix` of `16` is used.\n     *\n     * Note: This method avoids differences in native ES3 and ES5 `parseInt`\n     * implementations. See http://es5.github.io/#E.\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @param {string} value The value to parse.\n     * @param {number} [radix] The radix used to interpret the value to parse.\n     * @returns {number} Returns the new integer value.\n     * @example\n     *\n     * _.parseInt('08');\n     * // => 8\n     */\n    var parseInt = nativeParseInt(whitespace + '08') == 8 ? nativeParseInt : function(value, radix) {\n      // Firefox < 21 and Opera < 15 follow the ES3 specified implementation of `parseInt`\n      return nativeParseInt(isString(value) ? value.replace(reLeadingSpacesAndZeros, '') : value, radix || 0);\n    };\n\n    /**\n     * Creates a \"_.pluck\" style function, which returns the `key` value of a\n     * given object.\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @param {string} key The name of the property to retrieve.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var characters = [\n     *   { 'name': 'fred',   'age': 40 },\n     *   { 'name': 'barney', 'age': 36 }\n     * ];\n     *\n     * var getName = _.property('name');\n     *\n     * _.map(characters, getName);\n     * // => ['barney', 'fred']\n     *\n     * _.sortBy(characters, getName);\n     * // => [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred',   'age': 40 }]\n     */\n    function property(key) {\n      return function(object) {\n        return object[key];\n      };\n    }\n\n    /**\n     * Produces a random number between `min` and `max` (inclusive). If only one\n     * argument is provided a number between `0` and the given number will be\n     * returned. If `floating` is truey or either `min` or `max` are floats a\n     * floating-point number will be returned instead of an integer.\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @param {number} [min=0] The minimum possible value.\n     * @param {number} [max=1] The maximum possible value.\n     * @param {boolean} [floating=false] Specify returning a floating-point number.\n     * @returns {number} Returns a random number.\n     * @example\n     *\n     * _.random(0, 5);\n     * // => an integer between 0 and 5\n     *\n     * _.random(5);\n     * // => also an integer between 0 and 5\n     *\n     * _.random(5, true);\n     * // => a floating-point number between 0 and 5\n     *\n     * _.random(1.2, 5.2);\n     * // => a floating-point number between 1.2 and 5.2\n     */\n    function random(min, max, floating) {\n      var noMin = min == null,\n          noMax = max == null;\n\n      if (floating == null) {\n        if (typeof min == 'boolean' && noMax) {\n          floating = min;\n          min = 1;\n        }\n        else if (!noMax && typeof max == 'boolean') {\n          floating = max;\n          noMax = true;\n        }\n      }\n      if (noMin && noMax) {\n        max = 1;\n      }\n      min = +min || 0;\n      if (noMax) {\n        max = min;\n        min = 0;\n      } else {\n        max = +max || 0;\n      }\n      if (floating || min % 1 || max % 1) {\n        var rand = nativeRandom();\n        return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand +'').length - 1)))), max);\n      }\n      return baseRandom(min, max);\n    }\n\n    /**\n     * Resolves the value of property `key` on `object`. If `key` is a function\n     * it will be invoked with the `this` binding of `object` and its result returned,\n     * else the property value is returned. If `object` is falsey then `undefined`\n     * is returned.\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @param {Object} object The object to inspect.\n     * @param {string} key The name of the property to resolve.\n     * @returns {*} Returns the resolved value.\n     * @example\n     *\n     * var object = {\n     *   'cheese': 'crumpets',\n     *   'stuff': function() {\n     *     return 'nonsense';\n     *   }\n     * };\n     *\n     * _.result(object, 'cheese');\n     * // => 'crumpets'\n     *\n     * _.result(object, 'stuff');\n     * // => 'nonsense'\n     */\n    function result(object, key) {\n      if (object) {\n        var value = object[key];\n        return isFunction(value) ? object[key]() : value;\n      }\n    }\n\n    /**\n     * A micro-templating method that handles arbitrary delimiters, preserves\n     * whitespace, and correctly escapes quotes within interpolated code.\n     *\n     * Note: In the development build, `_.template` utilizes sourceURLs for easier\n     * debugging. See http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl\n     *\n     * For more information on precompiling templates see:\n     * https://lodash.com/custom-builds\n     *\n     * For more information on Chrome extension sandboxes see:\n     * http://developer.chrome.com/stable/extensions/sandboxingEval.html\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @param {string} text The template text.\n     * @param {Object} data The data object used to populate the text.\n     * @param {Object} [options] The options object.\n     * @param {RegExp} [options.escape] The \"escape\" delimiter.\n     * @param {RegExp} [options.evaluate] The \"evaluate\" delimiter.\n     * @param {Object} [options.imports] An object to import into the template as local variables.\n     * @param {RegExp} [options.interpolate] The \"interpolate\" delimiter.\n     * @param {string} [sourceURL] The sourceURL of the template's compiled source.\n     * @param {string} [variable] The data object variable name.\n     * @returns {Function|string} Returns a compiled function when no `data` object\n     *  is given, else it returns the interpolated text.\n     * @example\n     *\n     * // using the \"interpolate\" delimiter to create a compiled template\n     * var compiled = _.template('hello <%= name %>');\n     * compiled({ 'name': 'fred' });\n     * // => 'hello fred'\n     *\n     * // using the \"escape\" delimiter to escape HTML in data property values\n     * _.template('<b><%- value %></b>', { 'value': '<script>' });\n     * // => '<b>&lt;script&gt;</b>'\n     *\n     * // using the \"evaluate\" delimiter to generate HTML\n     * var list = '<% _.forEach(people, function(name) { %><li><%- name %></li><% }); %>';\n     * _.template(list, { 'people': ['fred', 'barney'] });\n     * // => '<li>fred</li><li>barney</li>'\n     *\n     * // using the ES6 delimiter as an alternative to the default \"interpolate\" delimiter\n     * _.template('hello ${ name }', { 'name': 'pebbles' });\n     * // => 'hello pebbles'\n     *\n     * // using the internal `print` function in \"evaluate\" delimiters\n     * _.template('<% print(\"hello \" + name); %>!', { 'name': 'barney' });\n     * // => 'hello barney!'\n     *\n     * // using a custom template delimiters\n     * _.templateSettings = {\n     *   'interpolate': /{{([\\s\\S]+?)}}/g\n     * };\n     *\n     * _.template('hello {{ name }}!', { 'name': 'mustache' });\n     * // => 'hello mustache!'\n     *\n     * // using the `imports` option to import jQuery\n     * var list = '<% jq.each(people, function(name) { %><li><%- name %></li><% }); %>';\n     * _.template(list, { 'people': ['fred', 'barney'] }, { 'imports': { 'jq': jQuery } });\n     * // => '<li>fred</li><li>barney</li>'\n     *\n     * // using the `sourceURL` option to specify a custom sourceURL for the template\n     * var compiled = _.template('hello <%= name %>', null, { 'sourceURL': '/basic/greeting.jst' });\n     * compiled(data);\n     * // => find the source of \"greeting.jst\" under the Sources tab or Resources panel of the web inspector\n     *\n     * // using the `variable` option to ensure a with-statement isn't used in the compiled template\n     * var compiled = _.template('hi <%= data.name %>!', null, { 'variable': 'data' });\n     * compiled.source;\n     * // => function(data) {\n     *   var __t, __p = '', __e = _.escape;\n     *   __p += 'hi ' + ((__t = ( data.name )) == null ? '' : __t) + '!';\n     *   return __p;\n     * }\n     *\n     * // using the `source` property to inline compiled templates for meaningful\n     * // line numbers in error messages and a stack trace\n     * fs.writeFileSync(path.join(cwd, 'jst.js'), '\\\n     *   var JST = {\\\n     *     \"main\": ' + _.template(mainText).source + '\\\n     *   };\\\n     * ');\n     */\n    function template(text, data, options) {\n      // based on John Resig's `tmpl` implementation\n      // http://ejohn.org/blog/javascript-micro-templating/\n      // and Laura Doktorova's doT.js\n      // https://github.com/olado/doT\n      var settings = lodash.templateSettings;\n      text = String(text || '');\n\n      // avoid missing dependencies when `iteratorTemplate` is not defined\n      options = defaults({}, options, settings);\n\n      var imports = defaults({}, options.imports, settings.imports),\n          importsKeys = keys(imports),\n          importsValues = values(imports);\n\n      var isEvaluating,\n          index = 0,\n          interpolate = options.interpolate || reNoMatch,\n          source = \"__p += '\";\n\n      // compile the regexp to match each delimiter\n      var reDelimiters = RegExp(\n        (options.escape || reNoMatch).source + '|' +\n        interpolate.source + '|' +\n        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +\n        (options.evaluate || reNoMatch).source + '|$'\n      , 'g');\n\n      text.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {\n        interpolateValue || (interpolateValue = esTemplateValue);\n\n        // escape characters that cannot be included in string literals\n        source += text.slice(index, offset).replace(reUnescapedString, escapeStringChar);\n\n        // replace delimiters with snippets\n        if (escapeValue) {\n          source += \"' +\\n__e(\" + escapeValue + \") +\\n'\";\n        }\n        if (evaluateValue) {\n          isEvaluating = true;\n          source += \"';\\n\" + evaluateValue + \";\\n__p += '\";\n        }\n        if (interpolateValue) {\n          source += \"' +\\n((__t = (\" + interpolateValue + \")) == null ? '' : __t) +\\n'\";\n        }\n        index = offset + match.length;\n\n        // the JS engine embedded in Adobe products requires returning the `match`\n        // string in order to produce the correct `offset` value\n        return match;\n      });\n\n      source += \"';\\n\";\n\n      // if `variable` is not specified, wrap a with-statement around the generated\n      // code to add the data object to the top of the scope chain\n      var variable = options.variable,\n          hasVariable = variable;\n\n      if (!hasVariable) {\n        variable = 'obj';\n        source = 'with (' + variable + ') {\\n' + source + '\\n}\\n';\n      }\n      // cleanup code by stripping empty strings\n      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)\n        .replace(reEmptyStringMiddle, '$1')\n        .replace(reEmptyStringTrailing, '$1;');\n\n      // frame code as the function body\n      source = 'function(' + variable + ') {\\n' +\n        (hasVariable ? '' : variable + ' || (' + variable + ' = {});\\n') +\n        \"var __t, __p = '', __e = _.escape\" +\n        (isEvaluating\n          ? ', __j = Array.prototype.join;\\n' +\n            \"function print() { __p += __j.call(arguments, '') }\\n\"\n          : ';\\n'\n        ) +\n        source +\n        'return __p\\n}';\n\n      // Use a sourceURL for easier debugging.\n      // http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl\n      var sourceURL = '\\n/*\\n//# sourceURL=' + (options.sourceURL || '/lodash/template/source[' + (templateCounter++) + ']') + '\\n*/';\n\n      try {\n        var result = Function(importsKeys, 'return ' + source + sourceURL).apply(undefined, importsValues);\n      } catch(e) {\n        e.source = source;\n        throw e;\n      }\n      if (data) {\n        return result(data);\n      }\n      // provide the compiled function's source by its `toString` method, in\n      // supported environments, or the `source` property as a convenience for\n      // inlining compiled templates during the build process\n      result.source = source;\n      return result;\n    }\n\n    /**\n     * Executes the callback `n` times, returning an array of the results\n     * of each callback execution. The callback is bound to `thisArg` and invoked\n     * with one argument; (index).\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @param {number} n The number of times to execute the callback.\n     * @param {Function} callback The function called per iteration.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Array} Returns an array of the results of each `callback` execution.\n     * @example\n     *\n     * var diceRolls = _.times(3, _.partial(_.random, 1, 6));\n     * // => [3, 6, 4]\n     *\n     * _.times(3, function(n) { mage.castSpell(n); });\n     * // => calls `mage.castSpell(n)` three times, passing `n` of `0`, `1`, and `2` respectively\n     *\n     * _.times(3, function(n) { this.cast(n); }, mage);\n     * // => also calls `mage.castSpell(n)` three times\n     */\n    function times(n, callback, thisArg) {\n      n = (n = +n) > -1 ? n : 0;\n      var index = -1,\n          result = Array(n);\n\n      callback = baseCreateCallback(callback, thisArg, 1);\n      while (++index < n) {\n        result[index] = callback(index);\n      }\n      return result;\n    }\n\n    /**\n     * The inverse of `_.escape` this method converts the HTML entities\n     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to their\n     * corresponding characters.\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @param {string} string The string to unescape.\n     * @returns {string} Returns the unescaped string.\n     * @example\n     *\n     * _.unescape('Fred, Barney &amp; Pebbles');\n     * // => 'Fred, Barney & Pebbles'\n     */\n    function unescape(string) {\n      return string == null ? '' : String(string).replace(reEscapedHtml, unescapeHtmlChar);\n    }\n\n    /**\n     * Generates a unique ID. If `prefix` is provided the ID will be appended to it.\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @param {string} [prefix] The value to prefix the ID with.\n     * @returns {string} Returns the unique ID.\n     * @example\n     *\n     * _.uniqueId('contact_');\n     * // => 'contact_104'\n     *\n     * _.uniqueId();\n     * // => '105'\n     */\n    function uniqueId(prefix) {\n      var id = ++idCounter;\n      return String(prefix == null ? '' : prefix) + id;\n    }\n\n    /*--------------------------------------------------------------------------*/\n\n    /**\n     * Creates a `lodash` object that wraps the given value with explicit\n     * method chaining enabled.\n     *\n     * @static\n     * @memberOf _\n     * @category Chaining\n     * @param {*} value The value to wrap.\n     * @returns {Object} Returns the wrapper object.\n     * @example\n     *\n     * var characters = [\n     *   { 'name': 'barney',  'age': 36 },\n     *   { 'name': 'fred',    'age': 40 },\n     *   { 'name': 'pebbles', 'age': 1 }\n     * ];\n     *\n     * var youngest = _.chain(characters)\n     *     .sortBy('age')\n     *     .map(function(chr) { return chr.name + ' is ' + chr.age; })\n     *     .first()\n     *     .value();\n     * // => 'pebbles is 1'\n     */\n    function chain(value) {\n      value = new lodashWrapper(value);\n      value.__chain__ = true;\n      return value;\n    }\n\n    /**\n     * Invokes `interceptor` with the `value` as the first argument and then\n     * returns `value`. The purpose of this method is to \"tap into\" a method\n     * chain in order to perform operations on intermediate results within\n     * the chain.\n     *\n     * @static\n     * @memberOf _\n     * @category Chaining\n     * @param {*} value The value to provide to `interceptor`.\n     * @param {Function} interceptor The function to invoke.\n     * @returns {*} Returns `value`.\n     * @example\n     *\n     * _([1, 2, 3, 4])\n     *  .tap(function(array) { array.pop(); })\n     *  .reverse()\n     *  .value();\n     * // => [3, 2, 1]\n     */\n    function tap(value, interceptor) {\n      interceptor(value);\n      return value;\n    }\n\n    /**\n     * Enables explicit method chaining on the wrapper object.\n     *\n     * @name chain\n     * @memberOf _\n     * @category Chaining\n     * @returns {*} Returns the wrapper object.\n     * @example\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36 },\n     *   { 'name': 'fred',   'age': 40 }\n     * ];\n     *\n     * // without explicit chaining\n     * _(characters).first();\n     * // => { 'name': 'barney', 'age': 36 }\n     *\n     * // with explicit chaining\n     * _(characters).chain()\n     *   .first()\n     *   .pick('age')\n     *   .value();\n     * // => { 'age': 36 }\n     */\n    function wrapperChain() {\n      this.__chain__ = true;\n      return this;\n    }\n\n    /**\n     * Produces the `toString` result of the wrapped value.\n     *\n     * @name toString\n     * @memberOf _\n     * @category Chaining\n     * @returns {string} Returns the string result.\n     * @example\n     *\n     * _([1, 2, 3]).toString();\n     * // => '1,2,3'\n     */\n    function wrapperToString() {\n      return String(this.__wrapped__);\n    }\n\n    /**\n     * Extracts the wrapped value.\n     *\n     * @name valueOf\n     * @memberOf _\n     * @alias value\n     * @category Chaining\n     * @returns {*} Returns the wrapped value.\n     * @example\n     *\n     * _([1, 2, 3]).valueOf();\n     * // => [1, 2, 3]\n     */\n    function wrapperValueOf() {\n      return this.__wrapped__;\n    }\n\n    /*--------------------------------------------------------------------------*/\n\n    // add functions that return wrapped values when chaining\n    lodash.after = after;\n    lodash.assign = assign;\n    lodash.at = at;\n    lodash.bind = bind;\n    lodash.bindAll = bindAll;\n    lodash.bindKey = bindKey;\n    lodash.chain = chain;\n    lodash.compact = compact;\n    lodash.compose = compose;\n    lodash.constant = constant;\n    lodash.countBy = countBy;\n    lodash.create = create;\n    lodash.createCallback = createCallback;\n    lodash.curry = curry;\n    lodash.debounce = debounce;\n    lodash.defaults = defaults;\n    lodash.defer = defer;\n    lodash.delay = delay;\n    lodash.difference = difference;\n    lodash.filter = filter;\n    lodash.flatten = flatten;\n    lodash.forEach = forEach;\n    lodash.forEachRight = forEachRight;\n    lodash.forIn = forIn;\n    lodash.forInRight = forInRight;\n    lodash.forOwn = forOwn;\n    lodash.forOwnRight = forOwnRight;\n    lodash.functions = functions;\n    lodash.groupBy = groupBy;\n    lodash.indexBy = indexBy;\n    lodash.initial = initial;\n    lodash.intersection = intersection;\n    lodash.invert = invert;\n    lodash.invoke = invoke;\n    lodash.keys = keys;\n    lodash.map = map;\n    lodash.mapValues = mapValues;\n    lodash.max = max;\n    lodash.memoize = memoize;\n    lodash.merge = merge;\n    lodash.min = min;\n    lodash.omit = omit;\n    lodash.once = once;\n    lodash.pairs = pairs;\n    lodash.partial = partial;\n    lodash.partialRight = partialRight;\n    lodash.pick = pick;\n    lodash.pluck = pluck;\n    lodash.property = property;\n    lodash.pull = pull;\n    lodash.range = range;\n    lodash.reject = reject;\n    lodash.remove = remove;\n    lodash.rest = rest;\n    lodash.shuffle = shuffle;\n    lodash.sortBy = sortBy;\n    lodash.tap = tap;\n    lodash.throttle = throttle;\n    lodash.times = times;\n    lodash.toArray = toArray;\n    lodash.transform = transform;\n    lodash.union = union;\n    lodash.uniq = uniq;\n    lodash.values = values;\n    lodash.where = where;\n    lodash.without = without;\n    lodash.wrap = wrap;\n    lodash.xor = xor;\n    lodash.zip = zip;\n    lodash.zipObject = zipObject;\n\n    // add aliases\n    lodash.collect = map;\n    lodash.drop = rest;\n    lodash.each = forEach;\n    lodash.eachRight = forEachRight;\n    lodash.extend = assign;\n    lodash.methods = functions;\n    lodash.object = zipObject;\n    lodash.select = filter;\n    lodash.tail = rest;\n    lodash.unique = uniq;\n    lodash.unzip = zip;\n\n    // add functions to `lodash.prototype`\n    mixin(lodash);\n\n    /*--------------------------------------------------------------------------*/\n\n    // add functions that return unwrapped values when chaining\n    lodash.clone = clone;\n    lodash.cloneDeep = cloneDeep;\n    lodash.contains = contains;\n    lodash.escape = escape;\n    lodash.every = every;\n    lodash.find = find;\n    lodash.findIndex = findIndex;\n    lodash.findKey = findKey;\n    lodash.findLast = findLast;\n    lodash.findLastIndex = findLastIndex;\n    lodash.findLastKey = findLastKey;\n    lodash.has = has;\n    lodash.identity = identity;\n    lodash.indexOf = indexOf;\n    lodash.isArguments = isArguments;\n    lodash.isArray = isArray;\n    lodash.isBoolean = isBoolean;\n    lodash.isDate = isDate;\n    lodash.isElement = isElement;\n    lodash.isEmpty = isEmpty;\n    lodash.isEqual = isEqual;\n    lodash.isFinite = isFinite;\n    lodash.isFunction = isFunction;\n    lodash.isNaN = isNaN;\n    lodash.isNull = isNull;\n    lodash.isNumber = isNumber;\n    lodash.isObject = isObject;\n    lodash.isPlainObject = isPlainObject;\n    lodash.isRegExp = isRegExp;\n    lodash.isString = isString;\n    lodash.isUndefined = isUndefined;\n    lodash.lastIndexOf = lastIndexOf;\n    lodash.mixin = mixin;\n    lodash.noConflict = noConflict;\n    lodash.noop = noop;\n    lodash.now = now;\n    lodash.parseInt = parseInt;\n    lodash.random = random;\n    lodash.reduce = reduce;\n    lodash.reduceRight = reduceRight;\n    lodash.result = result;\n    lodash.runInContext = runInContext;\n    lodash.size = size;\n    lodash.some = some;\n    lodash.sortedIndex = sortedIndex;\n    lodash.template = template;\n    lodash.unescape = unescape;\n    lodash.uniqueId = uniqueId;\n\n    // add aliases\n    lodash.all = every;\n    lodash.any = some;\n    lodash.detect = find;\n    lodash.findWhere = find;\n    lodash.foldl = reduce;\n    lodash.foldr = reduceRight;\n    lodash.include = contains;\n    lodash.inject = reduce;\n\n    mixin(function() {\n      var source = {}\n      forOwn(lodash, function(func, methodName) {\n        if (!lodash.prototype[methodName]) {\n          source[methodName] = func;\n        }\n      });\n      return source;\n    }(), false);\n\n    /*--------------------------------------------------------------------------*/\n\n    // add functions capable of returning wrapped and unwrapped values when chaining\n    lodash.first = first;\n    lodash.last = last;\n    lodash.sample = sample;\n\n    // add aliases\n    lodash.take = first;\n    lodash.head = first;\n\n    forOwn(lodash, function(func, methodName) {\n      var callbackable = methodName !== 'sample';\n      if (!lodash.prototype[methodName]) {\n        lodash.prototype[methodName]= function(n, guard) {\n          var chainAll = this.__chain__,\n              result = func(this.__wrapped__, n, guard);\n\n          return !chainAll && (n == null || (guard && !(callbackable && typeof n == 'function')))\n            ? result\n            : new lodashWrapper(result, chainAll);\n        };\n      }\n    });\n\n    /*--------------------------------------------------------------------------*/\n\n    /**\n     * The semantic version number.\n     *\n     * @static\n     * @memberOf _\n     * @type string\n     */\n    lodash.VERSION = '2.4.2';\n\n    // add \"Chaining\" functions to the wrapper\n    lodash.prototype.chain = wrapperChain;\n    lodash.prototype.toString = wrapperToString;\n    lodash.prototype.value = wrapperValueOf;\n    lodash.prototype.valueOf = wrapperValueOf;\n\n    // add `Array` functions that return unwrapped values\n    forEach(['join', 'pop', 'shift'], function(methodName) {\n      var func = arrayRef[methodName];\n      lodash.prototype[methodName] = function() {\n        var chainAll = this.__chain__,\n            result = func.apply(this.__wrapped__, arguments);\n\n        return chainAll\n          ? new lodashWrapper(result, chainAll)\n          : result;\n      };\n    });\n\n    // add `Array` functions that return the existing wrapped value\n    forEach(['push', 'reverse', 'sort', 'unshift'], function(methodName) {\n      var func = arrayRef[methodName];\n      lodash.prototype[methodName] = function() {\n        func.apply(this.__wrapped__, arguments);\n        return this;\n      };\n    });\n\n    // add `Array` functions that return new wrapped values\n    forEach(['concat', 'slice', 'splice'], function(methodName) {\n      var func = arrayRef[methodName];\n      lodash.prototype[methodName] = function() {\n        return new lodashWrapper(func.apply(this.__wrapped__, arguments), this.__chain__);\n      };\n    });\n\n    return lodash;\n  }\n\n  /*--------------------------------------------------------------------------*/\n\n  // expose Lo-Dash\n  var _ = runInContext();\n\n  // some AMD build optimizers like r.js check for condition patterns like the following:\n  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {\n    // Expose Lo-Dash to the global object even when an AMD loader is present in\n    // case Lo-Dash is loaded with a RequireJS shim config.\n    // See http://requirejs.org/docs/api.html#config-shim\n    root._ = _;\n\n    // define as an anonymous module so, through path mapping, it can be\n    // referenced as the \"underscore\" module\n    define(function() {\n      return _;\n    });\n  }\n  // check for `exports` after `define` in case a build optimizer adds an `exports` object\n  else if (freeExports && freeModule) {\n    // in Node.js or RingoJS\n    if (moduleExports) {\n      (freeModule.exports = _)._ = _;\n    }\n    // in Narwhal or Rhino -require\n    else {\n      freeExports._ = _;\n    }\n  }\n  else {\n    // in a browser or Rhino\n    root._ = _;\n  }\n}.call(this));\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails-generate/node_modules/merge-defaults/index.js":"var _ = require('lodash');\n\n/**\n * defaultsDeep\n *\n * Implement a deep version of `_.defaults`.\n *\n * This method is hopefully temporary, until lodash has something\n * similar that can be called in a single method.  For now, it's\n * worth it to use a temporary module for readability.\n * (i.e. I know what `_.defaults` means offhand- not true for `_.partialRight`)\n */\n\n// In case the end user decided to do `_.defaults = require('merge-defaults')`,\n// before doing anything else, let's make SURE we have a reference to the original\n// `_.defaults()` method definition.\nvar origLodashDefaults = _.defaults;\n\n// Corrected: see https://github.com/lodash/lodash/issues/540\nmodule.exports = _.partialRight(_.merge, function () {\n\n  // Ensure dates and arrays are not recursively merged\n  if (_.isArray(arguments[0]) || _.isDate(arguments[0])) {\n    return arguments[0];\n  }\n  return origLodashDefaults.apply(_, Array.prototype.slice.call(arguments));\n});\n\n\n// module.exports = _.partialRight(_.merge, _.defaults);\n\n// module.exports = _.partialRight(_.merge, function deep(a, b) {\n//   // Ensure dates and arrays are not recursively merged\n//   if (_.isArray(a) || _.isDate(a)) {\n//     return a;\n//   }\n//   else return _.merge(a, b, deep);\n// });","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails-generate/node_modules/async/lib/async.js":"/*global setImmediate: false, setTimeout: false, console: false */\n(function () {\n\n    var async = {};\n\n    // global on the server, window in the browser\n    var root, previous_async;\n\n    root = this;\n    if (root != null) {\n      previous_async = root.async;\n    }\n\n    async.noConflict = function () {\n        root.async = previous_async;\n        return async;\n    };\n\n    function only_once(fn) {\n        var called = false;\n        return function() {\n            if (called) throw new Error(\"Callback was already called.\");\n            called = true;\n            fn.apply(root, arguments);\n        }\n    }\n\n    //// cross-browser compatiblity functions ////\n\n    var _each = function (arr, iterator) {\n        if (arr.forEach) {\n            return arr.forEach(iterator);\n        }\n        for (var i = 0; i < arr.length; i += 1) {\n            iterator(arr[i], i, arr);\n        }\n    };\n\n    var _map = function (arr, iterator) {\n        if (arr.map) {\n            return arr.map(iterator);\n        }\n        var results = [];\n        _each(arr, function (x, i, a) {\n            results.push(iterator(x, i, a));\n        });\n        return results;\n    };\n\n    var _reduce = function (arr, iterator, memo) {\n        if (arr.reduce) {\n            return arr.reduce(iterator, memo);\n        }\n        _each(arr, function (x, i, a) {\n            memo = iterator(memo, x, i, a);\n        });\n        return memo;\n    };\n\n    var _keys = function (obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        }\n        var keys = [];\n        for (var k in obj) {\n            if (obj.hasOwnProperty(k)) {\n                keys.push(k);\n            }\n        }\n        return keys;\n    };\n\n    //// exported async module functions ////\n\n    //// nextTick implementation with browser-compatible fallback ////\n    if (typeof process === 'undefined' || !(process.nextTick)) {\n        if (typeof setImmediate === 'function') {\n            async.nextTick = function (fn) {\n                // not a direct alias for IE10 compatibility\n                setImmediate(fn);\n            };\n            async.setImmediate = async.nextTick;\n        }\n        else {\n            async.nextTick = function (fn) {\n                setTimeout(fn, 0);\n            };\n            async.setImmediate = async.nextTick;\n        }\n    }\n    else {\n        async.nextTick = process.nextTick;\n        if (typeof setImmediate !== 'undefined') {\n            async.setImmediate = function (fn) {\n              // not a direct alias for IE10 compatibility\n              setImmediate(fn);\n            };\n        }\n        else {\n            async.setImmediate = async.nextTick;\n        }\n    }\n\n    async.each = function (arr, iterator, callback) {\n        callback = callback || function () {};\n        if (!arr.length) {\n            return callback();\n        }\n        var completed = 0;\n        _each(arr, function (x) {\n            iterator(x, only_once(function (err) {\n                if (err) {\n                    callback(err);\n                    callback = function () {};\n                }\n                else {\n                    completed += 1;\n                    if (completed >= arr.length) {\n                        callback(null);\n                    }\n                }\n            }));\n        });\n    };\n    async.forEach = async.each;\n\n    async.eachSeries = function (arr, iterator, callback) {\n        callback = callback || function () {};\n        if (!arr.length) {\n            return callback();\n        }\n        var completed = 0;\n        var iterate = function () {\n            iterator(arr[completed], function (err) {\n                if (err) {\n                    callback(err);\n                    callback = function () {};\n                }\n                else {\n                    completed += 1;\n                    if (completed >= arr.length) {\n                        callback(null);\n                    }\n                    else {\n                        iterate();\n                    }\n                }\n            });\n        };\n        iterate();\n    };\n    async.forEachSeries = async.eachSeries;\n\n    async.eachLimit = function (arr, limit, iterator, callback) {\n        var fn = _eachLimit(limit);\n        fn.apply(null, [arr, iterator, callback]);\n    };\n    async.forEachLimit = async.eachLimit;\n\n    var _eachLimit = function (limit) {\n\n        return function (arr, iterator, callback) {\n            callback = callback || function () {};\n            if (!arr.length || limit <= 0) {\n                return callback();\n            }\n            var completed = 0;\n            var started = 0;\n            var running = 0;\n\n            (function replenish () {\n                if (completed >= arr.length) {\n                    return callback();\n                }\n\n                while (running < limit && started < arr.length) {\n                    started += 1;\n                    running += 1;\n                    iterator(arr[started - 1], function (err) {\n                        if (err) {\n                            callback(err);\n                            callback = function () {};\n                        }\n                        else {\n                            completed += 1;\n                            running -= 1;\n                            if (completed >= arr.length) {\n                                callback();\n                            }\n                            else {\n                                replenish();\n                            }\n                        }\n                    });\n                }\n            })();\n        };\n    };\n\n\n    var doParallel = function (fn) {\n        return function () {\n            var args = Array.prototype.slice.call(arguments);\n            return fn.apply(null, [async.each].concat(args));\n        };\n    };\n    var doParallelLimit = function(limit, fn) {\n        return function () {\n            var args = Array.prototype.slice.call(arguments);\n            return fn.apply(null, [_eachLimit(limit)].concat(args));\n        };\n    };\n    var doSeries = function (fn) {\n        return function () {\n            var args = Array.prototype.slice.call(arguments);\n            return fn.apply(null, [async.eachSeries].concat(args));\n        };\n    };\n\n\n    var _asyncMap = function (eachfn, arr, iterator, callback) {\n        var results = [];\n        arr = _map(arr, function (x, i) {\n            return {index: i, value: x};\n        });\n        eachfn(arr, function (x, callback) {\n            iterator(x.value, function (err, v) {\n                results[x.index] = v;\n                callback(err);\n            });\n        }, function (err) {\n            callback(err, results);\n        });\n    };\n    async.map = doParallel(_asyncMap);\n    async.mapSeries = doSeries(_asyncMap);\n    async.mapLimit = function (arr, limit, iterator, callback) {\n        return _mapLimit(limit)(arr, iterator, callback);\n    };\n\n    var _mapLimit = function(limit) {\n        return doParallelLimit(limit, _asyncMap);\n    };\n\n    // reduce only has a series version, as doing reduce in parallel won't\n    // work in many situations.\n    async.reduce = function (arr, memo, iterator, callback) {\n        async.eachSeries(arr, function (x, callback) {\n            iterator(memo, x, function (err, v) {\n                memo = v;\n                callback(err);\n            });\n        }, function (err) {\n            callback(err, memo);\n        });\n    };\n    // inject alias\n    async.inject = async.reduce;\n    // foldl alias\n    async.foldl = async.reduce;\n\n    async.reduceRight = function (arr, memo, iterator, callback) {\n        var reversed = _map(arr, function (x) {\n            return x;\n        }).reverse();\n        async.reduce(reversed, memo, iterator, callback);\n    };\n    // foldr alias\n    async.foldr = async.reduceRight;\n\n    var _filter = function (eachfn, arr, iterator, callback) {\n        var results = [];\n        arr = _map(arr, function (x, i) {\n            return {index: i, value: x};\n        });\n        eachfn(arr, function (x, callback) {\n            iterator(x.value, function (v) {\n                if (v) {\n                    results.push(x);\n                }\n                callback();\n            });\n        }, function (err) {\n            callback(_map(results.sort(function (a, b) {\n                return a.index - b.index;\n            }), function (x) {\n                return x.value;\n            }));\n        });\n    };\n    async.filter = doParallel(_filter);\n    async.filterSeries = doSeries(_filter);\n    // select alias\n    async.select = async.filter;\n    async.selectSeries = async.filterSeries;\n\n    var _reject = function (eachfn, arr, iterator, callback) {\n        var results = [];\n        arr = _map(arr, function (x, i) {\n            return {index: i, value: x};\n        });\n        eachfn(arr, function (x, callback) {\n            iterator(x.value, function (v) {\n                if (!v) {\n                    results.push(x);\n                }\n                callback();\n            });\n        }, function (err) {\n            callback(_map(results.sort(function (a, b) {\n                return a.index - b.index;\n            }), function (x) {\n                return x.value;\n            }));\n        });\n    };\n    async.reject = doParallel(_reject);\n    async.rejectSeries = doSeries(_reject);\n\n    var _detect = function (eachfn, arr, iterator, main_callback) {\n        eachfn(arr, function (x, callback) {\n            iterator(x, function (result) {\n                if (result) {\n                    main_callback(x);\n                    main_callback = function () {};\n                }\n                else {\n                    callback();\n                }\n            });\n        }, function (err) {\n            main_callback();\n        });\n    };\n    async.detect = doParallel(_detect);\n    async.detectSeries = doSeries(_detect);\n\n    async.some = function (arr, iterator, main_callback) {\n        async.each(arr, function (x, callback) {\n            iterator(x, function (v) {\n                if (v) {\n                    main_callback(true);\n                    main_callback = function () {};\n                }\n                callback();\n            });\n        }, function (err) {\n            main_callback(false);\n        });\n    };\n    // any alias\n    async.any = async.some;\n\n    async.every = function (arr, iterator, main_callback) {\n        async.each(arr, function (x, callback) {\n            iterator(x, function (v) {\n                if (!v) {\n                    main_callback(false);\n                    main_callback = function () {};\n                }\n                callback();\n            });\n        }, function (err) {\n            main_callback(true);\n        });\n    };\n    // all alias\n    async.all = async.every;\n\n    async.sortBy = function (arr, iterator, callback) {\n        async.map(arr, function (x, callback) {\n            iterator(x, function (err, criteria) {\n                if (err) {\n                    callback(err);\n                }\n                else {\n                    callback(null, {value: x, criteria: criteria});\n                }\n            });\n        }, function (err, results) {\n            if (err) {\n                return callback(err);\n            }\n            else {\n                var fn = function (left, right) {\n                    var a = left.criteria, b = right.criteria;\n                    return a < b ? -1 : a > b ? 1 : 0;\n                };\n                callback(null, _map(results.sort(fn), function (x) {\n                    return x.value;\n                }));\n            }\n        });\n    };\n\n    async.auto = function (tasks, callback) {\n        callback = callback || function () {};\n        var keys = _keys(tasks);\n        if (!keys.length) {\n            return callback(null);\n        }\n\n        var results = {};\n\n        var listeners = [];\n        var addListener = function (fn) {\n            listeners.unshift(fn);\n        };\n        var removeListener = function (fn) {\n            for (var i = 0; i < listeners.length; i += 1) {\n                if (listeners[i] === fn) {\n                    listeners.splice(i, 1);\n                    return;\n                }\n            }\n        };\n        var taskComplete = function () {\n            _each(listeners.slice(0), function (fn) {\n                fn();\n            });\n        };\n\n        addListener(function () {\n            if (_keys(results).length === keys.length) {\n                callback(null, results);\n                callback = function () {};\n            }\n        });\n\n        _each(keys, function (k) {\n            var task = (tasks[k] instanceof Function) ? [tasks[k]]: tasks[k];\n            var taskCallback = function (err) {\n                var args = Array.prototype.slice.call(arguments, 1);\n                if (args.length <= 1) {\n                    args = args[0];\n                }\n                if (err) {\n                    var safeResults = {};\n                    _each(_keys(results), function(rkey) {\n                        safeResults[rkey] = results[rkey];\n                    });\n                    safeResults[k] = args;\n                    callback(err, safeResults);\n                    // stop subsequent errors hitting callback multiple times\n                    callback = function () {};\n                }\n                else {\n                    results[k] = args;\n                    async.setImmediate(taskComplete);\n                }\n            };\n            var requires = task.slice(0, Math.abs(task.length - 1)) || [];\n            var ready = function () {\n                return _reduce(requires, function (a, x) {\n                    return (a && results.hasOwnProperty(x));\n                }, true) && !results.hasOwnProperty(k);\n            };\n            if (ready()) {\n                task[task.length - 1](taskCallback, results);\n            }\n            else {\n                var listener = function () {\n                    if (ready()) {\n                        removeListener(listener);\n                        task[task.length - 1](taskCallback, results);\n                    }\n                };\n                addListener(listener);\n            }\n        });\n    };\n\n    async.waterfall = function (tasks, callback) {\n        callback = callback || function () {};\n        if (tasks.constructor !== Array) {\n          var err = new Error('First argument to waterfall must be an array of functions');\n          return callback(err);\n        }\n        if (!tasks.length) {\n            return callback();\n        }\n        var wrapIterator = function (iterator) {\n            return function (err) {\n                if (err) {\n                    callback.apply(null, arguments);\n                    callback = function () {};\n                }\n                else {\n                    var args = Array.prototype.slice.call(arguments, 1);\n                    var next = iterator.next();\n                    if (next) {\n                        args.push(wrapIterator(next));\n                    }\n                    else {\n                        args.push(callback);\n                    }\n                    async.setImmediate(function () {\n                        iterator.apply(null, args);\n                    });\n                }\n            };\n        };\n        wrapIterator(async.iterator(tasks))();\n    };\n\n    var _parallel = function(eachfn, tasks, callback) {\n        callback = callback || function () {};\n        if (tasks.constructor === Array) {\n            eachfn.map(tasks, function (fn, callback) {\n                if (fn) {\n                    fn(function (err) {\n                        var args = Array.prototype.slice.call(arguments, 1);\n                        if (args.length <= 1) {\n                            args = args[0];\n                        }\n                        callback.call(null, err, args);\n                    });\n                }\n            }, callback);\n        }\n        else {\n            var results = {};\n            eachfn.each(_keys(tasks), function (k, callback) {\n                tasks[k](function (err) {\n                    var args = Array.prototype.slice.call(arguments, 1);\n                    if (args.length <= 1) {\n                        args = args[0];\n                    }\n                    results[k] = args;\n                    callback(err);\n                });\n            }, function (err) {\n                callback(err, results);\n            });\n        }\n    };\n\n    async.parallel = function (tasks, callback) {\n        _parallel({ map: async.map, each: async.each }, tasks, callback);\n    };\n\n    async.parallelLimit = function(tasks, limit, callback) {\n        _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);\n    };\n\n    async.series = function (tasks, callback) {\n        callback = callback || function () {};\n        if (tasks.constructor === Array) {\n            async.mapSeries(tasks, function (fn, callback) {\n                if (fn) {\n                    fn(function (err) {\n                        var args = Array.prototype.slice.call(arguments, 1);\n                        if (args.length <= 1) {\n                            args = args[0];\n                        }\n                        callback.call(null, err, args);\n                    });\n                }\n            }, callback);\n        }\n        else {\n            var results = {};\n            async.eachSeries(_keys(tasks), function (k, callback) {\n                tasks[k](function (err) {\n                    var args = Array.prototype.slice.call(arguments, 1);\n                    if (args.length <= 1) {\n                        args = args[0];\n                    }\n                    results[k] = args;\n                    callback(err);\n                });\n            }, function (err) {\n                callback(err, results);\n            });\n        }\n    };\n\n    async.iterator = function (tasks) {\n        var makeCallback = function (index) {\n            var fn = function () {\n                if (tasks.length) {\n                    tasks[index].apply(null, arguments);\n                }\n                return fn.next();\n            };\n            fn.next = function () {\n                return (index < tasks.length - 1) ? makeCallback(index + 1): null;\n            };\n            return fn;\n        };\n        return makeCallback(0);\n    };\n\n    async.apply = function (fn) {\n        var args = Array.prototype.slice.call(arguments, 1);\n        return function () {\n            return fn.apply(\n                null, args.concat(Array.prototype.slice.call(arguments))\n            );\n        };\n    };\n\n    var _concat = function (eachfn, arr, fn, callback) {\n        var r = [];\n        eachfn(arr, function (x, cb) {\n            fn(x, function (err, y) {\n                r = r.concat(y || []);\n                cb(err);\n            });\n        }, function (err) {\n            callback(err, r);\n        });\n    };\n    async.concat = doParallel(_concat);\n    async.concatSeries = doSeries(_concat);\n\n    async.whilst = function (test, iterator, callback) {\n        if (test()) {\n            iterator(function (err) {\n                if (err) {\n                    return callback(err);\n                }\n                async.whilst(test, iterator, callback);\n            });\n        }\n        else {\n            callback();\n        }\n    };\n\n    async.doWhilst = function (iterator, test, callback) {\n        iterator(function (err) {\n            if (err) {\n                return callback(err);\n            }\n            if (test()) {\n                async.doWhilst(iterator, test, callback);\n            }\n            else {\n                callback();\n            }\n        });\n    };\n\n    async.until = function (test, iterator, callback) {\n        if (!test()) {\n            iterator(function (err) {\n                if (err) {\n                    return callback(err);\n                }\n                async.until(test, iterator, callback);\n            });\n        }\n        else {\n            callback();\n        }\n    };\n\n    async.doUntil = function (iterator, test, callback) {\n        iterator(function (err) {\n            if (err) {\n                return callback(err);\n            }\n            if (!test()) {\n                async.doUntil(iterator, test, callback);\n            }\n            else {\n                callback();\n            }\n        });\n    };\n\n    async.queue = function (worker, concurrency) {\n        if (concurrency === undefined) {\n            concurrency = 1;\n        }\n        function _insert(q, data, pos, callback) {\n          if(data.constructor !== Array) {\n              data = [data];\n          }\n          _each(data, function(task) {\n              var item = {\n                  data: task,\n                  callback: typeof callback === 'function' ? callback : null\n              };\n\n              if (pos) {\n                q.tasks.unshift(item);\n              } else {\n                q.tasks.push(item);\n              }\n\n              if (q.saturated && q.tasks.length === concurrency) {\n                  q.saturated();\n              }\n              async.setImmediate(q.process);\n          });\n        }\n\n        var workers = 0;\n        var q = {\n            tasks: [],\n            concurrency: concurrency,\n            saturated: null,\n            empty: null,\n            drain: null,\n            push: function (data, callback) {\n              _insert(q, data, false, callback);\n            },\n            unshift: function (data, callback) {\n              _insert(q, data, true, callback);\n            },\n            process: function () {\n                if (workers < q.concurrency && q.tasks.length) {\n                    var task = q.tasks.shift();\n                    if (q.empty && q.tasks.length === 0) {\n                        q.empty();\n                    }\n                    workers += 1;\n                    var next = function () {\n                        workers -= 1;\n                        if (task.callback) {\n                            task.callback.apply(task, arguments);\n                        }\n                        if (q.drain && q.tasks.length + workers === 0) {\n                            q.drain();\n                        }\n                        q.process();\n                    };\n                    var cb = only_once(next);\n                    worker(task.data, cb);\n                }\n            },\n            length: function () {\n                return q.tasks.length;\n            },\n            running: function () {\n                return workers;\n            }\n        };\n        return q;\n    };\n\n    async.cargo = function (worker, payload) {\n        var working     = false,\n            tasks       = [];\n\n        var cargo = {\n            tasks: tasks,\n            payload: payload,\n            saturated: null,\n            empty: null,\n            drain: null,\n            push: function (data, callback) {\n                if(data.constructor !== Array) {\n                    data = [data];\n                }\n                _each(data, function(task) {\n                    tasks.push({\n                        data: task,\n                        callback: typeof callback === 'function' ? callback : null\n                    });\n                    if (cargo.saturated && tasks.length === payload) {\n                        cargo.saturated();\n                    }\n                });\n                async.setImmediate(cargo.process);\n            },\n            process: function process() {\n                if (working) return;\n                if (tasks.length === 0) {\n                    if(cargo.drain) cargo.drain();\n                    return;\n                }\n\n                var ts = typeof payload === 'number'\n                            ? tasks.splice(0, payload)\n                            : tasks.splice(0);\n\n                var ds = _map(ts, function (task) {\n                    return task.data;\n                });\n\n                if(cargo.empty) cargo.empty();\n                working = true;\n                worker(ds, function () {\n                    working = false;\n\n                    var args = arguments;\n                    _each(ts, function (data) {\n                        if (data.callback) {\n                            data.callback.apply(null, args);\n                        }\n                    });\n\n                    process();\n                });\n            },\n            length: function () {\n                return tasks.length;\n            },\n            running: function () {\n                return working;\n            }\n        };\n        return cargo;\n    };\n\n    var _console_fn = function (name) {\n        return function (fn) {\n            var args = Array.prototype.slice.call(arguments, 1);\n            fn.apply(null, args.concat([function (err) {\n                var args = Array.prototype.slice.call(arguments, 1);\n                if (typeof console !== 'undefined') {\n                    if (err) {\n                        if (console.error) {\n                            console.error(err);\n                        }\n                    }\n                    else if (console[name]) {\n                        _each(args, function (x) {\n                            console[name](x);\n                        });\n                    }\n                }\n            }]));\n        };\n    };\n    async.log = _console_fn('log');\n    async.dir = _console_fn('dir');\n    /*async.info = _console_fn('info');\n    async.warn = _console_fn('warn');\n    async.error = _console_fn('error');*/\n\n    async.memoize = function (fn, hasher) {\n        var memo = {};\n        var queues = {};\n        hasher = hasher || function (x) {\n            return x;\n        };\n        var memoized = function () {\n            var args = Array.prototype.slice.call(arguments);\n            var callback = args.pop();\n            var key = hasher.apply(null, args);\n            if (key in memo) {\n                callback.apply(null, memo[key]);\n            }\n            else if (key in queues) {\n                queues[key].push(callback);\n            }\n            else {\n                queues[key] = [callback];\n                fn.apply(null, args.concat([function () {\n                    memo[key] = arguments;\n                    var q = queues[key];\n                    delete queues[key];\n                    for (var i = 0, l = q.length; i < l; i++) {\n                      q[i].apply(null, arguments);\n                    }\n                }]));\n            }\n        };\n        memoized.memo = memo;\n        memoized.unmemoized = fn;\n        return memoized;\n    };\n\n    async.unmemoize = function (fn) {\n      return function () {\n        return (fn.unmemoized || fn).apply(null, arguments);\n      };\n    };\n\n    async.times = function (count, iterator, callback) {\n        var counter = [];\n        for (var i = 0; i < count; i++) {\n            counter.push(i);\n        }\n        return async.map(counter, iterator, callback);\n    };\n\n    async.timesSeries = function (count, iterator, callback) {\n        var counter = [];\n        for (var i = 0; i < count; i++) {\n            counter.push(i);\n        }\n        return async.mapSeries(counter, iterator, callback);\n    };\n\n    async.compose = function (/* functions... */) {\n        var fns = Array.prototype.reverse.call(arguments);\n        return function () {\n            var that = this;\n            var args = Array.prototype.slice.call(arguments);\n            var callback = args.pop();\n            async.reduce(fns, args, function (newargs, fn, cb) {\n                fn.apply(that, newargs.concat([function () {\n                    var err = arguments[0];\n                    var nextargs = Array.prototype.slice.call(arguments, 1);\n                    cb(err, nextargs);\n                }]))\n            },\n            function (err, results) {\n                callback.apply(that, [err].concat(results));\n            });\n        };\n    };\n\n    var _applyEach = function (eachfn, fns /*args...*/) {\n        var go = function () {\n            var that = this;\n            var args = Array.prototype.slice.call(arguments);\n            var callback = args.pop();\n            return eachfn(fns, function (fn, cb) {\n                fn.apply(that, args.concat([cb]));\n            },\n            callback);\n        };\n        if (arguments.length > 2) {\n            var args = Array.prototype.slice.call(arguments, 2);\n            return go.apply(this, args);\n        }\n        else {\n            return go;\n        }\n    };\n    async.applyEach = doParallel(_applyEach);\n    async.applyEachSeries = doSeries(_applyEach);\n\n    async.forever = function (fn, callback) {\n        function next(err) {\n            if (err) {\n                if (callback) {\n                    return callback(err);\n                }\n                throw err;\n            }\n            fn(next);\n        }\n        next();\n    };\n\n    // AMD / RequireJS\n    if (typeof define !== 'undefined' && define.amd) {\n        define([], function () {\n            return async;\n        });\n    }\n    // Node.js\n    else if (typeof module !== 'undefined' && module.exports) {\n        module.exports = async;\n    }\n    // included directly via <script> tag\n    else {\n        root.async = async;\n    }\n\n}());\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails-generate/lib/util.js":"/**\n * From Express core: (MIT License)\n * https://github.com/visionmedia/express/blob/cec0c06a70c874298761282984573475293c0071/lib/utils.js#L173\n *\n * --------------------------------------------------\n *\n * Normalize the given path string,\n * returning a regular expression.\n *\n * An empty array should be passed,\n * which will contain the placeholder\n * key names. For example \"/user/:id\" will\n * then contain [\"id\"].\n *\n * @param  {String|RegExp|Array} path\n * @param  {Array} keys\n * @param  {Boolean} sensitive\n * @param  {Boolean} strict\n * @return {RegExp}\n * @api private\n */\n\nexports.pathRegexp = function(path, keys, sensitive, strict) {\n  if (toString.call(path) == '[object RegExp]') return path;\n  if (Array.isArray(path)) path = '(' + path.join('|') + ')';\n  path = path\n    .concat(strict ? '' : '/?')\n    .replace(/\\/\\(/g, '(?:/')\n    .replace(/(\\/)?(\\.)?:(\\w+)(?:(\\(.*?\\)))?(\\?)?(\\*)?/g, function(_, slash, format, key, capture, optional, star) {\n      keys.push({\n        name: key,\n        optional: !! optional\n      });\n      slash = slash || '';\n      return '' + (optional ? '' : slash) + '(?:' + (optional ? slash : '') + (format || '') + (capture || (format && '([^/.]+?)' || '([^/]+?)')) + ')' + (optional || '') + (star ? '(/*)?' : '');\n    })\n    .replace(/([\\/.])/g, '\\\\$1')\n    .replace(/\\*/g, '(.*)');\n  return new RegExp('^' + path + '$', sensitive ? '' : 'i');\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails-generate/lib/rootGenerator.js":"/**\n * Base generator definition\n * @type {Object}\n */\nmodule.exports = {\n\n  before: function(scope, sb) {\n    sb();\n  },\n  targets: {}\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails-generate/lib/rootScope.js":"module.exports = {\n\n  // Configurable misc. options\n  engine: 'ejs',\n  linker: true,\n  adapter: 'sails-disk',\n  _maxHops: 100,\n\n  // starting point\n  // (should be overidden as needed in generators' `before()` method)\n  rootPath: process.cwd(),\n\n\n\n  // i.e. command-line arguments\n  //\n  // For example, if this is `sails-generate-foo`:\n  // `sails generate foo bar`\n  // -> args = ['bar']\n  //\n  args: [],\n\n\n  // current recursion depth w/i a generator's target set\n  // (useful for preventing infinite loops)\n  _depth: 0\n\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails-generate/lib/target.js":"/**\n * Module dependencies\n * @type {Object}\n */\nvar util = require('util');\nvar _ = require('lodash');\nvar path = require('path');\nvar async = require('async');\nvar report = require('reportback')();\n\nvar generate = require('./generate');\nvar FolderHelper = require('./helpers/folder');\nvar TemplateHelper = require('./helpers/template');\nvar JSONFileHelper = require('./helpers/jsonfile');\nvar CopyHelper = require('./helpers/copy');\nvar NOOP_GENERATOR = require('./rootGenerator');\n\n\n/**\n * generateTarget()\n *\n * @param  {Object}   options\n */\n\nfunction generateTarget(options, cb) {\n\n  var sb = report.extend(cb);\n\n  // Options\n  var target = options.target;\n  var scope = options.scope;\n  var parentGenerator = options.parent;\n  var recursiveGenerate = options.recursiveGenerate;\n\n\n  var MAX_RESOLVES = 5,\n    _resolves = 0;\n\n  async.until(\n    function checkIfTargetIsValidYet() {\n      return isValidTarget(target) || (++_resolves > MAX_RESOLVES);\n    },\n    function tryToParseTarget(async_cb) {\n      parseTarget(target, scope, function(err, resolvedTarget) {\n        if (err) return async_cb(err);\n        target = resolvedTarget;\n        return async_cb();\n      });\n    },\n    function afterwards(err) {\n      if (err) return sb(err);\n      if (!isValidTarget(target)) {\n        return sb(new Error('Generator Error: Could not resolve target \"' + scope.rootPath + '\" (probably a recursive loop)'));\n      }\n\n      // Pass down parent Generator's template directory abs path\n      scope.templatesDirectory = parentGenerator.templatesDirectory;\n\n      // Interpret generator definition\n      if (target.exec) {\n        return target.exec(scope, sb);\n      }\n      if (target.copy) {\n        scope = mergeSubtargetScope(scope, typeof target.copy === 'string' ? {\n          templatePath: target.copy\n        } : target.copy);\n        return CopyHelper(scope, sb);\n      }\n      if (target.folder) {\n        scope = mergeSubtargetScope(scope, target.folder);\n        return FolderHelper(scope, sb);\n      }\n      if (target.template) {\n        scope = mergeSubtargetScope(scope, typeof target.template === 'string' ? {\n          templatePath: target.template\n        } : target.template);\n\n        return TemplateHelper(scope, sb);\n      }\n      if (target.jsonfile) {\n        if (typeof target.jsonfile === 'object') {\n          scope = mergeSubtargetScope(scope, target.jsonfile);\n        } else if (typeof target.jsonfile === 'function') {\n          scope = _.merge(scope, {\n            data: target.jsonfile(scope)\n          });\n        }\n        return JSONFileHelper(scope, sb);\n      }\n\n      // If we made it here, this must be a recursive generator:\n\n      // Now that the generator definition has been resolved,\n      // call this method recursively on it, passing along our\n      // callback:\n      if (++scope._depth > scope.maxHops) {\n        return sb(new Error('`maxHops` (' + scope.maxHops + ' exceeded!  There is probably a recursive loop in one of your generators.'));\n      }\n      return recursiveGenerate(target, scope, sb);\n\n    }\n  ); //</ async.until >//\n}\n\nmodule.exports = generateTarget;\n\n\n\n/**\n * @param  {[type]} scope     [description]\n * @param  {[type]} subtarget [description]\n * @return {[type]}           [description]\n */\nfunction mergeSubtargetScope(scope, subtarget) {\n  return _.merge(scope, _.isObject(subtarget) ? subtarget : {});\n}\n\n\n/**\n * Known helpers\n * @type {Array}\n */\nvar KNOWN_HELPERS = ['exec', 'folder', 'template', 'jsonfile', 'file', 'copy'];\n\nfunction targetIsHelper(target) {\n  return _.some(target, function(subTarget, key) {\n    return _.contains(KNOWN_HELPERS, key);\n  });\n}\n\n\n/**\n *\n * @param  {String|Object}   target      [description]\n * @param  {Object}          scope [description]\n * @param  {Function} cb          [description]\n * @return {[type]}               [description]\n */\nfunction parseTarget(target, scope, cb) {\n\n  if (typeof target === 'string') {\n    target = {\n      generator: target\n    };\n  }\n\n  // Interpret generator definition\n  if (targetIsHelper(target)) {\n    return cb(null, target);\n  }\n\n  if (target.generator) {\n\n    // Normalize the subgenerator reference\n    var subGeneratorRef;\n    if (typeof target.generator === 'string') {\n      subGeneratorRef = {\n        module: target.generator\n      };\n    } else if (typeof target.generator === 'object') {\n      subGeneratorRef = target.generator;\n    }\n    if (!subGeneratorRef) {\n      return cb(new Error('Generator Error: Invalid subgenerator referenced for target \"' + scope.rootPath + '\"'));\n    }\n\n    // Now normalize the sub-generator\n    var subGenerator;\n\n    // No `module` means we'll treat this subgenerator as an inline generator definition.\n    if (!subGeneratorRef.module) {\n      subGenerator = subGeneratorRef;\n      if (subGenerator) return cb(null, subGenerator);\n    }\n\n\n\n    //\n    // Otherwise, we'll attempt to load this subgenerator.\n    //\n\n\n    if (typeof subGeneratorRef.module === 'string') {\n      // Lookup the generator by name if a `module` was specified\n      // (this allows the module for a given generator to be\n      //  overridden.)\n      var configuredReference = scope.modules && scope.modules[subGeneratorRef.module];\n\n      // Refers to a configured module (i.e. sailsrc or comparable)\n      // so keep going.\n      if (configuredReference) {\n        return cb(null, configuredReference);\n      }\n\n      // If this generator type is explicitly set to `false`,\n      // disable the generator.\n      else if (configuredReference === false) {\n        return cb(null, NOOP_GENERATOR);\n      }\n\n      // If `configuredReference` is undefined, continue on\n      // and try to require the module.\n      //\n      // ||\n      // \\/\n    }\n\n    // At this point, subGeneratorRef.module should be a string,\n    // and the best guess at the generator module we're going\n    // to get.\n    var module = subGeneratorRef.module;\n    var requireError;\n\n    // Try requiring it directly as a path\n    try {\n      subGenerator = require(module);\n    } catch (e0) {\n      requireError = e0;\n    }\n\n    // Try the scope's rootPath\n    if (!subGenerator) {\n      try {\n        var asDependencyInRootPath = path.resolve(scope.rootPath, 'node_modules', module);\n        subGenerator = require(asDependencyInRootPath);\n      } catch (e1) {\n        requireError = e1;\n      }\n    }\n\n    // Try the current working directory\n    if (!subGenerator) {\n      try {\n        subGenerator = require(path.resolve(process.cwd(), 'node_modules', module));\n      } catch (e1) {\n        requireError = e1;\n      }\n    }\n\n\n    // If we couldn't find a generator using the configured module,\n    // try requiring \"sails-generate-<module>\" to get the core generator\n    if (!subGenerator && !module.match(/^sails-generate-/)) {\n      try {\n        subGenerator = require('sails-generate-' + module);\n      }\n\n      // Ok, we give up.\n      catch (e1) {\n        requireError = e1;\n      }\n    }\n\n\n    // If we were able to find it, send it back!\n    if (subGenerator) return cb(null, subGenerator);\n\n\n    // But if we still can't find it, give up.\n\n    // TODO: look for subGeneratorRef on npm\n    // TODO: emit a message to scope.output letting user know what's going on\n    return cb(\n      new Error('Generator Error: Failed to load \"' +\n        subGeneratorRef.module + '\"...' +\n        (requireError ? ' (' + requireError + ')' : '') +\n        ''));\n\n\n\n  } //fi// target.generator\n\n\n  return cb(new Error(\n    'Unrecognized generator syntax in `targets[\"' + scope.keyPath + '\"]` ::\\n' +\n    util.inspect(target)));\n}\n\n\n\n/**\n *\n * @param  {[type]}  target [description]\n * @return {Boolean}        [description]\n */\nfunction isValidTarget(target) {\n  var ok = true;\n\n  ok = ok && typeof target === 'object';\n\n  // Is using a helper\n  // Or is another generator def.\n  ok = ok && (targetIsHelper(target) || _.has(target, 'targets'));\n\n  return ok;\n}\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails-generate/lib/helpers/folder/index.js":"/**\n * Module dependencies\n */\nvar fs = require('fs-extra')\n\t, _ = require('lodash')\n\t, path = require('path')\n\t, async = require('async')\n\t, reportback = require('reportback')();\n\n\n\n\n/**\n * Generate a folder\n *\n * @option {String} rootPath\n * @option {Boolean} gitkeep\n * [@option {Boolean} force=false]\n *\n * @sb [success]\n * @sb alreadyExists\n * @sb invalid\n * @sb error\n */\nmodule.exports = function ( options, sb ) {\n\n\t// Provide default values for sb\n\tsb = reportback.extend(sb, {\n\t\talreadyExists: 'error',\n\t\tinvalid: 'error'\n\t});\n\n\t// Provide defaults and validate required options\n\t_.defaults(options, {\n\t\tforce: false,\n\t\tgitkeep: false\n\t});\n\tvar missingOpts = _.difference([\n\t\t'rootPath'\n\t], Object.keys(options));\n\tif ( missingOpts.length ) return sb.invalid(missingOpts);\n\n\n\tvar rootPath = path.resolve( process.cwd() , options.rootPath );\n\n\t\n\t// Only override an existing folder if `options.force` is true\n\tfs.lstat(rootPath, function(err, inodeStatus) {\n\t\tvar exists = !(err && err.code === 'ENOENT');\n\t\tif (exists && err) return sb.error(err);\n\n\t\tif (exists && !options.force) {\n\t\t\treturn sb.alreadyExists('Something else already exists at ::'+rootPath);\n\t\t}\n\t\tif (exists) {\n\t\t\tfs.remove(rootPath, function deletedOldINode(err) {\n\t\t\t\tif (err) return sb.error(err);\n\t\t\t\t_afterwards_();\n\t\t\t});\n\t\t} else _afterwards_();\n\n\t\tfunction _afterwards_() {\n\t\t\t\n\t\t\t// Don't actually write the directory if this is a dry run.\n\t\t\tif (options.dry) return sb.success();\n\n\t\t\t// Create the directory\n\t\t\tfs.mkdirs(rootPath, function directoryWasWritten(err) {\n\t\t\t\tif (err) return sb.error(err);\n\t\t\t\t// console.log('created dir at :::: ',rootPath);\n\t\t\t\treturn sb.success();\n\t\t\t});\n\t\t}\n\t});\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails-generate/node_modules/fs-extra/lib/index.js":"\"use strict\"\n\nvar fs = null\n  , path = require('path')\n  , jsonFile = require('jsonfile')\n  , json = require('./json')\n  , fse = {};\n\ntry {\n  // optional dependency\n  fs = require(\"graceful-fs\")\n} catch (er) {\n  fs = require(\"fs\")\n}\n\nObject.keys(fs).forEach(function(key) {\n  var func = fs[key];\n  if (typeof func == 'function')\n    fse[key] = func;\n});\n\nfs = fse;\n\n// copy\n\nfs.copy = require('./copy').copy;\nfs.copySync = require('./copy').copySync;\n\n// remove\n\nvar remove = require('./remove');\nfs.remove = remove.remove;\nfs.removeSync = remove.removeSync;\nfs['delete'] = fs.remove\nfs.deleteSync = fs.removeSync\n\n// mkdir\n\nvar mkdir = require('./mkdir')\nfs.mkdirs = mkdir.mkdirs\nfs.mkdirsSync = mkdir.mkdirsSync\nfs.mkdirp = mkdir.mkdirs\nfs.mkdirpSync = mkdir.mkdirsSync\n\n// create\n\nvar create = require('./create')\nfs.createFile = create.createFile;\nfs.createFileSync = create.createFileSync;\n\n//deprecated\nfs.touch = function touch() {\n  console.log('fs.touch() is deprecated. Please use fs.createFile().')\n  fs.createFile.apply(null, arguments)\n}\n\nfs.touchSync = function touchSync() {\n  console.log('fs.touchSync() is deprecated. Please use fs.createFileSync().')\n  fs.createFileSync.apply(null, arguments)\n}\n\n// output\n\nvar output = require('./output');\nfs.outputFile = output.outputFile;\nfs.outputFileSync = output.outputFileSync;\n\n// read\n\n/*fs.readTextFile = function(file, callback) {\n  return fs.readFile(file, 'utf8', callback)\n}\n\nfs.readTextFileSync = function(file, callback) {\n  return fs.readFileSync(file, 'utf8')\n}*/\n\n// json files\n\nfs.readJsonFile = jsonFile.readFile;\nfs.readJSONFile = jsonFile.readFile;\nfs.readJsonFileSync = jsonFile.readFileSync;\nfs.readJSONFileSync = jsonFile.readFileSync;\n\nfs.readJson = jsonFile.readFile;\nfs.readJSON = jsonFile.readFile;\nfs.readJsonSync = jsonFile.readFileSync;\nfs.readJSONSync = jsonFile.readFileSync;\n\nfs.outputJsonSync = json.outputJsonSync;\nfs.outputJSONSync = json.outputJsonSync;\nfs.outputJson = json.outputJson;\nfs.outputJSON = json.outputJson;\n\nfs.writeJsonFile = jsonFile.writeFile;\nfs.writeJSONFile = jsonFile.writeFile;\nfs.writeJsonFileSync = jsonFile.writeFileSync;\nfs.writeJSONFileSync = jsonFile.writeFileSync;\n\nfs.writeJson = jsonFile.writeFile;\nfs.writeJSON = jsonFile.writeFile;\nfs.writeJsonSync = jsonFile.writeFileSync;\nfs.writeJSONSync = jsonFile.writeFileSync;\n\n\nmodule.exports = fs\n\njsonFile.spaces = 2; //set to 2\nmodule.exports.jsonfile = jsonFile; //so users of fs-extra can modify jsonFile.spaces;\n\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails-generate/node_modules/jsonfile/lib/jsonfile.js":"var fs = require('fs');\n\nvar me = module.exports;\n\nme.spaces = 2;\n\nme.readFile = function(file, callback) {\n  fs.readFile(file, 'utf8', function(err, data) {\n    if (err) return callback(err, null);\n\n    var obj = null;\n    try {\n      obj = JSON.parse(data);\n    } catch (err2) {\n      callback(err2, null);\n      return;\n    }\n    callback(null, obj);\n  })\n}\n\nme.readFileSync = function(file) {\n  return JSON.parse(fs.readFileSync(file, 'utf8'));\n}\n\nme.writeFile = function(file, obj, options, callback) {\n  if (callback == null) { // odd little swap because options is optional\n    callback = options;\n    options = null;\n  }\n\n  var str = '';\n  try {\n    str = JSON.stringify(obj, null, module.exports.spaces);\n  } catch (err) {\n    if (callback) {\n      callback(err, null);\n    }\n    return;\n  }\n  fs.writeFile(file, str, options, callback);\n}\n\nme.writeFileSync = function(file, obj, options) {\n  var str = JSON.stringify(obj, null, module.exports.spaces);\n  return fs.writeFileSync(file, str, options); //not sure if fs.writeFileSync returns anything, but just in case\n}","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails-generate/node_modules/fs-extra/lib/json.js":"\"use strict\"\n\nvar jsonFile = require('jsonfile')\n  , fs = require('fs')\n  , mkdir = require('./mkdir')\n  , path = require('path')\n\nvar me = module.exports\n\nme.outputJsonSync = function(file, data) {\n  var dir = path.dirname(file)\n\n  if (!fs.existsSync(dir))\n    mkdir.mkdirsSync(dir)\n\n  jsonFile.writeFileSync(file, data)\n}\n\nme.outputJson = function(file, data, callback) {\n  var dir = path.dirname(file)\n\n  fs.exists(dir, function(itDoes) {\n    if (itDoes) return jsonFile.writeFile(file, data, callback)\n\n    mkdir.mkdirs(dir, function(err) {\n      if (err) return callback(err)\n      jsonFile.writeFile(file, data, callback)\n    })\n  })\n}","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails-generate/node_modules/fs-extra/lib/mkdir.js":"\"use strict\"\n\nvar mkdirp = require('mkdirp');\n\nmodule.exports.mkdirs = mkdirp;\nmodule.exports.mkdirsSync = mkdirp.sync;\n\n\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails-generate/node_modules/mkdirp/index.js":"var path = require('path');\nvar fs = require('fs');\n\nmodule.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;\n\nfunction mkdirP (p, mode, f, made) {\n    if (typeof mode === 'function' || mode === undefined) {\n        f = mode;\n        mode = 0777 & (~process.umask());\n    }\n    if (!made) made = null;\n\n    var cb = f || function () {};\n    if (typeof mode === 'string') mode = parseInt(mode, 8);\n    p = path.resolve(p);\n\n    fs.mkdir(p, mode, function (er) {\n        if (!er) {\n            made = made || p;\n            return cb(null, made);\n        }\n        switch (er.code) {\n            case 'ENOENT':\n                mkdirP(path.dirname(p), mode, function (er, made) {\n                    if (er) cb(er, made);\n                    else mkdirP(p, mode, cb, made);\n                });\n                break;\n\n            // In the case of any other error, just see if there's a dir\n            // there already.  If so, then hooray!  If not, then something\n            // is borked.\n            default:\n                fs.stat(p, function (er2, stat) {\n                    // if the stat fails, then that's super weird.\n                    // let the original error be the failure reason.\n                    if (er2 || !stat.isDirectory()) cb(er, made)\n                    else cb(null, made);\n                });\n                break;\n        }\n    });\n}\n\nmkdirP.sync = function sync (p, mode, made) {\n    if (mode === undefined) {\n        mode = 0777 & (~process.umask());\n    }\n    if (!made) made = null;\n\n    if (typeof mode === 'string') mode = parseInt(mode, 8);\n    p = path.resolve(p);\n\n    try {\n        fs.mkdirSync(p, mode);\n        made = made || p;\n    }\n    catch (err0) {\n        switch (err0.code) {\n            case 'ENOENT' :\n                made = sync(path.dirname(p), mode, made);\n                sync(p, mode, made);\n                break;\n\n            // In the case of any other error, just see if there's a dir\n            // there already.  If so, then hooray!  If not, then something\n            // is borked.\n            default:\n                var stat;\n                try {\n                    stat = fs.statSync(p);\n                }\n                catch (err1) {\n                    throw err0;\n                }\n                if (!stat.isDirectory()) throw err0;\n                break;\n        }\n    }\n\n    return made;\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails-generate/node_modules/fs-extra/lib/copy.js":"\"use strict\"\n\nvar fs = require('fs')\n  , ncp = require('ncp').ncp\n  , path = require('path')\n  , mkdir = require('./mkdir'),\n    create = require('./create')\n\nmodule.exports.copy = copy;\nmodule.exports.copySync = copySync;\n\nvar BUF_LENGTH = 64 * 1024\nvar _buff = new Buffer(BUF_LENGTH)\n\nvar copyFileSync = function(srcFile, destFile) {\n  var bytesRead, fdr, fdw, pos;\n  fdr = fs.openSync(srcFile, 'r');\n  fdw = fs.openSync(destFile, 'w');\n  bytesRead = 1;\n  pos = 0;\n  while (bytesRead > 0) {\n    bytesRead = fs.readSync(fdr, _buff, 0, BUF_LENGTH, pos);\n    fs.writeSync(fdw, _buff, 0, bytesRead);\n    pos += bytesRead;\n  }\n  fs.closeSync(fdr);\n  return fs.closeSync(fdw);\n}\n\nfunction copy(src, dest, filter, callback) {\n  if( typeof filter === \"function\" && !callback) {\n      callback = filter;\n      filter = null;\n  }\n  callback = callback || function(){}\n\n  fs.lstat(src, function(err, stats) {\n    if (err) return callback(err)\n\n    var dir = null\n    if (stats.isDirectory()) {\n      var parts = dest.split(path.sep)\n      parts.pop()\n      dir = parts.join(path.sep)\n    } else {\n      dir = path.dirname(dest)\n    }\n\n    fs.exists(dir, function(dirExists) {\n      if (dirExists) return ncp(src, dest, {filter: filter}, callback);\n      mkdir.mkdirs(dir, function(err) {\n        if (err) return callback(err)\n        ncp(src, dest, {filter: filter}, callback);\n      })\n    })\n  })\n}\n\nfunction copySync(src, dest, filter) {\n  filter = filter || function () { return true; };\n  var stats = fs.lstatSync(src),\n      destExists = fs.exists(dest),\n      performCopy = false;\n  if (stats.isFile()) {\n    if (filter instanceof RegExp) performCopy = filter.test(src);\n    else if (typeof filter === \"function\") performCopy = filter(src);\n    if(performCopy) {\n      if (!destExists) create.createFileSync(dest);\n      copyFileSync(src, dest);\n    }\n  }\n  else if (stats.isDirectory()) {\n    if (!destExists) mkdir.mkdirsSync(dest);\n    var contents = fs.readdirSync(src);\n    contents.forEach(function (content) {\n      copySync(src + \"/\" + content, dest + \"/\" + content);\n    });\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails-generate/node_modules/fs-extra/lib/create.js":"\"use strict\"\n\nvar mkdir = require('./mkdir')\n  , path = require('path')\n  , fs = require('fs')\n  , exists = fs.exists || path.exists\n  , existsSync = fs.existsSync || path.existsSync\n\nfunction createFile (file, callback) {\n  function makeFile() {\n    fs.writeFile(file, '', function(err) {\n      if (err)\n        callback(err)\n      else\n        callback(null);\n    })\n  }\n\n  exists(file, function(fileExists) {\n    if (fileExists)\n      return callback(null);\n    else {\n      var dir = path.dirname(file);\n\n      exists(dir, function(dirExists) {\n        if (!dirExists) {\n          mkdir.mkdirs(dir, function(err) {\n            if (err)\n              callback(err)\n            else\n              makeFile();\n          })\n        } else {\n          makeFile();\n        }\n      })\n    }\n  })\n}\n\n\nfunction createFileSync (file) {\n  if (existsSync(file))\n    return;\n\n  var dir = path.dirname(file);\n  if (!existsSync(dir))\n    mkdir.mkdirsSync(dir);\n\n  fs.writeFileSync(file, '');\n}\n\n\nmodule.exports.createFile = createFile;\nmodule.exports.createFileSync = createFileSync;","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails-generate/node_modules/fs-extra/lib/remove.js":"\"use strict\"\n\nvar rimraf = require('rimraf')\n  , fs = require('fs');\n\nfunction rmrfSync(dir) {\n    return rimraf.sync(dir);\n}\n\nfunction rmrf(dir, cb) {\n    if (cb != null) {\n        return rimraf(dir, cb);\n    } else {\n        return rimraf(dir, (function() {}));\n    }\n}\n\nmodule.exports.remove = rmrf;\nmodule.exports.removeSync = rmrfSync;\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails-generate/node_modules/fs-extra/lib/output.js":"\"use strict\"\n\nvar mkdir = require('./mkdir')\n  , path = require('path')\n  , fs = require('fs')\n  , exists = fs.exists || path.exists\n  , existsSync = fs.existsSync || path.existsSync\n\nfunction outputFile (file, data, encoding, callback) {\n  if (typeof encoding === 'function') {\n    callback = encoding\n    encoding = 'utf8'\n  }\n\n  var dir = path.dirname(file)\n  exists(dir, function(itDoes) {\n    if (itDoes) return fs.writeFile(file, data, encoding, callback)\n\n    mkdir.mkdirs(dir, function(err) {\n      if (err) return callback(err)\n\n      fs.writeFile(file, data, encoding, callback)\n    })\n  })\n}\n\n\nfunction outputFileSync (file, data, encoding) {\n  var dir = path.dirname(file)\n  if (existsSync(dir)) return fs.writeFileSync.apply(fs, arguments)\n  mkdir.mkdirsSync(dir)\n  fs.writeFileSync.apply(fs, arguments)\n}\n\n\nmodule.exports.outputFile = outputFile;\nmodule.exports.outputFileSync = outputFileSync;","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails-generate/lib/helpers/template/index.js":"/**\n * Module dependencies\n */\nvar fs = require('fs-extra');\nvar _ = require('lodash');\nvar path = require('path');\nvar async = require('async');\nvar reportback = require('reportback')();\nvar FileHelper = require('../file');\n\n\n\n/**\n * Read an `ejs` template, compile it using scope.\n * Then use `file` helper to write it to its destination.\n *\n * @option {String}    rootPath\n * @option {String}    templatePath\n * @option {Boolean}   force[=false]\n * @option {Boolean}   escapeHTMLEntities[=false]\n *\n * @sb.success\n * @sb.error\n * @sb.alreadyExists\n * @sb.noTemplate\n */\n\nmodule.exports = function(options, sb) {\n  sb = reportback.extend(sb, {\n    noTemplate: 'error',\n    alreadyExists: 'error'\n  });\n\n  // console.log('In templatehelper for :',options.rootPath);\n\n\n  // Compute the canonical path to a template\n  // given its relative path from its source generator's\n  // `templates` directory.\n  var absTemplatePath = path.resolve(options.templatesDirectory, options.templatePath);\n\n  fs.readFile(absTemplatePath, 'utf8', function(err, contents) {\n    if (err) {\n      err = err instanceof Error ? err : new Error(err);\n      err.message = 'Template error: ' + err.message;\n      err.path = absTemplatePath;\n      if (err.code === 'ENOENT') {\n        return sb.noTemplate(err);\n      } else return sb(err);\n    }\n    try {\n      contents = _.template(contents, options);\n\n      // With lodash teplates, HTML entities are escaped by default.\n      // Default assumption is we DON'T want that, so we'll reverse it.\n      if (!options.escapeHTMLEntities) {\n        contents = _.unescape(contents);\n      }\n    } catch (e) {\n      return sb(e);\n    }\n\n    return FileHelper(_.merge(options, {\n      contents: contents\n    }), sb);\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails-generate/lib/helpers/file/index.js":"/**\n * Module dependencies\n */\n\nvar fs = require('fs-extra');\nvar path = require('path');\nvar async = require('async');\nvar _ = require('lodash');\nvar reportback = require('reportback')();\n\n\n\n\n/**\n * Generate a file using the specified string.\n *\n * @option {String} rootPath\n * @option {String} contents - the string contents to write to disk\n * [@option {Boolean} force=false]\n * [@option {Boolean} dry=false]\n *\n * @sb success\n * @sb error\n * @sb invalid\n * @sb alreadyExists\n */\nmodule.exports = function(options, sb) {\n\n  // provide default values for switchback\n  sb = reportback.extend(sb, {\n    alreadyExists: 'error'\n  });\n\n  // Provide defaults and validate required options\n  _.defaults(options, {\n    force: false\n  });\n  var missingOpts = _.difference([\n    'contents',\n    'rootPath'\n  ], Object.keys(options));\n  if (missingOpts.length) return sb.invalid(missingOpts);\n\n  // In case we ended up here w/ a relative path,\n  // resolve it using the process's CWD\n  var rootPath = path.resolve(process.cwd(), options.rootPath);\n  // console.log('FileHelper trying to generate:',rootPath);\n\n  // Only override an existing file if `options.force` is true\n  fs.exists(rootPath, function(exists) {\n    if (exists && !options.force) {\n      return sb.alreadyExists('Something else already exists at ::' + rootPath);\n    }\n\n    // Don't actually write the file if this is a dry run.\n    if (options.dry) return sb.success();\n\n    async.series([\n\n      function deleteExistingFileIfNecessary(cb) {\n        if (!exists) return cb();\n        return fs.remove(rootPath, cb);\n      },\n      function writeToDisk(cb) {\n        fs.outputFile(rootPath, options.contents, cb);\n      }\n    ], sb);\n\n  });\n\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails-generate/lib/helpers/jsonfile/index.js":"/**\n * Module dependencies\n */\nvar fs = require('fs-extra')\n\t, _ = require('lodash')\n\t, path = require('path')\n\t, reportback = require('reportback')();\n\n\n\n/**\n * Generate a JSON file\n *\n * @option {String} rootPath\n * @option {Object} data\n * [@option {Boolean} force=false]\n *\n * @handlers success\n * @handlers error\n * @handlers alreadyExists\n */\nmodule.exports = function ( options, handlers ) {\n\n\t// Provide default values for handlers\n\thandlers = reportback.extend(handlers, {\n\t\talreadyExists: 'error'\n\t});\n\n\t// Provide defaults and validate required options\n\t_.defaults(options, {\n\t\tforce: false\n\t});\n\n\tvar missingOpts = _.difference([\n\t\t'rootPath',\n\t\t'data'\n\t], Object.keys(options));\n\tif ( missingOpts.length ) return handlers.invalid(missingOpts);\n\n\n\tvar rootPath = path.resolve( process.cwd() , options.rootPath );\n\n\t// Only override an existing file if `options.force` is true\n\tfs.exists(rootPath, function (exists) {\n\t\tif (exists && !options.force) {\n\t\t\treturn handlers.alreadyExists('Something else already exists at ::'+rootPath);\n\t\t}\n\n\t\tif ( exists ) {\n\t\t\tfs.remove(rootPath, function deletedOldINode (err) {\n\t\t\t\tif (err) return handlers.error(err);\n\t\t\t\t_afterwards_();\n\t\t\t});\n\t\t}\n\t\telse _afterwards_();\n\n\t\tfunction _afterwards_ () {\n\t\t\tfs.outputJSON(rootPath, options.data, function (err){\n\t\t\t\tif (err) return handlers.error(err);\n\t\t\t\telse handlers.success();\n\t\t\t});\n\t\t}\n\t});\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails-generate/lib/helpers/copy/index.js":"/**\n * Module dependencies\n */\nvar _ = require('lodash'),\n  fsx = require('fs-extra'),\n  path = require('path'),\n  reportback = require('reportback')(),\n  FileHelper = require('../file');\n\n\n/**\n * Copy file from one place to another.\n *\n * @option {String}    rootPath\n * @option {String}    templatePath\n * @option {Boolean}   force[=false]\n *\n * @cb.success\n * @cb.error\n * @cb.alreadyExists\n * @cb.invalid\n */\nmodule.exports = function(options, cb) {\n  cb = reportback.extend(cb, {\n    alreadyExists: 'error',\n    invalid: 'error'\n  });\n\n  // Compute the canonical path to copy from\n  // given its relative path from its source generator's\n  // `templates` directory.\n  var absSrcPath = path.resolve(options.templatesDirectory, options.templatePath);\n\n  fsx.readFile(absSrcPath, function(err, contents) {\n    if (err) return cb.error(err);\n    return FileHelper(_.merge(options, {\n      contents: contents\n    }), cb);\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/bin/sails-lift.js":"#!/usr/bin/env node\n\n\n/**\n * Module dependencies\n */\n\nvar nodepath = require('path');\nvar _ = require('@sailshq/lodash');\nvar chalk = require('chalk');\nvar captains = require('captains-log');\nvar package = require('../package.json');\nvar rconf = require('../lib/app/configuration/rc');\nvar Sails = require('../lib/app');\n\n\n\n/**\n * `sails lift`\n *\n * Expose method which lifts the appropriate instance of Sails.\n * (Fire up the Sails app in our working directory.)\n *\n * @stability 3\n * @see http://sailsjs.org/documentation/reference/command-line-interface/sails-lift\n */\n\nmodule.exports = function() {\n\n  // console.time('cli_lift');\n  // console.time('cli_prelift');\n\n  // console.time('cli_rc');\n  var log = captains(rconf.log);\n  // console.timeEnd('cli_rc');\n\n  console.log();\n  log.info(chalk.grey('Starting app...'));\n  console.log();\n\n  // Build initial scope, mixing-in rc config\n  var scope = _.merge({\n    rootPath: process.cwd(),\n    sailsPackageJSON: package\n  }, rconf);\n\n  var appPath = process.cwd();\n\n  // Use the app's local Sails in `node_modules` if it's extant and valid\n  var localSailsPath = nodepath.resolve(appPath, 'node_modules/sails');\n  if (Sails.isLocalSailsValid(localSailsPath, appPath)) {\n    var localSails = require(localSailsPath);\n    // console.timeEnd('cli_prelift');\n\n    localSails.lift(scope, afterwards);\n    return;\n  }\n\n  // Otherwise, if no workable local Sails exists, run the app\n  // using the currently running version of Sails.  This is\n  // probably always the global install.\n  var globalSails = Sails();\n  // console.timeEnd('cli_prelift');\n\n  globalSails.lift(scope, afterwards);\n\n\n  function afterwards (err, sails) {\n    if (err) {\n      var message = err.stack ? err.stack : err;\n      sails ? sails.log.error(message) : log.error(message); process.exit(1);\n    }\n    // try {console.timeEnd('cli_lift');}catch(e){}\n  }\n};\n\n\n\n\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/bin/sails-new.js":"#!/usr/bin/env node\n\n\n/**\n * Module dependencies\n */\n\nvar nodepath = require('path');\nvar _ = require('@sailshq/lodash');\nvar sailsgen = require('sails-generate');\nvar package = require('../package.json');\nvar rconf = require('../lib/app/configuration/rc');\n\n\n\n/**\n * `sails new`\n *\n * Generate a new Sails app.\n *\n * ```\n * # In the current directory:\n * sails new\n * ```\n *\n * ```\n * # As a new directory or within an existing directory:\n * sails new foo\n * ```\n *\n * @stability 3\n * @see http://sailsjs.org/documentation/reference/command-line-interface/sails-new\n * ------------------------------------------------------------------------\n * This command builds `scope` for the generator by scooping up any available\n * configuration using `rc` (merging config from env vars, CLI opts, and\n * relevant `.sailsrc` files).  Then it runs the `sails-generate-new`\n * generator (https://github.com/balderdashy/sails-generate-new).\n */\n\nmodule.exports = function () {\n\n  // Build initial scope\n  var scope = {\n    rootPath: process.cwd(),\n    modules: {},\n    sailsRoot: nodepath.resolve(__dirname, '..'),\n    sailsPackageJSON: package,\n    viewEngine: rconf.viewEngine\n  };\n\n  // Support --template option for backwards-compat.\n  if (!scope.viewEngine && rconf.template) {\n    scope.viewEngine = rconf.template;\n  }\n\n  // Mix-in rconf\n  _.merge(scope, rconf.generators);\n\n  // TODO: just do a top-level merge and reference\n  // `scope.generators.modules` as needed (simpler)\n  _.merge(scope, rconf);\n\n\n  // Pass the original CLI arguments down to the generator\n  // (but first, remove commander's extra argument)\n  var cliArguments = Array.prototype.slice.call(arguments);\n  cliArguments.pop();\n  scope.args = cliArguments;\n\n  scope.generatorType = 'new';\n\n  return sailsgen(scope, {\n    success: function() {}\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/bin/sails-www.js":"#!/usr/bin/env node\n\n\n/**\n * Module dependencies\n */\n\nvar nodepath = require('path');\nvar _ = require('@sailshq/lodash');\nvar CaptainsLog = require('captains-log');\nvar Sails = require('../lib/app');\nvar rconf = require('../lib/app/configuration/rc');\nvar GruntHookDef = require('../lib/hooks/grunt');\nvar Err = require('../errors');\n\n\n\n\n/**\n * `sails www`\n *\n * Run the `build` or `buildProd` Grunt task (depending on whether this is the production environment)\n * for the Sails app in the current working directory.\n *\n * @stability 2\n * @see http://sailsjs.org/documentation/reference/command-line-interface/sails-www\n */\n\nmodule.exports = function() {\n  var log = CaptainsLog(rconf.log);\n\n  // The destination path.\n  var wwwPath = nodepath.resolve(process.cwd(), './www');\n\n  // Note that we _load_ but _don't lift_ the app.  That means that the HTTP/Socket.io\n  // servers will not actually listen on ports.\n  var sails = Sails();\n  sails.load(_.merge({}, rconf, {\n    // We leave Grunt disabled\n    // (since we do all the Grunting ourselves using the raw hook definition below)\n    hooks: { grunt: false }\n  }), function whenAppIsLoaded(err) {\n    if (err) {\n      return Err.fatal.failedToLoadSails(err);\n    }\n\n    // Determine the appropriate Grunt task to run based on `sails.config.environment`\n    // (which is itself based on NODE_ENV).\n    var overrideGruntTask;\n    if (sails.config.environment === 'production') {\n      overrideGruntTask = 'buildProd';\n    }\n    else {\n      overrideGruntTask = 'build';\n    }\n    log.info('Compiling assets into standalone `www` directory with `grunt ' + overrideGruntTask + '`...');\n\n    // Pass in our app (`sails`) to the hook definition (factory function) in order to get\n    // a \"hydrated\" Grunt hook (a dictionary with methods and other fine goods)\n    var hydratedGruntHook = GruntHookDef(sails);\n\n    // Now use that sopping hook definition to run the appropriate Grunt task.\n    // (by the way, `runTask` is technically a private method, and so should not\n    //  be relied upon in userland code outside of Sails core.  Its usage may be\n    //  tweaked in a subsequent release.)\n    hydratedGruntHook.runTask(overrideGruntTask);\n\n    // Listen for `hook:grunt:error` event from the Grunt hook-- if fired,\n    // this means the Grunt child process exited with a non-zero status code.\n    // (meaning that someting went awry.)\n    sails.on('hook:grunt:error', function(err) {\n      log.error('Error occured running `grunt ' + overrideGruntTask + '`');\n      log.error('Please resolve any issues and try running `sails www` again.');\n      log.error('Details:');\n      log.error(err);\n      process.exit(1);\n    });\n\n    // Listen for `hook:grunt:done` event from the Grunt hook-- if fired,\n    // this means the Grunt child process exited with a zero status code.\n    // (meaning that everything worked as expected!)\n    sails.on('hook:grunt:done', function() {\n      log.info();\n      log.info('Created `www` directory at:');\n      log.info(wwwPath);\n      process.exit(0);\n    });\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/hooks/grunt/index.js":"module.exports = function(sails) {\n\n  /**\n   * Module dependencies\n   */\n\n  var _ = require('@sailshq/lodash');\n  var Err = require('../../../errors');\n  var path = require('path');\n  var fs = require('fs');\n  var ChildProcess = require('child_process');\n\n\n  /**\n   * Grunt hook\n   *\n   * A core hook for interacting with the Grunt-powered pipeline which\n   * is the conventional default in all new Sails apps.\n   *\n   *\n   * @event 'hook:grunt:loaded'\n   *        Emitted when the Grunt hook has been automatically loaded by Sails core, and\n   *        triggered the callback in its `initialize` function.\n   *\n   * @event 'hook:grunt:done'\n   *        Emitted when the Grunt child process exits with a normal status code.\n   *        (in development, this will not fire until the app is lowered, since grunt-contrib-watch\n   *         keeps the child process active)\n   *\n   * @event 'hook:grunt:error'\n   *        Emitted when the Grunt child process exits with a non-zero status code.\n   *\n   *\n   * > In development, note that *neither* the `grunt:hook:done`, *nor* the `grunt:hook:done` event will\n   * > fire until the app is lowered if you're using the default pipeline.\n   * > (This is because `grunt-contrib-watch` keeps the child process active.)\n   *\n   *\n   * @stability 2\n   * @see http://sailsjs.org/documentation/concepts/assets\n   */\n  return {\n\n\n    /**\n     * When this hook is initialized, load this project's Grunt tasks.\n     */\n    initialize: function(cb) {\n\n      sails.log.verbose('Loading app Gruntfile...');\n\n      // Determine the proper Grunt task to run.\n      var gruntTaskListName;\n\n      // Check to see if the user has specified a grunt task list for the current environment\n      // (i.e. sails.config.environment)\n      //\n      // Note: Your asset pipeline can also be made environment-specific by checking\n      // `sails.config.environment` from within the Gruntfile itself, or any task.\n      // This convenience feature exists to make it easier to drop in an environment-specific\n      // task list without doing any manual config or imperative coding.\n      //\n      // Docs on how to work with the default Grunt asset pipeline here:\n      // http://sailsjs.org/documentation/concepts/assets/default-tasks\n      var pathForEnvSpecificTaskList = path.resolve( sails.config.appPath, path.join('tasks/register/',sails.config.environment + '.js') );\n      if ( fs.existsSync(pathForEnvSpecificTaskList) ) {\n        gruntTaskListName = sails.config.environment;\n      }\n      // If the environment is \"production\", use the \"prod\" tasklist (unless a \"production\" tasklist exists)\n      else if (sails.config.environment === 'production') {\n        gruntTaskListName = 'prod';\n      }\n      else {\n        gruntTaskListName = 'default';\n      }\n\n      // Now run the appropriate Grunt task for this environment\n      // (spinning up a child process)\n      return this.runTask(gruntTaskListName, cb);\n\n    },\n\n\n    /**\n     * `runTask()`\n     *\n     * Fork a Grunt child process that runs the specified task.\n     *\n     * @param {String} taskName\n     *        The name of the Grunt task to run.\n     *\n     * @param {Function} cb\n     *        Optional.  Fires when the Grunt task has been started (non-production) or exits successfully (in production).\n     *        Note that the `grunt:hook:error` and `grunt:hook:done` events are fired regardless of whether\n     *        a callback is provided or not. Also note that this callback is not precisely equivalent to the semantic\n     *        of these two events (for backwards compatibility).\n     *\n     * @api private\n     *      (however note that this is called directly by `sails www` in the CLI)\n     */\n    runTask: function(taskName, cb_afterTaskStarted) {\n\n      // Determine the path to the root directory of the current running instance\n      // of Sails core.\n      var pathToSails = path.resolve(__dirname, '../../../');\n\n      // If provided task is not a string, fail silently.\n      // TODO: handle this more elegantly-- leaving this in as-is to ensure backwards compatiblity,\n      // but it should be replaced in a subsequent release with an error instead (b/c )\n      if (!taskName) {\n        taskName = '';\n      }\n\n      // Fork Grunt child process\n      var child = ChildProcess.fork(\n\n        // Set our Grunt wrapper file in Sails core as the working directory for\n        // the Grunt child process.\n        path.join(__dirname, 'grunt-wrapper.js'),\n\n        // Command-line arguments (e.g. `foo bar`) and command-line options (e.g. `--foo=\"bar\"`)\n        // to pass to the child process.\n        [\n          taskName,\n          '--pathToSails=' + pathToSails,\n\n          // Backwards compatibility for v0.9.x\n          '--gdsrc=' + pathToSails + '/node_modules'\n        ],\n\n        // Command-line options (e.g. `--foo=\"bar\"`) to pass to the child process.\n        {\n          silent: true,\n          stdio: 'pipe',\n          // Pass all current node process arguments to the child process,\n          // except the debug-related arguments, see issue #2670\n          execArgv: process.execArgv.slice(0).filter(function(param) {\n            return !(new RegExp('--debug(-brk=[0-9]+)?').test(param));\n          })\n        }\n      );\n\n\n      // Initialize local variables which will be used to buffer the\n      // incoming output from our Grunt child process.\n      //\n      // `errorMsg` will end up holding the human-readable error message,\n      // while `stackTrace` will end up with our best guess at a reasonable\n      // stack trace parsed from the incoming child proc output.\n      var errorMsg = '';\n      var stackTrace = '';\n\n\n      // Receive output as it comes in from the child proc's stdout\n      // (e.g. when Grunt does `console.log()`)\n      child.stdout.on('data', function(consoleMsg) {\n\n        // store all the output\n        consoleMsg = consoleMsg.toString();\n        errorMsg += consoleMsg;\n\n        // Clean out all the whitespace\n        var trimmedStackTrace = (typeof stackTrace === 'string') ? stackTrace : '';\n        trimmedStackTrace = trimmedStackTrace.replace(/[\\n\\s]*$/, '');\n        trimmedStackTrace = trimmedStackTrace.replace(/^[\\n\\s]*/, '');\n        var trimmedConsoleMsg = (typeof consoleMsg === 'string') ? consoleMsg : '';\n        trimmedConsoleMsg = trimmedConsoleMsg.replace(/[\\n\\s]*$/, '');\n        trimmedConsoleMsg = trimmedConsoleMsg.replace(/^[\\n\\s]*/, '');\n\n        // Remove '--force to continue' message since it makes no sense\n        // in this context:\n        trimmedConsoleMsg = trimmedConsoleMsg.replace(/Use --force to continue\\./i, '');\n        trimmedStackTrace = trimmedStackTrace.replace(/Use --force to continue\\./i, '');\n\n        // Find the stack trace related to this warning\n        stackTrace = errorMsg.substring(errorMsg.lastIndexOf('Running \"'));\n\n        // Handle fatal errors, like missing grunt dependency, etc.\n        if (consoleMsg.match(/Fatal error/g)) {\n\n          // If no Gruntfile exists, don't crash- just display a warning.\n          if (consoleMsg.match(/Unable to find Gruntfile/i)) {\n            sails.log.info('Gruntfile could not be found.');\n            sails.log.info('(no grunt tasks will be run.)');\n\n            // In production, we consider this the end and trigger the callback if provided.\n            // (otherwise, we've already triggered the callback at this point, when the task started)\n            if (sails.config.environment === 'production') {\n              if (_.isFunction(cb_afterTaskStarted)) {  return cb_afterTaskStarted();  }\n              else { sails.log.verbose('`runTask()` could not find a Gruntfile.'); }\n            }\n            return;\n          } // </console message contains \"Unable to find Gruntfile\">\n\n          // Otherwise this is some other kind of fatal error, so log it as a \"Grunt aborted\" error.\n          else {\n            Err.fatal.__GruntAborted__(trimmedConsoleMsg, trimmedStackTrace);\n            return;\n          }\n\n        } // </console message contains \"Fatal error\">\n\n        // Handle fatal Grunt errors by killing Sails process as well:\n        ////////////////////////////////////////////////////////////////////\n        //\n        // \"Aborted due to warnings\"\n        else if (consoleMsg.match(/Aborted due to warnings/)) {\n          sails.log.error('** Grunt :: An error occurred. **');\n          // sails.log.warn(trimmedStackTrace);\n          // sails.emit('hook:grunt:error', trimmedStackTrace);\n          Err.fatal.__GruntAborted__(trimmedConsoleMsg, trimmedStackTrace);\n          return;\n        } // </console message contains \"Aborted due to warnings\">\n\n        // \"Warning: EMFILE\"\n        else if (consoleMsg.match(/EMFILE/ig)){\n          sails.log.error('** Grunt :: An EMFILE error occurred. **');\n          sails.log.error(\n            'Usually this means there are too many files open as per your system settings.\\n'+\n            'If you are developing on one of the many unix-based operating systems that has\\n'+\n            'the `ulimit` command, then you might try running: `ulimit -n 1024`.  For more tips,\\n'+\n            'see https://github.com/balderdashy/sails/issues/3523#issuecomment-175922746.\\n'+\n            '(command[]+double-click to open links in the terminal)'\n          );\n          Err.fatal.__GruntAborted__(trimmedConsoleMsg, trimmedStackTrace);\n          return;\n        } // </console message contains \"Warning: EMFILE\">\n\n        // \"ParseError\"\n        else if (consoleMsg.match(/ParseError/)) {\n          sails.log.warn('** Grunt :: Parse Warning **');\n          sails.log.warn(trimmedStackTrace);\n        } // </console message contains \"ParseError\">\n\n        // Only display console message if it has content besides whitespace\n        //////////////////////////////////////////////////////////////////\n        else if (!consoleMsg.match(/^\\s*$/)) {\n          sails.log.verbose('Grunt :: ' + trimmedConsoleMsg);\n        } // </console message has content which is not whitespace>\n\n      }); // </ stdout.on('data') >\n\n\n      // Handle errors on the stdout stream\n      // (rare- this is mainly to prevent throwing and crashing the process)\n      child.stdout.on('error', function(gruntOutput) {\n        sails.log.error('Grunt ::', _sanitize(gruntOutput));\n      }); //</on stdout error>\n\n      // Receive output from the proc's stderr stream.\n      // (e.g. when Grunt does `console.error()`)\n      child.stderr.on('data', function(gruntOutput) {\n        gruntOutput = _sanitize(gruntOutput);\n        // Ignore the \"debugger listening\" message from node --debug\n        if (gruntOutput.match(/debugger listening on port/)) {\n          return;\n        }\n        // Any other stderr output gets logged using `sails.log.error`.\n        else {\n          sails.log.error('Grunt ::', gruntOutput);\n        }\n      }); //</on stderr data>\n\n      // Handle errors on the stderr stream.\n      // (rare- this is mainly to prevent throwing and crashing the process)\n      child.stderr.on('error', function(gruntOutput) {\n        sails.log.error('Grunt ::', _sanitize(gruntOutput));\n      }); //</on stderr error>\n\n\n      // When Grunt child process exits, fire event on `sails` app object.\n      child.on('exit', function(code) {\n\n        // If this is a non-zero status code, emit the 'hook:grunt:error' event.\n        if (code !== 0) {\n          // (in production, the callback is called in the appropriate spots above, so\n          //  it does not need to be triggered again here)\n          // --TODO: make this implementation simpler!  It'll be a breaking change.--\n          return sails.emit('hook:grunt:error');\n        }\n\n        // Otherwise emit 'hook:grunt:done'\n        sails.emit('hook:grunt:done');\n\n        // Note that, if we're in a production environment, we wait until the Grunt\n        // child process actually exits (Grunt task finishes running) before firing\n        // the callback passed in to `runTask`.\n        // (if this is not production, then we already fired the callback when the\n        //  task was first run)\n        if (sails.config.environment === 'production') {\n          if (_.isFunction(cb_afterTaskStarted)) { return cb_afterTaskStarted(); }\n          else { sails.log.verbose('`runTask()` has finished the Grunt task.'); }\n        }\n      }); //</when child process exits>\n\n      // Since there could be long-running tasks like `grunt-contrib-watch` involved,\n      // we'll want the ability to flush our child process later.\n      // So we save a reference to it on `sails.childProcesses`.\n      sails.log.verbose('Tracking new grunt child process...');\n      if (!_.isArray(sails.childProcesses)) {\n        var consistencyViolationErr = new Error(\n        'Consistency violation: `sails.childProcesses` should exist and be an array.  ' +\n        'Instead it\\'s type: `' + typeof sails.childProcesses + '` '+\n        'This means that either a custom hook or app code has damaged the `sails.childProcesses` array, '+\n        'or there is a bug in Sails core.  If you expect the latter, please file an issue in the GitHub repo.'\n        );\n        if (_.isFunction(cb_afterTaskStarted)) {  return cb_afterTaskStarted(consistencyViolationErr);  }\n        else { sails.log.error(consistencyViolationErr); }\n      }\n      sails.childProcesses.push(child);\n\n\n      // Now that the child process is chugging along, if we are NOT in a production\n      // environment, we'll go ahead and fire our callback (since Grunt might just be sitting\n      // here backgrounded, assuming the conventional default pipeline is being used with\n      // grunt-contrib-watch.)\n      //\n      // Note that, if we were in a production environment, we'd wait until the Grunt\n      // child proc actually finished running before firing our callback.  But we go ahead\n      // and fire it here.\n      if (sails.config.environment !== 'production') {\n        if (_.isFunction(cb_afterTaskStarted)) {  return cb_afterTaskStarted();  }\n        else { sails.log.verbose('`runTask()` has started the Grunt task.'); }\n      }\n    }\n  };\n};\n\n\n/**\n * After ensuring a chunk is a string, trim any leading or\n * trailing whitespace.  If chunk cannot be nicely casted to a string,\n * pass it straight through.\n *\n * TODO: use `util.inspect()` and/or `rttc.compile()`to squeeze better string output out of non-strings.\n * TODO: when Lodash is upgraded, use `_.trim()`\n *\n * @param  {*} chunk\n * @return {*}\n */\nfunction _sanitize(chunk) {\n\n  if (chunk && typeof chunk === 'object' && chunk.toString) {\n    chunk = chunk.toString();\n  }\n  if (typeof chunk === 'string') {\n    chunk = chunk.replace(/^[\\s\\n]*/, '');\n    chunk = chunk.replace(/[\\s\\n]*$/, '');\n  }\n  return chunk;\n}\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/bin/sails.js":"#!/usr/bin/env node\n\n\n/**\n * Module dependencies\n */\n\nvar _ = require('@sailshq/lodash');\nvar program = require('./_commander');\nvar package = require('../package.json');\nvar NOOP = function() {};\n\n\n\nprogram\n  .version(package.version, '-v, --version');\n\n\n//\n// Normalize version argument, i.e.\n//\n// $ sails -v\n// $ sails -V\n// $ sails --version\n// $ sails version\n//\n\n\n// make `-v` option case-insensitive\nprocess.argv = _.map(process.argv, function(arg) {\n  return (arg === '-V') ? '-v' : arg;\n});\n\n\n// $ sails version (--version synonym)\nprogram\n  .command('version')\n  .description('')\n  .action(program.versionInformation);\n\n\n\nprogram\n  .option('--silent')\n  .option('--verbose')\n  .option('--silly')\n  .unknownOption = NOOP;\nprogram.usage('[command]');\n\n\n// $ sails lift\nvar cmd;\ncmd = program.command('lift');\ncmd.option('--prod');\ncmd.option('--port [port]');\ncmd.unknownOption = NOOP;\ncmd.description('');\ncmd.alias('l');\ncmd.action(require('./sails-lift'));\n\n\n// $ sails new <appname>\ncmd = program.command('new [path_to_new_app]');\n// cmd.option('--dry');\ncmd.option('--viewEngine [viewEngine]');\ncmd.option('--template [viewEngine]');\ncmd.usage('[path_to_new_app]');\ncmd.unknownOption = NOOP;\ncmd.action(require('./sails-new'));\n\n\n// $ sails generate <module>\ncmd = program.command('generate');\n// cmd.option('--dry');\ncmd.unknownOption = NOOP;\ncmd.description('');\ncmd.usage('[something]');\ncmd.action(require('./sails-generate'));\n\n// $ sails deploy\ncmd = program.command('deploy');\n// cmd.option('--dry');\ncmd.unknownOption = NOOP;\ncmd.description('');\ncmd.usage('');\ncmd.action(require('./sails-deploy'));\n\n\n// $ sails console\ncmd = program.command('console');\ncmd.unknownOption = NOOP;\ncmd.description('');\ncmd.alias('c');\ncmd.action(require('./sails-console'));\n\n\n// $ sails www\n// Compile `assets` directory into a standalone `www` folder.\ncmd = program.command('www');\ncmd.unknownOption = NOOP;\ncmd.description('');\ncmd.action(require('./sails-www'));\n\n\n\n// $ sails debug\ncmd = program.command('debug');\ncmd.unknownOption = NOOP;\ncmd.description('');\ncmd.action(require('./sails-debug'));\n\n\n\n//\n// Normalize help argument, i.e.\n//\n// $ sails --help\n// $ sails help\n// $ sails\n// $ sails <unrecognized_cmd>\n//\n\n\n// $ sails help (--help synonym)\ncmd = program.command('help');\ncmd.description('');\ncmd.action(program.usageMinusWildcard);\n\n\n\n// $ sails <unrecognized_cmd>\n// Mask the '*' in `help`.\nprogram\n  .command('*')\n  .action(program.usageMinusWildcard);\n\n\n\n// Don't balk at unknown options\nprogram.unknownOption = NOOP;\n\n\n\n// $ sails\n//\nprogram.parse(process.argv);\nvar NO_COMMAND_SPECIFIED = program.args.length === 0;\nif (NO_COMMAND_SPECIFIED) {\n  program.usageMinusWildcard();\n}\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/preinstall_npmcheck.js":"/**\n * npm pre-install script.\n *\n * This script checks if the installed npm-version matches the required engine\n * defined in the package.json.\n */\n\nvar exec = require('child_process').exec;\nvar project = require('./../package.json');\n\n\n// Validate npm version before installing Sails.\nif (project.engines && project.engines.npm) exec('npm -v', validateNpmVersion);\n\n/**\n * Callback for the 'npm -v' execution.\n * @param  err    Possible command execution error.\n * @param  stdout Command execution result.\n */\nfunction validateNpmVersion(err, stdout) {\n\n  // Throw-up process errors.\n  if (err) return exitWithMessage(err);\n\n  // Parse Semver for current and required.\n  var semver = getSemver(stdout);\n  var requiredNpmSemver = getSemver(project.engines.npm, true);\n\n  // Get only the release numbering.\n  var version = semver && semver[1];\n  var requiredNpmVersion = requiredNpmSemver && requiredNpmSemver[1];\n\n  // If no version is identified, stop install.\n  if (!version) exitWithMessage([\n    'Unable to check your npm-version',\n    '',\n    'Please reinstall npm to use Sails.js'\n  ]);\n\n  // Handle old npm installations.\n  if (!satisfiesVersion(version, requiredNpmVersion)) exitWithMessage([\n    'Your current npm version (' + version + ') is not supported:',\n    'Sails requires at least version ' + project.engines.npm,\n    '',\n    'Try uploading npm before installing Sails.'\n  ]);\n\n  console.log('Sails.js Installation: Checking npm-version successful');\n\n  // Exit process with success.\n  process.exit(0);\n}\n\n/**\n * Exit proccess with a given error beautifully.\n */\nfunction exitWithMessage(err, code) {\n\n  // Exit error header.\n  console.log('\\033[31mSails.js Installation - Error');\n  console.log('--------------------------------------------------------\\033[00m');\n\n  // Exit (possibly multiple) error lines.\n  (typeof err === 'string' ? [err] : err).forEach(function (err) {\n    console.log(err);\n  });\n\n  // Exit error footer.\n  console.log('\\033[31m--------------------------------------------------------');\n\n  // Exit processing with a 1 (error) default code.\n  process.exit(code === undefined ? 1 : code);\n}\n\n/**\n * Parse version string into semver array.\n * @param {string} version\n * @param {boolean} range If version is a range, make sure to consider up-front\n *                        specification.\n * @return {Array}  An array with the version's parts or null if not valid.\n */\nfunction getSemver(version, range) {\n\n  // Fulfil possibly missing zeros, if range is allowed.\n  if (range) {\n    version = version.split('.');\n    var missing = 3 - version.length;\n\n    for(;missing > 0; missing--) {\n      version.push(0);\n    }\n\n    version = version.join('.');\n  }\n\n  var versionRegex = '(([0-9]{1,})\\\\.([0-9]{1,})\\\\.([0-9]{1,}))(?:-?(.*))';\n  var regex = new RegExp('^' + (range ? '(?:.*)' : '') + versionRegex + '$');\n\n  return version.replace(/\\s+/g, '').match(regex);\n}\n\n/**\n * Makes a simple '>=' version comparison.\n * @param  {string} version\n * @param  {string} compare\n * @return {boolean}\n */\nfunction satisfiesVersion(version, compare) {\n  version = version.split('.');\n  compare = compare.split('.');\n  var satisfied;\n\n  return compare.every(function (value, i) {\n    if (satisfied !== undefined) return satisfied;\n    if (version[i] > value) return satisfied = true;\n    if (version[i] < value) return satisfied = false;\n\n    return true;\n  }) && satisfied !== false;\n}\n"}