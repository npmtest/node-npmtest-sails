{"/home/travis/build/npmtest/node-npmtest-sails/test.js":"/* istanbul instrument in package npmtest_sails */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-sails/lib.npmtest_sails.js":"/* istanbul instrument in package npmtest_sails */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_sails = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_sails = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-sails/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-sails && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_sails */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_sails\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_sails.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_sails.rollup.js'] =\n            local.assetsDict['/assets.npmtest_sails.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_sails.__dirname + '/lib.npmtest_sails.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/index.js":"/**\n * Module dependencies\n */\n\nvar Sails = require('./app');\n\n\n\n// Instantiate and expose a Sails singleton\n// (maintains legacy support)\nmodule.exports = new Sails();\n\n// Expose constructor for convenience/tests\nmodule.exports.Sails = Sails;\n\n\n// To access the Sails app constructor, do:\n// var Sails = require('sails').constructor;\n// or:\n// var Sails = require('sails').Sails;\n//\n// Then:\n// var newApp = new Sails();\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/app/index.js":"/**\n * Module dependencies.\n */\n\n// try {console.time('require_core');}catch(e){}\nvar Sails = require('./Sails');\nvar _ = require('@sailshq/lodash');\n\n\n/**\n * Expose `Sails` factory\n * (maintains backwards compatibility w/ constructor usage)\n */\n\nmodule.exports = SailsFactory;\n\nfunction SailsFactory() {\n  return new Sails();\n}\n\n\n// Backwards compatibility for Sails singleton usage:\nvar singleton = SailsFactory();\nSailsFactory.isLocalSailsValid = _.bind(singleton.isLocalSailsValid, singleton);\nSailsFactory.isSailsAppSync = _.bind(singleton.isSailsAppSync, singleton);\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/app/Sails.js":"/**\n * Module dependencies.\n */\n\nvar events = require('events');\nvar _ = require('@sailshq/lodash');\nvar util = require('util');\nvar loadSails = require('./load');\nvar mixinAfter = require('./private/after');\nvar __Router = require('../router');\nvar CaptainsLog = require('captains-log');\n\n\n\n/**\n * Construct a Sails (app) instance.\n *\n * @constructor\n */\n\nfunction Sails() {\n\n  // Inherit methods from EventEmitter\n  events.EventEmitter.call(this);\n\n  // Remove memory-leak warning about max listeners\n  // See: http://nodejs.org/docs/latest/api/events.html#events_emitter_setmaxlisteners_n\n  this.setMaxListeners(0);\n\n  // Keep track of spawned child processes\n  this.childProcesses = [];\n\n  // Ensure CaptainsLog exists\n  this.log = CaptainsLog();\n\n  // Build a Router instance (which will attach itself to the sails object)\n  __Router(this);\n\n  // Mixin `load()` method to load the pieces\n  // of a Sails app\n  this.load = loadSails(this);\n\n  // Mixin support for `Sails.prototype.after()`\n  mixinAfter(this);\n\n  // Bind `this` context for all `Sails.prototype.*` methods\n  this.load = _.bind(this.load, this);\n  this.request = _.bind(this.request, this);\n  this.lift = _.bind(this.lift, this);\n  this.lower = _.bind(this.lower, this);\n  this.getBaseurl = _.bind(this.getBaseurl, this);\n  this.initialize = _.bind(this.initialize, this);\n  this.exposeGlobals = _.bind(this.exposeGlobals, this);\n  this.runBootstrap = _.bind(this.runBootstrap, this);\n  this.getHost = _.bind(this.getHost, this);\n  this.isLocalSailsValid = _.bind(this.isLocalSailsValid, this);\n  this.isSailsAppSync = _.bind(this.isSailsAppSync, this);\n  this.inspect = _.bind(this.inspect, this);\n  this.toString = _.bind(this.toString, this);\n  this.toJSON = _.bind(this.toJSON, this);\n  this.all = _.bind(this.all, this);\n  this.get = _.bind(this.get, this);\n  this.post = _.bind(this.post, this);\n  this.put = _.bind(this.put, this);\n  this['delete'] = _.bind(this['delete'], this);\n}\n\n\n// Extend from EventEmitter to allow hooks to listen to stuff\nutil.inherits(Sails, events.EventEmitter);\n\n\n// Public methods\n////////////////////////////////////////////////////////\n\nSails.prototype.lift = require('./lift');\n\nSails.prototype.lower = require('./lower');\n\nSails.prototype._getBaseUrl = require('./getBaseurl');\nSails.prototype.getBaseurl = function() {\n  this.log.warn(\"sails.getBaseUrl() is deprecated and will be removed in Sails v1.0.  See http://sailsjs.org/documentation/reference/application/sails-getbaseurl for more info.\");\n  return this._getBaseUrl();\n};\nSails.prototype.getBaseURL = Sails.prototype.getBaseurl;\nSails.prototype.getBaseUrl = Sails.prototype.getBaseurl;\n\n\nSails.prototype.getRouteFor = require('./get-route-for');\nSails.prototype.getUrlFor = require('./get-url-for');\n\n\n\n// Experimental methods\n////////////////////////////////////////////////////////\n\nSails.prototype.request = require('./request');\n\n\n// Expose Express-esque synonyms for low-level usage of router\nSails.prototype.all = function(path, action) {\n  this.router.bind(path, action);\n  return this;\n};\nSails.prototype.get = function(path, action) {\n  this.router.bind(path, action, 'get');\n  return this;\n};\nSails.prototype.post = function(path, action) {\n  this.router.bind(path, action, 'post');\n  return this;\n};\nSails.prototype.put = function(path, action) {\n  this.router.bind(path, action, 'put');\n  return this;\n};\nSails.prototype.del = Sails.prototype['delete'] = function(path, action) {\n  this.router.bind(path, action, 'delete');\n  return this;\n};\n\n// Private methods:\n////////////////////////////////////////////////////////\n\nSails.prototype.initialize = require('./private/initialize');\nSails.prototype.exposeGlobals = require('./private/exposeGlobals');\nSails.prototype.runBootstrap = require('./private/bootstrap');\nSails.prototype.getHost = require('./private/getHost');\nSails.prototype.isLocalSailsValid = require('./private/isLocalSailsValid');\nSails.prototype.isSailsAppSync = require('./private/isSailsAppSync');\n\n// Presentation\nSails.prototype.inspect = require('./private/inspect');\nSails.prototype.toString = require('./private/toString');\nSails.prototype.toJSON = require('./private/toJSON');\n\n// Utilities\n// Includes lodash, node's `util`, and a few additional\n// static helper methods.\n// (may be deprecated in a future release)\nSails.prototype.util = require('sails-util');\n\n// Expose Sails constructor\nmodule.exports = Sails;\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/app/load.js":"var async = require('async');\nvar _ = require('@sailshq/lodash');\nvar util = require('util');\nvar __Configuration = require('./configuration');\nvar __initializeHooks = require('./private/loadHooks');\n\nmodule.exports = function(sails) {\n\n  var Configuration = __Configuration(sails);\n  var initializeHooks = __initializeHooks(sails);\n\n  /**\n   * Expose loader start point.\n   * (idempotent)\n   *\n   * @api public\n   */\n  return function load(configOverride, cb) {\n\n    if (sails._exiting) {\n      return cb(new Error('\\n*********\\nCannot load or lift an app after it has already been lowered. \\nYou can make a new app instance with:\\nvar SailsApp = require(\\'sails\\').Sails;\\nvar sails = new SailsApp();\\n\\nAnd then you can do:\\nsails.load([opts,] cb)\\n\\n'));\n    }\n\n    // configOverride is optional\n    if (_.isFunction(configOverride)) {\n      cb = configOverride;\n      configOverride = {};\n    }\n\n    // Ensure override is an object and clone it (or make an empty object if it's not)\n    configOverride = configOverride || {};\n    sails.config = _.cloneDeep(configOverride);\n\n\n    // If host is explicitly specified, set `explicitHost`\n    // (otherwise when host is omitted, Express will accept all connections via INADDR_ANY)\n    if (configOverride.host) {\n      configOverride.explicitHost = configOverride.host;\n    }\n\n    // Optionally expose services, models, sails, _, async, etc. as globals as soon as the\n    // user config loads.\n    sails.on('hook:userconfig:loaded', sails.exposeGlobals);\n\n    async.auto({\n\n      // Apply core defaults and hook-agnostic configuration,\n      // esp. overrides including command-line options, environment variables,\n      // and options that were passed in programmatically.\n      config: [Configuration.load],\n\n      // Load hooks into memory, with their middleware and routes\n      hooks: ['config', loadHooks],\n\n      // Populate the \"registry\"\n      // Houses \"middleware-esque\" functions bound by various hooks and/or Sails core itself.\n      // (i.e. `function (req, res [,next]) {}`)\n      //\n      // (Basically, that means we grab an exposed `middleware` object,\n      // full of functions, from each hook, then make it available as\n      // `sails.middleware.[HOOK_ID]`.)\n      //\n      // TODO: finish refactoring to change \"middleware\" nomenclature\n      // to avoid confusion with the more specific (and more common)\n      // usage of the term.\n      registry: ['hooks',\n        function populateRegistry(cb) {\n\n          sails.log.verbose('Instantiating registry...');\n\n          // Iterate through hooks and absorb the middleware therein\n          // Save a reference to registry and expose it on\n          // the Sails instance.\n          sails.middleware = sails.registry =\n          // Namespace functions by their source hook's identity\n          _.reduce(sails.hooks, function(registry, hook, identity) {\n            registry[identity] = hook.middleware;\n            return registry;\n          }, {});\n\n          sails.emit('middleware:registered');\n\n          cb();\n        }\n      ],\n\n      // Load the router and bind routes in `sails.config.routes`\n      router: ['registry', sails.router.load]\n\n    }, ready__(cb));\n\n    // Makes `app.load()` chainable\n    return sails;\n  };\n\n  /**\n   * Load hooks in parallel\n   * let them work out dependencies themselves,\n   * taking advantage of events fired from the sails object\n   *\n   * @api private\n   */\n  function loadHooks(cb) {\n    sails.hooks = { };\n\n    // If config.hooks is disabled, skip hook loading altogether\n    if (sails.config.hooks === false) {\n      return cb();\n    }\n\n    async.series([\n\n      function(cb) {\n        loadHookDefinitions(sails.hooks, cb);\n      },\n      function(cb) {\n        initializeHooks(sails.hooks, cb);\n      }\n    ], function(err) {\n      if (err) return cb(err);\n\n      // Inform any listeners that the initial, built-in hooks\n      // are finished loading\n      sails.emit('hooks:builtIn:ready');\n      sails.log.verbose('Built-in hooks are ready.');\n      return cb();\n    });\n  }\n\n  /**\n   * Load built-in hook definitions from `sails.config.hooks`\n   * and put them back into `hooks` (probably `sails.hooks`)\n   *\n   * @api private\n   */\n  function loadHookDefinitions(hooks, cb) {\n\n    // Mix in user-configured hook definitions\n    _.extend(hooks, sails.config.hooks);\n\n    // Make sure these changes to the hooks object get applied\n    // to sails.config.hooks to keep logic consistent\n    // (I think we can get away w/o this, but leaving as a stub)\n    // sails.config.hooks = hooks;\n\n    // If user configured `loadHooks`, only include those.\n    if (sails.config.loadHooks) {\n      if (!_.isArray(sails.config.loadHooks)) {\n        return cb('Invalid `loadHooks` config.  ' +\n          'Please specify an array of string hook names.\\n' +\n          'You specified ::' + util.inspect(sails.config.loadHooks));\n      }\n\n      _.each(hooks, function(def, hookName) {\n        if (!_.contains(sails.config.loadHooks, hookName)) {\n          hooks[hookName] = false;\n        }\n      });\n      sails.log.verbose('Deliberate partial load-- will only initialize hooks ::', sails.config.loadHooks);\n    }\n\n    return cb();\n  }\n\n  /**\n   * Returns function which is fired when Sails is ready to go\n   *\n   * @api private\n   */\n  function ready__(cb) {\n    return function(err) {\n      if (err) {\n        return cb && cb(err);\n      }\n\n      sails.log.verbose('All hooks were loaded successfully.');\n\n      // If userconfig hook is turned off, still load globals.\n      if (sails.config.hooks && sails.config.hooks.userconfig === false ||\n           (sails.config.loadHooks && sails.config.loadHooks.indexOf('userconfig') == -1)) {\n            sails.exposeGlobals();\n      }\n\n      cb && cb(null, sails);\n    };\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/app/configuration/index.js":"/**\n * Module dependencies.\n */\n\nvar _ = require('@sailshq/lodash');\nvar path = require('path');\nvar DEFAULT_HOOKS = require('./default-hooks');\n\nmodule.exports = function(sails) {\n\n  /**\n   * Expose new instance of `Configuration`\n   */\n\n  return new Configuration();\n\n\n  function Configuration() {\n\n\n    /**\n     * Sails default configuration\n     *\n     * @api private\n     */\n    this.defaults = function defaultConfig(appPath) {\n\n      var defaultEnv;\n      // If we're not loading the userconfig hook, which normally takes care\n      // of ensuring that we have an environment, then make sure we set one here.\n      if (_.isObject(sails.config.hooks) && sails.config.hooks.userconfig === false ||\n         (_.isArray(sails.config.loadHooks) && sails.config.loadHooks.indexOf('userconfig') == -1)\n      ) {\n        defaultEnv = sails.config.environment || \"development\";\n      }\n\n      // If `appPath` not specified, unfortunately, this is a fatal error,\n      // since reasonable defaults cannot be assumed\n      if (!appPath) {\n        throw new Error('No `appPath` specified!');\n      }\n\n      // Set up config defaults\n      return {\n\n        environment: defaultEnv,\n\n        // Note: to avoid confusion re: timing, `hooks` configuration may eventually be removed\n        // from `sails.config` in favor of something more flexible / obvious, e.g. the `app` object\n        // itself (i.e. because you can't configure hooks in `userconfig`-- only in `overrides`).\n\n        // Core (default) hooks\n        hooks: _.reduce(DEFAULT_HOOKS, function (memo, hookBundled, hookIdentity) {\n\n          // if `true`, then the core hook is bundled in the `lib/hooks/` directory\n          // as `lib/hooks/HOOK_IDENTITY`.\n          if (hookBundled === true) {\n            memo[hookIdentity] = require('../../hooks/'+hookIdentity);\n          }\n          // if it's a string, then the core hook is an NPM dependency of sails,\n          // so require it (which grabs it from `node_modules/`)\n          else if (_.isString(hookBundled)) {\n            var hook;\n            try {\n              hook = require(hookBundled);\n            }\n            catch (e) {\n              throw new Error('Sails internal error: Could not require(\\''+hookBundled+'\\')');\n            }\n            memo[hookIdentity] = hook;\n          }\n          // otherwise freak out\n          else {\n            throw new Error('Sails internal error: \"'+hookIdentity+'\", a core hook, is invalid!');\n          }\n          return memo;\n        }, {}) || {},\n\n        // Save appPath in implicit defaults\n        // appPath is passed from above in case `sails lift` was used\n        // This is the directory where this Sails process is being initiated from.\n        // (  usually this means `process.cwd()`  )\n        appPath: appPath,\n\n        // Built-in path defaults\n        paths: {\n          tmp: path.resolve(appPath, '.tmp')\n        },\n\n        // Start off `routes` and `middleware` as empty objects\n        routes: {},\n        middleware: {}\n\n      };\n    },\n\n\n\n    /**\n     * Load the configuration modules\n     *\n     * @api private\n     */\n\n    this.load = require('./load')(sails);\n\n\n\n    // Bind the context of all instance methods\n    _.bindAll(this);\n\n  }\n\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/app/configuration/default-hooks.js":"/**\n * Default hooks\n *\n * (order still matters for now for some of these-\n *  but mostly not, due to ouruse of events...\n *  ...but for a few core hooks, e.g. `moduleloader`,\n *  it still does.)\n */\n\nmodule.exports = {\n  'moduleloader': true,\n  'logger': true,\n  'request': true,\n  'orm': 'sails-hook-orm',\n  'views': true,\n  'blueprints': true,\n  'responses': true,\n  'controllers': true,\n  'sockets': 'sails-hook-sockets',\n  'pubsub': true,\n  'policies': true,\n  'services': true,\n  'csrf': true,\n  'cors': true,\n  'i18n': true,\n  'userconfig': true,\n  'session': true,\n  'grunt': true,\n  'http': true,\n  'userhooks': true\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/app/private/loadHooks.js":"var _ = require('@sailshq/lodash');\nvar async = require('async');\nvar __hooks = require('../../hooks');\nvar defaultsDeep = require('merge-defaults');\n\nmodule.exports = function(sails) {\n\n  var Hook = __hooks(sails);\n\n  /**\n   * Resolve the hook definitions and then finish loading them\n   *\n   * @api private\n   */\n  return function initializeHooks(hooks, cb) {\n\n    function prepareHook(id) {\n\n      var hookPrototype = hooks[id];\n\n      // Allow disabling of hooks by setting them to \"false\"\n      if (hookPrototype === false || hookPrototype === 'false' || hooks[id.split('.')[0]] === false) {\n        delete hooks[id];\n        return;\n      }\n\n      // Check for invalid hook config\n      if (hooks.userconfig && !hooks.moduleloader) {\n        return cb('Invalid configuration:: Cannot use the `userconfig` hook w/o the `moduleloader` hook enabled!');\n      }\n\n      // Handle folder-defined modules (default to index.js)\n      // Since a hook definition must be a function\n      if (_.isObject(hookPrototype) && !_.isArray(hookPrototype) && !_.isFunction(hookPrototype)) {\n        hookPrototype = hookPrototype.index;\n      }\n\n      if (!_.isFunction(hookPrototype)) {\n        sails.log.error('Malformed hook! (' + id + ')');\n        sails.log.error('Hooks should be a function with one argument (`sails`)');\n        process.exit(1);\n      }\n\n      // Instantiate the hook\n      var def = hookPrototype(sails);\n\n      // Mix in an `identity` property to hook definition\n      def.identity = id.toLowerCase();\n\n      // If a config key was defined for this hook when it was loaded,\n      // (probably because a user is overridding the default config key)\n      // set it on the hook definition\n      def.configKey = hookPrototype.configKey || def.identity;\n\n      // New up an actual Hook instance\n      hooks[id] = new Hook(def);\n    }\n\n    // Function to apply a hook's \"defaults\" obj or function\n    function applyDefaults(hook) {\n      // Get the hook defaults\n      var defaults = (_.isFunction(hook.defaults) ?\n                hook.defaults(sails.config) :\n                hook.defaults) || {};\n      // Replace the special __configKey__ key with the actual config key\n      if (hook.defaults.__configKey__ && hook.configKey) {\n        hook.defaults[hook.configKey] = hook.defaults.__configKey__;\n        delete hook.defaults.__configKey__;\n      }\n\n      defaultsDeep(sails.config, defaults);\n    }\n\n    // Load a hook (bind its routes, load any modules and initialize it)\n    function loadHook(id, cb) {\n\n      var timeoutInterval = (sails.config[hooks[id].configKey || id] && sails.config[hooks[id].configKey || id]._hookTimeout) || sails.config.hookTimeout || 20000;\n      var hookTimeout;\n      if (id != 'userhooks') {\n        hookTimeout = setTimeout(function tooLong() {\n          var hooksTookTooLongErr = 'The hook `'+id+'` is taking too long to load.\\n' +\n            'Make sure it is triggering its `initialize()` callback, ' +\n            'or else set `sails.config.' + (hooks[id].configKey || id) +\n            '._hookTimeout to a higher value (currently ' + timeoutInterval + ')';\n          var err = new Error(hooksTookTooLongErr);\n          err.code = 'E_HOOK_TIMEOUT';\n          cb(err);\n        }, timeoutInterval);\n      }\n      hooks[id].load(function(err) {\n        if (id != 'userhooks') {\n          clearTimeout(hookTimeout);\n        }\n        if (err) {\n          if (id != 'userhooks') {\n            sails.log.error('A hook (`' + id + '`) failed to load!');\n          }\n          sails.emit('hook:' + id + ':error');\n          return cb(err);\n        }\n\n        sails.log.verbose(id, 'hook loaded successfully.');\n        sails.emit('hook:' + id + ':loaded');\n\n        // Defer to next tick to allow other stuff to happen\n        process.nextTick(cb);\n      });\n    }\n\n    async.series({\n\n        // First load the moduleloader (if any)\n        moduleloader: function(cb) {\n          if (!hooks.moduleloader) {\n            return cb();\n          }\n          prepareHook('moduleloader');\n          applyDefaults(hooks['moduleloader']);\n          hooks['moduleloader'].configure();\n          loadHook('moduleloader', cb);\n        },\n\n        // Next load the user config (if any)\n        userconfig: function(cb) {\n          if (!hooks.userconfig) {\n            return cb();\n          }\n          prepareHook('userconfig');\n          applyDefaults(hooks['userconfig']);\n          hooks['userconfig'].configure();\n          loadHook('userconfig', cb);\n        },\n\n        // Next get the user hooks (if any), which will be\n        // added to the list of hooks to load\n        userhooks: function(cb) {\n          if (!hooks.userhooks) {\n            return cb();\n          }\n          prepareHook('userhooks');\n          applyDefaults(hooks['userhooks']);\n          hooks['userhooks'].configure();\n          loadHook('userhooks', cb);\n        },\n\n        // Prepare all other hooks\n        prepare: function(cb) {\n          async.each(_.without(_.keys(hooks), 'userconfig', 'moduleloader', 'userhooks'), function (id, cb) {\n            prepareHook(id);\n            // Defer to next tick to allow other stuff to happen\n            process.nextTick(cb);\n          }, cb);\n        },\n\n        // Apply the default config for all other hooks\n        defaults: function(cb) {\n          async.each(_.without(_.keys(hooks), 'userconfig', 'moduleloader', 'userhooks'), function (id, cb) {\n            var hook = hooks[id];\n            applyDefaults(hook);\n            // Defer to next tick to allow other stuff to happen\n            process.nextTick(cb);\n          }, cb);\n        },\n\n        // Run configuration method for all other hooks\n        configure: function(cb) {\n          async.each(_.without(_.keys(hooks), 'userconfig', 'moduleloader', 'userhooks'), function (id, cb) {\n            var hook = hooks[id];\n            try {\n              hook.configure();\n            } catch (e) {\n              return cb(e);\n            }\n            // Defer to next tick to allow other stuff to happen\n            process.nextTick(cb);\n          }, cb);\n        },\n\n        // Load all other hooks\n        load: function(cb) {\n          async.each(_.without(_.keys(hooks), 'userconfig', 'moduleloader', 'userhooks'), function (id, cb) {\n            sails.log.silly('Loading hook: ' + id);\n            loadHook(id, cb);\n          }, cb);\n        }\n      },\n\n      function hooksReady(err) {\n        return cb(err);\n      });\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/hooks/index.js":"/**\n * Module dependencies.\n */\n\nvar _ = require('@sailshq/lodash');\nvar async = require('async');\n\n\n\n\nmodule.exports = function(sails) {\n\n\n  /**\n   * Expose hook constructor\n   *\n   * @api private\n   */\n\n  return function Hook(definition) {\n\n    // A few sanity checks to make sure te provided definition does not contain any reserved properties.\n    if (!_.isObject(definition)) {\n      // This particular behavior can be made a bit less genteel in future versions (it is currently\n      // forgiving for backwards compatibility)\n      definition = definition || {};\n    }\n    \n    if (_.isFunction(definition.config)) {\n      throw new Error('Error defining hook: `config` is a reserved property and cannot be used as a custom hook method.');\n    }\n    if (_.isFunction(definition.middleware)) {\n      throw new Error('Error defining hook: `middleware` is a reserved property and cannot be used as a custom hook method.');\n    }\n    \n\n\n    /**\n     * Load the hook asynchronously\n     *\n     * @api private\n     */\n\n    this.load = function(cb) {\n\n      var self = this;\n\n      var routeCallbacks = function(routes) {\n        _.each(routes, function(middleware, route) {\n          middleware._middlewareType = self.identity.toUpperCase() + ' HOOK' + (middleware.name ? (': ' + middleware.name) : '');\n          sails.router.bind(route, middleware);\n        });\n      };\n\n      // Determine if this hook should load based on Sails environment & hook config\n      if (this.config.envs &&\n        this.config.envs.length > 0 &&\n        this.config.envs.indexOf(sails.config.environment) === -1) {\n        return cb();\n      }\n\n      // Convenience config to bind routes before any of the static app routes\n      sails.on('router:before', function() {\n        routeCallbacks(self.routes.before);\n      });\n\n      // Convenience config to bind routes after the static app routes\n      sails.on('router:after', function() {\n        routeCallbacks(self.routes.after);\n      });\n\n      // Run loadModules method if moduleloader is loaded\n      async.auto({\n\n        modules: function(cb) {\n\n            if (sails.config.hooks.moduleloader) {\n\n              return self.loadModules(cb);\n\n            }\n            return cb();\n          }\n\n      }, function(err) {\n        if (err) return cb(err);\n        try {\n          self.initialize(cb);\n        } catch(e) {\n          return cb(e);\n        }\n      });\n\n    };\n\n\n\n    /**\n     * `defaults`\n     *\n     * Default configuration for this hook.\n     *\n     * Hooks may override this function, or use a dictionary instead.\n     *\n     * @type {Function|Dictionary}\n     *       @returns {Dictionary} [default configuration for this hook to be merged into sails.config]\n     */\n    this.defaults = function(config) {\n      return {};\n    };\n\n    /**\n     * `configure`\n     *\n     * If this hook provides this function, the provided implementation should\n     * normalize and validate configuration related to this hook.  That config is\n     * already in `sails.config` at the time this function is called.  Any modifications\n     * should be made in place on `sails.config`\n     *\n     * Hooks may override this function.\n     *\n     * @type {Function}\n     */\n    this.configure = function() {\n\n    };\n\n    /**\n     * `loadModules`\n     *\n     * Load any modules as a dictionary and pass the loaded modules to the callback when finished.\n     *\n     * Hooks may override this function (This runs before `initialize()`!)\n     *\n     * @type {Function}\n     * @async\n     */\n    this.loadModules = function(cb) {\n      return cb();\n    };\n\n\n    /**\n     * `initialize`\n     *\n     * If provided, this implementation should prepare the hook, then trigger the callback.\n     *\n     * Hooks may override this function.\n     *\n     * @type {Function}\n     * @async\n     */\n    this.initialize = function(cb) {\n      return cb();\n    };\n\n\n\n    // Ensure that the hook definition has valid properties\n    _normalize(this);\n    definition = _normalize(definition);\n\n    // Merge default definition with overrides in the definition passed in\n    _.extend(definition.config, this.config, definition.config);\n    _.extend(definition.middleware, this.middleware, definition.middleware);\n    _.extend(definition.routes.before, this.routes.before, definition.routes.before);\n    _.extend(definition.routes.after, this.routes.after, definition.routes.after);\n    _.extend(this, definition);\n\n    // Bind context of new methods from definition\n    _.bindAll(this);\n\n\n\n    /**\n     * Ensure that a hook definition has the required properties.\n     * \n     * @returns {Dictionary} [coerced hook definition]\n     * @api private\n     */\n\n    function _normalize(def) {\n\n      def = def || {};\n\n      // Default hook config\n      def.config = def.config || {};\n\n      // list of environments to run in, if empty defaults to all\n      def.config.envs = def.config.envs || [];\n\n      def.middleware = def.middleware || {};\n\n      // Default hook routes\n      def.routes = def.routes || {};\n      def.routes.before = def.routes.before || {};\n      def.routes.after = def.routes.after || {};\n\n      return def;\n    }\n  };\n\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/app/private/after.js":"/**\n * Module dependencies\n */\n\nvar _ = require('@sailshq/lodash');\nvar async = require('async');\n\n\n//\n// TODO\n// Pull this into a separate module, since it's not specific to Sails.\n//\n\n\n/**\n * Mix-in an `after` function to an EventEmitter.\n *\n * If `events` have already fired, trigger fn immediately (with no args)\n * Otherwise bind a normal one-time event using `EventEmitter.prototype.once()`.\n * Useful for checking whether or not something has finished loading, etc.\n *\n * This is a lot like jQuery's `$(document).ready()`.\n *\n * @param  {EventEmitter} emitter\n */\n\nmodule.exports = function mixinAfter(emitter) {\n\n\n  /**\n   * { emitter.warmEvents }\n   *\n   * Events which have occurred at least once\n   * (Required to support `emitter.after()`)\n   */\n  emitter.warmEvents = {};\n\n\n  /**\n   * emitter.emit()\n   *\n   * Override `EventEmitter.prototype.emit`.\n   * (Required to support `emitter.after()`)\n   */\n\n  var _emit = emitter.emit;\n  emitter.emit = function(evName) {\n    var args = Array.prototype.slice.call(arguments, 0);\n    emitter.warmEvents[evName] = true;\n    _emit.apply(emitter, args);\n  };\n\n\n  /**\n   * `emitter.after()`\n   *\n   * Fires your handler **IF THE SPECIFIED EVENT HAS ALREADY BEEN TRIGGERED** or **WHEN IT IS TRIGGERED**.\n   *\n   * @param  {String|Array} events   [name of the event(s)]\n   * @param  {Function}     fn       [event handler function]\n   * @context {Sails}\n   */\n\n  emitter.after = function(events, fn) {\n\n    // Support a single event or an array of events\n    if (!_.isArray(events)) {\n      events = [events];\n    }\n\n    // Convert named event dependencies into an array\n    // of async-compatible functions.\n    var dependencies = _.reduce(events,\n      function(dependencies, event) {\n\n        var handlerFn = function(cb) {\n          if (emitter.warmEvents[event]) {\n            cb();\n          } else {\n            emitter.once(event, cb);\n          }\n        };\n        dependencies.push(handlerFn);\n        return dependencies;\n      }, []);\n\n    // When all events have fired, call `fn`\n    // (all arguments passed to `emit()` calls are discarded)\n    async.parallel(dependencies, function(err) {\n      if (err) sails.log.error(err);\n      return fn();\n    });\n\n  };\n\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/router/index.js":"/**\n * Module dependencies.\n */\n\nvar Readable = require('stream').Readable;\nvar QS = require('querystring');\nvar _ = require('@sailshq/lodash');\nvar Express = require('@sailshq/express');\n\nvar buildReq = require('./req');\nvar buildRes = require('./res');\nvar defaultHandlers = require('./bindDefaultHandlers');\n\n\n/**\n * Expose new instance of `Router`\n *\n * @api private\n */\nmodule.exports = function(sails) {\n  return new Router({sails: sails});\n};\n\n\n\n/**\n * Initialize a new `Router`\n *\n * @param {Object} options\n * @api private\n */\n\nfunction Router(options) {\n\n  options = options || {};\n  this.sails = options.sails;\n  this.defaultHandlers = defaultHandlers(this.sails);\n\n  // Expose router on `sails` object\n  this.sails.router = this;\n\n  // Required for dynamic NODE_ENV setting via command line args\n  // TODO:\n  // instead, use: https://www.npmjs.org/package/path-to-regexp\n  // (or: https://www.npmjs.org/package/path-match)\n  this._privateRouter = Express();\n\n  // Bind the context of all instance methods\n  this.load = _.bind(this.load, this);\n  this.bind = _.bind(this.bind, this);\n  this.unbind = _.bind(this.unbind, this);\n  this.reset = _.bind(this.reset, this);\n  this.flush = _.bind(this.flush, this);\n  this.route = _.bind(this.route, this);\n}\n\n\n/**\n * _privateRouter\n *\n * This internal \"private\" instance of an Express appobject\n * is used only for routing. (i.e. it will not be used for\n * listening to actual HTTP requests; instead, one or more\n * delegate servers can be attached- see the `http` or\n * `sockets` hooks for examples of attaching a server to\n * Sails)\n *\n * NOTE: Requires calling `load()` before use in order to\n * provide access to the proper NODE_ENV, since Express\n * uses that to determine its environment (development vs.\n * production.)\n */\n\n// Router.prototype._privateRouter;\n\n\n\n/**\n * `sails.router.load()`\n *\n * Expose the router, create the Express private router,\n * then call flush(), which will bind configured routes\n * and emit the appropriate events.\n *\n * @api public\n */\n\nRouter.prototype.load = function(cb) {\n  var sails = this.sails;\n\n  sails.log.verbose('Loading router...');\n\n  // Maintain a reference to the static route config\n  this.explicitRoutes = sails.config.routes;\n\n  // Save reference to sails logger\n  this.log = sails.log;\n\n  var sessionSecret = sails.config.session && sails.config.session.secret;\n  // If a session store is configured, hook it up as `req.session` by passing\n  // it down to the session middleware\n  if (sails.hooks.session) {\n    sails.after('hook:session:loaded', function (){\n      // if (!sails.config.session || !sails.config.session.store || !sails.config.session.secret) {\n      //   return cb(new Error('Consistency violation: expected session store+secret config to exist if the session hook is enabled. Is `sails.config.session` valid?'));\n      // }\n\n      // Set \"resave\" and \"saveUninitialized\" options or else express-session gives you a stern warning.\n      var opts = _.merge({\n        resave: true,\n        saveUninitialized: true\n      }, sails.config.session);\n      sails._privateSessionMiddleware = require('express-session')(opts);\n    });\n  }\n  // Otherwise double check the session secret (if one is provided) since it's usually checked\n  // in the session hook.\n  else {\n    // If available, Sails uses the configured session secret for signing cookies.\n    if (sessionSecret) {\n      // Ensure secret is a string.  This check happens in the session hook as well,\n      // but sails.config.session.secret may still be provided even if the session hook\n      // is turned off, so to be extra anal we'll check here as well.\n      if (!_.isString(sessionSecret)) {\n        return cb(new Error('If provided, sails.config.session.secret should be a string.'));\n      }\n    }\n  }\n  if (sessionSecret) {\n    sails._privateCpMware = require('cookie-parser')(sessionSecret);\n  } else {\n    sails._privateCpMware = require('cookie-parser')();\n  }\n\n  // Wipe any existing routes and bind them anew\n  this.flush();\n\n  // Listen for requests\n  sails.on('router:request', this.route);\n\n  // Listen for unhandled errors and unmatched routes\n  sails.on('router:request:500', this.defaultHandlers[500]);\n  sails.on('router:request:404', this.defaultHandlers[404]);\n\n  cb();\n};\n\n\n\n/**\n * `sails.router.route(partialReq, partialRes)`\n *\n * Interpret the specified (usually partial) request and response objects into\n * streams with all of the expected methods, then routes the fully-formed request\n * using the built-in private router. Useful for creating virtual request/response\n * streams from non-HTTP sources, like Socket.io or unit tests.\n *\n * This method is not always helpful-- it is not called for HTTP requests, for instance,\n * since the true HTTP req/res streams already exist.  In that case, at lift-time, Sails\n * calls `router:bind`, which loads Sails' routes as normal middleware/routes in the http hook.\n * stack will run as usual.\n *\n * On the other hand, Socket.io needs to use this method (i.e. the `router:request` event)\n * to simulate a connect-style router since it can't bind dynamic routes ahead of time.\n *\n * Keep in mind that, if `route` is not used, the implementing server is responsible\n * for routing to Sails' default `next(foo)` handler.\n *\n * @param {Request} req\n * @param {Response} res\n * @api private\n */\n\nRouter.prototype.route = function(req, res) {\n  var sails = this.sails;\n  var _privateRouter = this._privateRouter;\n\n  // If sails is `_exiting`, ignore the request.\n  if (sails._exiting) {\n    return;\n  }\n\n  // Provide access to SailsApp instance as `req._sails`.\n  req._sails = req._sails || sails;\n\n  // Note that, at this point, `req` and `res` are just dictionaries containing\n  // the properties of each object that have been built up _so far_.\n  //\n  // Use base req and res definitions to ensure the specified\n  // objects are at least ducktype-able as standard node HTTP\n  // req and req streams.\n  //\n  // Make sure request and response objects have reasonable defaults\n  // (will use the supplied definitions if possible)\n  req = buildReq(req);\n  res = buildRes(req, res);\n\n  // console.log('\\n\\n\\n\\n=======================\\nReceived request to %s %s\\nwith req.body:\\n',req.method,req.url, req.body);\n\n  // Deprecation error:\n  res._cb = function _cbIsDeprecated(err) {\n    throw new Error('As of v0.10, `_cb()` shim is no longer supported in the Sails router.');\n  };\n\n\n  // Run some basic middleware\n  sails.log.silly('Handling virtual request :: Running virtual querystring parser...');\n  qsParser(req,res, function (err) {\n    if (err) {\n      return res.send(400, err && err.stack);\n    }\n\n    // Parse cookies\n    parseCookies(req, res, function(err){\n      if (err) {\n        return res.send(400, err && err.stack);\n      }\n\n      // console.log('Ran cookie parser');\n      // console.log('res.writeHead= ',res.writeHead);\n\n      // Load session (if relevant)\n      loadSession(req, res, function (err) {\n        if (err) {\n          return res.send(400, err && err.stack);\n        }\n        // console.log('res is now:\\n',res);\n        // console.log('\\n\\n');\n        // console.log('Ran session middleware');\n        // console.log('req.sessionID= ',req.sessionID);\n        // console.log('The loaded req.session= ',req.session);\n\n        sails.log.silly('Handling virtual request :: Running virtual body parser...');\n        bodyParser(req,res, function (err) {\n          if (err) {\n            return res.send(400, err && err.stack);\n          }\n\n          // Use our private router to route the request\n          _privateRouter.router(req, res, function handleUnmatchedNext(err) {\n            //\n            // In the event of an unmatched `next()`, `next('foo')`,\n            // or `next('foo', errorCode)`...\n            //\n\n            // Use the default server error handler\n            if (err) {\n              sails.log.silly('Handling virtual request :: Running final \"error\" handler...');\n              sails.emit('router:request:500', err, req, res);\n              return;\n            }\n\n            // Or the default not found handler\n            sails.log.silly('Handling virtual request :: Running final \"not found\" handler...');\n            sails.emit('router:request:404', req, res);\n            return;\n          });\n        });\n      });\n\n    });\n  });\n\n};\n\n\n\n/**\n * `sails.router.bind()`\n *\n * Bind new route(s)\n *\n * @param {String|RegExp} path\n * @param {String|Object|Array|Function} bindTo\n * @param {String} verb\n * @api private\n */\n\nRouter.prototype.bind = require('./bind');\n\n\n\n/**\n * `sails.router.unbind()`\n *\n * Unbind existing route\n *\n * @param {Object} route\n * @api private\n */\n\nRouter.prototype.unbind = function(route) {\n\n  var sails = this.sails;\n\n  // Inform attached servers that route should be unbound\n  sails.emit('router:unbind', route);\n\n  // Remove route in internal router\n  var newRoutes = [];\n  _.each(this._privateRouter.routes[route.method], function(expressRoute) {\n    if (expressRoute.path !== route.path) {\n      newRoutes.push(expressRoute);\n    }\n  });\n  this._privateRouter.routes[route.method] = newRoutes;\n\n};\n\n\n\n/**\n * `sails.router.reset()`\n *\n * Unbind all routes currently attached to the router\n *\n * @api private\n */\n\nRouter.prototype.reset = function() {\n  var sails = this.sails;\n\n  // Unbind everything\n  _.each(this._privateRouter.routes, function(routes, httpMethod) {\n\n    // Unbind each route for the specified HTTP verb\n    var routesToUnbind = this._privateRouter.routes[httpMethod] || [];\n    _.each(routesToUnbind, this.unbind, this);\n\n  }, this);\n\n\n  // Emit reset event to allow attached servers to\n  // unbind all of their routes as well\n  sails.emit('router:reset');\n\n};\n\n\n\n/**\n * `sails.router.flush()`\n *\n * Unbind all current routes, then re-bind everything, re-emitting the routing\n * lifecycle events (e.g. `router:before` and `router:after`)\n *\n * @param {Object} routes - (optional)\n *  If specified, replaces `this.explicitRoutes` before flushing.\n *\n * @api private\n */\n\nRouter.prototype.flush = function(routes) {\n  var sails = this.sails;\n\n  // Wipe routes\n  this.reset();\n\n  // Fired before static routes are bound\n  sails.emit('router:before');\n\n  // If specified, replace `this.explicitRoutes`\n  if (routes) {\n    this.explicitRoutes = routes;\n  }\n\n  // Use specified path to bind static routes\n  _.each(this.explicitRoutes, function(target, path) {\n    this.bind(path, target);\n  }, this);\n\n\n  // Fired after static routes are bound\n  sails.emit('router:after');\n};\n\n\n\n\n\n\n\n\n\n////////////////////////////////////////////////////////////////////////////////////////////////////\n//\n// ||     Private functions\n// \\/\n//\n////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n\n\n\n// Extremely simple query string parser (`req.query`)\nfunction qsParser(req,res,next) {\n  var queryStringPos = req.url.indexOf('?');\n  if (queryStringPos !== -1) {\n    req.query = _.merge(req.query, QS.parse(req.url.substr(queryStringPos + 1)));\n  }\n  else {\n    req.query = req.query || {};\n  }\n  next();\n}\n// Extremely simple body parser (`req.body`)\nfunction bodyParser (req, res, next) {\n\n  // Set up a mock `req.file()` clarifying that req.file() is not available\n  // outside of the context of Skipper (i.e. in this case, most commonly from\n  // socket.io virtual requests).\n  req.file = function fileUploadsNotAvailable(){\n    return res.send(500, 'Streaming file uploads via `req.file()` are only available over HTTP with Skipper.');\n  };\n\n  var bodyBuffer='';\n  if (req.method === 'GET' || req.method === 'HEAD' || req.method === 'DELETE'){\n    req.body = _.extend({}, req.body);\n    return next();\n  }\n\n  // Ensure that `req` is a readable stream at this point\n  if ( ! req instanceof Readable ) {\n    return next(new Error('Sails Internal Error: `req` should be a Readable stream by the time `route()` is called'));\n  }\n\n  req.on('readable', function() {\n    var chunk;\n    while (null !== (chunk = req.read())) {\n      bodyBuffer += chunk;\n    }\n  });\n  req.on('end', function() {\n\n    var parsedBody;\n    try {\n      parsedBody = JSON.parse(bodyBuffer);\n    } catch (e) {}\n\n    req.body = _.merge(req.body, parsedBody);\n    next();\n  });\n}\n\n\n\n\n\n\n\n/**\n * [parseCookies description]\n * @param  {[type]}   req  [description]\n * @param  {[type]}   res  [description]\n * @param  {Function} next [description]\n * @return {[type]}        [description]\n */\nfunction parseCookies (req, res, next){\n\n  // req._sails.log.verbose('Parsing cookie:',req.headers.cookie);\n\n  if (req._sails._privateCpMware) {\n    // Run the middleware\n    return req._sails._privateCpMware(req, res, next);\n  }\n\n  // Otherwise don't even worry about it.\n  return next();\n}\n\n\n\n/**\n * [loadSession description]\n * @param  {[type]}   req  [description]\n * @param  {[type]}   res  [description]\n * @param  {Function} next [description]\n * @return {[type]}        [description]\n */\nfunction loadSession (req, res, next){\n\n  // If a session store is configured, and we haven't deliberately disabled\n  // session support for this request by setting the \"nosession\" header,\n  // hook up the store up as `req.session` by passing it down to the\n  // session middleware.\n  if (req._sails._privateSessionMiddleware && !req.headers.nosession) {\n\n    // Access store preconfigured session middleware as a private property on the app instance.\n    return req._sails._privateSessionMiddleware(req, res, next);\n  }\n\n  // Otherwise don't even worry about it.\n  return next();\n}\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/router/req.js":"/**\n * Module dependencies\n */\n\nvar _ = require('@sailshq/lodash');\nvar defaultsDeep = require('merge-defaults');\nvar MockReq = require('mock-req');\nvar parseurl = require('parseurl');\n\n/**\n * Factory which builds generic Sails request object (i.e. `req`).\n *\n * This generic implementation of `req` forms the basis for\n * Sails' transport-agnostic support of Connect/Express\n * middleware.  Used by hooks (i.e. sockets) but also for\n * tests-- both at the app-level and in Sails core.\n *\n * @param {Dictionary} _req\n *        the properties of this simulated request object that\n *        have been built up _so far_.\n *\n * @return {Request} simulated HTTP request object\n * @idempotent\n */\n\nmodule.exports = function buildRequest (_req) {\n\n  // Make sure _req is not undefined\n  _req = _req||{};\n\n  // Start our request object, which will be built by inheriting/transforming\n  // properties of _req and adding some spice of our own\n  var req;\n\n  // Attempt to parse the URL in _req, so that we can get the querystring\n  // and path\n  var parsedUrl;\n  try {parsedUrl = parseurl(_req) || {};}\n  catch (e) {parsedUrl = {};}\n\n  // If `_req` appears to be a stream (duck-typing), then don't try\n  // and turn it into a mock stream again.\n  if (typeof _req === 'object' && _req.read) {\n    req = _req;\n  }\n  else {\n\n    // TODO: send a PR to mock-req with a fix for this\n    if (_req.headers && typeof _req.headers === 'object') {\n      // Strip undefined headers\n      _.each(_req.headers, function (headerVal, headerKey) {\n        if (_.isUndefined(headerVal)){\n          delete _req.headers[headerKey];\n        }\n      });\n      // Make sure all remaining headers are strings\n      _req.headers = _.mapValues(_req.headers, function (headerVal, headerKey) { // :TODO 'headerKey' is defined but never used\n        if (typeof headerVal !== 'string') {\n          headerVal = ''+headerVal+'';\n        }\n        return headerVal;\n      });\n    }\n\n    // Create a mock IncomingMessage stream.\n    req = new MockReq({\n      method: _req && (_.isString(_req.method) ? _req.method.toUpperCase() : 'GET'),\n      headers: _req && _req.headers || {},\n      url: _req && _req.url\n    });\n\n    // Add .get() and .header() methods to match express 3\n    req.get = req.header = function (name) {\n      switch (name = name.toLowerCase()) {\n      case 'referer':\n      case 'referrer':\n        return this.headers.referrer || this.headers.referer;\n      default:\n        return this.headers[name];\n      }\n    };\n\n    // Now pump client request body to the mock IncomingMessage stream (req)\n    // Req stream ends automatically if this is a GET or HEAD or DELETE request\n    // (since there is no request body in that case) so no need to do it again.\n    if (req.method !== 'GET' && req.method !== 'HEAD' && req.method !== 'DELETE') {\n\n      // Only write the body if there IS a body.\n      if (req.body) {\n        req.write(req.body);\n      }\n      req.end();\n    }\n  }\n\n  // Track request start time\n  req._startTime = new Date();\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // Note that other core methods _could_ be added here for use w/ the virtual\n  // router.  But as per convo w/ dougwilson, the same _cannot_ be done for HTTP\n  // requests coming out of Express.  They would either have to (a) rely on modifying\n  // the HTTP request (IncomingMessage) prototype, or (B) rely on context (i.e. `this`),\n  // which would require `_.bind()`-ing them to avoid issues when triggered from\n  // userland code. And re: (B) at that point, the performance impact is effectively\n  // the same as if they were attached on the fly on a per-request basis.\n  //\n  // So we only initially attach `req.*` methods & properties here which are _not_\n  // already built-in to the mock request, and which are _not_ already taken care of\n  // by hooks, AND which don't rely on `res` (because it hasn't been built yet).\n  ////////////////////////////////////////////////////////////////////////////////\n\n  // Provide defaults for other request state and methods\n  req = defaultsDeep(req, {\n    params: [],\n    query: (_req && _req.query) || require('querystring').parse(parsedUrl.query) || {},\n    body: (_req && _req.body) || {},\n    param: function(paramName, defaultValue) {\n\n      var key, params = {};\n      for (key in (req.params || {}) ) {\n        params[key] = params[key] || req.params[key];\n      }\n      for (key in (req.query || {}) ) {\n        params[key] = params[key] || req.query[key];\n      }\n      for (key in (req.body || {}) ) {\n        params[key] = params[key] || req.body[key];\n      }\n\n      // Grab the value of the parameter from the appropriate place\n      // and return it\n      if (typeof params[paramName] !== 'undefined') {\n        return params[paramName];\n      } else {\n        return defaultValue;\n      }\n\n    },\n    wantsJSON: (_req && _req.wantsJSON === false) ? false : true,\n    method: 'GET',\n    originalUrl: _req.originalUrl || _req.url,\n    path: _req.path || parsedUrl.pathname\n  }, _req||{});\n\n  return req;\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/router/res.js":"/**\n * Module dependencies\n */\nvar util = require('util');\nvar Transform = require('stream').Transform;\nvar _ = require('@sailshq/lodash');\nvar MockRes = require('mock-res');\n\n\n/**\n * Ensure that response object has a minimum set of reasonable defaults\n * Used primarily as a test fixture.\n *\n * @api private\n * @idempotent\n */\n\nmodule.exports = function _buildResponse (req, _res) {\n  _res = _res||{};\n  req = req||{};\n\n  var res;\n\n  // If `_res` appears to be a stream (duck-typing), then don't try\n  // and turn it into a mock stream again.\n  if (typeof _res === 'object' && _res.end) {\n    res = _res;\n  }\n  else {\n    res = new MockRes();\n    delete res.statusCode;\n  }\n\n\n  // Ensure res.headers and res.locals exist.\n  res = _.extend(res, {locals: {}, headers: {}, _headers: {}});\n  res = _.extend(res, _res);\n\n  // Now that we're sure `res` is a Transform stream, we'll handle the two different\n  // approaches which a user of the virtual request interpreter might have taken:\n\n  // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  // (1) Providing a callback function (`_clientCallback`)\n  //\n  // If a `_clientCallback` function was provided, also pipe `res` into a\n  // fake clientRes stream where the response `body` will be buffered.\n  if (res._clientCallback) {\n\n    // If `res._clientRes` WAS NOT provided, then create one\n    if (!res._clientRes) {\n      res._clientRes = new MockClientResponse();\n    }\n\n    // Session is saved automatically since the virtual request interpreter is\n    // using `express-session` directly as of https://github.com/balderdashy/sails/commit/58e93f5a5f2e667e3fbeddf5b4b356f813e3555e.\n\n    // The stream should trigger the callback when it finishes or errors.\n    res._clientRes.on('finish', function() {\n      return res._clientCallback(res._clientRes);\n    });\n    res._clientRes.on('error', function(err) {\n      err = err || new Error('Error on response stream');\n      res._clientRes.statusCode = 500;\n      res._clientRes.body = err;\n      return res._clientCallback(res._clientRes);\n    });\n\n  }\n  // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  // (2) Providing a Writable stream (`_clientRes`)\n  //\n  // If a `_clientRes` response Transform stream was provided, pipe `res` directly to it.\n  if (res._clientRes) {\n    res.pipe(res._clientRes);\n  }\n  //\n  // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n\n  // Track whether headers have been written\n  // (TODO: pull all this into mock-res via a PR)\n\n  // res.writeHead() is wrapped in closure by the `on-header` module,\n  // but it still needs the underlying impl\n  res.writeHead = function ( /* statusCode, [reasonPhrase], headers */) {\n    // console.log('\\n\\n res.writeHead(%s)', Array.prototype.slice.call(arguments));\n    var statusCode = +arguments[0];\n    //TODO: Analyze this code, reasonPhras not used\n    var reasonPhrase = (function(){\n      if (arguments[2] && _.isString(arguments[1])) {\n        return arguments[1];\n      }\n      return undefined;\n    })();\n    var newHeaders = (function (){\n      if (arguments[2] && _.isObject(arguments[2])) {\n        return arguments[2];\n      }\n      return arguments[1];\n    })();\n\n    if (!statusCode) {\n      throw new Error('`statusCode` must be passed to res.writeHead().');\n    }\n    // Set status code\n    res.statusCode = statusCode;\n\n    // Ensure `._headers` have been merged into `.headers`\n    _.extend(res.headers, res._headers);\n\n    if (newHeaders) {\n      if (!_.isObject(newHeaders)) {\n        throw new Error('`headers` must be passed to res.writeHead() as an object. Got: '+util.inspect(newHeaders, false, null));\n      }\n      // Set new headers\n      _.extend(res.headers, newHeaders);\n    }\n\n    // Set status code and headers on the `_clientRes` stream so they are accessible\n    // to the provider of that stream.\n    // (this has to happen in `send()` because the code/headers might have just changed)\n    if (res._clientRes) {\n      // console.log('Setting headers on clientRes- res.headers = ',res.headers);\n      res._clientRes.headers = res.headers;\n      res._clientRes.statusCode = res.statusCode;\n    }\n\n  };\n\n\n  // Wrap res.write() and res.end() to get them to call writeHead()\n  var prevWrite = res.write;\n  res.write = function (){\n    res.writeHead(res.statusCode, _.extend(res._headers,res.headers));\n    // console.log('res.write():: called writeHead with headers=',_.extend(res._headers,res.headers));\n    prevWrite.apply(res, Array.prototype.slice.call(arguments));\n  };\n  var prevEnd = res.end;\n  res.end = function (){\n    res.writeHead(res.statusCode, _.extend(res._headers,res.headers));\n    // console.log('our res.end() was triggered');\n    // console.log('res.end():: called writeHead with headers=',_.extend(res._headers,res.headers));\n    prevEnd.apply(res, Array.prototype.slice.call(arguments));\n  };\n\n\n  // we get `setHeader` from mock-res\n  // see http://nodejs.org/api/http.html#http_response_setheader_name_value\n  //\n  // Usage:\n  // response.setHeader(\"Set-Cookie\", [\"type=ninja\", \"language=javascript\"]);\n\n  // If we ever need to wrap it...\n  //\n  // var prevSetHeader = res.setHeader;\n  // res.setHeader = function (){\n  //   prevSetHeader.apply(res, Array.prototype.slice.call(arguments));\n  // };\n\n  // res.status()\n  res.status = res.status || function status_shim (statusCode) {\n    res.statusCode = statusCode;\n    return res;\n  };\n\n  // res.send()\n  res.send = res.send || function send_shim () {\n    var args = normalizeResArgs(arguments);\n\n    // Don't allow users to respond/redirect more than once per request\n    // TODO: prbly move this check to our `res.writeHead()` impl\n    try {\n      onlyAllowOneResponse(res);\n    }\n    catch (e) {\n      if (req._sails && req._sails.log && req._sails.log.error) {\n        req._sails.log.error(e);\n        return;\n      }\n      // TODO: use debug()\n      console.error(e);\n      return;\n    }\n\n    // Ensure charset is set\n    res.charset = res.charset || 'utf-8';\n\n    // Ensure headers are set\n    _.extend(res.headers, res._headers);\n\n    // Ensure statusCode is set\n    // (override `this.statusCode` if `statusCode` argument specified)\n    res.statusCode = args.statusCode || res.statusCode || 200;\n\n    // if a `_clientCallback` was specified, we'll skip the streaming stuff for res.send().\n    if (res._clientCallback) {\n\n      // Hard-code `res.body` rather than writing to the stream.\n      // (but don't include body if it is empty)\n      if (args.other) {\n        res.body = args.other;\n        // Then expose on res._clientRes.body\n        res._clientRes.body = res.body;\n      }\n\n      // End the `res` stream (which will in turn end the `res._clientRes` stream)\n      res.end();\n      return;\n    }\n\n    //\n    // Otherwise, the hook using the interpreter must have provided us with a `res._clientRes` stream,\n    // so we'll need to serialize everything to work w/ that stream.\n    //\n\n    // console.log('\\n---\\nwriting to clientRes stream...');\n    // console.log('res.headers =>',res.headers);\n    // console.log('res._headers =>',res._headers);\n\n    // Write body to `res` stream\n    if (args.other) {\n\n      var toWrite = args.other;\n\n      if (typeof toWrite === 'object') {\n        try {\n          toWrite = JSON.stringify(args.other);\n\n          // original way:\n          // toWrite = util.inspect(toWrite);\n        }\n        catch(e) {\n          var failedStringify = new Error(\n            'Failed to stringify specified JSON response body :: ' + util.inspect(args.other) +\n            '\\nError:\\n' + util.inspect(e)\n          );\n          // console.log('failed to stringify!');\n          if (req._sails && req._sails.log && req._sails.log.error) {\n            req._sails.log.error(failedStringify);\n          }\n          else {\n            // todo: use debug()\n            console.error(failedStringify);\n          }\n          toWrite = failedStringify.message;\n          res.statusCode = 500;\n        }\n      }\n      res.write(toWrite);\n    }\n\n    // End the `res` stream.\n    res.end();\n  };\n\n  // res.json()\n  res.json = res.json || function json_shim () {\n    var args = normalizeResArgs(arguments);\n    return res.send(args.other, args.statusCode || res.statusCode || 200);\n  };\n\n  // res.render()\n  res.render = res.render || function render_shim (relativeViewPath, locals, cb) {\n    if (_.isFunction(arguments[1])) {\n      cb = arguments[1];\n      locals = {};\n    }\n\n    if (!req._sails) {\n      return  res.send(500, 'Cannot call res.render() - `req._sails` was not attached');\n    }\n    if (!req._sails.renderView) {\n      return res.send(500, 'Cannot call res.render() - `req._sails.renderView` was not attached (perhaps `views` hook is not enabled?)');\n    }\n\n    // TODO:\n    // Instead of this shim, turn `sails.renderView` into something like\n    // `sails.hooks.views.render()`, and then call it.\n    return res.send(501,'Not implemented in core yet');\n  };\n\n  // res.redirect()\n  res.redirect = res.redirect || function redirect_shim () {\n    var args = normalizeResArgs(arguments);\n\n    var address = args.other;\n\n    // Set location header\n    res.set('Location',address);\n\n    // address = this.get('Location');\n    return res.send(args.statusCode || res.statusCode || 302, 'Redirecting to '+encodeURI(address));\n  };\n\n\n\n  /**\n   * res.set( headerName, value )\n   *\n   * @param {[type]} headerName [description]\n   * @param {[type]} value   [description]\n   */\n  res.set = function (headerName, value) {\n    res.headers = res.headers || {};\n    res.headers[headerName] = value;\n    return this;\n  };\n\n  /**\n   * res.get( headerName )\n   *\n   * @param  {[type]} headerName [description]\n   * @return {[type]}            [description]\n   */\n  res.get = function (headerName) {\n    return res.headers && res.headers[headerName];\n  };\n\n\n\n  return res;\n\n\n};\n\n\n/**\n * As long as one of them is a number (i.e. a status code),\n * allows a 2-nary method to be called with flip-flopped arguments:\n *    method( [statusCode|other], [statusCode|other] )\n *\n * This avoids confusing errors & provides Express 2.x backwards compat.\n *\n * E.g. usage in res.send():\n *    var args    = normalizeResArgs.apply(this, arguments),\n *      body    = args.other,\n *      statusCode  = args.statusCode;\n *\n * @api private\n */\nfunction normalizeResArgs( args ) {\n\n  // Traditional usage:\n  // `method( other [,statusCode] )`\n  var isNumeric = function (x) {\n    return (+x === x);\n  };\n  if (isNumeric(args[0])) {\n    return {\n      statusCode: args[0],\n      other: args[1]\n    };\n  }\n  else return {\n    statusCode: args[1],\n    other: args[0]\n  };\n}\n\n\n/**\n * NOTE: ALL RESPONSES (INCLUDING REDIRECTS) ARE PREVENTED ONCE THE RESPONSE HAS BEEN SENT!!\n * Even though this is not strictly required with sockets, since res.redirect()\n * is an HTTP-oriented method from Express, it's important to maintain consistency.\n *\n * @api private\n */\nfunction onlyAllowOneResponse (res) {\n  if (res._virtualResponseStarted) {\n    throw new Error('Cannot write to response more than once');\n  }\n  res._virtualResponseStarted = true;\n}\n\n\n// The constructor for clientRes stream\n// (just a normal transform stream)\nfunction MockClientResponse() {\n  Transform.call(this);\n}\nutil.inherits(MockClientResponse, Transform);\nMockClientResponse.prototype._transform = function(chunk, encoding, next) {\n  this.push(chunk);\n  next();\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/router/bindDefaultHandlers.js":"/**\n * Module dependencies\n */\n\nvar _ = require('@sailshq/lodash');\n\n\n/**\n * Default 500 and 404 handler.\n * (defers to res.serverError() and res.notFound() whenever possible)\n *\n * With default hook configuration, these handlers apply to both HTTP\n * and virtual requests\n */\nmodule.exports = function(sails) {\n\n\n  return {\n\n    /**\n     * Default 500 handler.\n     * (for errors implicitly thrown in middleware/routes)\n     *\n     * @param  {*} err\n     * @param  {Request} req\n     * @param  {Response} res\n     */\n    500: function(err, req, res) {\n\n      // console.log('* * * FIRED DEFAULT HANDLER (500) * * *');\n      // console.log('args:',arguments);\n      // console.log('* * * </FIRED_DEFAULT_HANDLER_500> * * *');\n      // console.log();\n\n      // First, check for special built-in errors from Express.\n      // We don't necessarily want to treat any error that is thrown with\n      // a `status` property of 400 as if it were intentional.  So we also check\n      // the error message.  In Express 5, hopefully this can be improved a bit\n      // further.\n      if (_.isError(err)) {\n        var msgMatches = err.message.match(/^Failed to decode param \\'([^']+)\\'/);\n        if (err.status === 400 && msgMatches) {\n          sails.log.verbose('Bad request: Could not decode the requested URL ('+req.path+')');\n          // Note for future: The problematic URL section is: `msgMatches[1]`\n          return res.send(400, 'Bad request: Could not decode requested URL.');\n        }\n      }//>-\n\n      // Next, try to use `res.negotiate()`, if it exists and is valid.\n      try {\n\n        if (typeof res.negotiate === 'function') {\n          return res.negotiate(err);\n        }//>-\n\n      } catch (e) { /* ignore any unexpected error encountered when attempting to respond w/ res.negotiate(). */ }\n\n      // Catch-all:\n      // Log a message and try to use `res.send` to respond.\n      try {\n\n        sails.log.error('Server Error:');\n        sails.log.error(err);\n        if (process.env.NODE_ENV === 'production') { return res.send(500); }\n        return res.send(500, err);\n\n      } catch (errorSendingResponse) {\n\n        // Serious error occurred-- unable to send response.\n        //\n        // Note that in the future, we could also emit an `abort` message on the request object\n        // in this case-- then if an attached server is managing this request, it could monitor\n        // for `abort` events and manage its private resources (e.g. TCP sockets) accordingly.\n        // However, such contingencies should really handled by the underlying HTTP hook, so\n        // this might not actually make sense.\n        sails.log.error('But no response could be sent because another error occurred:');\n        sails.log.error(errorSendingResponse);\n\n      }//</catch>\n    },\n\n\n\n    /**\n     * Default 404 handler.\n     * (for unmatched routes)\n     *\n     * @param  {Request} req\n     * @param  {Response} res\n     */\n    404: function(req, res) {\n\n      // Use `notFound` handler if it exists\n      try {\n        if (typeof res.notFound === 'function') {\n          return res.notFound();\n        }\n      } catch (e) {}\n\n      // Catch-all:\n      // Log a message and try to use `res.send` to respond.\n      try {\n        sails.log.verbose('A request (%s) did not match any routes, and no `res.notFound` handler is configured.', req.url);\n        res.send(404);\n        return;\n      }\n\n      // Serious error occurred-- unable to send response.\n      //\n      // Note that in the future, we could also emit an `abort` message on the request object\n      // in this case-- then if an attached server is managing this request, it could monitor\n      // for `abort` events and manage its private resources (e.g. TCP sockets) accordingly.\n      // However, such contingencies should really handled by the underlying HTTP hook, so\n      // this might not actually make sense.\n      catch (e) {\n        sails.log.error('An unmatched route was encountered in a request...');\n        sails.log.error('But no response could be sent because an error occurred:');\n        sails.log.error(e);\n        return;\n      }\n    }\n  };\n\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/router/bind.js":"/**\n * Module dependencies.\n */\n\nvar _ = require('@sailshq/lodash');\nvar sailsUtil = require('sails-util');\n\n\n\n/**\n * Expose `bind` method.\n */\nmodule.exports = bind;\n\n\n\n/**\n * Bind new route(s)\n *\n * @param {String|RegExp} path\n * @param {String|Object|Array|Function} target\n * @param {String} verb (optional)\n * @param {Object} options (optional)\n *\n * @this {SJSRouter}\n * @return {SJSApp}\n *\n * @api private\n */\n\nfunction bind( /* path, target, verb, options */ ) {\n  var sails = this.sails;\n\n  var args = sanitize.apply(this, Array.prototype.slice.call(arguments));\n  var path = args.path;\n  var target = args.target;\n  var verb = args.verb;\n  var options = args.options;\n\n  // Don't allow paths with \"length\" as a route param, because Express chokes on it\n  if (path.match(/\\/:length($|\\/)/)) {\n    throw new Error('Failed to bind route: `'+ path +'`\\n'+\n    'Routes which contain `/:length` in their address URL are not supported by Sails/Express (consider using `/:len`)');\n  }\n\n  // Bind a list of multiple functions in order\n  if (_.isArray(target)) {\n    bindArray.apply(this, [path, target, verb, options]);\n  }\n  // Handle string redirects\n  // (to either public-facingURLs or internal routes)\n  else if (_.isString(target) && target.match(/^(https?:|\\/)/)) {\n    bindRedirect.apply(this, [path, target, verb, options]);\n  }\n\n  // Bind a middleware function directly\n  else if (_.isFunction(target)) {\n    bindFunction.apply(this, [path, target, verb, options]);\n  }\n\n  // If target is an object with a `target`, pull out the rest\n  // of the keys as route options and then bind the target.\n  else if (_.isPlainObject(target) && (target.target || target.fn)) {\n    var _target = target.target || target.fn;\n    options = _.merge(options, _.omit(target, 'target'));\n    bind.apply(this, [path, _target, verb, options]);\n  }\n  else {\n\n    // If we make it here, the router doesn't know how to parse the target.\n    //\n    // This doesn't mean that it's necessarily invalid though--\n    // so we'll emit an event informing any listeners that an unrecognized route\n    // target was encountered.  Then hooks can listen to this event and act\n    // accordingly.  This makes it easier to add functionality to Sails.\n    sails.emit('route:typeUnknown', {\n      path: path,\n      target: target,\n      verb: verb,\n      options: options\n    });\n\n    // Note that, in the future, it would be good to track emissions of \"typeUnknown\" to\n    // avoid logic errors that result in circular routes.\n    // (part of the effort to make a more friendly environment for custom hook developers)\n  }\n\n  // Makes `.bind()` chainable (sort of)\n  return sails;\n\n}\n\n\n\n/**\n * Requests will be redirected to the specified string\n * (which should be a URL or redirectable path.)\n *\n * @api private\n */\nfunction bindRedirect(path, redirectTo, verb, options) {\n  var sails = this.sails;\n\n  bind.apply(this,[path, function(req, res) {\n    sails.log.verbose('Redirecting request (`' + path + '`) to `' + redirectTo + '`...');\n    res.redirect(redirectTo);\n  }, verb, options]);\n}\n\n\n/**\n * Recursively bind an array of targets in order\n *\n * TODO: Use a counter to prevent indefinite loops--\n * only possible if a bad route is bound,\n * but would still potentially be helpful.\n *\n * @api private\n */\nfunction bindArray(path, target, verb, options) {\n  var self = this;\n  var sails = this.sails;\n\n  if (target.length === 0) {\n    sails.log.verbose('Ignoring empty array in `router.bind(' + path + ')`...');\n  } else {\n    // Bind each middleware fn\n    _.each(target, function(fn) {\n      bind.apply(self,[path, fn, verb, options]);\n    });\n  }\n}\n\n\n\n/**\n * Attach middleware function to route.\n *\n * @api private\n */\nfunction bindFunction(path, fn, verb, options) {\n  var sails = this.sails;\n\n  // Regex to check if a URL is an asset (something with a file extension)\n  var skipAssetsRegex = /^[^?]*\\/[^?\\/]+\\.[^?\\/]+(\\?.*)?$/;\n\n  // Make sure (optional) options is a valid plain object ({})\n  options = _.isPlainObject(options) ? _.cloneDeep(options) : {};\n  var _middlewareType = options._middlewareType || fn._middlewareType || (fn.name && ('FUNCTION: ' + fn.name));\n  sails.log.silly('Binding route :: ', verb || '', path, _middlewareType?('('+_middlewareType+')'):'');\n\n\n  /**\n   * `router:route`\n   *\n   * Create a closure that emits the `router:route` event each time the route is hit\n   * before actually triggering the target function.\n   *\n   * NOTE: Modifications to route path parameters (i.e. `req.params`) or to `req.options`\n   * must be made here, since their values can change not only on a per-request, but\n   * also a per-route basis.\n   */\n  var enhancedFn = function routeTargetFnWrapper(req, res, next) {\n\n    // Set req.options, using `options` to supply default values\n    req.options = _.merge({}, options || {}, req.options || {});\n\n    // This event can be tapped into to take control of\n    // (synchronous) logic that should be run before each bound\n    // route handler function runs.\n    sails.emit('router:route', {\n      req: req,\n      res: res,\n      next: next,\n      options: options,\n      fn: fn\n    });\n\n\n    // Trigger original route handler function.\n    fn(req, res, next);\n  };\n\n  /**\n   * Wrap a regex route in a helper function that pulls out regex params\n   *\n   * Example: for route: 'r|/\\\\d+/(.*)/(.*)$|foo,bar', the two parenthesized\n   * groups would be pulled out as req.params[0] and req.params[1] by Express;\n   * the regexRouteWrapper would then map them to req.params['foo'] and req.params['bar']\n   *\n   * @param  {array} params List of params to apply to the req.params object\n   * @return {Function} A middleware function\n   */\n  var regexRouteWrapper = function(params) {\n\n    return function(req, res, next) {\n      // Apply the regex route params\n      params.forEach(function(param, index) {\n        req.params[param] = req.params[index];\n      });\n      // Call enhancedFn\n      enhancedFn(req, res, next);\n    };\n  };\n\n  /**\n   * Wrap a route in a helper function that first checks whether the URL matches\n   * any of a set of regexes, and if so, skips the defined handler.\n   *\n   * @param  {array}   regexes Array of regexes to match the URL against\n   * @param  {Function} fn      Middleware function to run if URL does NOT match regexes\n   * @return {Function} A middleware function\n   */\n  var skipRegexesWrapper = function(regexes, fn) {\n\n    // Remove anything that's not a regex\n    regexes = _.compact(regexes.map(function(regex) {\n      if (regex instanceof RegExp) {\n        return regex;\n      }\n      sails.log.warn('Invalid regex \"' + regex + \"' supplied to skipRegexesWrapper; ignoring.\");\n      return undefined;\n    }));\n\n\n    return function(req, res, next) {\n\n      // Check for matches\n      for (var i = 0; i < regexes.length; i++) {\n        if (req.url.match(regexes[i])) {\n          // If we find one, bail out\n          return next();\n        }\n      }\n\n      // Otherwise continue with the handler\n      return fn(req, res, next);\n\n    };\n\n  };\n\n  // If verb is not specified, default to CRUD methods.\n  // You can still explicitly route to \"all /path\" if you want ALLLLlllll the things.\n  var targetVerb = verb || ['get', 'put', 'post', 'delete', 'patch'];\n\n  // Function to actually bind\n  var targetFn;\n\n  // Regex to check if the route is...a regex.\n  var regExRoute = /^r\\|(.*)\\|(.*)$/;\n\n  // Perform the check\n  var matches = path.match(regExRoute);\n\n  // If it *is* a regex, create a RegExp object that Express can bind,\n  // pull out the params, and wrap the handler in regexRouteWrapper\n  if (matches) {\n    path = new RegExp(matches[1]);\n    var params = matches[2].split(',');\n    targetFn = regexRouteWrapper(params);\n  }\n\n  // Otherwise just bind enhancedFn\n  else {\n    targetFn = enhancedFn;\n  }\n\n  // If options.skipRegex is specified, make sure it's an array\n  if (options.skipRegex) {\n    if (!Array.isArray(options.skipRegex)) {\n      options.skipRegex = [options.skipRegex];\n    }\n  }\n  // Otherwise just make it an empty array\n  else {\n    options.skipRegex = [];\n  }\n\n  // If \"skipAssets\" option is true, add the skipAssets regex\n  // to the options.skipRegex array\n  if (options.skipAssets) {\n    options.skipRegex.push(skipAssetsRegex);\n  }\n\n  // If we have anything in the options.skipRegex array, wrap\n  // the target function again.\n  if (options.skipRegex.length) {\n    targetFn = skipRegexesWrapper(options.skipRegex, targetFn);\n  }\n\n  // Ensure targetVerb is an array\n  if (!Array.isArray(targetVerb)) {targetVerb = [targetVerb];}\n  // Loop through the verbs we want to bind\n  targetVerb.forEach(function(verb) {\n    verb = verb.toLowerCase();\n    // Bind the function to the private router\n    sails.router._privateRouter[verb](path, targetFn);\n    // Emit an event to make hooks aware that a route was bound\n    // This allows hooks to handle routes directly if they want to-\n    // e.g. with Express, the handler for this event looks like:\n    // sails.hooks.http.app[verb || 'all'](path, target);\n    sails.emit('router:bind', {\n      path: path,\n      target: targetFn,\n      verb: verb,\n      options: options,\n      originalFn: fn\n    });\n\n  });\n\n\n}\n\n\n\n/**\n * Sanitize the arguments to `sails.router.bind()`\n *\n * @returns {Object} sanitized arguments\n * @api private\n */\nfunction sanitize(path, target, verb, options) {\n  options = options || {};\n\n  // If trying to bind '*', that's probably not what was intended, so fix it up\n  path = path === '*' ? '/*' : path;\n\n  // If route has an HTTP verb (e.g. `get /foo/bar`, `put /bar/foo`, etc.) parse it out,\n  var detectedVerb = sailsUtil.detectVerb(path);\n  // then prune it from the path\n  path = detectedVerb.original;\n  // Keep track of parsed verb so we know if it was specified later\n  options.detectedVerb = detectedVerb;\n\n  // If a verb override was not specified,\n  // use the detected verb from the string route\n  if (!verb) {\n    verb = detectedVerb.verb;\n  }\n\n  return {\n    path: path,\n    target: target,\n    verb: verb,\n    options: options\n  };\n}\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails-util/index.js":"var _ = require('lodash'),\n\tnodeutil = require('util'),\n\tfs = require('fs'),\n\tsafeStringify = require('json-stringify-safe');\n\t_.str = require('underscore.string');\n\n\n\n\n// Extend util with underscore/lodash\n// and underscore.string methods\n_.extend(exports, _);\n\n\n// Merge in util submodules\nvar CLIUtil = require('./cli');\n_.extend(exports, CLIUtil);\n\n\n// Extend with node util methods\n_.extend(exports, nodeutil);\n\n\n/**\n * Accept things like `FooController` or `FoO`, then transform\n * and lower-case them to things like `foo`\n *\n * @api private\n */\n\nexports.normalizeControllerId = function normalizeControllerId (controllerId) {\n\tif (!_.isString(controllerId)) {\n\t\treturn null;\n\t}\n\tcontrollerId = controllerId.replace(/(.+)Controller$/i, '$1');\n\tcontrollerId = controllerId.toLowerCase();\n\treturn controllerId;\n};\n\n\n\n\n\n/**\n * Accept things like `FooAdapter` or `FoO`, then transform\n * and lower-case them to things like `foo`\n *\n * Works for adapters, controllers, and services\n *\n * @api private\n */\n\nexports.normalizeId = function normalizeId (id) {\n\tif (!_.isString(id)) {\n\t\treturn null;\n\t}\n\tid = id.replace(/(.+)(Controller|Adapter|Service)$/i, '$1');\n\tid = id.toLowerCase();\n\treturn id;\n};\n\n\n\n\n\n/**\n * isValidECMA51Variable\n *\n * @param {String} v\n *\n * @api private\n */\n\nexports.isValidECMA51Variable = function(v) {\n\treturn v.match(/^(?!(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$)[$A-Z\\_a-z\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u08a0\\u08a2-\\u08ac\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0977\\u0979-\\u097f\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c33\\u0c35-\\u0c39\\u0c3d\\u0c58\\u0c59\\u0c60\\u0c61\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d60\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f4\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f0\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1877\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191c\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19c1-\\u19c7\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1ce9-\\u1cec\\u1cee-\\u1cf1\\u1cf5\\u1cf6\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2119-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u212d\\u212f-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u2e2f\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309d-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua697\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua78e\\ua790-\\ua793\\ua7a0-\\ua7aa\\ua7f8-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa80-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uabc0-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc][$A-Z\\_a-z\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u08a0\\u08a2-\\u08ac\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0977\\u0979-\\u097f\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c33\\u0c35-\\u0c39\\u0c3d\\u0c58\\u0c59\\u0c60\\u0c61\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d60\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f4\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f0\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1877\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191c\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19c1-\\u19c7\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1ce9-\\u1cec\\u1cee-\\u1cf1\\u1cf5\\u1cf6\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2119-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u212d\\u212f-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u2e2f\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309d-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua697\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua78e\\ua790-\\ua793\\ua7a0-\\ua7aa\\ua7f8-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa80-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uabc0-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc0-9\\u0300-\\u036f\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u0669\\u0670\\u06d6-\\u06dc\\u06df-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u06f0-\\u06f9\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07c0-\\u07c9\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0859-\\u085b\\u08e4-\\u08fe\\u0900-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09cd\\u09d7\\u09e2\\u09e3\\u09e6-\\u09ef\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2\\u0ae3\\u0ae6-\\u0aef\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c01-\\u0c03\\u0c3e-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0c66-\\u0c6f\\u0c82\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0ce6-\\u0cef\\u0d02\\u0d03\\u0d3e-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4d\\u0d57\\u0d62\\u0d63\\u0d66-\\u0d6f\\u0d82\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0df2\\u0df3\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0e50-\\u0e59\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e\\u0f3f\\u0f71-\\u0f84\\u0f86\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102b-\\u103e\\u1040-\\u1049\\u1056-\\u1059\\u105e-\\u1060\\u1062-\\u1064\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b4-\\u17d3\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u18a9\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u194f\\u19b0-\\u19c0\\u19c8\\u19c9\\u19d0-\\u19d9\\u1a17-\\u1a1b\\u1a55-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1b00-\\u1b04\\u1b34-\\u1b44\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1b82\\u1ba1-\\u1bad\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c24-\\u1c37\\u1c40-\\u1c49\\u1c50-\\u1c59\\u1cd0-\\u1cd2\\u1cd4-\\u1ce8\\u1ced\\u1cf2-\\u1cf4\\u1dc0-\\u1de6\\u1dfc-\\u1dff\\u200c\\u200d\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2cef-\\u2cf1\\u2d7f\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua620-\\ua629\\ua66f\\ua674-\\ua67d\\ua69f\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua823-\\ua827\\ua880\\ua881\\ua8b4-\\ua8c4\\ua8d0-\\ua8d9\\ua8e0-\\ua8f1\\ua900-\\ua909\\ua926-\\ua92d\\ua947-\\ua953\\ua980-\\ua983\\ua9b3-\\ua9c0\\ua9d0-\\ua9d9\\uaa29-\\uaa36\\uaa43\\uaa4c\\uaa4d\\uaa50-\\uaa59\\uaa7b\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uaaeb-\\uaaef\\uaaf5\\uaaf6\\uabe3-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe26\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f]*$/);\n};\n\n\n\n\n\n\n/**\n * defaultsDeep\n *\n * Implement a deep version of `_.defaults`.\n *\n * @api private\n */\n\nexports.defaultsDeep = _.partialRight(_.merge, _.defaults);\n\n\n\n\n\n\n/**\n * Normalize an error or array of errors into an array of proper, readable Errors\n *\n * @param {String|Object|Error|Array} errOrErrs\n * @returns {Array[Error]}\n *\n * @api private\n */\n\nexports.normalizeErrors = function normalizeErrors(errOrErrs) {\n\n\t// If `errOrErrs` is not an array already, make it one\n\tvar errorsToDisplay = _.isArray(errOrErrs) ? errOrErrs : [errOrErrs];\n\n\t// Ensure that each error is formatted correctly\n\treturn _.map(errorsToDisplay, function (e, i) {\n\t\tvar displayError;\n\n\t\t// Make error easier to read, and normalize its type\n\t\tif (e instanceof Error) {\n\t\t\tdisplayError = e;\n\t\t}\n\n\t\t// Create an error ad hoc\n\t\t// (but save reference to original)\n\t\telse {\n\t\t\tdisplayError = new Error( nodeutil.inspect(e) );\n\t\t\tdisplayError.original = e;\n\t\t}\n\n\t\treturn displayError;\n\t});\n};\n\n\n\n\n\n\n/**\n * Detect HTTP verb in an expression like:\n * `get baz`    or     `get /foo/baz`\n *\n * @api private\n */\n\nexports.detectVerb = function (haystack) {\n\tvar verbExpr = /^(all|get|post|put|delete|trace|options|connect|patch|head)\\s+/i;\n\tvar verbSpecified = _.last(haystack.match(verbExpr) || []) || '';\n\tverbSpecified = verbSpecified.toLowerCase();\n\n\t// If a verb was specified, eliminate the verb from the original string\n\tif (verbSpecified) {\n\t\thaystack = haystack.replace(verbExpr,'');\n\t}\n\n\treturn {\n\t\tverb: verbSpecified,\n\t\toriginal: haystack,\n\t\tpath: haystack\n\t};\n};\n\n\n\n\n\n\n\n/**\n * pluralize\n *\n * Run a method meant for a single object on a single instance OR array.\n * For a list, run the method on each item return the resulting array.\n * For anything else, return it silently.\n *\n * @api private\n */\n\nexports.pluralize = function pluralize(collection, application) {\n\tif(_.isArray(collection)) {\n\t\treturn _.map(collection, application);\n\t}\n\treturn application(collection);\n};\n\n\n\n\n\n\n/**\n * Detect if a string is \"safe\" to eval()\n *\n * @api private\n */\n\nexports.safeToEval = function(someString) {\n\ttry {\n\t\t!(/[^,:{}\\[\\]0-9.\\-+Eaeflnr-u \\n\\r\\t]/.test(someString.replace(/\"(\\\\.|[^\"\\\\])*\"/g, ''))) && eval('(' + someString + ')');\n\t} catch(e) {\n\t\treturn false;\n\t}\n\treturn true;\n};\n\n\n\n\n\n\n/**\n * Return whether the specified item is an object, but NOT an array or function\n *\n * TODO:\treplace usages of this method with `instanceof`\n *\t\t\tand `_.isPlainObject()`\n *\n * @api private\n *\n * @api private\n */\nexports.isDictionary = function isDictionary(thing) {\n\treturn _.isObject(thing) && !_.isArray(thing) && !_.isFunction(thing);\n};\n\n\n\n\n\n\n\n\n/**\n * optional\n *\n * Wrap a callback function to make it optional\n *\n * @api private\n */\n\nexports.optional = function wrapOptionalCallback (cb) {\n\tif ( _.isFunction(cb) ) return cb;\n\treturn function _noOp (){};\n\n\t// return function optionalCallback () {\n\t// \tif (!cb) return;\n\t// \tvar args = Array.prototype.slice.call(arguments);\n\t// \treturn cb.apply(this, args);\n\t// };\n};\n\n\n\n\n/**\n * Get the domain out of the origin header--\n * compare it to the host\n *\n * @api private\n */\n\nexports.isSameOrigin = function isSameOrigin(req, strict) {\n\n\t// If there's no origin header, consider it same origin unless\n\t// we're in strict mode\n\tif (!req.headers.origin) {\n\t\treturn !strict;\n\t}\n\n\t// Get the domain and port out of the origin header\n\tvar matches = req.headers.origin.match(/^https?:\\/\\/([^:]+)(:(\\d+))?$/);\n\t// If the origin doesn't match the regex, consider it okay if we're not\n\t// in strict mode--this will allow non-http origins like \"chrome-extension://\"\n\tif (matches === null) {\n\t\treturn !strict;\n\t}\n\tvar domain = matches[1];\n\tvar port = matches[3];\n\n\t// Compare it to the host\n\treturn (req.host == domain && (!port || req.port == port));\n};\n\n\n\n\n/**\n * Return whether the given object is an instance of Error\n *\n * @api private\n */\n\nexports.isError = function (e) {\n\treturn e instanceof Error;\n};\n\n\n\n\n\n/**\n * Extract the file extension suffix from a filename or path\n *\n * @api private\n */\n\nexports.fileExtension = function(str) {\n\tif(str === null) return '';\n\tvar pieces = String(str).split('.');\n\treturn pieces.length > 1 ? _.last(pieces) : '';\n};\n\n\n\n\n/**\n * Return the abbreviated ordinal string for a given integer\n *\n * http://en.wikipedia.org/wiki/Ordinal_number_(linguistics)\n * i.e. prettier rendering of things like: 1st, 2nd, 3rd, 4th\n *\n * @api private\n */\n\nexports.ordinal = function(integer) {\n\tif(_.isFinite(+integer) && Math.floor(+integer) === +integer) {\n\t\tvar lastDigit = +integer % 10;\n\t\tvar lastTwoDigits = +integer % 100;\n\t\tvar response = integer + \"\";\n\n\t\t// Handle n-teen case\n\t\tif(lastTwoDigits >= 11 && lastTwoDigits <= 13) {\n\t\t\treturn response + \"th\";\n\t\t}\n\n\t\t// Handle general case\n\t\tswitch(lastDigit) {\n\t\tcase 1:\n\t\t\treturn response + \"st\";\n\t\tcase 2:\n\t\t\treturn response + \"nd\";\n\t\tcase 3:\n\t\t\treturn response + \"rd\";\n\t\tdefault:\n\t\t\treturn response + \"th\";\n\t\t}\n\t}\n\tthrow new Error(\"sails.util.ordinal() only works on integers!\");\n};\n\n\n\n\n\n/**\n * Get the names of a function's arguments\n *\n * @param {Function} func\n * @returns array of argument names, e.g. ['req', 'res']\n *\n * @api private\n */\nexports.getParamNames = function(func) {\n\n\tvar STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg;\n\tvar fnStr = func.toString().replace(STRIP_COMMENTS, '');\n\tvar result = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).match(/([^\\s,]+)/g);\n\tif (result === null)\n\t\tresult = [];\n\treturn result;\n};\n\n\n\n\n/**\n * parseJSONFile\n *\n * Read a json file at the specified path.\n * If an error occurs, call cb(err), and dont throw!\n *\n * @api private\n */\n\nexports.parseJSONFile = function ( path, cb ) {\n\tif (!cb) throw new Error('Callback required!');\n\tif (cb === 'sync') {\n\t\tvar jsonString;\n\t\ttry {\n\t\t\tjsonString = fs.readFileSync(path, 'utf-8');\n\t\t}\n\t\tcatch (e) {\n\t\t\treturn false;\n\t\t}\n\t\treturn andThen(jsonString);\n\t}\n\tfs.readFile(path, 'utf-8', function (err, file) {\n\t\tif (err) return cb(err);\n\t\tandThen(file);\n\t});\n\n\t// Attempt to parse JSON, then return\n\tfunction andThen( json ) {\n\t\tvar err;\n\t\ttry {\n\t\t\tjson = JSON.parse(json);\n\t\t} catch (e) {\n\t\t\terr = e;\n\t\t\tjson = false;\n\t\t}\n\n\t\t// Parse failed:\n\t\tif (err) {\n\t\t\tif (cb==='sync') return false;\n\t\t\telse return cb(err);\n\t\t}\n\n\t\t// Success:\n\t\tif ( cb === 'sync' ) return json;\n\t\treturn cb(null, json);\n\t}\n};\n\n/**\n * getJSONFileSync\n *\n * Synchronous version of getJSONFile()\n * Returns false if json file cannot be read or parsed.\n *\n * @api private\n */\n\nexports.parseJSONFileSync = function ( path ) {\n\treturn exports.parseJSONFile(path, 'sync');\n};\n\n\n\n\n/**\n * getPackage\n *\n * Read package.json file in the directory at the specified\n * path.  If an error occurs, call cb(err), and dont throw!\n *\n * @api private\n */\n\nexports.getPackage = function (path, cb) {\n\tpath = _.str.rtrim(path, '/');\n\tpath += '/package.json';\n\n\texports.parseJSONFile(path, function (err, json) {\n\t\tif (err) return cb(err);\n\n\t\t// Success:\n\t\t// Ensure dependencies are at least an empty object\n\t\tjson.dependencies = json.dependencies || {};\n\t\tif ( cb === 'sync' ) return json;\n\t\treturn cb(null, json);\n\t});\n};\n\n\n\n\n\n\n/**\n * getPackageSync\n *\n * Synchronous version of getPackage()\n * Returns false if package.json cannot be read or parsed.\n *\n * @api private\n */\n\nexports.getPackageSync = function (path) {\n\tpath = _.str.rtrim(path, '/');\n\tpath += '/package.json';\n\n\t// Success:\n\t// Ensure dependencies are at least an empty object\n\tvar json = exports.parseJSONFileSync(path, 'sync');\n\tif (!json) return json;\n\tjson.dependencies = json.dependencies || {};\n\treturn json;\n};\n\n\n\n\n/**\n * Get path to the home directory in an OS-agnostic way\n *\n * @api private\n */\n\nexports.homeDirectory = function () {\n\treturn process.env[\n\t\t(process.platform == 'win32') ?\n\t\t'USERPROFILE' :\n\t\t'HOME'\n\t];\n};\n\n\n\n\n\n/**\n * tolerantParse\n *\n * Parse specified JSON, but if it fails,\n * return false instead of throwing.\n *\n * @api private\n */\n\nexports.tolerantParse = function ( json ) {\n\tvar args = Array.prototype.slice.call(arguments);\n\ttry {\n\t\treturn JSON.parse.apply(this, args);\n\t} catch (e) {\n\t\treturn false;\n\t}\n};\n\n\n\n\n\n/**\n * Wrapper for @isaacs' `json-stringify-safe`\n *\n * Automatically handles circular references.\n * See: https://github.com/isaacs/json-stringify-safe\n *\n * If stringification doesn't work, instead of throwing,\n * return false.\n *\n * @api private\n */\nexports.stringify = function ( json, serializer, indent, decycler ) {\n\tvar args = Array.prototype.slice.call(arguments);\n\ttry {\n\t\treturn safeStringify.apply(this, args);\n\t}\n\tcatch (e) {\n\t\treturn false;\n\t}\n};\n\n\n\n\n\n\n\n// Underscore extensions for objects\n_.extend(exports,{\n\n\n\n\t/**\n\t * _.objMap\n\t *\n\t * _.map for objects, keeps key/value associations\n\t *\n\t * @api private\n\t */\n\n\tobjMap: function(input, mapper, context) {\n\t\treturn _.reduce(input, function(obj, v, k) {\n\t\t\tobj[k] = mapper.call(context, v, k, input);\n\t\t\treturn obj;\n\t\t}, {}, context);\n\t},\n\n\n\n\n\t/**\n\t * _.objFilter\n\t *\n\t * _.filter for objects, keeps key/value associations\n\t * but only includes the properties that pass test().\n\t *\n\t * @api private\n\t */\n\n\tobjFilter: function(input, test, context) {\n\t\treturn _.reduce(input, function(obj, v, k) {\n\t\t\tif(test.call(context, v, k, input)) {\n\t\t\t\tobj[k] = v;\n\t\t\t}\n\t\t\treturn obj;\n\t\t}, {}, context);\n\t},\n\n\n\n\n\t/**\n\t * _.objReject\n\t *\n\t * _.reject for objects, keeps key/value associations\n\t * but does not include the properties that pass test().\n\t *\n\t * @api private\n\t */\n\n\tobjReject: function(input, test, context) {\n\t\treturn _.reduce(input, function(obj, v, k) {\n\t\t\tif(!test.call(context, v, k, input)) {\n\t\t\t\tobj[k] = v;\n\t\t\t}\n\t\t\treturn obj;\n\t\t}, {}, context);\n\t},\n\n\n\n\t/**\n\t * _.objInvoke\n\t *\n\t * Usage:\n\t *\tobj -> the object\n\t *\targuments* -> other arguments can be specified to be invoked on each of the functions\n\t *\n\t * @api private\n\t */\n\n\tobjInvoke: function(obj) {\n\t\tvar args = _.toArray(arguments).shift();\n\t\treturn exports.objMap(obj, function(fn) {\n\t\t\treturn fn(args);\n\t\t});\n\t},\n\n\t/**\n\t * _.objCompact\n\t *\n\t * _.compact for objects; keeps only keys whose values are not undefined\n\t *\tobj -> the object\n\t *\tstrict -> if \"true\", only keep keys whose values are falsy\n\t *\n\t * @api private\n\t */\n\tobjCompact: function(obj, strict) {\n\t\tobj = _.reduce(obj, function(memo, value, paramName) {\n\t\t\tif (strict) {\n\t\t\t\tif (value !== undefined && value !== null && value !== false && value !== '') {\n\t\t\t\t\tmemo[paramName] = value;\n\t\t\t\t}\n\t\t\t} else if (value !== undefined) {\n        \t\tmemo[paramName] = value;\n      \t\t}\n      \t\treturn memo;\n    \t}, {});\n    \treturn obj;\n\t},\n\n\t/**\n\t * _.objDeref\n\t *\n\t * Safely dereference an object given a path\n\t * @param  {object} obj  The object to dereference\n\t * @param  {string} path The dot-delimited path to use\n\t * @return {mixed}      The value of the object at that path, or undefined\n\t */\n\tobjDeref: function(obj, path) {\n\t\treturn path.split('.').reduce(_objDeref, obj);\n\t}\n\n});\n\nfunction _objDeref(obj,i) {return (typeof obj == 'object' && obj !== null) ? obj[i] : undefined;}","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails-util/node_modules/underscore.string/lib/underscore.string.js":"//  Underscore.string\n//  (c) 2010 Esa-Matti Suuronen <esa-matti aet suuronen dot org>\n//  Underscore.string is freely distributable under the terms of the MIT license.\n//  Documentation: https://github.com/epeli/underscore.string\n//  Some code is borrowed from MooTools and Alexandru Marasteanu.\n//  Version '2.3.2'\n\n!function(root, String){\n  'use strict';\n\n  // Defining helper functions.\n\n  var nativeTrim = String.prototype.trim;\n  var nativeTrimRight = String.prototype.trimRight;\n  var nativeTrimLeft = String.prototype.trimLeft;\n\n  var parseNumber = function(source) { return source * 1 || 0; };\n\n  var strRepeat = function(str, qty){\n    if (qty < 1) return '';\n    var result = '';\n    while (qty > 0) {\n      if (qty & 1) result += str;\n      qty >>= 1, str += str;\n    }\n    return result;\n  };\n\n  var slice = [].slice;\n\n  var defaultToWhiteSpace = function(characters) {\n    if (characters == null)\n      return '\\\\s';\n    else if (characters.source)\n      return characters.source;\n    else\n      return '[' + _s.escapeRegExp(characters) + ']';\n  };\n\n  // Helper for toBoolean\n  function boolMatch(s, matchers) {\n    var i, matcher, down = s.toLowerCase();\n    matchers = [].concat(matchers);\n    for (i = 0; i < matchers.length; i += 1) {\n      matcher = matchers[i];\n      if (!matcher) continue;\n      if (matcher.test && matcher.test(s)) return true;\n      if (matcher.toLowerCase() === down) return true;\n    }\n  }\n\n  var escapeChars = {\n    lt: '<',\n    gt: '>',\n    quot: '\"',\n    amp: '&',\n    apos: \"'\"\n  };\n\n  var reversedEscapeChars = {};\n  for(var key in escapeChars) reversedEscapeChars[escapeChars[key]] = key;\n  reversedEscapeChars[\"'\"] = '#39';\n\n  // sprintf() for JavaScript 0.7-beta1\n  // http://www.diveintojavascript.com/projects/javascript-sprintf\n  //\n  // Copyright (c) Alexandru Marasteanu <alexaholic [at) gmail (dot] com>\n  // All rights reserved.\n\n  var sprintf = (function() {\n    function get_type(variable) {\n      return Object.prototype.toString.call(variable).slice(8, -1).toLowerCase();\n    }\n\n    var str_repeat = strRepeat;\n\n    var str_format = function() {\n      if (!str_format.cache.hasOwnProperty(arguments[0])) {\n        str_format.cache[arguments[0]] = str_format.parse(arguments[0]);\n      }\n      return str_format.format.call(null, str_format.cache[arguments[0]], arguments);\n    };\n\n    str_format.format = function(parse_tree, argv) {\n      var cursor = 1, tree_length = parse_tree.length, node_type = '', arg, output = [], i, k, match, pad, pad_character, pad_length;\n      for (i = 0; i < tree_length; i++) {\n        node_type = get_type(parse_tree[i]);\n        if (node_type === 'string') {\n          output.push(parse_tree[i]);\n        }\n        else if (node_type === 'array') {\n          match = parse_tree[i]; // convenience purposes only\n          if (match[2]) { // keyword argument\n            arg = argv[cursor];\n            for (k = 0; k < match[2].length; k++) {\n              if (!arg.hasOwnProperty(match[2][k])) {\n                throw new Error(sprintf('[_.sprintf] property \"%s\" does not exist', match[2][k]));\n              }\n              arg = arg[match[2][k]];\n            }\n          } else if (match[1]) { // positional argument (explicit)\n            arg = argv[match[1]];\n          }\n          else { // positional argument (implicit)\n            arg = argv[cursor++];\n          }\n\n          if (/[^s]/.test(match[8]) && (get_type(arg) != 'number')) {\n            throw new Error(sprintf('[_.sprintf] expecting number but found %s', get_type(arg)));\n          }\n          switch (match[8]) {\n            case 'b': arg = arg.toString(2); break;\n            case 'c': arg = String.fromCharCode(arg); break;\n            case 'd': arg = parseInt(arg, 10); break;\n            case 'e': arg = match[7] ? arg.toExponential(match[7]) : arg.toExponential(); break;\n            case 'f': arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg); break;\n            case 'o': arg = arg.toString(8); break;\n            case 's': arg = ((arg = String(arg)) && match[7] ? arg.substring(0, match[7]) : arg); break;\n            case 'u': arg = Math.abs(arg); break;\n            case 'x': arg = arg.toString(16); break;\n            case 'X': arg = arg.toString(16).toUpperCase(); break;\n          }\n          arg = (/[def]/.test(match[8]) && match[3] && arg >= 0 ? '+'+ arg : arg);\n          pad_character = match[4] ? match[4] == '0' ? '0' : match[4].charAt(1) : ' ';\n          pad_length = match[6] - String(arg).length;\n          pad = match[6] ? str_repeat(pad_character, pad_length) : '';\n          output.push(match[5] ? arg + pad : pad + arg);\n        }\n      }\n      return output.join('');\n    };\n\n    str_format.cache = {};\n\n    str_format.parse = function(fmt) {\n      var _fmt = fmt, match = [], parse_tree = [], arg_names = 0;\n      while (_fmt) {\n        if ((match = /^[^\\x25]+/.exec(_fmt)) !== null) {\n          parse_tree.push(match[0]);\n        }\n        else if ((match = /^\\x25{2}/.exec(_fmt)) !== null) {\n          parse_tree.push('%');\n        }\n        else if ((match = /^\\x25(?:([1-9]\\d*)\\$|\\(([^\\)]+)\\))?(\\+)?(0|'[^$])?(-)?(\\d+)?(?:\\.(\\d+))?([b-fosuxX])/.exec(_fmt)) !== null) {\n          if (match[2]) {\n            arg_names |= 1;\n            var field_list = [], replacement_field = match[2], field_match = [];\n            if ((field_match = /^([a-z_][a-z_\\d]*)/i.exec(replacement_field)) !== null) {\n              field_list.push(field_match[1]);\n              while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {\n                if ((field_match = /^\\.([a-z_][a-z_\\d]*)/i.exec(replacement_field)) !== null) {\n                  field_list.push(field_match[1]);\n                }\n                else if ((field_match = /^\\[(\\d+)\\]/.exec(replacement_field)) !== null) {\n                  field_list.push(field_match[1]);\n                }\n                else {\n                  throw new Error('[_.sprintf] huh?');\n                }\n              }\n            }\n            else {\n              throw new Error('[_.sprintf] huh?');\n            }\n            match[2] = field_list;\n          }\n          else {\n            arg_names |= 2;\n          }\n          if (arg_names === 3) {\n            throw new Error('[_.sprintf] mixing positional and named placeholders is not (yet) supported');\n          }\n          parse_tree.push(match);\n        }\n        else {\n          throw new Error('[_.sprintf] huh?');\n        }\n        _fmt = _fmt.substring(match[0].length);\n      }\n      return parse_tree;\n    };\n\n    return str_format;\n  })();\n\n\n\n  // Defining underscore.string\n\n  var _s = {\n\n    VERSION: '2.3.0',\n\n    isBlank: function(str){\n      if (str == null) str = '';\n      return (/^\\s*$/).test(str);\n    },\n\n    stripTags: function(str){\n      if (str == null) return '';\n      return String(str).replace(/<\\/?[^>]+>/g, '');\n    },\n\n    capitalize : function(str){\n      str = str == null ? '' : String(str);\n      return str.charAt(0).toUpperCase() + str.slice(1);\n    },\n\n    chop: function(str, step){\n      if (str == null) return [];\n      str = String(str);\n      step = ~~step;\n      return step > 0 ? str.match(new RegExp('.{1,' + step + '}', 'g')) : [str];\n    },\n\n    clean: function(str){\n      return _s.strip(str).replace(/\\s+/g, ' ');\n    },\n\n    count: function(str, substr){\n      if (str == null || substr == null) return 0;\n\n      str = String(str);\n      substr = String(substr);\n\n      var count = 0,\n        pos = 0,\n        length = substr.length;\n\n      while (true) {\n        pos = str.indexOf(substr, pos);\n        if (pos === -1) break;\n        count++;\n        pos += length;\n      }\n\n      return count;\n    },\n\n    chars: function(str) {\n      if (str == null) return [];\n      return String(str).split('');\n    },\n\n    swapCase: function(str) {\n      if (str == null) return '';\n      return String(str).replace(/\\S/g, function(c){\n        return c === c.toUpperCase() ? c.toLowerCase() : c.toUpperCase();\n      });\n    },\n\n    escapeHTML: function(str) {\n      if (str == null) return '';\n      return String(str).replace(/[&<>\"']/g, function(m){ return '&' + reversedEscapeChars[m] + ';'; });\n    },\n\n    unescapeHTML: function(str) {\n      if (str == null) return '';\n      return String(str).replace(/\\&([^;]+);/g, function(entity, entityCode){\n        var match;\n\n        if (entityCode in escapeChars) {\n          return escapeChars[entityCode];\n        } else if (match = entityCode.match(/^#x([\\da-fA-F]+)$/)) {\n          return String.fromCharCode(parseInt(match[1], 16));\n        } else if (match = entityCode.match(/^#(\\d+)$/)) {\n          return String.fromCharCode(~~match[1]);\n        } else {\n          return entity;\n        }\n      });\n    },\n\n    escapeRegExp: function(str){\n      if (str == null) return '';\n      return String(str).replace(/([.*+?^=!:${}()|[\\]\\/\\\\])/g, '\\\\$1');\n    },\n\n    splice: function(str, i, howmany, substr){\n      var arr = _s.chars(str);\n      arr.splice(~~i, ~~howmany, substr);\n      return arr.join('');\n    },\n\n    insert: function(str, i, substr){\n      return _s.splice(str, i, 0, substr);\n    },\n\n    include: function(str, needle){\n      if (needle === '') return true;\n      if (str == null) return false;\n      return String(str).indexOf(needle) !== -1;\n    },\n\n    join: function() {\n      var args = slice.call(arguments),\n        separator = args.shift();\n\n      if (separator == null) separator = '';\n\n      return args.join(separator);\n    },\n\n    lines: function(str) {\n      if (str == null) return [];\n      return String(str).split(\"\\n\");\n    },\n\n    reverse: function(str){\n      return _s.chars(str).reverse().join('');\n    },\n\n    startsWith: function(str, starts){\n      if (starts === '') return true;\n      if (str == null || starts == null) return false;\n      str = String(str); starts = String(starts);\n      return str.length >= starts.length && str.slice(0, starts.length) === starts;\n    },\n\n    endsWith: function(str, ends){\n      if (ends === '') return true;\n      if (str == null || ends == null) return false;\n      str = String(str); ends = String(ends);\n      return str.length >= ends.length && str.slice(str.length - ends.length) === ends;\n    },\n\n    succ: function(str){\n      if (str == null) return '';\n      str = String(str);\n      return str.slice(0, -1) + String.fromCharCode(str.charCodeAt(str.length-1) + 1);\n    },\n\n    titleize: function(str){\n      if (str == null) return '';\n      str  = String(str).toLowerCase();\n      return str.replace(/(?:^|\\s|-)\\S/g, function(c){ return c.toUpperCase(); });\n    },\n\n    camelize: function(str){\n      return _s.trim(str).replace(/[-_\\s]+(.)?/g, function(match, c){ return c ? c.toUpperCase() : \"\"; });\n    },\n\n    underscored: function(str){\n      return _s.trim(str).replace(/([a-z\\d])([A-Z]+)/g, '$1_$2').replace(/[-\\s]+/g, '_').toLowerCase();\n    },\n\n    dasherize: function(str){\n      return _s.trim(str).replace(/([A-Z])/g, '-$1').replace(/[-_\\s]+/g, '-').toLowerCase();\n    },\n\n    classify: function(str){\n      return _s.titleize(String(str).replace(/[\\W_]/g, ' ')).replace(/\\s/g, '');\n    },\n\n    humanize: function(str){\n      return _s.capitalize(_s.underscored(str).replace(/_id$/,'').replace(/_/g, ' '));\n    },\n\n    trim: function(str, characters){\n      if (str == null) return '';\n      if (!characters && nativeTrim) return nativeTrim.call(str);\n      characters = defaultToWhiteSpace(characters);\n      return String(str).replace(new RegExp('\\^' + characters + '+|' + characters + '+$', 'g'), '');\n    },\n\n    ltrim: function(str, characters){\n      if (str == null) return '';\n      if (!characters && nativeTrimLeft) return nativeTrimLeft.call(str);\n      characters = defaultToWhiteSpace(characters);\n      return String(str).replace(new RegExp('^' + characters + '+'), '');\n    },\n\n    rtrim: function(str, characters){\n      if (str == null) return '';\n      if (!characters && nativeTrimRight) return nativeTrimRight.call(str);\n      characters = defaultToWhiteSpace(characters);\n      return String(str).replace(new RegExp(characters + '+$'), '');\n    },\n\n    truncate: function(str, length, truncateStr){\n      if (str == null) return '';\n      str = String(str); truncateStr = truncateStr || '...';\n      length = ~~length;\n      return str.length > length ? str.slice(0, length) + truncateStr : str;\n    },\n\n    /**\n     * _s.prune: a more elegant version of truncate\n     * prune extra chars, never leaving a half-chopped word.\n     * @author github.com/rwz\n     */\n    prune: function(str, length, pruneStr){\n      if (str == null) return '';\n\n      str = String(str); length = ~~length;\n      pruneStr = pruneStr != null ? String(pruneStr) : '...';\n\n      if (str.length <= length) return str;\n\n      var tmpl = function(c){ return c.toUpperCase() !== c.toLowerCase() ? 'A' : ' '; },\n        template = str.slice(0, length+1).replace(/.(?=\\W*\\w*$)/g, tmpl); // 'Hello, world' -> 'HellAA AAAAA'\n\n      if (template.slice(template.length-2).match(/\\w\\w/))\n        template = template.replace(/\\s*\\S+$/, '');\n      else\n        template = _s.rtrim(template.slice(0, template.length-1));\n\n      return (template+pruneStr).length > str.length ? str : str.slice(0, template.length)+pruneStr;\n    },\n\n    words: function(str, delimiter) {\n      if (_s.isBlank(str)) return [];\n      return _s.trim(str, delimiter).split(delimiter || /\\s+/);\n    },\n\n    pad: function(str, length, padStr, type) {\n      str = str == null ? '' : String(str);\n      length = ~~length;\n\n      var padlen  = 0;\n\n      if (!padStr)\n        padStr = ' ';\n      else if (padStr.length > 1)\n        padStr = padStr.charAt(0);\n\n      switch(type) {\n        case 'right':\n          padlen = length - str.length;\n          return str + strRepeat(padStr, padlen);\n        case 'both':\n          padlen = length - str.length;\n          return strRepeat(padStr, Math.ceil(padlen/2)) + str\n                  + strRepeat(padStr, Math.floor(padlen/2));\n        default: // 'left'\n          padlen = length - str.length;\n          return strRepeat(padStr, padlen) + str;\n        }\n    },\n\n    lpad: function(str, length, padStr) {\n      return _s.pad(str, length, padStr);\n    },\n\n    rpad: function(str, length, padStr) {\n      return _s.pad(str, length, padStr, 'right');\n    },\n\n    lrpad: function(str, length, padStr) {\n      return _s.pad(str, length, padStr, 'both');\n    },\n\n    sprintf: sprintf,\n\n    vsprintf: function(fmt, argv){\n      argv.unshift(fmt);\n      return sprintf.apply(null, argv);\n    },\n\n    toNumber: function(str, decimals) {\n      if (!str) return 0;\n      str = _s.trim(str);\n      if (!str.match(/^-?\\d+(?:\\.\\d+)?$/)) return NaN;\n      return parseNumber(parseNumber(str).toFixed(~~decimals));\n    },\n\n    numberFormat : function(number, dec, dsep, tsep) {\n      if (isNaN(number) || number == null) return '';\n\n      number = number.toFixed(~~dec);\n      tsep = typeof tsep == 'string' ? tsep : ',';\n\n      var parts = number.split('.'), fnums = parts[0],\n        decimals = parts[1] ? (dsep || '.') + parts[1] : '';\n\n      return fnums.replace(/(\\d)(?=(?:\\d{3})+$)/g, '$1' + tsep) + decimals;\n    },\n\n    strRight: function(str, sep){\n      if (str == null) return '';\n      str = String(str); sep = sep != null ? String(sep) : sep;\n      var pos = !sep ? -1 : str.indexOf(sep);\n      return ~pos ? str.slice(pos+sep.length, str.length) : str;\n    },\n\n    strRightBack: function(str, sep){\n      if (str == null) return '';\n      str = String(str); sep = sep != null ? String(sep) : sep;\n      var pos = !sep ? -1 : str.lastIndexOf(sep);\n      return ~pos ? str.slice(pos+sep.length, str.length) : str;\n    },\n\n    strLeft: function(str, sep){\n      if (str == null) return '';\n      str = String(str); sep = sep != null ? String(sep) : sep;\n      var pos = !sep ? -1 : str.indexOf(sep);\n      return ~pos ? str.slice(0, pos) : str;\n    },\n\n    strLeftBack: function(str, sep){\n      if (str == null) return '';\n      str += ''; sep = sep != null ? ''+sep : sep;\n      var pos = str.lastIndexOf(sep);\n      return ~pos ? str.slice(0, pos) : str;\n    },\n\n    toSentence: function(array, separator, lastSeparator, serial) {\n      separator = separator || ', ';\n      lastSeparator = lastSeparator || ' and ';\n      var a = array.slice(), lastMember = a.pop();\n\n      if (array.length > 2 && serial) lastSeparator = _s.rtrim(separator) + lastSeparator;\n\n      return a.length ? a.join(separator) + lastSeparator + lastMember : lastMember;\n    },\n\n    toSentenceSerial: function() {\n      var args = slice.call(arguments);\n      args[3] = true;\n      return _s.toSentence.apply(_s, args);\n    },\n\n    slugify: function(str) {\n      if (str == null) return '';\n\n      var from  = \"\",\n          to    = \"aaaaaaaaaceeeeeiiiilnoooooosstuuuunczz\",\n          regex = new RegExp(defaultToWhiteSpace(from), 'g');\n\n      str = String(str).toLowerCase().replace(regex, function(c){\n        var index = from.indexOf(c);\n        return to.charAt(index) || '-';\n      });\n\n      return _s.dasherize(str.replace(/[^\\w\\s-]/g, ''));\n    },\n\n    surround: function(str, wrapper) {\n      return [wrapper, str, wrapper].join('');\n    },\n\n    quote: function(str, quoteChar) {\n      return _s.surround(str, quoteChar || '\"');\n    },\n\n    unquote: function(str, quoteChar) {\n      quoteChar = quoteChar || '\"';\n      if (str[0] === quoteChar && str[str.length-1] === quoteChar)\n        return str.slice(1,str.length-1);\n      else return str;\n    },\n\n    exports: function() {\n      var result = {};\n\n      for (var prop in this) {\n        if (!this.hasOwnProperty(prop) || prop.match(/^(?:include|contains|reverse)$/)) continue;\n        result[prop] = this[prop];\n      }\n\n      return result;\n    },\n\n    repeat: function(str, qty, separator){\n      if (str == null) return '';\n\n      qty = ~~qty;\n\n      // using faster implementation if separator is not needed;\n      if (separator == null) return strRepeat(String(str), qty);\n\n      // this one is about 300x slower in Google Chrome\n      for (var repeat = []; qty > 0; repeat[--qty] = str) {}\n      return repeat.join(separator);\n    },\n\n    naturalCmp: function(str1, str2){\n      if (str1 == str2) return 0;\n      if (!str1) return -1;\n      if (!str2) return 1;\n\n      var cmpRegex = /(\\.\\d+)|(\\d+)|(\\D+)/g,\n        tokens1 = String(str1).toLowerCase().match(cmpRegex),\n        tokens2 = String(str2).toLowerCase().match(cmpRegex),\n        count = Math.min(tokens1.length, tokens2.length);\n\n      for(var i = 0; i < count; i++) {\n        var a = tokens1[i], b = tokens2[i];\n\n        if (a !== b){\n          var num1 = parseInt(a, 10);\n          if (!isNaN(num1)){\n            var num2 = parseInt(b, 10);\n            if (!isNaN(num2) && num1 - num2)\n              return num1 - num2;\n          }\n          return a < b ? -1 : 1;\n        }\n      }\n\n      if (tokens1.length === tokens2.length)\n        return tokens1.length - tokens2.length;\n\n      return str1 < str2 ? -1 : 1;\n    },\n\n    levenshtein: function(str1, str2) {\n      if (str1 == null && str2 == null) return 0;\n      if (str1 == null) return String(str2).length;\n      if (str2 == null) return String(str1).length;\n\n      str1 = String(str1); str2 = String(str2);\n\n      var current = [], prev, value;\n\n      for (var i = 0; i <= str2.length; i++)\n        for (var j = 0; j <= str1.length; j++) {\n          if (i && j)\n            if (str1.charAt(j - 1) === str2.charAt(i - 1))\n              value = prev;\n            else\n              value = Math.min(current[j], current[j - 1], prev) + 1;\n          else\n            value = i + j;\n\n          prev = current[j];\n          current[j] = value;\n        }\n\n      return current.pop();\n    },\n\n    toBoolean: function(str, trueValues, falseValues) {\n      if (typeof str === \"number\") str = \"\" + str;\n      if (typeof str !== \"string\") return !!str;\n      str = _s.trim(str);\n      if (boolMatch(str, trueValues || [\"true\", \"1\"])) return true;\n      if (boolMatch(str, falseValues || [\"false\", \"0\"])) return false;\n    }\n  };\n\n  // Aliases\n\n  _s.strip    = _s.trim;\n  _s.lstrip   = _s.ltrim;\n  _s.rstrip   = _s.rtrim;\n  _s.center   = _s.lrpad;\n  _s.rjust    = _s.lpad;\n  _s.ljust    = _s.rpad;\n  _s.contains = _s.include;\n  _s.q        = _s.quote;\n  _s.toBool   = _s.toBoolean;\n\n  // Exporting\n\n  // CommonJS module is defined\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports)\n      module.exports = _s;\n\n    exports._s = _s;\n  }\n\n  // Register as a named module with AMD.\n  if (typeof define === 'function' && define.amd)\n    define('underscore.string', [], function(){ return _s; });\n\n\n  // Integrate with Underscore.js if defined\n  // or create our own underscore object.\n  root._ = root._ || {};\n  root._.string = root._.str = _s;\n}(this, String);\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails-util/cli.js":"\n/**\n * Module dependencies.\n */\n\nvar _\t\t\t= require('lodash'),\n\targv\t\t= require('optimist').argv;\n\n\n\n// Start building object to export\nvar util = {};\n\n\n/**\n * Expose `fs`, but monkey-patched to make sure existsSync()\n * doesn't crash older versions of Node\n *\n * @api private\n */\n\nvar fs = require('fs-extra');\nfs.existsSync = fs.existsSync || require('path').existsSync;\nutil.fs = fs;\n\n\n\n\n\n/**\n * Convert command-line arguments into configuration\n * options for the Sails core\n *\n * @param argv\n *\n * @api private\n */\n\nutil.getCLIConfig = function ( argv ) {\n\n\treturn {\n\t\t\n\t\t// `--silent` command-line argument\n\t\t// `--verbose` command-line argument\n\t\t// `--silly` command-line argument\n\t\tlog:\targv.verbose ? {level: 'verbose'} : \n\t\t\t\targv.silly ? {level: 'silly'} :\n\t\t\t\targv.silent ? {level: 'silent'} :\n\t\t\t\tundefined,\n\n\t\t// `--port=?` command-line argument\n\t\tport: argv.port || undefined,\n\n\t\t// `--prod` command-line argument\n\t\tenvironment: argv.prod ? 'production' : undefined\n\n\t};\n};\n\n\n\n\n/**\n * Methods which return a string with usage information\n * for the Sails CLI\n */\n\nutil.usage = {\n\n\tsails: function () {\n\t\tvar usage = 'Usage: sails <command>\\n\\n';\n\t\t// (if node_modules/sails exists, it will be used instead of the global install)\\n';\n\t\tusage += _tab('sails lift') + 'Run the Sails app in the current directory:\\n';\n\t\tusage += _tab('  [--prod]') + '  - in production mode \\n';\n\t\tusage += _tab('  [--port 3000]') + '  - on port 3000 \\n';\n\t\tusage += _tab('  [--verbose]') + '  - with verbose logging enabled \\n';\n\t\tusage += '\\n';\n\t\tusage += _tab('sails new <appName>') + 'Create a new Sails project in a folder called <appName>:\\n';\n\t\tusage += _tab('  [--no-linker]') + '  - disable auto-<link> of assets in HTML files via Grunt\\n';\n\t\tusage += '\\n';\n\t\tusage += _tab('sails generate model <foo>') + 'Generate a model (`api/models/Foo.js`)\\n';\n\t\tusage += _tab('sails generate controller <foo>') + 'Generate a controller (`api/controllers/FooController.js`)\\n';\n\t\tusage += _tab('sails generate <foo>') + 'Generate both.\\n';\n\t\tusage += _tab('  [--dry]') + 'Don\\'t actually create the module file.\\n';\n\t\tusage += '\\n';\n\t\tusage += _tab('sails console') + 'Run Sails in interactive mode (REPL)\\n';\n\t\tusage += _tab('sails version') + 'Get the current globally installed Sails version\\n';\n\t\tusage += _tab('sails run <command>') + 'Run a management command (exported by YOUR_APP/commands/index.js)';\n\n\t\treturn usage;\n\t},\n\n\n\tgenerate: {\n\t\tmodel: function () {\n\t\t\tvar usage = 'Usage:\\n';\n\t\t\tusage += 'sails generate model <foo> [attribute0Name:type] [attribute1Name:attribute1Type] [...]' + '\\n';\n\t\t\tusage += '\\n';\n\t\t\tusage += 'E.g., to generate api/models/Cockatiel.js:' + '\\n';\n\t\t\tusage += 'sails generate model cockatiel' + '\\n';\n\t\t\tusage += '\\n';\n\t\t\tusage += 'With some attributes:' + '\\n';\n\t\t\tusage += 'sails generate model cockatiel name:string weight:float birthdate:date color:string';\n\t\t}\n\t}\n};\n\n\n\n\n\n\n\n/**\n * Generate a file\n *\n * @api private\n */\n\nutil.generateFile = function(boilerplatePath, newPath) {\n\tvar fullBpPath = __dirname + '/boilerplates/' + (boilerplatePath || '');\n\tvar file = fs.readFileSync(fullBpPath, 'utf8');\n\tvar newFilePath = (newPath || '');\n\tutil.verifyDoesntExist(newFilePath, 'A file/directory already exists at ' + newFilePath);\n\n\t// Touch output file to make sure the path to it exists\n\tif (fs.createFileSync(newFilePath)) {\n\t\tlog.error('Could not create file, ' + newFilePath + '!');\n\t\tprocess.exit(1);\n\t}\n\tfs.writeFileSync(newFilePath, file);\n};\n\n\n\n/**\n * Generate a directory\n *\n * @api private\n */\n\nutil.generateDir = function(newPath, gitkeep) {\n\tif (!newPath) {\n\t\tlog.verbose('Creating directory in pwd...');\n\t} else {\n\t\tlog.verbose('Creating directory directory in ' + newPath + '...');\n\t}\n\tvar newDirPath = (newPath || '');\n\tutil.verifyDoesntExist(newDirPath, 'A file/directory already exists at ' + newDirPath);\n\tfs.mkdirSync(newDirPath);\n\t// If directory will be empty, create a .gitkeep in it\n\tif (gitkeep) {\n\t\tgenerateFile('.gitkeep', newPath + '/.gitkeep');\n\t}\n};\n\n\n/**\n * Verify that a file doesn't exist\n *\n * @api private\n */\n\nutil.verifyDoesntExist = function(path, msg) {\n\tif (util.fileExists(path)) {\n\t\tlog.error(msg);\n\t\tprocess.exit(1);\n\t}\n};\n\n\n\n/** \n * Check if a file or directory exists\n *\n * @api private\n */\n\nutil.fileExists = function(path) {\n\ttry {\n\t\t// Query the entry\n\t\tvar stats = fs.lstatSync(path);\n\n\t\t// Is it a directory?\n\t\tif (stats.isDirectory() || stats.isFile()) {\n\t\t\treturn true;\n\t\t}\n\t} catch (e) {\n\t\t// ...\n\t}\n\n\treturn false;\n};\n\n\n\n/** \n * Read an EJS template representing a Sails module,\n * then send back the return string.\n *\n * @api private\n */\n\n// util.renderBoilerplateTemplate = function(path, data) {\n// \tvar boilerplatePath = __dirname + '/boilerplates/templates/' + boilerplate;\n// \tutil.verifyExists(boilerplatePath, \"Boilerplate (\" + boilerplate + \") doesn't exist!\");\n// \tvar file = fs.readFileSync(boilerplatePath, 'utf8');\n// \treturn ejs.render(file, data);\n// };\n\n\n\n/** \n *\n *\n * @api private\n */\n\nutil.verifyExists = function(path, msg) {\n\tif (!util.fileExists(path)) {\n\t\tlog.error(msg);\n\t\tprocess.exit(1);\n\t}\n};\n\n\n\n/** \n * Copy a boilerplate directory or file\n *\n * @api private\n */\n\nutil.copyBoilerplate = function(boilerplate, destination, cb) {\n\tvar boilerplatePath = __dirname + '/boilerplates/' + boilerplate;\n\tfs.copy(boilerplatePath, destination, function(err) {\n\t\treturn cb && cb(err);\n\t});\n};\n\n\n\n/** \n * Copy global sails module into current project as a local dependency\n * (currently unusued)\n *\n * @api private\n */\n\nutil.copySails = function(destination, cb) {\n\ttry {\n\t\tfs.mkdirSync(destination);\n\t} catch (e) {\n\t\treturn cb && cb(e);\n\t}\n\n\t// Progress notifications\n\tvar stopShowingProgressNotifications,\n\t\terrorCopying,\n\t\tinterval = 150;\n\n\n\t// Draw progress notification\n\t// Returns progress function\n\tlog.verbose('Copying modules into ' + destination + '...');\n\tvar canvas = turtle();\n\n\tasync.until(\n\n\tfunction checkIfDone() {\n\t\tcanvas.tick();\n\t\treturn stopShowingProgressNotifications;\n\t},\n\n\tfunction setAlarm(cb) {\n\t\tsetTimeout(cb, interval);\n\t},\n\n\tfunction done(err) {\n\t\t// If an error occurred, send it back\n\t\terr = err || errorCopying;\n\t\treturn cb && cb(err);\n\t});\n\n\tasync.each(['lib', 'package.json', 'node_modules'], function(fileOrDir, cb) {\n\t\tfs.copy(__dirname + '/../' + fileOrDir, destination + '/' + fileOrDir, cb);\n\t}, function doneCopying(err) {\n\n\t\t// Hold onto error if there is one\n\t\terrorCopying = err;\n\n\t\t// When finished copying, mark done\n\t\t// progress notifications will trigger the callback\n\t\tstopShowingProgressNotifications = true;\n\t});\n};\n\n\n\n/** \n * Copy a core Sails dependency to the top-level node_modules directory\n * of the current application---- in a smart way\n *\n * @api private\n */\n\nutil.copySailsDependency = function(moduleName, pathToNewNodeModules, cb) {\n\tvar path = __dirname + '/../node_modules/' + moduleName;\n\tfs.copy(path, pathToNewNodeModules + '/' + moduleName, function(err) {\n\t\tif (err) return cb && cb(err);\n\n\t\t// Parse the module's package.json\n\t\tvar packageJSONPath = path + '/package.json';\n\t\tvar packageJSON;\n\t\ttry {\n\t\t\tpackageJSON = JSON.parse(fs.readFileSync(packageJSONPath, 'utf-8'));\n\t\t} catch (e) {\n\n\t\t\t// Ignore missing package.json\n\t\t\tpackageJSON = {\n\t\t\t\tdependencies: {}\n\t\t\t};\n\t\t}\n\n\t\t// Get actual dependencies in this module's node_modules directory\n\t\tvar dependencies;\n\t\ttry {\n\t\t\tdependencies = fs.readdirSync(path + '/node_modules');\n\n\t\t\t// Remove hidden files\n\t\t\t_.without(dependencies, function(val) {\n\t\t\t\treturn val.match(/\\..+/);\n\t\t\t});\n\t\t} catch (e) {\n\t\t\t// Assume empty dependencies\n\t\t\tdependencies = {};\n\t\t}\n\n\t\t// If there are any missing dependencies which are being pulled from Sails,\n\t\t// copy them from Sails' main node_modules directory\n\t\tvar missingModules = _.difference(_.keys(packageJSON.dependencies || {}), _.values(dependencies));\n\t\t_.each(missingModules, function(missingModuleName) {\n\t\t\tlog.verbose('Resolving ' + moduleName + '\\'s missing dependency (' + missingModuleName + ') using the version in Sails.');\n\t\t\tutil.copySailsDependency(missingModuleName, pathToNewNodeModules + '/' + moduleName + '/node_modules/');\n\t\t});\n\n\t\treturn cb && cb(err);\n\t});\n};\n\n\n\n\n/**\n * Return a tabbed-over version of the string,\n * adjusting for spacing\n *\n * @api private\n */\nfunction _tab (str) {\n\tvar n = (33 - str.length);\n\treturn str + _.str.repeat(' ', n);\n}\n\n\n\n// Export `util` object\nmodule.exports = _.cloneDeep(util);\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/bin/sails.js":"#!/usr/bin/env node\n\n\n/**\n * Module dependencies\n */\n\nvar _ = require('@sailshq/lodash');\nvar program = require('./_commander');\nvar package = require('../package.json');\nvar NOOP = function() {};\n\n\n\nprogram\n  .version(package.version, '-v, --version');\n\n\n//\n// Normalize version argument, i.e.\n//\n// $ sails -v\n// $ sails -V\n// $ sails --version\n// $ sails version\n//\n\n\n// make `-v` option case-insensitive\nprocess.argv = _.map(process.argv, function(arg) {\n  return (arg === '-V') ? '-v' : arg;\n});\n\n\n// $ sails version (--version synonym)\nprogram\n  .command('version')\n  .description('')\n  .action(program.versionInformation);\n\n\n\nprogram\n  .option('--silent')\n  .option('--verbose')\n  .option('--silly')\n  .unknownOption = NOOP;\nprogram.usage('[command]');\n\n\n// $ sails lift\nvar cmd;\ncmd = program.command('lift');\ncmd.option('--prod');\ncmd.option('--port [port]');\ncmd.unknownOption = NOOP;\ncmd.description('');\ncmd.alias('l');\ncmd.action(require('./sails-lift'));\n\n\n// $ sails new <appname>\ncmd = program.command('new [path_to_new_app]');\n// cmd.option('--dry');\ncmd.option('--viewEngine [viewEngine]');\ncmd.option('--template [viewEngine]');\ncmd.usage('[path_to_new_app]');\ncmd.unknownOption = NOOP;\ncmd.action(require('./sails-new'));\n\n\n// $ sails generate <module>\ncmd = program.command('generate');\n// cmd.option('--dry');\ncmd.unknownOption = NOOP;\ncmd.description('');\ncmd.usage('[something]');\ncmd.action(require('./sails-generate'));\n\n// $ sails deploy\ncmd = program.command('deploy');\n// cmd.option('--dry');\ncmd.unknownOption = NOOP;\ncmd.description('');\ncmd.usage('');\ncmd.action(require('./sails-deploy'));\n\n\n// $ sails console\ncmd = program.command('console');\ncmd.unknownOption = NOOP;\ncmd.description('');\ncmd.alias('c');\ncmd.action(require('./sails-console'));\n\n\n// $ sails www\n// Compile `assets` directory into a standalone `www` folder.\ncmd = program.command('www');\ncmd.unknownOption = NOOP;\ncmd.description('');\ncmd.action(require('./sails-www'));\n\n\n\n// $ sails debug\ncmd = program.command('debug');\ncmd.unknownOption = NOOP;\ncmd.description('');\ncmd.action(require('./sails-debug'));\n\n\n\n//\n// Normalize help argument, i.e.\n//\n// $ sails --help\n// $ sails help\n// $ sails\n// $ sails <unrecognized_cmd>\n//\n\n\n// $ sails help (--help synonym)\ncmd = program.command('help');\ncmd.description('');\ncmd.action(program.usageMinusWildcard);\n\n\n\n// $ sails <unrecognized_cmd>\n// Mask the '*' in `help`.\nprogram\n  .command('*')\n  .action(program.usageMinusWildcard);\n\n\n\n// Don't balk at unknown options\nprogram.unknownOption = NOOP;\n\n\n\n// $ sails\n//\nprogram.parse(process.argv);\nvar NO_COMMAND_SPECIFIED = program.args.length === 0;\nif (NO_COMMAND_SPECIFIED) {\n  program.usageMinusWildcard();\n}\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/bin/_commander.js":"/**\n * Module dependencies\n */\n\nvar _ = require('@sailshq/lodash');\nvar program = require('commander');\n\n\n//\n//\n// Monkey-patch commander\n//\n//\n\n// Allow us to display help(), but omit the wildcard (*) command.\nprogram.Command.prototype.usageMinusWildcard = program.usageMinusWildcard = function() {\n  program.commands = _.reject(program.commands, {\n    _name: '*'\n  });\n  program.help();\n};\n\n// Force commander to display version information.\nprogram.Command.prototype.versionInformation = program.versionInformation = function() {\n  program.emit('version');\n};\n\nmodule.exports = program;\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/bin/sails-lift.js":"#!/usr/bin/env node\n\n\n/**\n * Module dependencies\n */\n\nvar nodepath = require('path');\nvar _ = require('@sailshq/lodash');\nvar chalk = require('chalk');\nvar captains = require('captains-log');\nvar package = require('../package.json');\nvar rconf = require('../lib/app/configuration/rc');\nvar Sails = require('../lib/app');\n\n\n\n/**\n * `sails lift`\n *\n * Expose method which lifts the appropriate instance of Sails.\n * (Fire up the Sails app in our working directory.)\n *\n * @stability 3\n * @see http://sailsjs.org/documentation/reference/command-line-interface/sails-lift\n */\n\nmodule.exports = function() {\n\n  // console.time('cli_lift');\n  // console.time('cli_prelift');\n\n  // console.time('cli_rc');\n  var log = captains(rconf.log);\n  // console.timeEnd('cli_rc');\n\n  console.log();\n  log.info(chalk.grey('Starting app...'));\n  console.log();\n\n  // Build initial scope, mixing-in rc config\n  var scope = _.merge({\n    rootPath: process.cwd(),\n    sailsPackageJSON: package\n  }, rconf);\n\n  var appPath = process.cwd();\n\n  // Use the app's local Sails in `node_modules` if it's extant and valid\n  var localSailsPath = nodepath.resolve(appPath, 'node_modules/sails');\n  if (Sails.isLocalSailsValid(localSailsPath, appPath)) {\n    var localSails = require(localSailsPath);\n    // console.timeEnd('cli_prelift');\n\n    localSails.lift(scope, afterwards);\n    return;\n  }\n\n  // Otherwise, if no workable local Sails exists, run the app\n  // using the currently running version of Sails.  This is\n  // probably always the global install.\n  var globalSails = Sails();\n  // console.timeEnd('cli_prelift');\n\n  globalSails.lift(scope, afterwards);\n\n\n  function afterwards (err, sails) {\n    if (err) {\n      var message = err.stack ? err.stack : err;\n      sails ? sails.log.error(message) : log.error(message); process.exit(1);\n    }\n    // try {console.timeEnd('cli_lift');}catch(e){}\n  }\n};\n\n\n\n\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/app/configuration/rc.js":"/**\n * Module dependencies\n */\n\nvar rc = require('rc');\n\n\n/**\n * Locate and load a .sailsrc file if one exists.\n *\n * NOTE: this occurs almost immediately when sails is required,\n * and since `rc` is synchronous, the examination of env variables,\n * cmdline opts, and .sailsrc files is immediate, and happens only once.\n *\n * @type {Object}\n */\nmodule.exports = rc('sails');\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/bin/sails-console.js":"#!/usr/bin/env node\n\n\n/**\n * Module dependencies\n */\n\nvar nodepath = require('path');\nvar REPL = require('repl');\nvar fs = require('fs');\nvar _ = require('@sailshq/lodash');\nvar chalk = require('chalk');\nvar CaptainsLog = require('captains-log');\nvar Sails = require('../lib/app');\nvar rconf = require('../lib/app/configuration/rc');\nvar Err = require('../errors');\nvar package = require('../package.json');\n\n\n\n/**\n * `sails console`\n *\n * Enter the interactive console (aka REPL) for the app\n * in our working directory.  This is just like the default\n * Node REPL except that it starts with the Sails app in the\n * current directory lifted, and with console history enabled\n * (i.e. so you can press up arrow to browse and potentially\n *  replay commands from past runs)\n *\n * @stability 3\n * @see http://sailsjs.org/documentation/reference/command-line-interface/sails-console\n * ------------------------------------------------------------------------\n * This lifts the Sails app in the current working directory, then uses\n * the `repl` package to spin up an interactive console.\n *\n * Note that, if `--dontLift` was set, then `sails.load()` will be used\n * instead. (By default, the `sails console` cmd runs `sails.lift()`.)\n * ------------------------------------------------------------------------\n */\n\nmodule.exports = function() {\n\n  // Get a logger\n  var log = CaptainsLog(rconf.log);\n\n  // Build initial scope, mixing-in rc config\n  var scope = _.merge({\n    rootPath: process.cwd(),\n    sailsPackageJSON: package\n  }, rconf, {\n\n    // Disable ASCII ship to keep from dirtying things up\n    log: {\n      noShip: true\n    }\n  });\n\n  // Assume the current working directory to be the root of the app\n  var appPath = process.cwd();\n\n  // Determine whether to use the local or global Sails install.\n  var sailsApp = (function _determineAppropriateSailsAppInstance(){\n    // Use the app's local Sails in `node_modules` if it's extant and valid\n    var localSailsPath = nodepath.resolve(appPath, 'node_modules/sails');\n    if (Sails.isLocalSailsValid(localSailsPath, appPath)) {\n      return require(localSailsPath);\n    } else {\n      // Otherwise, if no workable local Sails exists, run the app\n      // using the currently running version of Sails.  This is\n      // probably always the global install.\n      log.info('No local Sails install detected; using globally-installed Sails.');\n      return Sails();\n    }\n  })();\n\n  console.log();\n  log.info(chalk.blue('Starting app in interactive mode...'));\n  console.log();\n\n\n  // Lift (or load) Sails\n  (function _ifThenFinally(done){\n    // If `--dontLift` was set, then use `.load()` instead.\n    if (!_.isUndefined(scope.dontLift)) {\n      sailsApp.load(scope, done);\n    }\n    // Otherwise, go with the default behavior (`.lift()`)\n    else {\n      sailsApp.lift(scope, done);\n    }\n  })(function afterwards(err){\n    if (err) {\n      return Err.fatal.failedToLoadSails(err);\n    }\n\n    log.info('Welcome to the Sails console.');\n    log.info(chalk.grey('( to exit, type ' + '<CTRL>+<C>' + ' )'));\n    console.log();\n\n    // Start a REPL\n    var repl = REPL.start({prompt: 'sails> ', useGlobal: true});\n    try {\n      history(repl, nodepath.join(sails.config.paths.tmp, '.node_history'));\n    } catch (e) {\n      log.verbose('Console history cannot be found.  Proceeding without it. This is due to error:', e);\n    }\n    repl.on('exit', function(err) {\n      if (err) {\n        log.error(err);\n        process.exit(1);\n      }\n      process.exit(0);\n    });\n\n  });//</_ifThenFinally()>\n};\n\n\n\n\n\n\n/**\n * REPL History\n * Pulled directly from https://github.com/tmpvar/repl.history\n * with the slight tweak of setting historyIndex to -1 so that\n * it works as expected.\n */\n\nfunction history(repl, file) {\n\n  try {\n    var stat = fs.statSync(file);\n    repl.rli.history = fs.readFileSync(file, 'utf-8').split('\\n').reverse();\n    repl.rli.history.shift();\n    repl.rli.historyIndex = -1;\n  } catch (e) {}\n\n  var fd = fs.openSync(file, 'a'),\n    reval = repl.eval;\n\n  repl.rli.addListener('line', function(code) {\n    if (code && code !== '.history') {\n      fs.write(fd, code + '\\n');\n    } else {\n      repl.rli.historyIndex++;\n      repl.rli.history.pop();\n    }\n  });\n\n  process.on('exit', function() {\n    fs.closeSync(fd);\n  });\n\n  repl.commands['.history'] = {\n    help: 'Show the history',\n    action: function() {\n      var out = [];\n      repl.rli.history.forEach(function(v, k) {\n        out.push(v);\n      });\n      repl.outputStream.write(out.reverse().join('\\n') + '\\n');\n      repl.displayPrompt();\n    }\n  };\n}\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/bin/sails-debug.js":"#!/usr/bin/env node\n\n\n/**\n * Module dependencies\n */\n\nvar path = require('path');\nvar Womb = require('child_process');\nvar CaptainsLog = require('captains-log');\nvar chalk = require('chalk');\nvar Sails = require('../lib/app');\n\n\n/**\n * `sails debug`\n *\n * Attach the Node debugger and lift a Sails app.\n * You can then use Node inspector to debug your app as it runs.\n *\n * @stability 2\n * @see http://sailsjs.org/documentation/reference/command-line-interface/sails-debug\n */\nmodule.exports = function() {\n  var log = CaptainsLog();\n\n  // Use the app's local Sails in `node_modules` if one exists\n  // But first make sure it'll work...\n  var appPath = process.cwd();\n  var pathToSails = path.resolve(appPath, '/node_modules/sails');\n  if (!Sails.isLocalSailsValid(pathToSails, appPath)) {\n    // otherwise, use the currently-running instance of Sails\n    pathToSails = path.resolve(__dirname, './sails.js');\n  }\n\n  console.log();\n  log.info('Running app in debug mode...');\n\n  // Check whether node-inspector is running\n  Womb.exec('ps', function(error, stdout, stderr) {\n\n    // If not, suggest that they run it\n    if (error || stderr || !stdout.toString().match(/node-inspector/)) {\n      log.info('You probably want to install / run node-inspector to help with debugging!');\n      log.info('https://github.com/node-inspector/node-inspector');\n      console.log();\n    }\n\n    log.info(chalk.grey('( to exit, type ' + '<CTRL>+<C>' + ' )'));\n    console.log();\n\n    // Spin up child process for Sails\n    Womb.spawn('node', ['--debug', pathToSails, 'lift'], {\n      stdio: 'inherit'\n    });\n  });\n\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/bin/sails-deploy.js":"#!/usr/bin/env node\n\n\n/**\n * Module dependencies\n */\n\nvar _ = require('@sailshq/lodash');\nvar util = require('util');\nvar path = require('path');\nvar rconf = require('../lib/app/configuration/rc');\n\n/**\n * `sails deploy`\n *\n * Deploy the Sails app in the current directory to a hosting provider.\n *\n * @stability 1\n */\n\nmodule.exports = function() {\n\n  var commands = rconf.commands;\n  var deploy = commands && commands.deploy;\n  var modulePath = deploy && deploy.module;\n  var module;\n\n  // If no module path was specified, bail out\n  if (!modulePath) {\n    console.error('No module specified for the `deploy` command.');\n    console.error('To use `sails deploy`, set a `commands.deploy.module` setting in your .sailsrc file');\n    return;\n  }\n\n  // Attempt to require the specified module from the project node_modules folder\n  try {\n    module = require(path.resolve(process.cwd(), 'node_modules', modulePath));\n  }\n\n  // If the module couldn't be required, bail out\n  catch (e) {\n    console.error('Could not require module at path: ' + modulePath + '.  Please check the path and try again.');\n  }\n\n  try {\n    // Attempt to run the deploy command\n    module({config: rconf}, function(err, result) {\n      // If there were any issues, log them to the console.\n      if (err) {\n        console.error('=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-');\n        console.error('Deployment failed!  Details below:');\n        console.error('=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-');\n        console.error(err);\n      }\n    });\n  }\n  // Chances are we won't catch any errors internal to the deploy command here;\n  // this would probably be an error at the top level of the deploy script.\n  catch(e) {\n    console.error('=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-');\n    console.error('Could not run deploy!  Details below:');\n    console.error('=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-');\n    console.error(e);\n  }\n\n\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/bin/sails-generate.js":"#!/usr/bin/env node\n\n\n/**\n * Module dependencies\n */\n\nvar _ = require('@sailshq/lodash');\nvar util = require('util');\nvar path = require('path');\nvar async = require('async');\nvar reportback = require('reportback')();\nvar sailsgen = require('sails-generate');\nvar package = require('../package.json');\nvar rconf = require('../lib/app/configuration/rc');\n\n\n/**\n * `sails generate`\n *\n * Generate one or more file(s) in our working directory.\n * This runs an appropriate generator.\n *\n * @stability 2\n * @see http://sailsjs.org/documentation/reference/command-line-interface/sails-generate\n */\n\nmodule.exports = function() {\n\n  // Build initial scope\n  var scope = {\n    rootPath: process.cwd(),\n    sailsRoot: path.resolve(__dirname, '..'),\n    modules: {},\n    sailsPackageJSON: package,\n  };\n\n  // Mix-in rc config\n  _.merge(scope, rconf.generators);\n\n  // TODO: just do a top-level merge and reference\n  // `scope.generators.modules` as needed (simpler)\n  _.merge(scope, rconf);\n\n\n  // Pass the original CLI arguments down to the generator\n  // (but first, remove commander's extra argument)\n  // (also peel off the `generatorType` arg)\n  var cliArguments = _.initial(arguments);\n  scope.generatorType = cliArguments.shift();\n  scope.args = cliArguments;\n\n  // Create a new reportback\n  var cb = reportback.extend();\n\n  // Show usage if no generator type is defined\n  if (!scope.generatorType) {\n    return cb.log.error('Usage: sails generate [something]');\n  }\n\n  // Set the \"invalid\" exit to forward to \"error\"\n  cb.error = function(msg) {\n    var log = this.log || cb.log;\n    log.error(msg);\n    process.exit(1);\n  };\n\n  cb.invalid = 'error';\n\n  cb.success = function() {\n\n    // Infer the `outputPath` if necessary/possible.\n    if (!scope.outputPath && scope.filename && scope.destDir) {\n      scope.outputPath = scope.destDir + scope.filename;\n    }\n\n    // Humanize the output path\n    var humanizedPath;\n    if (scope.outputPath) {\n      humanizedPath = ' at ' + scope.outputPath;\n    }\n    else if (scope.destDir) {\n      humanizedPath = ' in ' + scope.destDir;\n    }\n    else {\n      humanizedPath = '';\n    }\n\n    // Humanize the module identity\n    var humanizedId;\n    if (scope.id) {\n      humanizedId = util.format(' (\"%s\")',scope.id);\n    }\n    else humanizedId = '';\n\n    if (scope.generatorType != 'new') {\n\n      cb.log.info(util.format(\n        'Created a new %s%s%s!',\n        scope.generatorType, humanizedId, humanizedPath\n      ));\n\n    }\n\n  };\n\n  return sailsgen(scope, cb);\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/bin/sails-new.js":"#!/usr/bin/env node\n\n\n/**\n * Module dependencies\n */\n\nvar nodepath = require('path');\nvar _ = require('@sailshq/lodash');\nvar sailsgen = require('sails-generate');\nvar package = require('../package.json');\nvar rconf = require('../lib/app/configuration/rc');\n\n\n\n/**\n * `sails new`\n *\n * Generate a new Sails app.\n *\n * ```\n * # In the current directory:\n * sails new\n * ```\n *\n * ```\n * # As a new directory or within an existing directory:\n * sails new foo\n * ```\n *\n * @stability 3\n * @see http://sailsjs.org/documentation/reference/command-line-interface/sails-new\n * ------------------------------------------------------------------------\n * This command builds `scope` for the generator by scooping up any available\n * configuration using `rc` (merging config from env vars, CLI opts, and\n * relevant `.sailsrc` files).  Then it runs the `sails-generate-new`\n * generator (https://github.com/balderdashy/sails-generate-new).\n */\n\nmodule.exports = function () {\n\n  // Build initial scope\n  var scope = {\n    rootPath: process.cwd(),\n    modules: {},\n    sailsRoot: nodepath.resolve(__dirname, '..'),\n    sailsPackageJSON: package,\n    viewEngine: rconf.viewEngine\n  };\n\n  // Support --template option for backwards-compat.\n  if (!scope.viewEngine && rconf.template) {\n    scope.viewEngine = rconf.template;\n  }\n\n  // Mix-in rconf\n  _.merge(scope, rconf.generators);\n\n  // TODO: just do a top-level merge and reference\n  // `scope.generators.modules` as needed (simpler)\n  _.merge(scope, rconf);\n\n\n  // Pass the original CLI arguments down to the generator\n  // (but first, remove commander's extra argument)\n  var cliArguments = Array.prototype.slice.call(arguments);\n  cliArguments.pop();\n  scope.args = cliArguments;\n\n  scope.generatorType = 'new';\n\n  return sailsgen(scope, {\n    success: function() {}\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails-generate/lib/index.js":"/**\n * Module dependencies\n */\n\nvar generate = require('./generate');\nvar path = require('path');\nvar reportback = require('reportback')();\n\n\n\n/**\n * Generate module(s)\n *\n * @param  {Object}   scope [description]\n * @param  {Function} cb    [description]\n * @return {[type]}         [description]\n */\nmodule.exports = function(scope, cb) {\n  cb = cb || {};\n  cb = reportback.extend(cb, {\n    error: cb.error,\n    invalid: cb.invalid,\n    success: function(output) {\n      cb.log.info('ok!');\n    },\n    notSailsApp: function() {\n      cb.log.error('Not a sails app.');\n    },\n    alreadyExists: function() {\n      return cb.error();\n    }\n  });\n\n  if (!scope.generatorType) {\n    return cb.error('Sorry, `scope.generatorType` must be defined.');\n  }\n\n  // Use configured module name for this generatorType if applicable.\n  var module =\n    (scope.modules && scope.modules[scope.generatorType]) ||\n    'sails-generate-' + scope.generatorType;\n\n  var Generator;\n  var requirePath;\n  var requireError;\n\n  function throwIfModuleNotFoundError (e, module) {\n    var isModuleNotFoundError = e && e.code === 'MODULE_NOT_FOUND' && e.message.match(new RegExp(module));\n    if (!isModuleNotFoundError) {\n      cb.log.error('Error in \"'+scope.generatorType+'\" generator (loaded from '+module+')');\n      throw e;\n    }\n    else return e;\n  }\n\n\n  // Allow `scope.generator` to be specified as an inline generator\n  // ... todo ...\n\n  // Try requiring from node_modules\n  try {\n    Generator = require(module);\n  } catch (e) {\n    requireError = throwIfModuleNotFoundError(e, module);\n  }\n\n  // Try requiring it directly as a path resolved from process.cwd()\n  if (!Generator) {\n    try {\n      requirePath = path.resolve(process.cwd(), module);\n      Generator = require(requirePath);\n    } catch (e) {\n      requireError = throwIfModuleNotFoundError(e, module);\n    }\n  }\n\n\n  // Try requiring the generator from the rootPath\n  if (!Generator) {\n    try {\n      requirePath = path.resolve(scope.rootPath, 'node_modules', module);\n      Generator = require(requirePath);\n    } catch (e) {\n      requireError = throwIfModuleNotFoundError(e, module);\n    }\n  }\n\n  // If that doesn't work, try `require()`ing it from console user's cwd\n  if (!Generator) {\n    try {\n      requirePath = path.resolve(process.cwd(), 'node_modules', module);\n      Generator = require(requirePath);\n    } catch (e) {\n      requireError = throwIfModuleNotFoundError(e, module);\n    }\n  }\n\n  // Finally, try to load the generator module from sails-generate's dependencies\n  if (!Generator) {\n    try {\n      Generator = require(path.resolve(scope.rootPath || process.cwd(), module));\n    } catch (e) {\n      requireError = throwIfModuleNotFoundError(e, module);\n    }\n  }\n\n\n  if (!Generator) {\n    return cb.log.error(\"No generator called `\" + scope.generatorType + \"` found; perhaps you meant `sails generate api \" + scope.generatorType + \"`?\");\n  }\n\n  generate(Generator, scope, cb);\n\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails-generate/lib/generate.js":"/**\n * Module dependencies\n */\n\nvar util = require('util');\nvar _ = require('lodash');\n_.defaults = require('merge-defaults');\nvar async = require('async');\nvar path = require('path');\nvar reportback = require('reportback')();\nvar pathRegexp = require('./util').pathRegexp;\nvar rootGenerator = require('./rootGenerator');\nvar rootScope = require('./rootScope');\nvar generateTarget = require('./target');\n\n\n\n/**\n * Run a generator given an existing scope.\n *\n * @param  {Object} Generator\n * @param  {Object} scope\n * @param  {Switchback} cb\n */\n\nfunction generate(Generator, scope, cb) {\n\n  var sb = reportback.extend(cb, {\n    error: cb.error,\n    invalid: cb.invalid,\n    alreadyExists: 'error'\n  });\n\n  // Merge with root scope\n  _.defaults(scope, rootScope);\n\n  // TODO: validate args more thoroughly\n  if (!_.isArray(scope.args)) {\n    return sb(new Error('Invalid `scope.args` passed to generator: ' + util.inspect(scope.args)));\n  }\n\n  // Ensure that `rootPath` exists\n  // TODO: Ensure that `rootPath` is reasonable\n  // (i.e. within highest acceptable path-- prevents accidental smashing of file-system, etc.)\n  if (!scope.rootPath) {\n    return sb(new Error('Invalid `scope.rootPath` passed to generator: ' + util.inspect(scope.rootPath)));\n  }\n\n  // TODO: deprecate this:\n  //\n  // Alias first handful of arguments on scope object\n  // for easy access and use as :params in `targets` keys\n  // _.defaults(scope, {\n  // \targ0: scope.args[0],\n  // \targ1: scope.args[1],\n  // \targ2: scope.args[2],\n  // \targ3: scope.args[3]\n  // });\n\n  // Resolve string shorthand for generator defs\n  // to `{ generator: 'originalDef' }`\n  if (typeof Generator === 'string') {\n    var generatorName = Generator;\n    Generator = {\n      generator: generatorName\n    };\n  }\n\n  // Merge with root generator\n  _.defaults(Generator, rootGenerator);\n\n  // Run the generator's `before()` method proceeding\n  Generator.before(scope, reportback.extend({\n    error: sb.error,\n    invalid: sb.invalid,\n    success: function() {\n\n      // Emit output\n      sb.log.verbose('Generating ' + util.inspect(Generator) + ' at ' + scope.rootPath + '...');\n\n      // Process all of the generator's targets concurrently\n      async.each(Object.keys(Generator.targets), function(keyPath, async_each_cb) {\n          var async_each_sb = reportback.extend(async_each_cb);\n\n\n          // Create a new scope object for this target,\n          // with references to the important bits of the original.\n          // (depth will be passed-by-value, but that's what we want)\n          //\n          // Then generate the target, passing along a reference to\n          // the base `generate` method to allow for recursive generators.\n          var target = Generator.targets[keyPath];\n          if (!target) return async_each_sb(new Error('Generator error: Invalid target: {\"' + keyPath + '\": ' + util.inspect(target) + '}'));\n\n          // Input tolerance\n          if (keyPath === '') keyPath = '.';\n\n          // Interpret `keyPath` using express's parameterized route conventions,\n          // first parsing params, then replacing them with their proper values from scope.\n          var params = [];\n          pathRegexp(keyPath, params);\n          var err;\n          var parsedKeyPath = _.reduce(params, function(memoKeyPath, param, i) {\n            if (err) return false;\n\n            try {\n              var paramMatchExpr = ':' + param.name;\n              var actualParamValue = scope[param.name];\n              if (!actualParamValue) {\n                err = new Error(\n                  'Generator error:\\n' +\n                  'A scope variable (`' + param.name + '`) was referenced in target: `' + memoKeyPath + '`,\\n' +\n                  'but `' + param.name + '` does not exist in the generator\\'s scope.'\n                );\n                return false;\n              }\n              actualParamValue = String(actualParamValue);\n\n              return memoKeyPath.replace(paramMatchExpr, actualParamValue);\n            } catch (e) {\n              err = new Error('Generator error: Could not parse target key: ' + memoKeyPath);\n              err.message = e;\n              return false;\n            }\n          }, keyPath);\n          if (!parsedKeyPath) return async_each_sb(err);\n\n          // Create path from `rootPath` to `keyPath` to use as the `rootPath`\n          // for any generators or helpers in this target.\n          // (use a copy so that child generators don't mutate the scope)\n          var targetScope = _.merge({}, scope, {\n            rootPath: path.resolve(scope.rootPath, parsedKeyPath),\n            // Include reference to original keypath for error reporting\n            keyPath: keyPath\n          });\n\n\n\n          // If `target` is an array, run each item\n          if (_.isArray(target)) {\n            async.eachSeries(target, function(targetItem, async_eachSeries_cb) {\n\n              generateTarget({\n                target: targetItem,\n                parent: Generator,\n                scope: _.cloneDeep(targetScope),\n                recursiveGenerate: generate\n              }, async_eachSeries_cb);\n\n            }, async_each_sb);\n            return;\n          }\n\n          // Otherwise, just run the single target generator/helper\n          generateTarget({\n            target: target,\n            parent: Generator,\n            scope: targetScope,\n            recursiveGenerate: generate\n          }, async_each_sb);\n\n        }, // </async.each.iterator>\n\n        function done(err) {\n\n          // Expose a `error` handler in generators\n          if (err) {\n            var errorFn = Generator.error || function defaultError(err, scope, _cb) {\n                return _cb(err);\n              };\n            return errorFn(err, scope, sb);\n          }\n\n          // Expose a `after` handler in generators (on success only)\n          var afterFn = Generator.after || function defaultAfter(scope, _cb) {\n              return _cb();\n            };\n          return afterFn(scope, sb);\n\n        }); // </async.each>\n\n    } // </Generator.before -> success>\n  })); // </Generator.before>\n}\n\n\nmodule.exports = generate;\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails-generate/node_modules/lodash/dist/lodash.js":"/**\n * @license\n * Lo-Dash 2.4.2 (Custom Build) <https://lodash.com/>\n * Build: `lodash modern -o ./dist/lodash.js`\n * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <https://lodash.com/license>\n */\n;(function() {\n\n  /** Used as a safe reference for `undefined` in pre ES5 environments */\n  var undefined;\n\n  /** Used to pool arrays and objects used internally */\n  var arrayPool = [],\n      objectPool = [];\n\n  /** Used to generate unique IDs */\n  var idCounter = 0;\n\n  /** Used to prefix keys to avoid issues with `__proto__` and properties on `Object.prototype` */\n  var keyPrefix = +new Date + '';\n\n  /** Used as the size when optimizations are enabled for large arrays */\n  var largeArraySize = 75;\n\n  /** Used as the max size of the `arrayPool` and `objectPool` */\n  var maxPoolSize = 40;\n\n  /** Used to detect and test whitespace */\n  var whitespace = (\n    // whitespace\n    ' \\t\\x0B\\f\\xA0\\ufeff' +\n\n    // line terminators\n    '\\n\\r\\u2028\\u2029' +\n\n    // unicode category \"Zs\" space separators\n    '\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000'\n  );\n\n  /** Used to match empty string literals in compiled template source */\n  var reEmptyStringLeading = /\\b__p \\+= '';/g,\n      reEmptyStringMiddle = /\\b(__p \\+=) '' \\+/g,\n      reEmptyStringTrailing = /(__e\\(.*?\\)|\\b__t\\)) \\+\\n'';/g;\n\n  /**\n   * Used to match ES6 template delimiters\n   * http://people.mozilla.org/~jorendorff/es6-draft.html#sec-literals-string-literals\n   */\n  var reEsTemplate = /\\$\\{([^\\\\}]*(?:\\\\.[^\\\\}]*)*)\\}/g;\n\n  /** Used to match regexp flags from their coerced string values */\n  var reFlags = /\\w*$/;\n\n  /** Used to detected named functions */\n  var reFuncName = /^\\s*function[ \\n\\r\\t]+\\w/;\n\n  /** Used to match \"interpolate\" template delimiters */\n  var reInterpolate = /<%=([\\s\\S]+?)%>/g;\n\n  /** Used to match leading whitespace and zeros to be removed */\n  var reLeadingSpacesAndZeros = RegExp('^[' + whitespace + ']*0+(?=.$)');\n\n  /** Used to ensure capturing order of template delimiters */\n  var reNoMatch = /($^)/;\n\n  /** Used to detect functions containing a `this` reference */\n  var reThis = /\\bthis\\b/;\n\n  /** Used to match unescaped characters in compiled string literals */\n  var reUnescapedString = /['\\n\\r\\t\\u2028\\u2029\\\\]/g;\n\n  /** Used to assign default `context` object properties */\n  var contextProps = [\n    'Array', 'Boolean', 'Date', 'Function', 'Math', 'Number', 'Object',\n    'RegExp', 'String', '_', 'attachEvent', 'clearTimeout', 'isFinite', 'isNaN',\n    'parseInt', 'setTimeout'\n  ];\n\n  /** Used to make template sourceURLs easier to identify */\n  var templateCounter = 0;\n\n  /** `Object#toString` result shortcuts */\n  var argsClass = '[object Arguments]',\n      arrayClass = '[object Array]',\n      boolClass = '[object Boolean]',\n      dateClass = '[object Date]',\n      funcClass = '[object Function]',\n      numberClass = '[object Number]',\n      objectClass = '[object Object]',\n      regexpClass = '[object RegExp]',\n      stringClass = '[object String]';\n\n  /** Used to identify object classifications that `_.clone` supports */\n  var cloneableClasses = {};\n  cloneableClasses[funcClass] = false;\n  cloneableClasses[argsClass] = cloneableClasses[arrayClass] =\n  cloneableClasses[boolClass] = cloneableClasses[dateClass] =\n  cloneableClasses[numberClass] = cloneableClasses[objectClass] =\n  cloneableClasses[regexpClass] = cloneableClasses[stringClass] = true;\n\n  /** Used as an internal `_.debounce` options object */\n  var debounceOptions = {\n    'leading': false,\n    'maxWait': 0,\n    'trailing': false\n  };\n\n  /** Used as the property descriptor for `__bindData__` */\n  var descriptor = {\n    'configurable': false,\n    'enumerable': false,\n    'value': null,\n    'writable': false\n  };\n\n  /** Used to determine if values are of the language type Object */\n  var objectTypes = {\n    'boolean': false,\n    'function': true,\n    'object': true,\n    'number': false,\n    'string': false,\n    'undefined': false\n  };\n\n  /** Used to escape characters for inclusion in compiled string literals */\n  var stringEscapes = {\n    '\\\\': '\\\\',\n    \"'\": \"'\",\n    '\\n': 'n',\n    '\\r': 'r',\n    '\\t': 't',\n    '\\u2028': 'u2028',\n    '\\u2029': 'u2029'\n  };\n\n  /** Used as a reference to the global object */\n  var root = (objectTypes[typeof window] && window) || this;\n\n  /** Detect free variable `exports` */\n  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;\n\n  /** Detect free variable `module` */\n  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;\n\n  /** Detect the popular CommonJS extension `module.exports` */\n  var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;\n\n  /** Detect free variable `global` from Node.js or Browserified code and use it as `root` */\n  var freeGlobal = objectTypes[typeof global] && global;\n  if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {\n    root = freeGlobal;\n  }\n\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * The base implementation of `_.indexOf` without support for binary searches\n   * or `fromIndex` constraints.\n   *\n   * @private\n   * @param {Array} array The array to search.\n   * @param {*} value The value to search for.\n   * @param {number} [fromIndex=0] The index to search from.\n   * @returns {number} Returns the index of the matched value or `-1`.\n   */\n  function baseIndexOf(array, value, fromIndex) {\n    var index = (fromIndex || 0) - 1,\n        length = array ? array.length : 0;\n\n    while (++index < length) {\n      if (array[index] === value) {\n        return index;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * An implementation of `_.contains` for cache objects that mimics the return\n   * signature of `_.indexOf` by returning `0` if the value is found, else `-1`.\n   *\n   * @private\n   * @param {Object} cache The cache object to inspect.\n   * @param {*} value The value to search for.\n   * @returns {number} Returns `0` if `value` is found, else `-1`.\n   */\n  function cacheIndexOf(cache, value) {\n    var type = typeof value;\n    cache = cache.cache;\n\n    if (type == 'boolean' || value == null) {\n      return cache[value] ? 0 : -1;\n    }\n    if (type != 'number' && type != 'string') {\n      type = 'object';\n    }\n    var key = type == 'number' ? value : keyPrefix + value;\n    cache = (cache = cache[type]) && cache[key];\n\n    return type == 'object'\n      ? (cache && baseIndexOf(cache, value) > -1 ? 0 : -1)\n      : (cache ? 0 : -1);\n  }\n\n  /**\n   * Adds a given value to the corresponding cache object.\n   *\n   * @private\n   * @param {*} value The value to add to the cache.\n   */\n  function cachePush(value) {\n    var cache = this.cache,\n        type = typeof value;\n\n    if (type == 'boolean' || value == null) {\n      cache[value] = true;\n    } else {\n      if (type != 'number' && type != 'string') {\n        type = 'object';\n      }\n      var key = type == 'number' ? value : keyPrefix + value,\n          typeCache = cache[type] || (cache[type] = {});\n\n      if (type == 'object') {\n        (typeCache[key] || (typeCache[key] = [])).push(value);\n      } else {\n        typeCache[key] = true;\n      }\n    }\n  }\n\n  /**\n   * Used by `_.max` and `_.min` as the default callback when a given\n   * collection is a string value.\n   *\n   * @private\n   * @param {string} value The character to inspect.\n   * @returns {number} Returns the code unit of given character.\n   */\n  function charAtCallback(value) {\n    return value.charCodeAt(0);\n  }\n\n  /**\n   * Used by `sortBy` to compare transformed `collection` elements, stable sorting\n   * them in ascending order.\n   *\n   * @private\n   * @param {Object} a The object to compare to `b`.\n   * @param {Object} b The object to compare to `a`.\n   * @returns {number} Returns the sort order indicator of `1` or `-1`.\n   */\n  function compareAscending(a, b) {\n    var ac = a.criteria,\n        bc = b.criteria,\n        index = -1,\n        length = ac.length;\n\n    while (++index < length) {\n      var value = ac[index],\n          other = bc[index];\n\n      if (value !== other) {\n        if (value > other || typeof value == 'undefined') {\n          return 1;\n        }\n        if (value < other || typeof other == 'undefined') {\n          return -1;\n        }\n      }\n    }\n    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications\n    // that causes it, under certain circumstances, to return the same value for\n    // `a` and `b`. See https://github.com/jashkenas/underscore/pull/1247\n    //\n    // This also ensures a stable sort in V8 and other engines.\n    // See http://code.google.com/p/v8/issues/detail?id=90\n    return a.index - b.index;\n  }\n\n  /**\n   * Creates a cache object to optimize linear searches of large arrays.\n   *\n   * @private\n   * @param {Array} [array=[]] The array to search.\n   * @returns {null|Object} Returns the cache object or `null` if caching should not be used.\n   */\n  function createCache(array) {\n    var index = -1,\n        length = array.length,\n        first = array[0],\n        mid = array[(length / 2) | 0],\n        last = array[length - 1];\n\n    if (first && typeof first == 'object' &&\n        mid && typeof mid == 'object' && last && typeof last == 'object') {\n      return false;\n    }\n    var cache = getObject();\n    cache['false'] = cache['null'] = cache['true'] = cache['undefined'] = false;\n\n    var result = getObject();\n    result.array = array;\n    result.cache = cache;\n    result.push = cachePush;\n\n    while (++index < length) {\n      result.push(array[index]);\n    }\n    return result;\n  }\n\n  /**\n   * Used by `template` to escape characters for inclusion in compiled\n   * string literals.\n   *\n   * @private\n   * @param {string} match The matched character to escape.\n   * @returns {string} Returns the escaped character.\n   */\n  function escapeStringChar(match) {\n    return '\\\\' + stringEscapes[match];\n  }\n\n  /**\n   * Gets an array from the array pool or creates a new one if the pool is empty.\n   *\n   * @private\n   * @returns {Array} The array from the pool.\n   */\n  function getArray() {\n    return arrayPool.pop() || [];\n  }\n\n  /**\n   * Gets an object from the object pool or creates a new one if the pool is empty.\n   *\n   * @private\n   * @returns {Object} The object from the pool.\n   */\n  function getObject() {\n    return objectPool.pop() || {\n      'array': null,\n      'cache': null,\n      'criteria': null,\n      'false': false,\n      'index': 0,\n      'null': false,\n      'number': null,\n      'object': null,\n      'push': null,\n      'string': null,\n      'true': false,\n      'undefined': false,\n      'value': null\n    };\n  }\n\n  /**\n   * Releases the given array back to the array pool.\n   *\n   * @private\n   * @param {Array} [array] The array to release.\n   */\n  function releaseArray(array) {\n    array.length = 0;\n    if (arrayPool.length < maxPoolSize) {\n      arrayPool.push(array);\n    }\n  }\n\n  /**\n   * Releases the given object back to the object pool.\n   *\n   * @private\n   * @param {Object} [object] The object to release.\n   */\n  function releaseObject(object) {\n    var cache = object.cache;\n    if (cache) {\n      releaseObject(cache);\n    }\n    object.array = object.cache = object.criteria = object.object = object.number = object.string = object.value = null;\n    if (objectPool.length < maxPoolSize) {\n      objectPool.push(object);\n    }\n  }\n\n  /**\n   * Slices the `collection` from the `start` index up to, but not including,\n   * the `end` index.\n   *\n   * Note: This function is used instead of `Array#slice` to support node lists\n   * in IE < 9 and to ensure dense arrays are returned.\n   *\n   * @private\n   * @param {Array|Object|string} collection The collection to slice.\n   * @param {number} start The start index.\n   * @param {number} end The end index.\n   * @returns {Array} Returns the new array.\n   */\n  function slice(array, start, end) {\n    start || (start = 0);\n    if (typeof end == 'undefined') {\n      end = array ? array.length : 0;\n    }\n    var index = -1,\n        length = end - start || 0,\n        result = Array(length < 0 ? 0 : length);\n\n    while (++index < length) {\n      result[index] = array[start + index];\n    }\n    return result;\n  }\n\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * Create a new `lodash` function using the given context object.\n   *\n   * @static\n   * @memberOf _\n   * @category Utilities\n   * @param {Object} [context=root] The context object.\n   * @returns {Function} Returns the `lodash` function.\n   */\n  function runInContext(context) {\n    // Avoid issues with some ES3 environments that attempt to use values, named\n    // after built-in constructors like `Object`, for the creation of literals.\n    // ES5 clears this up by stating that literals must use built-in constructors.\n    // See http://es5.github.io/#x11.1.5.\n    context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;\n\n    /** Native constructor references */\n    var Array = context.Array,\n        Boolean = context.Boolean,\n        Date = context.Date,\n        Function = context.Function,\n        Math = context.Math,\n        Number = context.Number,\n        Object = context.Object,\n        RegExp = context.RegExp,\n        String = context.String,\n        TypeError = context.TypeError;\n\n    /**\n     * Used for `Array` method references.\n     *\n     * Normally `Array.prototype` would suffice, however, using an array literal\n     * avoids issues in Narwhal.\n     */\n    var arrayRef = [];\n\n    /** Used for native method references */\n    var objectProto = Object.prototype;\n\n    /** Used to restore the original `_` reference in `noConflict` */\n    var oldDash = context._;\n\n    /** Used to resolve the internal [[Class]] of values */\n    var toString = objectProto.toString;\n\n    /** Used to detect if a method is native */\n    var reNative = RegExp('^' +\n      String(toString)\n        .replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')\n        .replace(/toString| for [^\\]]+/g, '.*?') + '$'\n    );\n\n    /** Native method shortcuts */\n    var ceil = Math.ceil,\n        clearTimeout = context.clearTimeout,\n        floor = Math.floor,\n        fnToString = Function.prototype.toString,\n        getPrototypeOf = isNative(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf,\n        hasOwnProperty = objectProto.hasOwnProperty,\n        push = arrayRef.push,\n        setTimeout = context.setTimeout,\n        splice = arrayRef.splice,\n        unshift = arrayRef.unshift;\n\n    /** Used to set meta data on functions */\n    var defineProperty = (function() {\n      // IE 8 only accepts DOM elements\n      try {\n        var o = {},\n            func = isNative(func = Object.defineProperty) && func,\n            result = func(o, o, o) && func;\n      } catch(e) { }\n      return result;\n    }());\n\n    /* Native method shortcuts for methods with the same name as other `lodash` methods */\n    var nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate,\n        nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray,\n        nativeIsFinite = context.isFinite,\n        nativeIsNaN = context.isNaN,\n        nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys,\n        nativeMax = Math.max,\n        nativeMin = Math.min,\n        nativeParseInt = context.parseInt,\n        nativeRandom = Math.random;\n\n    /** Used to lookup a built-in constructor by [[Class]] */\n    var ctorByClass = {};\n    ctorByClass[arrayClass] = Array;\n    ctorByClass[boolClass] = Boolean;\n    ctorByClass[dateClass] = Date;\n    ctorByClass[funcClass] = Function;\n    ctorByClass[objectClass] = Object;\n    ctorByClass[numberClass] = Number;\n    ctorByClass[regexpClass] = RegExp;\n    ctorByClass[stringClass] = String;\n\n    /*--------------------------------------------------------------------------*/\n\n    /**\n     * Creates a `lodash` object which wraps the given value to enable intuitive\n     * method chaining.\n     *\n     * In addition to Lo-Dash methods, wrappers also have the following `Array` methods:\n     * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`, `splice`,\n     * and `unshift`\n     *\n     * Chaining is supported in custom builds as long as the `value` method is\n     * implicitly or explicitly included in the build.\n     *\n     * The chainable wrapper functions are:\n     * `after`, `assign`, `bind`, `bindAll`, `bindKey`, `chain`, `compact`,\n     * `compose`, `concat`, `countBy`, `create`, `createCallback`, `curry`,\n     * `debounce`, `defaults`, `defer`, `delay`, `difference`, `filter`, `flatten`,\n     * `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`,\n     * `functions`, `groupBy`, `indexBy`, `initial`, `intersection`, `invert`,\n     * `invoke`, `keys`, `map`, `max`, `memoize`, `merge`, `min`, `object`, `omit`,\n     * `once`, `pairs`, `partial`, `partialRight`, `pick`, `pluck`, `pull`, `push`,\n     * `range`, `reject`, `remove`, `rest`, `reverse`, `shuffle`, `slice`, `sort`,\n     * `sortBy`, `splice`, `tap`, `throttle`, `times`, `toArray`, `transform`,\n     * `union`, `uniq`, `unshift`, `unzip`, `values`, `where`, `without`, `wrap`,\n     * and `zip`\n     *\n     * The non-chainable wrapper functions are:\n     * `clone`, `cloneDeep`, `contains`, `escape`, `every`, `find`, `findIndex`,\n     * `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `has`, `identity`,\n     * `indexOf`, `isArguments`, `isArray`, `isBoolean`, `isDate`, `isElement`,\n     * `isEmpty`, `isEqual`, `isFinite`, `isFunction`, `isNaN`, `isNull`, `isNumber`,\n     * `isObject`, `isPlainObject`, `isRegExp`, `isString`, `isUndefined`, `join`,\n     * `lastIndexOf`, `mixin`, `noConflict`, `parseInt`, `pop`, `random`, `reduce`,\n     * `reduceRight`, `result`, `shift`, `size`, `some`, `sortedIndex`, `runInContext`,\n     * `template`, `unescape`, `uniqueId`, and `value`\n     *\n     * The wrapper functions `first` and `last` return wrapped values when `n` is\n     * provided, otherwise they return unwrapped values.\n     *\n     * Explicit chaining can be enabled by using the `_.chain` method.\n     *\n     * @name _\n     * @constructor\n     * @category Chaining\n     * @param {*} value The value to wrap in a `lodash` instance.\n     * @returns {Object} Returns a `lodash` instance.\n     * @example\n     *\n     * var wrapped = _([1, 2, 3]);\n     *\n     * // returns an unwrapped value\n     * wrapped.reduce(function(sum, num) {\n     *   return sum + num;\n     * });\n     * // => 6\n     *\n     * // returns a wrapped value\n     * var squares = wrapped.map(function(num) {\n     *   return num * num;\n     * });\n     *\n     * _.isArray(squares);\n     * // => false\n     *\n     * _.isArray(squares.value());\n     * // => true\n     */\n    function lodash(value) {\n      // don't wrap if already wrapped, even if wrapped by a different `lodash` constructor\n      return (value && typeof value == 'object' && !isArray(value) && hasOwnProperty.call(value, '__wrapped__'))\n       ? value\n       : new lodashWrapper(value);\n    }\n\n    /**\n     * A fast path for creating `lodash` wrapper objects.\n     *\n     * @private\n     * @param {*} value The value to wrap in a `lodash` instance.\n     * @param {boolean} chainAll A flag to enable chaining for all methods\n     * @returns {Object} Returns a `lodash` instance.\n     */\n    function lodashWrapper(value, chainAll) {\n      this.__chain__ = !!chainAll;\n      this.__wrapped__ = value;\n    }\n    // ensure `new lodashWrapper` is an instance of `lodash`\n    lodashWrapper.prototype = lodash.prototype;\n\n    /**\n     * An object used to flag environments features.\n     *\n     * @static\n     * @memberOf _\n     * @type Object\n     */\n    var support = lodash.support = {};\n\n    /**\n     * Detect if functions can be decompiled by `Function#toString`\n     * (all but PS3 and older Opera mobile browsers & avoided in Windows 8 apps).\n     *\n     * @memberOf _.support\n     * @type boolean\n     */\n    support.funcDecomp = !isNative(context.WinRTError) && reThis.test(runInContext);\n\n    /**\n     * Detect if `Function#name` is supported (all but IE).\n     *\n     * @memberOf _.support\n     * @type boolean\n     */\n    support.funcNames = typeof Function.name == 'string';\n\n    /**\n     * By default, the template delimiters used by Lo-Dash are similar to those in\n     * embedded Ruby (ERB). Change the following template settings to use alternative\n     * delimiters.\n     *\n     * @static\n     * @memberOf _\n     * @type Object\n     */\n    lodash.templateSettings = {\n\n      /**\n       * Used to detect `data` property values to be HTML-escaped.\n       *\n       * @memberOf _.templateSettings\n       * @type RegExp\n       */\n      'escape': /<%-([\\s\\S]+?)%>/g,\n\n      /**\n       * Used to detect code to be evaluated.\n       *\n       * @memberOf _.templateSettings\n       * @type RegExp\n       */\n      'evaluate': /<%([\\s\\S]+?)%>/g,\n\n      /**\n       * Used to detect `data` property values to inject.\n       *\n       * @memberOf _.templateSettings\n       * @type RegExp\n       */\n      'interpolate': reInterpolate,\n\n      /**\n       * Used to reference the data object in the template text.\n       *\n       * @memberOf _.templateSettings\n       * @type string\n       */\n      'variable': '',\n\n      /**\n       * Used to import variables into the compiled template.\n       *\n       * @memberOf _.templateSettings\n       * @type Object\n       */\n      'imports': {\n\n        /**\n         * A reference to the `lodash` function.\n         *\n         * @memberOf _.templateSettings.imports\n         * @type Function\n         */\n        '_': lodash\n      }\n    };\n\n    /*--------------------------------------------------------------------------*/\n\n    /**\n     * The base implementation of `_.bind` that creates the bound function and\n     * sets its meta data.\n     *\n     * @private\n     * @param {Array} bindData The bind data array.\n     * @returns {Function} Returns the new bound function.\n     */\n    function baseBind(bindData) {\n      var func = bindData[0],\n          partialArgs = bindData[2],\n          thisArg = bindData[4];\n\n      function bound() {\n        // `Function#bind` spec\n        // http://es5.github.io/#x15.3.4.5\n        if (partialArgs) {\n          // avoid `arguments` object deoptimizations by using `slice` instead\n          // of `Array.prototype.slice.call` and not assigning `arguments` to a\n          // variable as a ternary expression\n          var args = slice(partialArgs);\n          push.apply(args, arguments);\n        }\n        // mimic the constructor's `return` behavior\n        // http://es5.github.io/#x13.2.2\n        if (this instanceof bound) {\n          // ensure `new bound` is an instance of `func`\n          var thisBinding = baseCreate(func.prototype),\n              result = func.apply(thisBinding, args || arguments);\n          return isObject(result) ? result : thisBinding;\n        }\n        return func.apply(thisArg, args || arguments);\n      }\n      setBindData(bound, bindData);\n      return bound;\n    }\n\n    /**\n     * The base implementation of `_.clone` without argument juggling or support\n     * for `thisArg` binding.\n     *\n     * @private\n     * @param {*} value The value to clone.\n     * @param {boolean} [isDeep=false] Specify a deep clone.\n     * @param {Function} [callback] The function to customize cloning values.\n     * @param {Array} [stackA=[]] Tracks traversed source objects.\n     * @param {Array} [stackB=[]] Associates clones with source counterparts.\n     * @returns {*} Returns the cloned value.\n     */\n    function baseClone(value, isDeep, callback, stackA, stackB) {\n      if (callback) {\n        var result = callback(value);\n        if (typeof result != 'undefined') {\n          return result;\n        }\n      }\n      // inspect [[Class]]\n      var isObj = isObject(value);\n      if (isObj) {\n        var className = toString.call(value);\n        if (!cloneableClasses[className]) {\n          return value;\n        }\n        var ctor = ctorByClass[className];\n        switch (className) {\n          case boolClass:\n          case dateClass:\n            return new ctor(+value);\n\n          case numberClass:\n          case stringClass:\n            return new ctor(value);\n\n          case regexpClass:\n            result = ctor(value.source, reFlags.exec(value));\n            result.lastIndex = value.lastIndex;\n            return result;\n        }\n      } else {\n        return value;\n      }\n      var isArr = isArray(value);\n      if (isDeep) {\n        // check for circular references and return corresponding clone\n        var initedStack = !stackA;\n        stackA || (stackA = getArray());\n        stackB || (stackB = getArray());\n\n        var length = stackA.length;\n        while (length--) {\n          if (stackA[length] == value) {\n            return stackB[length];\n          }\n        }\n        result = isArr ? ctor(value.length) : {};\n      }\n      else {\n        result = isArr ? slice(value) : assign({}, value);\n      }\n      // add array properties assigned by `RegExp#exec`\n      if (isArr) {\n        if (hasOwnProperty.call(value, 'index')) {\n          result.index = value.index;\n        }\n        if (hasOwnProperty.call(value, 'input')) {\n          result.input = value.input;\n        }\n      }\n      // exit for shallow clone\n      if (!isDeep) {\n        return result;\n      }\n      // add the source value to the stack of traversed objects\n      // and associate it with its clone\n      stackA.push(value);\n      stackB.push(result);\n\n      // recursively populate clone (susceptible to call stack limits)\n      (isArr ? forEach : forOwn)(value, function(objValue, key) {\n        result[key] = baseClone(objValue, isDeep, callback, stackA, stackB);\n      });\n\n      if (initedStack) {\n        releaseArray(stackA);\n        releaseArray(stackB);\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.create` without support for assigning\n     * properties to the created object.\n     *\n     * @private\n     * @param {Object} prototype The object to inherit from.\n     * @returns {Object} Returns the new object.\n     */\n    function baseCreate(prototype, properties) {\n      return isObject(prototype) ? nativeCreate(prototype) : {};\n    }\n    // fallback for browsers without `Object.create`\n    if (!nativeCreate) {\n      baseCreate = (function() {\n        function Object() {}\n        return function(prototype) {\n          if (isObject(prototype)) {\n            Object.prototype = prototype;\n            var result = new Object;\n            Object.prototype = null;\n          }\n          return result || context.Object();\n        };\n      }());\n    }\n\n    /**\n     * The base implementation of `_.createCallback` without support for creating\n     * \"_.pluck\" or \"_.where\" style callbacks.\n     *\n     * @private\n     * @param {*} [func=identity] The value to convert to a callback.\n     * @param {*} [thisArg] The `this` binding of the created callback.\n     * @param {number} [argCount] The number of arguments the callback accepts.\n     * @returns {Function} Returns a callback function.\n     */\n    function baseCreateCallback(func, thisArg, argCount) {\n      if (typeof func != 'function') {\n        return identity;\n      }\n      // exit early for no `thisArg` or already bound by `Function#bind`\n      if (typeof thisArg == 'undefined' || !('prototype' in func)) {\n        return func;\n      }\n      var bindData = func.__bindData__;\n      if (typeof bindData == 'undefined') {\n        if (support.funcNames) {\n          bindData = !func.name;\n        }\n        bindData = bindData || !support.funcDecomp;\n        if (!bindData) {\n          var source = fnToString.call(func);\n          if (!support.funcNames) {\n            bindData = !reFuncName.test(source);\n          }\n          if (!bindData) {\n            // checks if `func` references the `this` keyword and stores the result\n            bindData = reThis.test(source);\n            setBindData(func, bindData);\n          }\n        }\n      }\n      // exit early if there are no `this` references or `func` is bound\n      if (bindData === false || (bindData !== true && bindData[1] & 1)) {\n        return func;\n      }\n      switch (argCount) {\n        case 1: return function(value) {\n          return func.call(thisArg, value);\n        };\n        case 2: return function(a, b) {\n          return func.call(thisArg, a, b);\n        };\n        case 3: return function(value, index, collection) {\n          return func.call(thisArg, value, index, collection);\n        };\n        case 4: return function(accumulator, value, index, collection) {\n          return func.call(thisArg, accumulator, value, index, collection);\n        };\n      }\n      return bind(func, thisArg);\n    }\n\n    /**\n     * The base implementation of `createWrapper` that creates the wrapper and\n     * sets its meta data.\n     *\n     * @private\n     * @param {Array} bindData The bind data array.\n     * @returns {Function} Returns the new function.\n     */\n    function baseCreateWrapper(bindData) {\n      var func = bindData[0],\n          bitmask = bindData[1],\n          partialArgs = bindData[2],\n          partialRightArgs = bindData[3],\n          thisArg = bindData[4],\n          arity = bindData[5];\n\n      var isBind = bitmask & 1,\n          isBindKey = bitmask & 2,\n          isCurry = bitmask & 4,\n          isCurryBound = bitmask & 8,\n          key = func;\n\n      function bound() {\n        var thisBinding = isBind ? thisArg : this;\n        if (partialArgs) {\n          var args = slice(partialArgs);\n          push.apply(args, arguments);\n        }\n        if (partialRightArgs || isCurry) {\n          args || (args = slice(arguments));\n          if (partialRightArgs) {\n            push.apply(args, partialRightArgs);\n          }\n          if (isCurry && args.length < arity) {\n            bitmask |= 16 & ~32;\n            return baseCreateWrapper([func, (isCurryBound ? bitmask : bitmask & ~3), args, null, thisArg, arity]);\n          }\n        }\n        args || (args = arguments);\n        if (isBindKey) {\n          func = thisBinding[key];\n        }\n        if (this instanceof bound) {\n          thisBinding = baseCreate(func.prototype);\n          var result = func.apply(thisBinding, args);\n          return isObject(result) ? result : thisBinding;\n        }\n        return func.apply(thisBinding, args);\n      }\n      setBindData(bound, bindData);\n      return bound;\n    }\n\n    /**\n     * The base implementation of `_.difference` that accepts a single array\n     * of values to exclude.\n     *\n     * @private\n     * @param {Array} array The array to process.\n     * @param {Array} [values] The array of values to exclude.\n     * @returns {Array} Returns a new array of filtered values.\n     */\n    function baseDifference(array, values) {\n      var index = -1,\n          indexOf = getIndexOf(),\n          length = array ? array.length : 0,\n          isLarge = length >= largeArraySize && indexOf === baseIndexOf,\n          result = [];\n\n      if (isLarge) {\n        var cache = createCache(values);\n        if (cache) {\n          indexOf = cacheIndexOf;\n          values = cache;\n        } else {\n          isLarge = false;\n        }\n      }\n      while (++index < length) {\n        var value = array[index];\n        if (indexOf(values, value) < 0) {\n          result.push(value);\n        }\n      }\n      if (isLarge) {\n        releaseObject(values);\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.flatten` without support for callback\n     * shorthands or `thisArg` binding.\n     *\n     * @private\n     * @param {Array} array The array to flatten.\n     * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.\n     * @param {boolean} [isStrict=false] A flag to restrict flattening to arrays and `arguments` objects.\n     * @param {number} [fromIndex=0] The index to start from.\n     * @returns {Array} Returns a new flattened array.\n     */\n    function baseFlatten(array, isShallow, isStrict, fromIndex) {\n      var index = (fromIndex || 0) - 1,\n          length = array ? array.length : 0,\n          result = [];\n\n      while (++index < length) {\n        var value = array[index];\n\n        if (value && typeof value == 'object' && typeof value.length == 'number'\n            && (isArray(value) || isArguments(value))) {\n          // recursively flatten arrays (susceptible to call stack limits)\n          if (!isShallow) {\n            value = baseFlatten(value, isShallow, isStrict);\n          }\n          var valIndex = -1,\n              valLength = value.length,\n              resIndex = result.length;\n\n          result.length += valLength;\n          while (++valIndex < valLength) {\n            result[resIndex++] = value[valIndex];\n          }\n        } else if (!isStrict) {\n          result.push(value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.isEqual`, without support for `thisArg` binding,\n     * that allows partial \"_.where\" style comparisons.\n     *\n     * @private\n     * @param {*} a The value to compare.\n     * @param {*} b The other value to compare.\n     * @param {Function} [callback] The function to customize comparing values.\n     * @param {Function} [isWhere=false] A flag to indicate performing partial comparisons.\n     * @param {Array} [stackA=[]] Tracks traversed `a` objects.\n     * @param {Array} [stackB=[]] Tracks traversed `b` objects.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     */\n    function baseIsEqual(a, b, callback, isWhere, stackA, stackB) {\n      // used to indicate that when comparing objects, `a` has at least the properties of `b`\n      if (callback) {\n        var result = callback(a, b);\n        if (typeof result != 'undefined') {\n          return !!result;\n        }\n      }\n      // exit early for identical values\n      if (a === b) {\n        // treat `+0` vs. `-0` as not equal\n        return a !== 0 || (1 / a == 1 / b);\n      }\n      var type = typeof a,\n          otherType = typeof b;\n\n      // exit early for unlike primitive values\n      if (a === a &&\n          !(a && objectTypes[type]) &&\n          !(b && objectTypes[otherType])) {\n        return false;\n      }\n      // exit early for `null` and `undefined` avoiding ES3's Function#call behavior\n      // http://es5.github.io/#x15.3.4.4\n      if (a == null || b == null) {\n        return a === b;\n      }\n      // compare [[Class]] names\n      var className = toString.call(a),\n          otherClass = toString.call(b);\n\n      if (className == argsClass) {\n        className = objectClass;\n      }\n      if (otherClass == argsClass) {\n        otherClass = objectClass;\n      }\n      if (className != otherClass) {\n        return false;\n      }\n      switch (className) {\n        case boolClass:\n        case dateClass:\n          // coerce dates and booleans to numbers, dates to milliseconds and booleans\n          // to `1` or `0` treating invalid dates coerced to `NaN` as not equal\n          return +a == +b;\n\n        case numberClass:\n          // treat `NaN` vs. `NaN` as equal\n          return (a != +a)\n            ? b != +b\n            // but treat `+0` vs. `-0` as not equal\n            : (a == 0 ? (1 / a == 1 / b) : a == +b);\n\n        case regexpClass:\n        case stringClass:\n          // coerce regexes to strings (http://es5.github.io/#x15.10.6.4)\n          // treat string primitives and their corresponding object instances as equal\n          return a == String(b);\n      }\n      var isArr = className == arrayClass;\n      if (!isArr) {\n        // unwrap any `lodash` wrapped values\n        var aWrapped = hasOwnProperty.call(a, '__wrapped__'),\n            bWrapped = hasOwnProperty.call(b, '__wrapped__');\n\n        if (aWrapped || bWrapped) {\n          return baseIsEqual(aWrapped ? a.__wrapped__ : a, bWrapped ? b.__wrapped__ : b, callback, isWhere, stackA, stackB);\n        }\n        // exit for functions and DOM nodes\n        if (className != objectClass) {\n          return false;\n        }\n        // in older versions of Opera, `arguments` objects have `Array` constructors\n        var ctorA = a.constructor,\n            ctorB = b.constructor;\n\n        // non `Object` object instances with different constructors are not equal\n        if (ctorA != ctorB &&\n              !(isFunction(ctorA) && ctorA instanceof ctorA && isFunction(ctorB) && ctorB instanceof ctorB) &&\n              ('constructor' in a && 'constructor' in b)\n            ) {\n          return false;\n        }\n      }\n      // assume cyclic structures are equal\n      // the algorithm for detecting cyclic structures is adapted from ES 5.1\n      // section 15.12.3, abstract operation `JO` (http://es5.github.io/#x15.12.3)\n      var initedStack = !stackA;\n      stackA || (stackA = getArray());\n      stackB || (stackB = getArray());\n\n      var length = stackA.length;\n      while (length--) {\n        if (stackA[length] == a) {\n          return stackB[length] == b;\n        }\n      }\n      var size = 0;\n      result = true;\n\n      // add `a` and `b` to the stack of traversed objects\n      stackA.push(a);\n      stackB.push(b);\n\n      // recursively compare objects and arrays (susceptible to call stack limits)\n      if (isArr) {\n        // compare lengths to determine if a deep comparison is necessary\n        length = a.length;\n        size = b.length;\n        result = size == length;\n\n        if (result || isWhere) {\n          // deep compare the contents, ignoring non-numeric properties\n          while (size--) {\n            var index = length,\n                value = b[size];\n\n            if (isWhere) {\n              while (index--) {\n                if ((result = baseIsEqual(a[index], value, callback, isWhere, stackA, stackB))) {\n                  break;\n                }\n              }\n            } else if (!(result = baseIsEqual(a[size], value, callback, isWhere, stackA, stackB))) {\n              break;\n            }\n          }\n        }\n      }\n      else {\n        // deep compare objects using `forIn`, instead of `forOwn`, to avoid `Object.keys`\n        // which, in this case, is more costly\n        forIn(b, function(value, key, b) {\n          if (hasOwnProperty.call(b, key)) {\n            // count the number of properties.\n            size++;\n            // deep compare each property value.\n            return (result = hasOwnProperty.call(a, key) && baseIsEqual(a[key], value, callback, isWhere, stackA, stackB));\n          }\n        });\n\n        if (result && !isWhere) {\n          // ensure both objects have the same number of properties\n          forIn(a, function(value, key, a) {\n            if (hasOwnProperty.call(a, key)) {\n              // `size` will be `-1` if `a` has more properties than `b`\n              return (result = --size > -1);\n            }\n          });\n        }\n      }\n      stackA.pop();\n      stackB.pop();\n\n      if (initedStack) {\n        releaseArray(stackA);\n        releaseArray(stackB);\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.merge` without argument juggling or support\n     * for `thisArg` binding.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @param {Function} [callback] The function to customize merging properties.\n     * @param {Array} [stackA=[]] Tracks traversed source objects.\n     * @param {Array} [stackB=[]] Associates values with source counterparts.\n     */\n    function baseMerge(object, source, callback, stackA, stackB) {\n      (isArray(source) ? forEach : forOwn)(source, function(source, key) {\n        var found,\n            isArr,\n            result = source,\n            value = object[key];\n\n        if (source && ((isArr = isArray(source)) || isPlainObject(source))) {\n          // avoid merging previously merged cyclic sources\n          var stackLength = stackA.length;\n          while (stackLength--) {\n            if ((found = stackA[stackLength] == source)) {\n              value = stackB[stackLength];\n              break;\n            }\n          }\n          if (!found) {\n            var isShallow;\n            if (callback) {\n              result = callback(value, source);\n              if ((isShallow = typeof result != 'undefined')) {\n                value = result;\n              }\n            }\n            if (!isShallow) {\n              value = isArr\n                ? (isArray(value) ? value : [])\n                : (isPlainObject(value) ? value : {});\n            }\n            // add `source` and associated `value` to the stack of traversed objects\n            stackA.push(source);\n            stackB.push(value);\n\n            // recursively merge objects and arrays (susceptible to call stack limits)\n            if (!isShallow) {\n              baseMerge(value, source, callback, stackA, stackB);\n            }\n          }\n        }\n        else {\n          if (callback) {\n            result = callback(value, source);\n            if (typeof result == 'undefined') {\n              result = source;\n            }\n          }\n          if (typeof result != 'undefined') {\n            value = result;\n          }\n        }\n        object[key] = value;\n      });\n    }\n\n    /**\n     * The base implementation of `_.random` without argument juggling or support\n     * for returning floating-point numbers.\n     *\n     * @private\n     * @param {number} min The minimum possible value.\n     * @param {number} max The maximum possible value.\n     * @returns {number} Returns a random number.\n     */\n    function baseRandom(min, max) {\n      return min + floor(nativeRandom() * (max - min + 1));\n    }\n\n    /**\n     * The base implementation of `_.uniq` without support for callback shorthands\n     * or `thisArg` binding.\n     *\n     * @private\n     * @param {Array} array The array to process.\n     * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.\n     * @param {Function} [callback] The function called per iteration.\n     * @returns {Array} Returns a duplicate-value-free array.\n     */\n    function baseUniq(array, isSorted, callback) {\n      var index = -1,\n          indexOf = getIndexOf(),\n          length = array ? array.length : 0,\n          result = [];\n\n      var isLarge = !isSorted && length >= largeArraySize && indexOf === baseIndexOf,\n          seen = (callback || isLarge) ? getArray() : result;\n\n      if (isLarge) {\n        var cache = createCache(seen);\n        indexOf = cacheIndexOf;\n        seen = cache;\n      }\n      while (++index < length) {\n        var value = array[index],\n            computed = callback ? callback(value, index, array) : value;\n\n        if (isSorted\n              ? !index || seen[seen.length - 1] !== computed\n              : indexOf(seen, computed) < 0\n            ) {\n          if (callback || isLarge) {\n            seen.push(computed);\n          }\n          result.push(value);\n        }\n      }\n      if (isLarge) {\n        releaseArray(seen.array);\n        releaseObject(seen);\n      } else if (callback) {\n        releaseArray(seen);\n      }\n      return result;\n    }\n\n    /**\n     * Creates a function that aggregates a collection, creating an object composed\n     * of keys generated from the results of running each element of the collection\n     * through a callback. The given `setter` function sets the keys and values\n     * of the composed object.\n     *\n     * @private\n     * @param {Function} setter The setter function.\n     * @returns {Function} Returns the new aggregator function.\n     */\n    function createAggregator(setter) {\n      return function(collection, callback, thisArg) {\n        var result = {};\n        callback = lodash.createCallback(callback, thisArg, 3);\n\n        var index = -1,\n            length = collection ? collection.length : 0;\n\n        if (typeof length == 'number') {\n          while (++index < length) {\n            var value = collection[index];\n            setter(result, value, callback(value, index, collection), collection);\n          }\n        } else {\n          forOwn(collection, function(value, key, collection) {\n            setter(result, value, callback(value, key, collection), collection);\n          });\n        }\n        return result;\n      };\n    }\n\n    /**\n     * Creates a function that, when called, either curries or invokes `func`\n     * with an optional `this` binding and partially applied arguments.\n     *\n     * @private\n     * @param {Function|string} func The function or method name to reference.\n     * @param {number} bitmask The bitmask of method flags to compose.\n     *  The bitmask may be composed of the following flags:\n     *  1 - `_.bind`\n     *  2 - `_.bindKey`\n     *  4 - `_.curry`\n     *  8 - `_.curry` (bound)\n     *  16 - `_.partial`\n     *  32 - `_.partialRight`\n     * @param {Array} [partialArgs] An array of arguments to prepend to those\n     *  provided to the new function.\n     * @param {Array} [partialRightArgs] An array of arguments to append to those\n     *  provided to the new function.\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @param {number} [arity] The arity of `func`.\n     * @returns {Function} Returns the new function.\n     */\n    function createWrapper(func, bitmask, partialArgs, partialRightArgs, thisArg, arity) {\n      var isBind = bitmask & 1,\n          isBindKey = bitmask & 2,\n          isCurry = bitmask & 4,\n          isCurryBound = bitmask & 8,\n          isPartial = bitmask & 16,\n          isPartialRight = bitmask & 32;\n\n      if (!isBindKey && !isFunction(func)) {\n        throw new TypeError;\n      }\n      if (isPartial && !partialArgs.length) {\n        bitmask &= ~16;\n        isPartial = partialArgs = false;\n      }\n      if (isPartialRight && !partialRightArgs.length) {\n        bitmask &= ~32;\n        isPartialRight = partialRightArgs = false;\n      }\n      var bindData = func && func.__bindData__;\n      if (bindData && bindData !== true) {\n        // clone `bindData`\n        bindData = slice(bindData);\n        if (bindData[2]) {\n          bindData[2] = slice(bindData[2]);\n        }\n        if (bindData[3]) {\n          bindData[3] = slice(bindData[3]);\n        }\n        // set `thisBinding` is not previously bound\n        if (isBind && !(bindData[1] & 1)) {\n          bindData[4] = thisArg;\n        }\n        // set if previously bound but not currently (subsequent curried functions)\n        if (!isBind && bindData[1] & 1) {\n          bitmask |= 8;\n        }\n        // set curried arity if not yet set\n        if (isCurry && !(bindData[1] & 4)) {\n          bindData[5] = arity;\n        }\n        // append partial left arguments\n        if (isPartial) {\n          push.apply(bindData[2] || (bindData[2] = []), partialArgs);\n        }\n        // append partial right arguments\n        if (isPartialRight) {\n          unshift.apply(bindData[3] || (bindData[3] = []), partialRightArgs);\n        }\n        // merge flags\n        bindData[1] |= bitmask;\n        return createWrapper.apply(null, bindData);\n      }\n      // fast path for `_.bind`\n      var creater = (bitmask == 1 || bitmask === 17) ? baseBind : baseCreateWrapper;\n      return creater([func, bitmask, partialArgs, partialRightArgs, thisArg, arity]);\n    }\n\n    /**\n     * Used by `escape` to convert characters to HTML entities.\n     *\n     * @private\n     * @param {string} match The matched character to escape.\n     * @returns {string} Returns the escaped character.\n     */\n    function escapeHtmlChar(match) {\n      return htmlEscapes[match];\n    }\n\n    /**\n     * Gets the appropriate \"indexOf\" function. If the `_.indexOf` method is\n     * customized, this method returns the custom method, otherwise it returns\n     * the `baseIndexOf` function.\n     *\n     * @private\n     * @returns {Function} Returns the \"indexOf\" function.\n     */\n    function getIndexOf() {\n      var result = (result = lodash.indexOf) === indexOf ? baseIndexOf : result;\n      return result;\n    }\n\n    /**\n     * Checks if `value` is a native function.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the `value` is a native function, else `false`.\n     */\n    function isNative(value) {\n      return typeof value == 'function' && reNative.test(value);\n    }\n\n    /**\n     * Sets `this` binding data on a given function.\n     *\n     * @private\n     * @param {Function} func The function to set data on.\n     * @param {Array} value The data array to set.\n     */\n    var setBindData = !defineProperty ? noop : function(func, value) {\n      descriptor.value = value;\n      defineProperty(func, '__bindData__', descriptor);\n      descriptor.value = null;\n    };\n\n    /**\n     * A fallback implementation of `isPlainObject` which checks if a given value\n     * is an object created by the `Object` constructor, assuming objects created\n     * by the `Object` constructor have no inherited enumerable properties and that\n     * there are no `Object.prototype` extensions.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n     */\n    function shimIsPlainObject(value) {\n      var ctor,\n          result;\n\n      // avoid non Object objects, `arguments` objects, and DOM elements\n      if (!(value && toString.call(value) == objectClass) ||\n          (ctor = value.constructor, isFunction(ctor) && !(ctor instanceof ctor))) {\n        return false;\n      }\n      // In most environments an object's own properties are iterated before\n      // its inherited properties. If the last iterated property is an object's\n      // own property then there are no inherited enumerable properties.\n      forIn(value, function(value, key) {\n        result = key;\n      });\n      return typeof result == 'undefined' || hasOwnProperty.call(value, result);\n    }\n\n    /**\n     * Used by `unescape` to convert HTML entities to characters.\n     *\n     * @private\n     * @param {string} match The matched character to unescape.\n     * @returns {string} Returns the unescaped character.\n     */\n    function unescapeHtmlChar(match) {\n      return htmlUnescapes[match];\n    }\n\n    /*--------------------------------------------------------------------------*/\n\n    /**\n     * Checks if `value` is an `arguments` object.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the `value` is an `arguments` object, else `false`.\n     * @example\n     *\n     * (function() { return _.isArguments(arguments); })(1, 2, 3);\n     * // => true\n     *\n     * _.isArguments([1, 2, 3]);\n     * // => false\n     */\n    function isArguments(value) {\n      return value && typeof value == 'object' && typeof value.length == 'number' &&\n        toString.call(value) == argsClass || false;\n    }\n\n    /**\n     * Checks if `value` is an array.\n     *\n     * @static\n     * @memberOf _\n     * @type Function\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the `value` is an array, else `false`.\n     * @example\n     *\n     * (function() { return _.isArray(arguments); })();\n     * // => false\n     *\n     * _.isArray([1, 2, 3]);\n     * // => true\n     */\n    var isArray = nativeIsArray || function(value) {\n      return value && typeof value == 'object' && typeof value.length == 'number' &&\n        toString.call(value) == arrayClass || false;\n    };\n\n    /**\n     * A fallback implementation of `Object.keys` which produces an array of the\n     * given object's own enumerable property names.\n     *\n     * @private\n     * @type Function\n     * @param {Object} object The object to inspect.\n     * @returns {Array} Returns an array of property names.\n     */\n    var shimKeys = function(object) {\n      var index, iterable = object, result = [];\n      if (!iterable) return result;\n      if (!(objectTypes[typeof object])) return result;\n        for (index in iterable) {\n          if (hasOwnProperty.call(iterable, index)) {\n            result.push(index);\n          }\n        }\n      return result\n    };\n\n    /**\n     * Creates an array composed of the own enumerable property names of an object.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The object to inspect.\n     * @returns {Array} Returns an array of property names.\n     * @example\n     *\n     * _.keys({ 'one': 1, 'two': 2, 'three': 3 });\n     * // => ['one', 'two', 'three'] (property order is not guaranteed across environments)\n     */\n    var keys = !nativeKeys ? shimKeys : function(object) {\n      if (!isObject(object)) {\n        return [];\n      }\n      return nativeKeys(object);\n    };\n\n    /**\n     * Used to convert characters to HTML entities:\n     *\n     * Though the `>` character is escaped for symmetry, characters like `>` and `/`\n     * don't require escaping in HTML and have no special meaning unless they're part\n     * of a tag or an unquoted attribute value.\n     * http://mathiasbynens.be/notes/ambiguous-ampersands (under \"semi-related fun fact\")\n     */\n    var htmlEscapes = {\n      '&': '&amp;',\n      '<': '&lt;',\n      '>': '&gt;',\n      '\"': '&quot;',\n      \"'\": '&#39;'\n    };\n\n    /** Used to convert HTML entities to characters */\n    var htmlUnescapes = invert(htmlEscapes);\n\n    /** Used to match HTML entities and HTML characters */\n    var reEscapedHtml = RegExp('(' + keys(htmlUnescapes).join('|') + ')', 'g'),\n        reUnescapedHtml = RegExp('[' + keys(htmlEscapes).join('') + ']', 'g');\n\n    /*--------------------------------------------------------------------------*/\n\n    /**\n     * Assigns own enumerable properties of source object(s) to the destination\n     * object. Subsequent sources will overwrite property assignments of previous\n     * sources. If a callback is provided it will be executed to produce the\n     * assigned values. The callback is bound to `thisArg` and invoked with two\n     * arguments; (objectValue, sourceValue).\n     *\n     * @static\n     * @memberOf _\n     * @type Function\n     * @alias extend\n     * @category Objects\n     * @param {Object} object The destination object.\n     * @param {...Object} [source] The source objects.\n     * @param {Function} [callback] The function to customize assigning values.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Object} Returns the destination object.\n     * @example\n     *\n     * _.assign({ 'name': 'fred' }, { 'employer': 'slate' });\n     * // => { 'name': 'fred', 'employer': 'slate' }\n     *\n     * var defaults = _.partialRight(_.assign, function(a, b) {\n     *   return typeof a == 'undefined' ? b : a;\n     * });\n     *\n     * var object = { 'name': 'barney' };\n     * defaults(object, { 'name': 'fred', 'employer': 'slate' });\n     * // => { 'name': 'barney', 'employer': 'slate' }\n     */\n    var assign = function(object, source, guard) {\n      var index, iterable = object, result = iterable;\n      if (!iterable) return result;\n      var args = arguments,\n          argsIndex = 0,\n          argsLength = typeof guard == 'number' ? 2 : args.length;\n      if (argsLength > 3 && typeof args[argsLength - 2] == 'function') {\n        var callback = baseCreateCallback(args[--argsLength - 1], args[argsLength--], 2);\n      } else if (argsLength > 2 && typeof args[argsLength - 1] == 'function') {\n        callback = args[--argsLength];\n      }\n      while (++argsIndex < argsLength) {\n        iterable = args[argsIndex];\n        if (iterable && objectTypes[typeof iterable]) {\n        var ownIndex = -1,\n            ownProps = objectTypes[typeof iterable] && keys(iterable),\n            length = ownProps ? ownProps.length : 0;\n\n        while (++ownIndex < length) {\n          index = ownProps[ownIndex];\n          result[index] = callback ? callback(result[index], iterable[index]) : iterable[index];\n        }\n        }\n      }\n      return result\n    };\n\n    /**\n     * Creates a clone of `value`. If `isDeep` is `true` nested objects will also\n     * be cloned, otherwise they will be assigned by reference. If a callback\n     * is provided it will be executed to produce the cloned values. If the\n     * callback returns `undefined` cloning will be handled by the method instead.\n     * The callback is bound to `thisArg` and invoked with one argument; (value).\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to clone.\n     * @param {boolean} [isDeep=false] Specify a deep clone.\n     * @param {Function} [callback] The function to customize cloning values.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {*} Returns the cloned value.\n     * @example\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36 },\n     *   { 'name': 'fred',   'age': 40 }\n     * ];\n     *\n     * var shallow = _.clone(characters);\n     * shallow[0] === characters[0];\n     * // => true\n     *\n     * var deep = _.clone(characters, true);\n     * deep[0] === characters[0];\n     * // => false\n     *\n     * _.mixin({\n     *   'clone': _.partialRight(_.clone, function(value) {\n     *     return _.isElement(value) ? value.cloneNode(false) : undefined;\n     *   })\n     * });\n     *\n     * var clone = _.clone(document.body);\n     * clone.childNodes.length;\n     * // => 0\n     */\n    function clone(value, isDeep, callback, thisArg) {\n      // allows working with \"Collections\" methods without using their `index`\n      // and `collection` arguments for `isDeep` and `callback`\n      if (typeof isDeep != 'boolean' && isDeep != null) {\n        thisArg = callback;\n        callback = isDeep;\n        isDeep = false;\n      }\n      return baseClone(value, isDeep, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));\n    }\n\n    /**\n     * Creates a deep clone of `value`. If a callback is provided it will be\n     * executed to produce the cloned values. If the callback returns `undefined`\n     * cloning will be handled by the method instead. The callback is bound to\n     * `thisArg` and invoked with one argument; (value).\n     *\n     * Note: This method is loosely based on the structured clone algorithm. Functions\n     * and DOM nodes are **not** cloned. The enumerable properties of `arguments` objects and\n     * objects created by constructors other than `Object` are cloned to plain `Object` objects.\n     * See http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to deep clone.\n     * @param {Function} [callback] The function to customize cloning values.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {*} Returns the deep cloned value.\n     * @example\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36 },\n     *   { 'name': 'fred',   'age': 40 }\n     * ];\n     *\n     * var deep = _.cloneDeep(characters);\n     * deep[0] === characters[0];\n     * // => false\n     *\n     * var view = {\n     *   'label': 'docs',\n     *   'node': element\n     * };\n     *\n     * var clone = _.cloneDeep(view, function(value) {\n     *   return _.isElement(value) ? value.cloneNode(true) : undefined;\n     * });\n     *\n     * clone.node == view.node;\n     * // => false\n     */\n    function cloneDeep(value, callback, thisArg) {\n      return baseClone(value, true, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));\n    }\n\n    /**\n     * Creates an object that inherits from the given `prototype` object. If a\n     * `properties` object is provided its own enumerable properties are assigned\n     * to the created object.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} prototype The object to inherit from.\n     * @param {Object} [properties] The properties to assign to the object.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * function Shape() {\n     *   this.x = 0;\n     *   this.y = 0;\n     * }\n     *\n     * function Circle() {\n     *   Shape.call(this);\n     * }\n     *\n     * Circle.prototype = _.create(Shape.prototype, { 'constructor': Circle });\n     *\n     * var circle = new Circle;\n     * circle instanceof Circle;\n     * // => true\n     *\n     * circle instanceof Shape;\n     * // => true\n     */\n    function create(prototype, properties) {\n      var result = baseCreate(prototype);\n      return properties ? assign(result, properties) : result;\n    }\n\n    /**\n     * Assigns own enumerable properties of source object(s) to the destination\n     * object for all destination properties that resolve to `undefined`. Once a\n     * property is set, additional defaults of the same property will be ignored.\n     *\n     * @static\n     * @memberOf _\n     * @type Function\n     * @category Objects\n     * @param {Object} object The destination object.\n     * @param {...Object} [source] The source objects.\n     * @param- {Object} [guard] Allows working with `_.reduce` without using its\n     *  `key` and `object` arguments as sources.\n     * @returns {Object} Returns the destination object.\n     * @example\n     *\n     * var object = { 'name': 'barney' };\n     * _.defaults(object, { 'name': 'fred', 'employer': 'slate' });\n     * // => { 'name': 'barney', 'employer': 'slate' }\n     */\n    var defaults = function(object, source, guard) {\n      var index, iterable = object, result = iterable;\n      if (!iterable) return result;\n      var args = arguments,\n          argsIndex = 0,\n          argsLength = typeof guard == 'number' ? 2 : args.length;\n      while (++argsIndex < argsLength) {\n        iterable = args[argsIndex];\n        if (iterable && objectTypes[typeof iterable]) {\n        var ownIndex = -1,\n            ownProps = objectTypes[typeof iterable] && keys(iterable),\n            length = ownProps ? ownProps.length : 0;\n\n        while (++ownIndex < length) {\n          index = ownProps[ownIndex];\n          if (typeof result[index] == 'undefined') result[index] = iterable[index];\n        }\n        }\n      }\n      return result\n    };\n\n    /**\n     * This method is like `_.findIndex` except that it returns the key of the\n     * first element that passes the callback check, instead of the element itself.\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The object to search.\n     * @param {Function|Object|string} [callback=identity] The function called per\n     *  iteration. If a property name or object is provided it will be used to\n     *  create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {string|undefined} Returns the key of the found element, else `undefined`.\n     * @example\n     *\n     * var characters = {\n     *   'barney': {  'age': 36, 'blocked': false },\n     *   'fred': {    'age': 40, 'blocked': true },\n     *   'pebbles': { 'age': 1,  'blocked': false }\n     * };\n     *\n     * _.findKey(characters, function(chr) {\n     *   return chr.age < 40;\n     * });\n     * // => 'barney' (property order is not guaranteed across environments)\n     *\n     * // using \"_.where\" callback shorthand\n     * _.findKey(characters, { 'age': 1 });\n     * // => 'pebbles'\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.findKey(characters, 'blocked');\n     * // => 'fred'\n     */\n    function findKey(object, callback, thisArg) {\n      var result;\n      callback = lodash.createCallback(callback, thisArg, 3);\n      forOwn(object, function(value, key, object) {\n        if (callback(value, key, object)) {\n          result = key;\n          return false;\n        }\n      });\n      return result;\n    }\n\n    /**\n     * This method is like `_.findKey` except that it iterates over elements\n     * of a `collection` in the opposite order.\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The object to search.\n     * @param {Function|Object|string} [callback=identity] The function called per\n     *  iteration. If a property name or object is provided it will be used to\n     *  create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {string|undefined} Returns the key of the found element, else `undefined`.\n     * @example\n     *\n     * var characters = {\n     *   'barney': {  'age': 36, 'blocked': true },\n     *   'fred': {    'age': 40, 'blocked': false },\n     *   'pebbles': { 'age': 1,  'blocked': true }\n     * };\n     *\n     * _.findLastKey(characters, function(chr) {\n     *   return chr.age < 40;\n     * });\n     * // => returns `pebbles`, assuming `_.findKey` returns `barney`\n     *\n     * // using \"_.where\" callback shorthand\n     * _.findLastKey(characters, { 'age': 40 });\n     * // => 'fred'\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.findLastKey(characters, 'blocked');\n     * // => 'pebbles'\n     */\n    function findLastKey(object, callback, thisArg) {\n      var result;\n      callback = lodash.createCallback(callback, thisArg, 3);\n      forOwnRight(object, function(value, key, object) {\n        if (callback(value, key, object)) {\n          result = key;\n          return false;\n        }\n      });\n      return result;\n    }\n\n    /**\n     * Iterates over own and inherited enumerable properties of an object,\n     * executing the callback for each property. The callback is bound to `thisArg`\n     * and invoked with three arguments; (value, key, object). Callbacks may exit\n     * iteration early by explicitly returning `false`.\n     *\n     * @static\n     * @memberOf _\n     * @type Function\n     * @category Objects\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [callback=identity] The function called per iteration.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * function Shape() {\n     *   this.x = 0;\n     *   this.y = 0;\n     * }\n     *\n     * Shape.prototype.move = function(x, y) {\n     *   this.x += x;\n     *   this.y += y;\n     * };\n     *\n     * _.forIn(new Shape, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => logs 'x', 'y', and 'move' (property order is not guaranteed across environments)\n     */\n    var forIn = function(collection, callback, thisArg) {\n      var index, iterable = collection, result = iterable;\n      if (!iterable) return result;\n      if (!objectTypes[typeof iterable]) return result;\n      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);\n        for (index in iterable) {\n          if (callback(iterable[index], index, collection) === false) return result;\n        }\n      return result\n    };\n\n    /**\n     * This method is like `_.forIn` except that it iterates over elements\n     * of a `collection` in the opposite order.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [callback=identity] The function called per iteration.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * function Shape() {\n     *   this.x = 0;\n     *   this.y = 0;\n     * }\n     *\n     * Shape.prototype.move = function(x, y) {\n     *   this.x += x;\n     *   this.y += y;\n     * };\n     *\n     * _.forInRight(new Shape, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => logs 'move', 'y', and 'x' assuming `_.forIn ` logs 'x', 'y', and 'move'\n     */\n    function forInRight(object, callback, thisArg) {\n      var pairs = [];\n\n      forIn(object, function(value, key) {\n        pairs.push(key, value);\n      });\n\n      var length = pairs.length;\n      callback = baseCreateCallback(callback, thisArg, 3);\n      while (length--) {\n        if (callback(pairs[length--], pairs[length], object) === false) {\n          break;\n        }\n      }\n      return object;\n    }\n\n    /**\n     * Iterates over own enumerable properties of an object, executing the callback\n     * for each property. The callback is bound to `thisArg` and invoked with three\n     * arguments; (value, key, object). Callbacks may exit iteration early by\n     * explicitly returning `false`.\n     *\n     * @static\n     * @memberOf _\n     * @type Function\n     * @category Objects\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [callback=identity] The function called per iteration.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * _.forOwn({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {\n     *   console.log(key);\n     * });\n     * // => logs '0', '1', and 'length' (property order is not guaranteed across environments)\n     */\n    var forOwn = function(collection, callback, thisArg) {\n      var index, iterable = collection, result = iterable;\n      if (!iterable) return result;\n      if (!objectTypes[typeof iterable]) return result;\n      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);\n        var ownIndex = -1,\n            ownProps = objectTypes[typeof iterable] && keys(iterable),\n            length = ownProps ? ownProps.length : 0;\n\n        while (++ownIndex < length) {\n          index = ownProps[ownIndex];\n          if (callback(iterable[index], index, collection) === false) return result;\n        }\n      return result\n    };\n\n    /**\n     * This method is like `_.forOwn` except that it iterates over elements\n     * of a `collection` in the opposite order.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [callback=identity] The function called per iteration.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * _.forOwnRight({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {\n     *   console.log(key);\n     * });\n     * // => logs 'length', '1', and '0' assuming `_.forOwn` logs '0', '1', and 'length'\n     */\n    function forOwnRight(object, callback, thisArg) {\n      var props = keys(object),\n          length = props.length;\n\n      callback = baseCreateCallback(callback, thisArg, 3);\n      while (length--) {\n        var key = props[length];\n        if (callback(object[key], key, object) === false) {\n          break;\n        }\n      }\n      return object;\n    }\n\n    /**\n     * Creates a sorted array of property names of all enumerable properties,\n     * own and inherited, of `object` that have function values.\n     *\n     * @static\n     * @memberOf _\n     * @alias methods\n     * @category Objects\n     * @param {Object} object The object to inspect.\n     * @returns {Array} Returns an array of property names that have function values.\n     * @example\n     *\n     * _.functions(_);\n     * // => ['all', 'any', 'bind', 'bindAll', 'clone', 'compact', 'compose', ...]\n     */\n    function functions(object) {\n      var result = [];\n      forIn(object, function(value, key) {\n        if (isFunction(value)) {\n          result.push(key);\n        }\n      });\n      return result.sort();\n    }\n\n    /**\n     * Checks if the specified property name exists as a direct property of `object`,\n     * instead of an inherited property.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The object to inspect.\n     * @param {string} key The name of the property to check.\n     * @returns {boolean} Returns `true` if key is a direct property, else `false`.\n     * @example\n     *\n     * _.has({ 'a': 1, 'b': 2, 'c': 3 }, 'b');\n     * // => true\n     */\n    function has(object, key) {\n      return object ? hasOwnProperty.call(object, key) : false;\n    }\n\n    /**\n     * Creates an object composed of the inverted keys and values of the given object.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The object to invert.\n     * @returns {Object} Returns the created inverted object.\n     * @example\n     *\n     * _.invert({ 'first': 'fred', 'second': 'barney' });\n     * // => { 'fred': 'first', 'barney': 'second' }\n     */\n    function invert(object) {\n      var index = -1,\n          props = keys(object),\n          length = props.length,\n          result = {};\n\n      while (++index < length) {\n        var key = props[index];\n        result[object[key]] = key;\n      }\n      return result;\n    }\n\n    /**\n     * Checks if `value` is a boolean value.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the `value` is a boolean value, else `false`.\n     * @example\n     *\n     * _.isBoolean(null);\n     * // => false\n     */\n    function isBoolean(value) {\n      return value === true || value === false ||\n        value && typeof value == 'object' && toString.call(value) == boolClass || false;\n    }\n\n    /**\n     * Checks if `value` is a date.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the `value` is a date, else `false`.\n     * @example\n     *\n     * _.isDate(new Date);\n     * // => true\n     */\n    function isDate(value) {\n      return value && typeof value == 'object' && toString.call(value) == dateClass || false;\n    }\n\n    /**\n     * Checks if `value` is a DOM element.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the `value` is a DOM element, else `false`.\n     * @example\n     *\n     * _.isElement(document.body);\n     * // => true\n     */\n    function isElement(value) {\n      return value && value.nodeType === 1 || false;\n    }\n\n    /**\n     * Checks if `value` is empty. Arrays, strings, or `arguments` objects with a\n     * length of `0` and objects with no own enumerable properties are considered\n     * \"empty\".\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Array|Object|string} value The value to inspect.\n     * @returns {boolean} Returns `true` if the `value` is empty, else `false`.\n     * @example\n     *\n     * _.isEmpty([1, 2, 3]);\n     * // => false\n     *\n     * _.isEmpty({});\n     * // => true\n     *\n     * _.isEmpty('');\n     * // => true\n     */\n    function isEmpty(value) {\n      var result = true;\n      if (!value) {\n        return result;\n      }\n      var className = toString.call(value),\n          length = value.length;\n\n      if ((className == arrayClass || className == stringClass || className == argsClass ) ||\n          (className == objectClass && typeof length == 'number' && isFunction(value.splice))) {\n        return !length;\n      }\n      forOwn(value, function() {\n        return (result = false);\n      });\n      return result;\n    }\n\n    /**\n     * Performs a deep comparison between two values to determine if they are\n     * equivalent to each other. If a callback is provided it will be executed\n     * to compare values. If the callback returns `undefined` comparisons will\n     * be handled by the method instead. The callback is bound to `thisArg` and\n     * invoked with two arguments; (a, b).\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} a The value to compare.\n     * @param {*} b The other value to compare.\n     * @param {Function} [callback] The function to customize comparing values.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     * @example\n     *\n     * var object = { 'name': 'fred' };\n     * var copy = { 'name': 'fred' };\n     *\n     * object == copy;\n     * // => false\n     *\n     * _.isEqual(object, copy);\n     * // => true\n     *\n     * var words = ['hello', 'goodbye'];\n     * var otherWords = ['hi', 'goodbye'];\n     *\n     * _.isEqual(words, otherWords, function(a, b) {\n     *   var reGreet = /^(?:hello|hi)$/i,\n     *       aGreet = _.isString(a) && reGreet.test(a),\n     *       bGreet = _.isString(b) && reGreet.test(b);\n     *\n     *   return (aGreet || bGreet) ? (aGreet == bGreet) : undefined;\n     * });\n     * // => true\n     */\n    function isEqual(a, b, callback, thisArg) {\n      return baseIsEqual(a, b, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 2));\n    }\n\n    /**\n     * Checks if `value` is, or can be coerced to, a finite number.\n     *\n     * Note: This is not the same as native `isFinite` which will return true for\n     * booleans and empty strings. See http://es5.github.io/#x15.1.2.5.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the `value` is finite, else `false`.\n     * @example\n     *\n     * _.isFinite(-101);\n     * // => true\n     *\n     * _.isFinite('10');\n     * // => true\n     *\n     * _.isFinite(true);\n     * // => false\n     *\n     * _.isFinite('');\n     * // => false\n     *\n     * _.isFinite(Infinity);\n     * // => false\n     */\n    function isFinite(value) {\n      return nativeIsFinite(value) && !nativeIsNaN(parseFloat(value));\n    }\n\n    /**\n     * Checks if `value` is a function.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the `value` is a function, else `false`.\n     * @example\n     *\n     * _.isFunction(_);\n     * // => true\n     */\n    function isFunction(value) {\n      return typeof value == 'function';\n    }\n\n    /**\n     * Checks if `value` is the language type of Object.\n     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the `value` is an object, else `false`.\n     * @example\n     *\n     * _.isObject({});\n     * // => true\n     *\n     * _.isObject([1, 2, 3]);\n     * // => true\n     *\n     * _.isObject(1);\n     * // => false\n     */\n    function isObject(value) {\n      // check if the value is the ECMAScript language type of Object\n      // http://es5.github.io/#x8\n      // and avoid a V8 bug\n      // http://code.google.com/p/v8/issues/detail?id=2291\n      return !!(value && objectTypes[typeof value]);\n    }\n\n    /**\n     * Checks if `value` is `NaN`.\n     *\n     * Note: This is not the same as native `isNaN` which will return `true` for\n     * `undefined` and other non-numeric values. See http://es5.github.io/#x15.1.2.4.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the `value` is `NaN`, else `false`.\n     * @example\n     *\n     * _.isNaN(NaN);\n     * // => true\n     *\n     * _.isNaN(new Number(NaN));\n     * // => true\n     *\n     * isNaN(undefined);\n     * // => true\n     *\n     * _.isNaN(undefined);\n     * // => false\n     */\n    function isNaN(value) {\n      // `NaN` as a primitive is the only value that is not equal to itself\n      // (perform the [[Class]] check first to avoid errors with some host objects in IE)\n      return isNumber(value) && value != +value;\n    }\n\n    /**\n     * Checks if `value` is `null`.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the `value` is `null`, else `false`.\n     * @example\n     *\n     * _.isNull(null);\n     * // => true\n     *\n     * _.isNull(undefined);\n     * // => false\n     */\n    function isNull(value) {\n      return value === null;\n    }\n\n    /**\n     * Checks if `value` is a number.\n     *\n     * Note: `NaN` is considered a number. See http://es5.github.io/#x8.5.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the `value` is a number, else `false`.\n     * @example\n     *\n     * _.isNumber(8.4 * 5);\n     * // => true\n     */\n    function isNumber(value) {\n      return typeof value == 'number' ||\n        value && typeof value == 'object' && toString.call(value) == numberClass || false;\n    }\n\n    /**\n     * Checks if `value` is an object created by the `Object` constructor.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n     * @example\n     *\n     * function Shape() {\n     *   this.x = 0;\n     *   this.y = 0;\n     * }\n     *\n     * _.isPlainObject(new Shape);\n     * // => false\n     *\n     * _.isPlainObject([1, 2, 3]);\n     * // => false\n     *\n     * _.isPlainObject({ 'x': 0, 'y': 0 });\n     * // => true\n     */\n    var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function(value) {\n      if (!(value && toString.call(value) == objectClass)) {\n        return false;\n      }\n      var valueOf = value.valueOf,\n          objProto = isNative(valueOf) && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);\n\n      return objProto\n        ? (value == objProto || getPrototypeOf(value) == objProto)\n        : shimIsPlainObject(value);\n    };\n\n    /**\n     * Checks if `value` is a regular expression.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the `value` is a regular expression, else `false`.\n     * @example\n     *\n     * _.isRegExp(/fred/);\n     * // => true\n     */\n    function isRegExp(value) {\n      return value && typeof value == 'object' && toString.call(value) == regexpClass || false;\n    }\n\n    /**\n     * Checks if `value` is a string.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the `value` is a string, else `false`.\n     * @example\n     *\n     * _.isString('fred');\n     * // => true\n     */\n    function isString(value) {\n      return typeof value == 'string' ||\n        value && typeof value == 'object' && toString.call(value) == stringClass || false;\n    }\n\n    /**\n     * Checks if `value` is `undefined`.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the `value` is `undefined`, else `false`.\n     * @example\n     *\n     * _.isUndefined(void 0);\n     * // => true\n     */\n    function isUndefined(value) {\n      return typeof value == 'undefined';\n    }\n\n    /**\n     * Creates an object with the same keys as `object` and values generated by\n     * running each own enumerable property of `object` through the callback.\n     * The callback is bound to `thisArg` and invoked with three arguments;\n     * (value, key, object).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The object to iterate over.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Array} Returns a new object with values of the results of each `callback` execution.\n     * @example\n     *\n     * _.mapValues({ 'a': 1, 'b': 2, 'c': 3} , function(num) { return num * 3; });\n     * // => { 'a': 3, 'b': 6, 'c': 9 }\n     *\n     * var characters = {\n     *   'fred': { 'name': 'fred', 'age': 40 },\n     *   'pebbles': { 'name': 'pebbles', 'age': 1 }\n     * };\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.mapValues(characters, 'age');\n     * // => { 'fred': 40, 'pebbles': 1 }\n     */\n    function mapValues(object, callback, thisArg) {\n      var result = {};\n      callback = lodash.createCallback(callback, thisArg, 3);\n\n      forOwn(object, function(value, key, object) {\n        result[key] = callback(value, key, object);\n      });\n      return result;\n    }\n\n    /**\n     * Recursively merges own enumerable properties of the source object(s), that\n     * don't resolve to `undefined` into the destination object. Subsequent sources\n     * will overwrite property assignments of previous sources. If a callback is\n     * provided it will be executed to produce the merged values of the destination\n     * and source properties. If the callback returns `undefined` merging will\n     * be handled by the method instead. The callback is bound to `thisArg` and\n     * invoked with two arguments; (objectValue, sourceValue).\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The destination object.\n     * @param {...Object} [source] The source objects.\n     * @param {Function} [callback] The function to customize merging properties.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Object} Returns the destination object.\n     * @example\n     *\n     * var names = {\n     *   'characters': [\n     *     { 'name': 'barney' },\n     *     { 'name': 'fred' }\n     *   ]\n     * };\n     *\n     * var ages = {\n     *   'characters': [\n     *     { 'age': 36 },\n     *     { 'age': 40 }\n     *   ]\n     * };\n     *\n     * _.merge(names, ages);\n     * // => { 'characters': [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred', 'age': 40 }] }\n     *\n     * var food = {\n     *   'fruits': ['apple'],\n     *   'vegetables': ['beet']\n     * };\n     *\n     * var otherFood = {\n     *   'fruits': ['banana'],\n     *   'vegetables': ['carrot']\n     * };\n     *\n     * _.merge(food, otherFood, function(a, b) {\n     *   return _.isArray(a) ? a.concat(b) : undefined;\n     * });\n     * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot] }\n     */\n    function merge(object) {\n      var args = arguments,\n          length = 2;\n\n      if (!isObject(object)) {\n        return object;\n      }\n      // allows working with `_.reduce` and `_.reduceRight` without using\n      // their `index` and `collection` arguments\n      if (typeof args[2] != 'number') {\n        length = args.length;\n      }\n      if (length > 3 && typeof args[length - 2] == 'function') {\n        var callback = baseCreateCallback(args[--length - 1], args[length--], 2);\n      } else if (length > 2 && typeof args[length - 1] == 'function') {\n        callback = args[--length];\n      }\n      var sources = slice(arguments, 1, length),\n          index = -1,\n          stackA = getArray(),\n          stackB = getArray();\n\n      while (++index < length) {\n        baseMerge(object, sources[index], callback, stackA, stackB);\n      }\n      releaseArray(stackA);\n      releaseArray(stackB);\n      return object;\n    }\n\n    /**\n     * Creates a shallow clone of `object` excluding the specified properties.\n     * Property names may be specified as individual arguments or as arrays of\n     * property names. If a callback is provided it will be executed for each\n     * property of `object` omitting the properties the callback returns truey\n     * for. The callback is bound to `thisArg` and invoked with three arguments;\n     * (value, key, object).\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The source object.\n     * @param {Function|...string|string[]} [callback] The properties to omit or the\n     *  function called per iteration.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Object} Returns an object without the omitted properties.\n     * @example\n     *\n     * _.omit({ 'name': 'fred', 'age': 40 }, 'age');\n     * // => { 'name': 'fred' }\n     *\n     * _.omit({ 'name': 'fred', 'age': 40 }, function(value) {\n     *   return typeof value == 'number';\n     * });\n     * // => { 'name': 'fred' }\n     */\n    function omit(object, callback, thisArg) {\n      var result = {};\n      if (typeof callback != 'function') {\n        var props = [];\n        forIn(object, function(value, key) {\n          props.push(key);\n        });\n        props = baseDifference(props, baseFlatten(arguments, true, false, 1));\n\n        var index = -1,\n            length = props.length;\n\n        while (++index < length) {\n          var key = props[index];\n          result[key] = object[key];\n        }\n      } else {\n        callback = lodash.createCallback(callback, thisArg, 3);\n        forIn(object, function(value, key, object) {\n          if (!callback(value, key, object)) {\n            result[key] = value;\n          }\n        });\n      }\n      return result;\n    }\n\n    /**\n     * Creates a two dimensional array of an object's key-value pairs,\n     * i.e. `[[key1, value1], [key2, value2]]`.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The object to inspect.\n     * @returns {Array} Returns new array of key-value pairs.\n     * @example\n     *\n     * _.pairs({ 'barney': 36, 'fred': 40 });\n     * // => [['barney', 36], ['fred', 40]] (property order is not guaranteed across environments)\n     */\n    function pairs(object) {\n      var index = -1,\n          props = keys(object),\n          length = props.length,\n          result = Array(length);\n\n      while (++index < length) {\n        var key = props[index];\n        result[index] = [key, object[key]];\n      }\n      return result;\n    }\n\n    /**\n     * Creates a shallow clone of `object` composed of the specified properties.\n     * Property names may be specified as individual arguments or as arrays of\n     * property names. If a callback is provided it will be executed for each\n     * property of `object` picking the properties the callback returns truey\n     * for. The callback is bound to `thisArg` and invoked with three arguments;\n     * (value, key, object).\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The source object.\n     * @param {Function|...string|string[]} [callback] The function called per\n     *  iteration or property names to pick, specified as individual property\n     *  names or arrays of property names.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Object} Returns an object composed of the picked properties.\n     * @example\n     *\n     * _.pick({ 'name': 'fred', '_userid': 'fred1' }, 'name');\n     * // => { 'name': 'fred' }\n     *\n     * _.pick({ 'name': 'fred', '_userid': 'fred1' }, function(value, key) {\n     *   return key.charAt(0) != '_';\n     * });\n     * // => { 'name': 'fred' }\n     */\n    function pick(object, callback, thisArg) {\n      var result = {};\n      if (typeof callback != 'function') {\n        var index = -1,\n            props = baseFlatten(arguments, true, false, 1),\n            length = isObject(object) ? props.length : 0;\n\n        while (++index < length) {\n          var key = props[index];\n          if (key in object) {\n            result[key] = object[key];\n          }\n        }\n      } else {\n        callback = lodash.createCallback(callback, thisArg, 3);\n        forIn(object, function(value, key, object) {\n          if (callback(value, key, object)) {\n            result[key] = value;\n          }\n        });\n      }\n      return result;\n    }\n\n    /**\n     * An alternative to `_.reduce` this method transforms `object` to a new\n     * `accumulator` object which is the result of running each of its own\n     * enumerable properties through a callback, with each callback execution\n     * potentially mutating the `accumulator` object. The callback is bound to\n     * `thisArg` and invoked with four arguments; (accumulator, value, key, object).\n     * Callbacks may exit iteration early by explicitly returning `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Array|Object} object The object to iterate over.\n     * @param {Function} [callback=identity] The function called per iteration.\n     * @param {*} [accumulator] The custom accumulator value.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {*} Returns the accumulated value.\n     * @example\n     *\n     * var squares = _.transform([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], function(result, num) {\n     *   num *= num;\n     *   if (num % 2) {\n     *     return result.push(num) < 3;\n     *   }\n     * });\n     * // => [1, 9, 25]\n     *\n     * var mapped = _.transform({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {\n     *   result[key] = num * 3;\n     * });\n     * // => { 'a': 3, 'b': 6, 'c': 9 }\n     */\n    function transform(object, callback, accumulator, thisArg) {\n      var isArr = isArray(object);\n      if (accumulator == null) {\n        if (isArr) {\n          accumulator = [];\n        } else {\n          var ctor = object && object.constructor,\n              proto = ctor && ctor.prototype;\n\n          accumulator = baseCreate(proto);\n        }\n      }\n      if (callback) {\n        callback = lodash.createCallback(callback, thisArg, 4);\n        (isArr ? forEach : forOwn)(object, function(value, index, object) {\n          return callback(accumulator, value, index, object);\n        });\n      }\n      return accumulator;\n    }\n\n    /**\n     * Creates an array composed of the own enumerable property values of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The object to inspect.\n     * @returns {Array} Returns an array of property values.\n     * @example\n     *\n     * _.values({ 'one': 1, 'two': 2, 'three': 3 });\n     * // => [1, 2, 3] (property order is not guaranteed across environments)\n     */\n    function values(object) {\n      var index = -1,\n          props = keys(object),\n          length = props.length,\n          result = Array(length);\n\n      while (++index < length) {\n        result[index] = object[props[index]];\n      }\n      return result;\n    }\n\n    /*--------------------------------------------------------------------------*/\n\n    /**\n     * Creates an array of elements from the specified indexes, or keys, of the\n     * `collection`. Indexes may be specified as individual arguments or as arrays\n     * of indexes.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {...(number|number[]|string|string[])} [index] The indexes of `collection`\n     *   to retrieve, specified as individual indexes or arrays of indexes.\n     * @returns {Array} Returns a new array of elements corresponding to the\n     *  provided indexes.\n     * @example\n     *\n     * _.at(['a', 'b', 'c', 'd', 'e'], [0, 2, 4]);\n     * // => ['a', 'c', 'e']\n     *\n     * _.at(['fred', 'barney', 'pebbles'], 0, 2);\n     * // => ['fred', 'pebbles']\n     */\n    function at(collection) {\n      var args = arguments,\n          index = -1,\n          props = baseFlatten(args, true, false, 1),\n          length = (args[2] && args[2][args[1]] === collection) ? 1 : props.length,\n          result = Array(length);\n\n      while(++index < length) {\n        result[index] = collection[props[index]];\n      }\n      return result;\n    }\n\n    /**\n     * Checks if a given value is present in a collection using strict equality\n     * for comparisons, i.e. `===`. If `fromIndex` is negative, it is used as the\n     * offset from the end of the collection.\n     *\n     * @static\n     * @memberOf _\n     * @alias include\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {*} target The value to check for.\n     * @param {number} [fromIndex=0] The index to search from.\n     * @returns {boolean} Returns `true` if the `target` element is found, else `false`.\n     * @example\n     *\n     * _.contains([1, 2, 3], 1);\n     * // => true\n     *\n     * _.contains([1, 2, 3], 1, 2);\n     * // => false\n     *\n     * _.contains({ 'name': 'fred', 'age': 40 }, 'fred');\n     * // => true\n     *\n     * _.contains('pebbles', 'eb');\n     * // => true\n     */\n    function contains(collection, target, fromIndex) {\n      var index = -1,\n          indexOf = getIndexOf(),\n          length = collection ? collection.length : 0,\n          result = false;\n\n      fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex) || 0;\n      if (isArray(collection)) {\n        result = indexOf(collection, target, fromIndex) > -1;\n      } else if (typeof length == 'number') {\n        result = (isString(collection) ? collection.indexOf(target, fromIndex) : indexOf(collection, target, fromIndex)) > -1;\n      } else {\n        forOwn(collection, function(value) {\n          if (++index >= fromIndex) {\n            return !(result = value === target);\n          }\n        });\n      }\n      return result;\n    }\n\n    /**\n     * Creates an object composed of keys generated from the results of running\n     * each element of `collection` through the callback. The corresponding value\n     * of each key is the number of times the key was returned by the callback.\n     * The callback is bound to `thisArg` and invoked with three arguments;\n     * (value, index|key, collection).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Object} Returns the composed aggregate object.\n     * @example\n     *\n     * _.countBy([4.3, 6.1, 6.4], function(num) { return Math.floor(num); });\n     * // => { '4': 1, '6': 2 }\n     *\n     * _.countBy([4.3, 6.1, 6.4], function(num) { return this.floor(num); }, Math);\n     * // => { '4': 1, '6': 2 }\n     *\n     * _.countBy(['one', 'two', 'three'], 'length');\n     * // => { '3': 2, '5': 1 }\n     */\n    var countBy = createAggregator(function(result, value, key) {\n      (hasOwnProperty.call(result, key) ? result[key]++ : result[key] = 1);\n    });\n\n    /**\n     * Checks if the given callback returns truey value for **all** elements of\n     * a collection. The callback is bound to `thisArg` and invoked with three\n     * arguments; (value, index|key, collection).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @alias all\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {boolean} Returns `true` if all elements passed the callback check,\n     *  else `false`.\n     * @example\n     *\n     * _.every([true, 1, null, 'yes']);\n     * // => false\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36 },\n     *   { 'name': 'fred',   'age': 40 }\n     * ];\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.every(characters, 'age');\n     * // => true\n     *\n     * // using \"_.where\" callback shorthand\n     * _.every(characters, { 'age': 36 });\n     * // => false\n     */\n    function every(collection, callback, thisArg) {\n      var result = true;\n      callback = lodash.createCallback(callback, thisArg, 3);\n\n      var index = -1,\n          length = collection ? collection.length : 0;\n\n      if (typeof length == 'number') {\n        while (++index < length) {\n          if (!(result = !!callback(collection[index], index, collection))) {\n            break;\n          }\n        }\n      } else {\n        forOwn(collection, function(value, index, collection) {\n          return (result = !!callback(value, index, collection));\n        });\n      }\n      return result;\n    }\n\n    /**\n     * Iterates over elements of a collection, returning an array of all elements\n     * the callback returns truey for. The callback is bound to `thisArg` and\n     * invoked with three arguments; (value, index|key, collection).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @alias select\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Array} Returns a new array of elements that passed the callback check.\n     * @example\n     *\n     * var evens = _.filter([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });\n     * // => [2, 4, 6]\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36, 'blocked': false },\n     *   { 'name': 'fred',   'age': 40, 'blocked': true }\n     * ];\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.filter(characters, 'blocked');\n     * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]\n     *\n     * // using \"_.where\" callback shorthand\n     * _.filter(characters, { 'age': 36 });\n     * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]\n     */\n    function filter(collection, callback, thisArg) {\n      var result = [];\n      callback = lodash.createCallback(callback, thisArg, 3);\n\n      var index = -1,\n          length = collection ? collection.length : 0;\n\n      if (typeof length == 'number') {\n        while (++index < length) {\n          var value = collection[index];\n          if (callback(value, index, collection)) {\n            result.push(value);\n          }\n        }\n      } else {\n        forOwn(collection, function(value, index, collection) {\n          if (callback(value, index, collection)) {\n            result.push(value);\n          }\n        });\n      }\n      return result;\n    }\n\n    /**\n     * Iterates over elements of a collection, returning the first element that\n     * the callback returns truey for. The callback is bound to `thisArg` and\n     * invoked with three arguments; (value, index|key, collection).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @alias detect, findWhere\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {*} Returns the found element, else `undefined`.\n     * @example\n     *\n     * var characters = [\n     *   { 'name': 'barney',  'age': 36, 'blocked': false },\n     *   { 'name': 'fred',    'age': 40, 'blocked': true },\n     *   { 'name': 'pebbles', 'age': 1,  'blocked': false }\n     * ];\n     *\n     * _.find(characters, function(chr) {\n     *   return chr.age < 40;\n     * });\n     * // => { 'name': 'barney', 'age': 36, 'blocked': false }\n     *\n     * // using \"_.where\" callback shorthand\n     * _.find(characters, { 'age': 1 });\n     * // =>  { 'name': 'pebbles', 'age': 1, 'blocked': false }\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.find(characters, 'blocked');\n     * // => { 'name': 'fred', 'age': 40, 'blocked': true }\n     */\n    function find(collection, callback, thisArg) {\n      callback = lodash.createCallback(callback, thisArg, 3);\n\n      var index = -1,\n          length = collection ? collection.length : 0;\n\n      if (typeof length == 'number') {\n        while (++index < length) {\n          var value = collection[index];\n          if (callback(value, index, collection)) {\n            return value;\n          }\n        }\n      } else {\n        var result;\n        forOwn(collection, function(value, index, collection) {\n          if (callback(value, index, collection)) {\n            result = value;\n            return false;\n          }\n        });\n        return result;\n      }\n    }\n\n    /**\n     * This method is like `_.find` except that it iterates over elements\n     * of a `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {*} Returns the found element, else `undefined`.\n     * @example\n     *\n     * _.findLast([1, 2, 3, 4], function(num) {\n     *   return num % 2 == 1;\n     * });\n     * // => 3\n     */\n    function findLast(collection, callback, thisArg) {\n      var result;\n      callback = lodash.createCallback(callback, thisArg, 3);\n      forEachRight(collection, function(value, index, collection) {\n        if (callback(value, index, collection)) {\n          result = value;\n          return false;\n        }\n      });\n      return result;\n    }\n\n    /**\n     * Iterates over elements of a collection, executing the callback for each\n     * element. The callback is bound to `thisArg` and invoked with three arguments;\n     * (value, index|key, collection). Callbacks may exit iteration early by\n     * explicitly returning `false`.\n     *\n     * Note: As with other \"Collections\" methods, objects with a `length` property\n     * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`\n     * may be used for object iteration.\n     *\n     * @static\n     * @memberOf _\n     * @alias each\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function} [callback=identity] The function called per iteration.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Array|Object|string} Returns `collection`.\n     * @example\n     *\n     * _([1, 2, 3]).forEach(function(num) { console.log(num); }).join(',');\n     * // => logs each number and returns '1,2,3'\n     *\n     * _.forEach({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { console.log(num); });\n     * // => logs each number and returns the object (property order is not guaranteed across environments)\n     */\n    function forEach(collection, callback, thisArg) {\n      var index = -1,\n          length = collection ? collection.length : 0;\n\n      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);\n      if (typeof length == 'number') {\n        while (++index < length) {\n          if (callback(collection[index], index, collection) === false) {\n            break;\n          }\n        }\n      } else {\n        forOwn(collection, callback);\n      }\n      return collection;\n    }\n\n    /**\n     * This method is like `_.forEach` except that it iterates over elements\n     * of a `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @alias eachRight\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function} [callback=identity] The function called per iteration.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Array|Object|string} Returns `collection`.\n     * @example\n     *\n     * _([1, 2, 3]).forEachRight(function(num) { console.log(num); }).join(',');\n     * // => logs each number from right to left and returns '3,2,1'\n     */\n    function forEachRight(collection, callback, thisArg) {\n      var length = collection ? collection.length : 0;\n      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);\n      if (typeof length == 'number') {\n        while (length--) {\n          if (callback(collection[length], length, collection) === false) {\n            break;\n          }\n        }\n      } else {\n        var props = keys(collection);\n        length = props.length;\n        forOwn(collection, function(value, key, collection) {\n          key = props ? props[--length] : --length;\n          return callback(collection[key], key, collection);\n        });\n      }\n      return collection;\n    }\n\n    /**\n     * Creates an object composed of keys generated from the results of running\n     * each element of a collection through the callback. The corresponding value\n     * of each key is an array of the elements responsible for generating the key.\n     * The callback is bound to `thisArg` and invoked with three arguments;\n     * (value, index|key, collection).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Object} Returns the composed aggregate object.\n     * @example\n     *\n     * _.groupBy([4.2, 6.1, 6.4], function(num) { return Math.floor(num); });\n     * // => { '4': [4.2], '6': [6.1, 6.4] }\n     *\n     * _.groupBy([4.2, 6.1, 6.4], function(num) { return this.floor(num); }, Math);\n     * // => { '4': [4.2], '6': [6.1, 6.4] }\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.groupBy(['one', 'two', 'three'], 'length');\n     * // => { '3': ['one', 'two'], '5': ['three'] }\n     */\n    var groupBy = createAggregator(function(result, value, key) {\n      (hasOwnProperty.call(result, key) ? result[key] : result[key] = []).push(value);\n    });\n\n    /**\n     * Creates an object composed of keys generated from the results of running\n     * each element of the collection through the given callback. The corresponding\n     * value of each key is the last element responsible for generating the key.\n     * The callback is bound to `thisArg` and invoked with three arguments;\n     * (value, index|key, collection).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Object} Returns the composed aggregate object.\n     * @example\n     *\n     * var keys = [\n     *   { 'dir': 'left', 'code': 97 },\n     *   { 'dir': 'right', 'code': 100 }\n     * ];\n     *\n     * _.indexBy(keys, 'dir');\n     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }\n     *\n     * _.indexBy(keys, function(key) { return String.fromCharCode(key.code); });\n     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }\n     *\n     * _.indexBy(characters, function(key) { this.fromCharCode(key.code); }, String);\n     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }\n     */\n    var indexBy = createAggregator(function(result, value, key) {\n      result[key] = value;\n    });\n\n    /**\n     * Invokes the method named by `methodName` on each element in the `collection`\n     * returning an array of the results of each invoked method. Additional arguments\n     * will be provided to each invoked method. If `methodName` is a function it\n     * will be invoked for, and `this` bound to, each element in the `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|string} methodName The name of the method to invoke or\n     *  the function invoked per iteration.\n     * @param {...*} [arg] Arguments to invoke the method with.\n     * @returns {Array} Returns a new array of the results of each invoked method.\n     * @example\n     *\n     * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');\n     * // => [[1, 5, 7], [1, 2, 3]]\n     *\n     * _.invoke([123, 456], String.prototype.split, '');\n     * // => [['1', '2', '3'], ['4', '5', '6']]\n     */\n    function invoke(collection, methodName) {\n      var args = slice(arguments, 2),\n          index = -1,\n          isFunc = typeof methodName == 'function',\n          length = collection ? collection.length : 0,\n          result = Array(typeof length == 'number' ? length : 0);\n\n      forEach(collection, function(value) {\n        result[++index] = (isFunc ? methodName : value[methodName]).apply(value, args);\n      });\n      return result;\n    }\n\n    /**\n     * Creates an array of values by running each element in the collection\n     * through the callback. The callback is bound to `thisArg` and invoked with\n     * three arguments; (value, index|key, collection).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @alias collect\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Array} Returns a new array of the results of each `callback` execution.\n     * @example\n     *\n     * _.map([1, 2, 3], function(num) { return num * 3; });\n     * // => [3, 6, 9]\n     *\n     * _.map({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { return num * 3; });\n     * // => [3, 6, 9] (property order is not guaranteed across environments)\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36 },\n     *   { 'name': 'fred',   'age': 40 }\n     * ];\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.map(characters, 'name');\n     * // => ['barney', 'fred']\n     */\n    function map(collection, callback, thisArg) {\n      var index = -1,\n          length = collection ? collection.length : 0;\n\n      callback = lodash.createCallback(callback, thisArg, 3);\n      if (typeof length == 'number') {\n        var result = Array(length);\n        while (++index < length) {\n          result[index] = callback(collection[index], index, collection);\n        }\n      } else {\n        result = [];\n        forOwn(collection, function(value, key, collection) {\n          result[++index] = callback(value, key, collection);\n        });\n      }\n      return result;\n    }\n\n    /**\n     * Retrieves the maximum value of a collection. If the collection is empty or\n     * falsey `-Infinity` is returned. If a callback is provided it will be executed\n     * for each value in the collection to generate the criterion by which the value\n     * is ranked. The callback is bound to `thisArg` and invoked with three\n     * arguments; (value, index, collection).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {*} Returns the maximum value.\n     * @example\n     *\n     * _.max([4, 2, 8, 6]);\n     * // => 8\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36 },\n     *   { 'name': 'fred',   'age': 40 }\n     * ];\n     *\n     * _.max(characters, function(chr) { return chr.age; });\n     * // => { 'name': 'fred', 'age': 40 };\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.max(characters, 'age');\n     * // => { 'name': 'fred', 'age': 40 };\n     */\n    function max(collection, callback, thisArg) {\n      var computed = -Infinity,\n          result = computed;\n\n      // allows working with functions like `_.map` without using\n      // their `index` argument as a callback\n      if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {\n        callback = null;\n      }\n      if (callback == null && isArray(collection)) {\n        var index = -1,\n            length = collection.length;\n\n        while (++index < length) {\n          var value = collection[index];\n          if (value > result) {\n            result = value;\n          }\n        }\n      } else {\n        callback = (callback == null && isString(collection))\n          ? charAtCallback\n          : lodash.createCallback(callback, thisArg, 3);\n\n        forEach(collection, function(value, index, collection) {\n          var current = callback(value, index, collection);\n          if (current > computed) {\n            computed = current;\n            result = value;\n          }\n        });\n      }\n      return result;\n    }\n\n    /**\n     * Retrieves the minimum value of a collection. If the collection is empty or\n     * falsey `Infinity` is returned. If a callback is provided it will be executed\n     * for each value in the collection to generate the criterion by which the value\n     * is ranked. The callback is bound to `thisArg` and invoked with three\n     * arguments; (value, index, collection).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {*} Returns the minimum value.\n     * @example\n     *\n     * _.min([4, 2, 8, 6]);\n     * // => 2\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36 },\n     *   { 'name': 'fred',   'age': 40 }\n     * ];\n     *\n     * _.min(characters, function(chr) { return chr.age; });\n     * // => { 'name': 'barney', 'age': 36 };\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.min(characters, 'age');\n     * // => { 'name': 'barney', 'age': 36 };\n     */\n    function min(collection, callback, thisArg) {\n      var computed = Infinity,\n          result = computed;\n\n      // allows working with functions like `_.map` without using\n      // their `index` argument as a callback\n      if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {\n        callback = null;\n      }\n      if (callback == null && isArray(collection)) {\n        var index = -1,\n            length = collection.length;\n\n        while (++index < length) {\n          var value = collection[index];\n          if (value < result) {\n            result = value;\n          }\n        }\n      } else {\n        callback = (callback == null && isString(collection))\n          ? charAtCallback\n          : lodash.createCallback(callback, thisArg, 3);\n\n        forEach(collection, function(value, index, collection) {\n          var current = callback(value, index, collection);\n          if (current < computed) {\n            computed = current;\n            result = value;\n          }\n        });\n      }\n      return result;\n    }\n\n    /**\n     * Retrieves the value of a specified property from all elements in the collection.\n     *\n     * @static\n     * @memberOf _\n     * @type Function\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {string} property The name of the property to pluck.\n     * @returns {Array} Returns a new array of property values.\n     * @example\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36 },\n     *   { 'name': 'fred',   'age': 40 }\n     * ];\n     *\n     * _.pluck(characters, 'name');\n     * // => ['barney', 'fred']\n     */\n    var pluck = map;\n\n    /**\n     * Reduces a collection to a value which is the accumulated result of running\n     * each element in the collection through the callback, where each successive\n     * callback execution consumes the return value of the previous execution. If\n     * `accumulator` is not provided the first element of the collection will be\n     * used as the initial `accumulator` value. The callback is bound to `thisArg`\n     * and invoked with four arguments; (accumulator, value, index|key, collection).\n     *\n     * @static\n     * @memberOf _\n     * @alias foldl, inject\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function} [callback=identity] The function called per iteration.\n     * @param {*} [accumulator] Initial value of the accumulator.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {*} Returns the accumulated value.\n     * @example\n     *\n     * var sum = _.reduce([1, 2, 3], function(sum, num) {\n     *   return sum + num;\n     * });\n     * // => 6\n     *\n     * var mapped = _.reduce({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {\n     *   result[key] = num * 3;\n     *   return result;\n     * }, {});\n     * // => { 'a': 3, 'b': 6, 'c': 9 }\n     */\n    function reduce(collection, callback, accumulator, thisArg) {\n      if (!collection) return accumulator;\n      var noaccum = arguments.length < 3;\n      callback = lodash.createCallback(callback, thisArg, 4);\n\n      var index = -1,\n          length = collection.length;\n\n      if (typeof length == 'number') {\n        if (noaccum) {\n          accumulator = collection[++index];\n        }\n        while (++index < length) {\n          accumulator = callback(accumulator, collection[index], index, collection);\n        }\n      } else {\n        forOwn(collection, function(value, index, collection) {\n          accumulator = noaccum\n            ? (noaccum = false, value)\n            : callback(accumulator, value, index, collection)\n        });\n      }\n      return accumulator;\n    }\n\n    /**\n     * This method is like `_.reduce` except that it iterates over elements\n     * of a `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @alias foldr\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function} [callback=identity] The function called per iteration.\n     * @param {*} [accumulator] Initial value of the accumulator.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {*} Returns the accumulated value.\n     * @example\n     *\n     * var list = [[0, 1], [2, 3], [4, 5]];\n     * var flat = _.reduceRight(list, function(a, b) { return a.concat(b); }, []);\n     * // => [4, 5, 2, 3, 0, 1]\n     */\n    function reduceRight(collection, callback, accumulator, thisArg) {\n      var noaccum = arguments.length < 3;\n      callback = lodash.createCallback(callback, thisArg, 4);\n      forEachRight(collection, function(value, index, collection) {\n        accumulator = noaccum\n          ? (noaccum = false, value)\n          : callback(accumulator, value, index, collection);\n      });\n      return accumulator;\n    }\n\n    /**\n     * The opposite of `_.filter` this method returns the elements of a\n     * collection that the callback does **not** return truey for.\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Array} Returns a new array of elements that failed the callback check.\n     * @example\n     *\n     * var odds = _.reject([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });\n     * // => [1, 3, 5]\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36, 'blocked': false },\n     *   { 'name': 'fred',   'age': 40, 'blocked': true }\n     * ];\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.reject(characters, 'blocked');\n     * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]\n     *\n     * // using \"_.where\" callback shorthand\n     * _.reject(characters, { 'age': 36 });\n     * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]\n     */\n    function reject(collection, callback, thisArg) {\n      callback = lodash.createCallback(callback, thisArg, 3);\n      return filter(collection, function(value, index, collection) {\n        return !callback(value, index, collection);\n      });\n    }\n\n    /**\n     * Retrieves a random element or `n` random elements from a collection.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to sample.\n     * @param {number} [n] The number of elements to sample.\n     * @param- {Object} [guard] Allows working with functions like `_.map`\n     *  without using their `index` arguments as `n`.\n     * @returns {Array} Returns the random sample(s) of `collection`.\n     * @example\n     *\n     * _.sample([1, 2, 3, 4]);\n     * // => 2\n     *\n     * _.sample([1, 2, 3, 4], 2);\n     * // => [3, 1]\n     */\n    function sample(collection, n, guard) {\n      if (collection && typeof collection.length != 'number') {\n        collection = values(collection);\n      }\n      if (n == null || guard) {\n        return collection ? collection[baseRandom(0, collection.length - 1)] : undefined;\n      }\n      var result = shuffle(collection);\n      result.length = nativeMin(nativeMax(0, n), result.length);\n      return result;\n    }\n\n    /**\n     * Creates an array of shuffled values, using a version of the Fisher-Yates\n     * shuffle. See http://en.wikipedia.org/wiki/Fisher-Yates_shuffle.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to shuffle.\n     * @returns {Array} Returns a new shuffled collection.\n     * @example\n     *\n     * _.shuffle([1, 2, 3, 4, 5, 6]);\n     * // => [4, 1, 6, 3, 5, 2]\n     */\n    function shuffle(collection) {\n      var index = -1,\n          length = collection ? collection.length : 0,\n          result = Array(typeof length == 'number' ? length : 0);\n\n      forEach(collection, function(value) {\n        var rand = baseRandom(0, ++index);\n        result[index] = result[rand];\n        result[rand] = value;\n      });\n      return result;\n    }\n\n    /**\n     * Gets the size of the `collection` by returning `collection.length` for arrays\n     * and array-like objects or the number of own enumerable properties for objects.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to inspect.\n     * @returns {number} Returns `collection.length` or number of own enumerable properties.\n     * @example\n     *\n     * _.size([1, 2]);\n     * // => 2\n     *\n     * _.size({ 'one': 1, 'two': 2, 'three': 3 });\n     * // => 3\n     *\n     * _.size('pebbles');\n     * // => 7\n     */\n    function size(collection) {\n      var length = collection ? collection.length : 0;\n      return typeof length == 'number' ? length : keys(collection).length;\n    }\n\n    /**\n     * Checks if the callback returns a truey value for **any** element of a\n     * collection. The function returns as soon as it finds a passing value and\n     * does not iterate over the entire collection. The callback is bound to\n     * `thisArg` and invoked with three arguments; (value, index|key, collection).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @alias any\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {boolean} Returns `true` if any element passed the callback check,\n     *  else `false`.\n     * @example\n     *\n     * _.some([null, 0, 'yes', false], Boolean);\n     * // => true\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36, 'blocked': false },\n     *   { 'name': 'fred',   'age': 40, 'blocked': true }\n     * ];\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.some(characters, 'blocked');\n     * // => true\n     *\n     * // using \"_.where\" callback shorthand\n     * _.some(characters, { 'age': 1 });\n     * // => false\n     */\n    function some(collection, callback, thisArg) {\n      var result;\n      callback = lodash.createCallback(callback, thisArg, 3);\n\n      var index = -1,\n          length = collection ? collection.length : 0;\n\n      if (typeof length == 'number') {\n        while (++index < length) {\n          if ((result = callback(collection[index], index, collection))) {\n            break;\n          }\n        }\n      } else {\n        forOwn(collection, function(value, index, collection) {\n          return !(result = callback(value, index, collection));\n        });\n      }\n      return !!result;\n    }\n\n    /**\n     * Creates an array of elements, sorted in ascending order by the results of\n     * running each element in a collection through the callback. This method\n     * performs a stable sort, that is, it will preserve the original sort order\n     * of equal elements. The callback is bound to `thisArg` and invoked with\n     * three arguments; (value, index|key, collection).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an array of property names is provided for `callback` the collection\n     * will be sorted by each property value.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Array|Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Array} Returns a new array of sorted elements.\n     * @example\n     *\n     * _.sortBy([1, 2, 3], function(num) { return Math.sin(num); });\n     * // => [3, 1, 2]\n     *\n     * _.sortBy([1, 2, 3], function(num) { return this.sin(num); }, Math);\n     * // => [3, 1, 2]\n     *\n     * var characters = [\n     *   { 'name': 'barney',  'age': 36 },\n     *   { 'name': 'fred',    'age': 40 },\n     *   { 'name': 'barney',  'age': 26 },\n     *   { 'name': 'fred',    'age': 30 }\n     * ];\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.map(_.sortBy(characters, 'age'), _.values);\n     * // => [['barney', 26], ['fred', 30], ['barney', 36], ['fred', 40]]\n     *\n     * // sorting by multiple properties\n     * _.map(_.sortBy(characters, ['name', 'age']), _.values);\n     * // = > [['barney', 26], ['barney', 36], ['fred', 30], ['fred', 40]]\n     */\n    function sortBy(collection, callback, thisArg) {\n      var index = -1,\n          isArr = isArray(callback),\n          length = collection ? collection.length : 0,\n          result = Array(typeof length == 'number' ? length : 0);\n\n      if (!isArr) {\n        callback = lodash.createCallback(callback, thisArg, 3);\n      }\n      forEach(collection, function(value, key, collection) {\n        var object = result[++index] = getObject();\n        if (isArr) {\n          object.criteria = map(callback, function(key) { return value[key]; });\n        } else {\n          (object.criteria = getArray())[0] = callback(value, key, collection);\n        }\n        object.index = index;\n        object.value = value;\n      });\n\n      length = result.length;\n      result.sort(compareAscending);\n      while (length--) {\n        var object = result[length];\n        result[length] = object.value;\n        if (!isArr) {\n          releaseArray(object.criteria);\n        }\n        releaseObject(object);\n      }\n      return result;\n    }\n\n    /**\n     * Converts the `collection` to an array.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to convert.\n     * @returns {Array} Returns the new converted array.\n     * @example\n     *\n     * (function() { return _.toArray(arguments).slice(1); })(1, 2, 3, 4);\n     * // => [2, 3, 4]\n     */\n    function toArray(collection) {\n      if (collection && typeof collection.length == 'number') {\n        return slice(collection);\n      }\n      return values(collection);\n    }\n\n    /**\n     * Performs a deep comparison of each element in a `collection` to the given\n     * `properties` object, returning an array of all elements that have equivalent\n     * property values.\n     *\n     * @static\n     * @memberOf _\n     * @type Function\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Object} props The object of property values to filter by.\n     * @returns {Array} Returns a new array of elements that have the given properties.\n     * @example\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36, 'pets': ['hoppy'] },\n     *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }\n     * ];\n     *\n     * _.where(characters, { 'age': 36 });\n     * // => [{ 'name': 'barney', 'age': 36, 'pets': ['hoppy'] }]\n     *\n     * _.where(characters, { 'pets': ['dino'] });\n     * // => [{ 'name': 'fred', 'age': 40, 'pets': ['baby puss', 'dino'] }]\n     */\n    var where = filter;\n\n    /*--------------------------------------------------------------------------*/\n\n    /**\n     * Creates an array with all falsey values removed. The values `false`, `null`,\n     * `0`, `\"\"`, `undefined`, and `NaN` are all falsey.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to compact.\n     * @returns {Array} Returns a new array of filtered values.\n     * @example\n     *\n     * _.compact([0, 1, false, 2, '', 3]);\n     * // => [1, 2, 3]\n     */\n    function compact(array) {\n      var index = -1,\n          length = array ? array.length : 0,\n          result = [];\n\n      while (++index < length) {\n        var value = array[index];\n        if (value) {\n          result.push(value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Creates an array excluding all values of the provided arrays using strict\n     * equality for comparisons, i.e. `===`.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to process.\n     * @param {...Array} [values] The arrays of values to exclude.\n     * @returns {Array} Returns a new array of filtered values.\n     * @example\n     *\n     * _.difference([1, 2, 3, 4, 5], [5, 2, 10]);\n     * // => [1, 3, 4]\n     */\n    function difference(array) {\n      return baseDifference(array, baseFlatten(arguments, true, true, 1));\n    }\n\n    /**\n     * This method is like `_.find` except that it returns the index of the first\n     * element that passes the callback check, instead of the element itself.\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to search.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {number} Returns the index of the found element, else `-1`.\n     * @example\n     *\n     * var characters = [\n     *   { 'name': 'barney',  'age': 36, 'blocked': false },\n     *   { 'name': 'fred',    'age': 40, 'blocked': true },\n     *   { 'name': 'pebbles', 'age': 1,  'blocked': false }\n     * ];\n     *\n     * _.findIndex(characters, function(chr) {\n     *   return chr.age < 20;\n     * });\n     * // => 2\n     *\n     * // using \"_.where\" callback shorthand\n     * _.findIndex(characters, { 'age': 36 });\n     * // => 0\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.findIndex(characters, 'blocked');\n     * // => 1\n     */\n    function findIndex(array, callback, thisArg) {\n      var index = -1,\n          length = array ? array.length : 0;\n\n      callback = lodash.createCallback(callback, thisArg, 3);\n      while (++index < length) {\n        if (callback(array[index], index, array)) {\n          return index;\n        }\n      }\n      return -1;\n    }\n\n    /**\n     * This method is like `_.findIndex` except that it iterates over elements\n     * of a `collection` from right to left.\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to search.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {number} Returns the index of the found element, else `-1`.\n     * @example\n     *\n     * var characters = [\n     *   { 'name': 'barney',  'age': 36, 'blocked': true },\n     *   { 'name': 'fred',    'age': 40, 'blocked': false },\n     *   { 'name': 'pebbles', 'age': 1,  'blocked': true }\n     * ];\n     *\n     * _.findLastIndex(characters, function(chr) {\n     *   return chr.age > 30;\n     * });\n     * // => 1\n     *\n     * // using \"_.where\" callback shorthand\n     * _.findLastIndex(characters, { 'age': 36 });\n     * // => 0\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.findLastIndex(characters, 'blocked');\n     * // => 2\n     */\n    function findLastIndex(array, callback, thisArg) {\n      var length = array ? array.length : 0;\n      callback = lodash.createCallback(callback, thisArg, 3);\n      while (length--) {\n        if (callback(array[length], length, array)) {\n          return length;\n        }\n      }\n      return -1;\n    }\n\n    /**\n     * Gets the first element or first `n` elements of an array. If a callback\n     * is provided elements at the beginning of the array are returned as long\n     * as the callback returns truey. The callback is bound to `thisArg` and\n     * invoked with three arguments; (value, index, array).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @alias head, take\n     * @category Arrays\n     * @param {Array} array The array to query.\n     * @param {Function|Object|number|string} [callback] The function called\n     *  per element or the number of elements to return. If a property name or\n     *  object is provided it will be used to create a \"_.pluck\" or \"_.where\"\n     *  style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {*} Returns the first element(s) of `array`.\n     * @example\n     *\n     * _.first([1, 2, 3]);\n     * // => 1\n     *\n     * _.first([1, 2, 3], 2);\n     * // => [1, 2]\n     *\n     * _.first([1, 2, 3], function(num) {\n     *   return num < 3;\n     * });\n     * // => [1, 2]\n     *\n     * var characters = [\n     *   { 'name': 'barney',  'blocked': true,  'employer': 'slate' },\n     *   { 'name': 'fred',    'blocked': false, 'employer': 'slate' },\n     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }\n     * ];\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.first(characters, 'blocked');\n     * // => [{ 'name': 'barney', 'blocked': true, 'employer': 'slate' }]\n     *\n     * // using \"_.where\" callback shorthand\n     * _.pluck(_.first(characters, { 'employer': 'slate' }), 'name');\n     * // => ['barney', 'fred']\n     */\n    function first(array, callback, thisArg) {\n      var n = 0,\n          length = array ? array.length : 0;\n\n      if (typeof callback != 'number' && callback != null) {\n        var index = -1;\n        callback = lodash.createCallback(callback, thisArg, 3);\n        while (++index < length && callback(array[index], index, array)) {\n          n++;\n        }\n      } else {\n        n = callback;\n        if (n == null || thisArg) {\n          return array ? array[0] : undefined;\n        }\n      }\n      return slice(array, 0, nativeMin(nativeMax(0, n), length));\n    }\n\n    /**\n     * Flattens a nested array (the nesting can be to any depth). If `isShallow`\n     * is truey, the array will only be flattened a single level. If a callback\n     * is provided each element of the array is passed through the callback before\n     * flattening. The callback is bound to `thisArg` and invoked with three\n     * arguments; (value, index, array).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to flatten.\n     * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Array} Returns a new flattened array.\n     * @example\n     *\n     * _.flatten([1, [2], [3, [[4]]]]);\n     * // => [1, 2, 3, 4];\n     *\n     * _.flatten([1, [2], [3, [[4]]]], true);\n     * // => [1, 2, 3, [[4]]];\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 30, 'pets': ['hoppy'] },\n     *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }\n     * ];\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.flatten(characters, 'pets');\n     * // => ['hoppy', 'baby puss', 'dino']\n     */\n    function flatten(array, isShallow, callback, thisArg) {\n      // juggle arguments\n      if (typeof isShallow != 'boolean' && isShallow != null) {\n        thisArg = callback;\n        callback = (typeof isShallow != 'function' && thisArg && thisArg[isShallow] === array) ? null : isShallow;\n        isShallow = false;\n      }\n      if (callback != null) {\n        array = map(array, callback, thisArg);\n      }\n      return baseFlatten(array, isShallow);\n    }\n\n    /**\n     * Gets the index at which the first occurrence of `value` is found using\n     * strict equality for comparisons, i.e. `===`. If the array is already sorted\n     * providing `true` for `fromIndex` will run a faster binary search.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to search.\n     * @param {*} value The value to search for.\n     * @param {boolean|number} [fromIndex=0] The index to search from or `true`\n     *  to perform a binary search on a sorted array.\n     * @returns {number} Returns the index of the matched value or `-1`.\n     * @example\n     *\n     * _.indexOf([1, 2, 3, 1, 2, 3], 2);\n     * // => 1\n     *\n     * _.indexOf([1, 2, 3, 1, 2, 3], 2, 3);\n     * // => 4\n     *\n     * _.indexOf([1, 1, 2, 2, 3, 3], 2, true);\n     * // => 2\n     */\n    function indexOf(array, value, fromIndex) {\n      if (typeof fromIndex == 'number') {\n        var length = array ? array.length : 0;\n        fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex || 0);\n      } else if (fromIndex) {\n        var index = sortedIndex(array, value);\n        return array[index] === value ? index : -1;\n      }\n      return baseIndexOf(array, value, fromIndex);\n    }\n\n    /**\n     * Gets all but the last element or last `n` elements of an array. If a\n     * callback is provided elements at the end of the array are excluded from\n     * the result as long as the callback returns truey. The callback is bound\n     * to `thisArg` and invoked with three arguments; (value, index, array).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to query.\n     * @param {Function|Object|number|string} [callback=1] The function called\n     *  per element or the number of elements to exclude. If a property name or\n     *  object is provided it will be used to create a \"_.pluck\" or \"_.where\"\n     *  style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Array} Returns a slice of `array`.\n     * @example\n     *\n     * _.initial([1, 2, 3]);\n     * // => [1, 2]\n     *\n     * _.initial([1, 2, 3], 2);\n     * // => [1]\n     *\n     * _.initial([1, 2, 3], function(num) {\n     *   return num > 1;\n     * });\n     * // => [1]\n     *\n     * var characters = [\n     *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },\n     *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },\n     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }\n     * ];\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.initial(characters, 'blocked');\n     * // => [{ 'name': 'barney',  'blocked': false, 'employer': 'slate' }]\n     *\n     * // using \"_.where\" callback shorthand\n     * _.pluck(_.initial(characters, { 'employer': 'na' }), 'name');\n     * // => ['barney', 'fred']\n     */\n    function initial(array, callback, thisArg) {\n      var n = 0,\n          length = array ? array.length : 0;\n\n      if (typeof callback != 'number' && callback != null) {\n        var index = length;\n        callback = lodash.createCallback(callback, thisArg, 3);\n        while (index-- && callback(array[index], index, array)) {\n          n++;\n        }\n      } else {\n        n = (callback == null || thisArg) ? 1 : callback || n;\n      }\n      return slice(array, 0, nativeMin(nativeMax(0, length - n), length));\n    }\n\n    /**\n     * Creates an array of unique values present in all provided arrays using\n     * strict equality for comparisons, i.e. `===`.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {...Array} [array] The arrays to inspect.\n     * @returns {Array} Returns an array of shared values.\n     * @example\n     *\n     * _.intersection([1, 2, 3], [5, 2, 1, 4], [2, 1]);\n     * // => [1, 2]\n     */\n    function intersection() {\n      var args = [],\n          argsIndex = -1,\n          argsLength = arguments.length,\n          caches = getArray(),\n          indexOf = getIndexOf(),\n          trustIndexOf = indexOf === baseIndexOf,\n          seen = getArray();\n\n      while (++argsIndex < argsLength) {\n        var value = arguments[argsIndex];\n        if (isArray(value) || isArguments(value)) {\n          args.push(value);\n          caches.push(trustIndexOf && value.length >= largeArraySize &&\n            createCache(argsIndex ? args[argsIndex] : seen));\n        }\n      }\n      var array = args[0],\n          index = -1,\n          length = array ? array.length : 0,\n          result = [];\n\n      outer:\n      while (++index < length) {\n        var cache = caches[0];\n        value = array[index];\n\n        if ((cache ? cacheIndexOf(cache, value) : indexOf(seen, value)) < 0) {\n          argsIndex = argsLength;\n          (cache || seen).push(value);\n          while (--argsIndex) {\n            cache = caches[argsIndex];\n            if ((cache ? cacheIndexOf(cache, value) : indexOf(args[argsIndex], value)) < 0) {\n              continue outer;\n            }\n          }\n          result.push(value);\n        }\n      }\n      while (argsLength--) {\n        cache = caches[argsLength];\n        if (cache) {\n          releaseObject(cache);\n        }\n      }\n      releaseArray(caches);\n      releaseArray(seen);\n      return result;\n    }\n\n    /**\n     * Gets the last element or last `n` elements of an array. If a callback is\n     * provided elements at the end of the array are returned as long as the\n     * callback returns truey. The callback is bound to `thisArg` and invoked\n     * with three arguments; (value, index, array).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to query.\n     * @param {Function|Object|number|string} [callback] The function called\n     *  per element or the number of elements to return. If a property name or\n     *  object is provided it will be used to create a \"_.pluck\" or \"_.where\"\n     *  style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {*} Returns the last element(s) of `array`.\n     * @example\n     *\n     * _.last([1, 2, 3]);\n     * // => 3\n     *\n     * _.last([1, 2, 3], 2);\n     * // => [2, 3]\n     *\n     * _.last([1, 2, 3], function(num) {\n     *   return num > 1;\n     * });\n     * // => [2, 3]\n     *\n     * var characters = [\n     *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },\n     *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },\n     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }\n     * ];\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.pluck(_.last(characters, 'blocked'), 'name');\n     * // => ['fred', 'pebbles']\n     *\n     * // using \"_.where\" callback shorthand\n     * _.last(characters, { 'employer': 'na' });\n     * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]\n     */\n    function last(array, callback, thisArg) {\n      var n = 0,\n          length = array ? array.length : 0;\n\n      if (typeof callback != 'number' && callback != null) {\n        var index = length;\n        callback = lodash.createCallback(callback, thisArg, 3);\n        while (index-- && callback(array[index], index, array)) {\n          n++;\n        }\n      } else {\n        n = callback;\n        if (n == null || thisArg) {\n          return array ? array[length - 1] : undefined;\n        }\n      }\n      return slice(array, nativeMax(0, length - n));\n    }\n\n    /**\n     * Gets the index at which the last occurrence of `value` is found using strict\n     * equality for comparisons, i.e. `===`. If `fromIndex` is negative, it is used\n     * as the offset from the end of the collection.\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to search.\n     * @param {*} value The value to search for.\n     * @param {number} [fromIndex=array.length-1] The index to search from.\n     * @returns {number} Returns the index of the matched value or `-1`.\n     * @example\n     *\n     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2);\n     * // => 4\n     *\n     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2, 3);\n     * // => 1\n     */\n    function lastIndexOf(array, value, fromIndex) {\n      var index = array ? array.length : 0;\n      if (typeof fromIndex == 'number') {\n        index = (fromIndex < 0 ? nativeMax(0, index + fromIndex) : nativeMin(fromIndex, index - 1)) + 1;\n      }\n      while (index--) {\n        if (array[index] === value) {\n          return index;\n        }\n      }\n      return -1;\n    }\n\n    /**\n     * Removes all provided values from the given array using strict equality for\n     * comparisons, i.e. `===`.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to modify.\n     * @param {...*} [value] The values to remove.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = [1, 2, 3, 1, 2, 3];\n     * _.pull(array, 2, 3);\n     * console.log(array);\n     * // => [1, 1]\n     */\n    function pull(array) {\n      var args = arguments,\n          argsIndex = 0,\n          argsLength = args.length,\n          length = array ? array.length : 0;\n\n      while (++argsIndex < argsLength) {\n        var index = -1,\n            value = args[argsIndex];\n        while (++index < length) {\n          if (array[index] === value) {\n            splice.call(array, index--, 1);\n            length--;\n          }\n        }\n      }\n      return array;\n    }\n\n    /**\n     * Creates an array of numbers (positive and/or negative) progressing from\n     * `start` up to but not including `end`. If `start` is less than `stop` a\n     * zero-length range is created unless a negative `step` is specified.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {number} [start=0] The start of the range.\n     * @param {number} end The end of the range.\n     * @param {number} [step=1] The value to increment or decrement by.\n     * @returns {Array} Returns a new range array.\n     * @example\n     *\n     * _.range(4);\n     * // => [0, 1, 2, 3]\n     *\n     * _.range(1, 5);\n     * // => [1, 2, 3, 4]\n     *\n     * _.range(0, 20, 5);\n     * // => [0, 5, 10, 15]\n     *\n     * _.range(0, -4, -1);\n     * // => [0, -1, -2, -3]\n     *\n     * _.range(1, 4, 0);\n     * // => [1, 1, 1]\n     *\n     * _.range(0);\n     * // => []\n     */\n    function range(start, end, step) {\n      start = +start || 0;\n      step = typeof step == 'number' ? step : (+step || 1);\n\n      if (end == null) {\n        end = start;\n        start = 0;\n      }\n      // use `Array(length)` so engines like Chakra and V8 avoid slower modes\n      // http://youtu.be/XAqIpGU8ZZk#t=17m25s\n      var index = -1,\n          length = nativeMax(0, ceil((end - start) / (step || 1))),\n          result = Array(length);\n\n      while (++index < length) {\n        result[index] = start;\n        start += step;\n      }\n      return result;\n    }\n\n    /**\n     * Removes all elements from an array that the callback returns truey for\n     * and returns an array of removed elements. The callback is bound to `thisArg`\n     * and invoked with three arguments; (value, index, array).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to modify.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Array} Returns a new array of removed elements.\n     * @example\n     *\n     * var array = [1, 2, 3, 4, 5, 6];\n     * var evens = _.remove(array, function(num) { return num % 2 == 0; });\n     *\n     * console.log(array);\n     * // => [1, 3, 5]\n     *\n     * console.log(evens);\n     * // => [2, 4, 6]\n     */\n    function remove(array, callback, thisArg) {\n      var index = -1,\n          length = array ? array.length : 0,\n          result = [];\n\n      callback = lodash.createCallback(callback, thisArg, 3);\n      while (++index < length) {\n        var value = array[index];\n        if (callback(value, index, array)) {\n          result.push(value);\n          splice.call(array, index--, 1);\n          length--;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The opposite of `_.initial` this method gets all but the first element or\n     * first `n` elements of an array. If a callback function is provided elements\n     * at the beginning of the array are excluded from the result as long as the\n     * callback returns truey. The callback is bound to `thisArg` and invoked\n     * with three arguments; (value, index, array).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @alias drop, tail\n     * @category Arrays\n     * @param {Array} array The array to query.\n     * @param {Function|Object|number|string} [callback=1] The function called\n     *  per element or the number of elements to exclude. If a property name or\n     *  object is provided it will be used to create a \"_.pluck\" or \"_.where\"\n     *  style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Array} Returns a slice of `array`.\n     * @example\n     *\n     * _.rest([1, 2, 3]);\n     * // => [2, 3]\n     *\n     * _.rest([1, 2, 3], 2);\n     * // => [3]\n     *\n     * _.rest([1, 2, 3], function(num) {\n     *   return num < 3;\n     * });\n     * // => [3]\n     *\n     * var characters = [\n     *   { 'name': 'barney',  'blocked': true,  'employer': 'slate' },\n     *   { 'name': 'fred',    'blocked': false,  'employer': 'slate' },\n     *   { 'name': 'pebbles', 'blocked': true, 'employer': 'na' }\n     * ];\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.pluck(_.rest(characters, 'blocked'), 'name');\n     * // => ['fred', 'pebbles']\n     *\n     * // using \"_.where\" callback shorthand\n     * _.rest(characters, { 'employer': 'slate' });\n     * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]\n     */\n    function rest(array, callback, thisArg) {\n      if (typeof callback != 'number' && callback != null) {\n        var n = 0,\n            index = -1,\n            length = array ? array.length : 0;\n\n        callback = lodash.createCallback(callback, thisArg, 3);\n        while (++index < length && callback(array[index], index, array)) {\n          n++;\n        }\n      } else {\n        n = (callback == null || thisArg) ? 1 : nativeMax(0, callback);\n      }\n      return slice(array, n);\n    }\n\n    /**\n     * Uses a binary search to determine the smallest index at which a value\n     * should be inserted into a given sorted array in order to maintain the sort\n     * order of the array. If a callback is provided it will be executed for\n     * `value` and each element of `array` to compute their sort ranking. The\n     * callback is bound to `thisArg` and invoked with one argument; (value).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     * @example\n     *\n     * _.sortedIndex([20, 30, 50], 40);\n     * // => 2\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.sortedIndex([{ 'x': 20 }, { 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');\n     * // => 2\n     *\n     * var dict = {\n     *   'wordToNumber': { 'twenty': 20, 'thirty': 30, 'fourty': 40, 'fifty': 50 }\n     * };\n     *\n     * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {\n     *   return dict.wordToNumber[word];\n     * });\n     * // => 2\n     *\n     * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {\n     *   return this.wordToNumber[word];\n     * }, dict);\n     * // => 2\n     */\n    function sortedIndex(array, value, callback, thisArg) {\n      var low = 0,\n          high = array ? array.length : low;\n\n      // explicitly reference `identity` for better inlining in Firefox\n      callback = callback ? lodash.createCallback(callback, thisArg, 1) : identity;\n      value = callback(value);\n\n      while (low < high) {\n        var mid = (low + high) >>> 1;\n        (callback(array[mid]) < value)\n          ? low = mid + 1\n          : high = mid;\n      }\n      return low;\n    }\n\n    /**\n     * Creates an array of unique values, in order, of the provided arrays using\n     * strict equality for comparisons, i.e. `===`.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {...Array} [array] The arrays to inspect.\n     * @returns {Array} Returns an array of combined values.\n     * @example\n     *\n     * _.union([1, 2, 3], [5, 2, 1, 4], [2, 1]);\n     * // => [1, 2, 3, 5, 4]\n     */\n    function union() {\n      return baseUniq(baseFlatten(arguments, true, true));\n    }\n\n    /**\n     * Creates a duplicate-value-free version of an array using strict equality\n     * for comparisons, i.e. `===`. If the array is sorted, providing\n     * `true` for `isSorted` will use a faster algorithm. If a callback is provided\n     * each element of `array` is passed through the callback before uniqueness\n     * is computed. The callback is bound to `thisArg` and invoked with three\n     * arguments; (value, index, array).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @alias unique\n     * @category Arrays\n     * @param {Array} array The array to process.\n     * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Array} Returns a duplicate-value-free array.\n     * @example\n     *\n     * _.uniq([1, 2, 1, 3, 1]);\n     * // => [1, 2, 3]\n     *\n     * _.uniq([1, 1, 2, 2, 3], true);\n     * // => [1, 2, 3]\n     *\n     * _.uniq(['A', 'b', 'C', 'a', 'B', 'c'], function(letter) { return letter.toLowerCase(); });\n     * // => ['A', 'b', 'C']\n     *\n     * _.uniq([1, 2.5, 3, 1.5, 2, 3.5], function(num) { return this.floor(num); }, Math);\n     * // => [1, 2.5, 3]\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');\n     * // => [{ 'x': 1 }, { 'x': 2 }]\n     */\n    function uniq(array, isSorted, callback, thisArg) {\n      // juggle arguments\n      if (typeof isSorted != 'boolean' && isSorted != null) {\n        thisArg = callback;\n        callback = (typeof isSorted != 'function' && thisArg && thisArg[isSorted] === array) ? null : isSorted;\n        isSorted = false;\n      }\n      if (callback != null) {\n        callback = lodash.createCallback(callback, thisArg, 3);\n      }\n      return baseUniq(array, isSorted, callback);\n    }\n\n    /**\n     * Creates an array excluding all provided values using strict equality for\n     * comparisons, i.e. `===`.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to filter.\n     * @param {...*} [value] The values to exclude.\n     * @returns {Array} Returns a new array of filtered values.\n     * @example\n     *\n     * _.without([1, 2, 1, 0, 3, 1, 4], 0, 1);\n     * // => [2, 3, 4]\n     */\n    function without(array) {\n      return baseDifference(array, slice(arguments, 1));\n    }\n\n    /**\n     * Creates an array that is the symmetric difference of the provided arrays.\n     * See http://en.wikipedia.org/wiki/Symmetric_difference.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {...Array} [array] The arrays to inspect.\n     * @returns {Array} Returns an array of values.\n     * @example\n     *\n     * _.xor([1, 2, 3], [5, 2, 1, 4]);\n     * // => [3, 5, 4]\n     *\n     * _.xor([1, 2, 5], [2, 3, 5], [3, 4, 5]);\n     * // => [1, 4, 5]\n     */\n    function xor() {\n      var index = -1,\n          length = arguments.length;\n\n      while (++index < length) {\n        var array = arguments[index];\n        if (isArray(array) || isArguments(array)) {\n          var result = result\n            ? baseUniq(baseDifference(result, array).concat(baseDifference(array, result)))\n            : array;\n        }\n      }\n      return result || [];\n    }\n\n    /**\n     * Creates an array of grouped elements, the first of which contains the first\n     * elements of the given arrays, the second of which contains the second\n     * elements of the given arrays, and so on.\n     *\n     * @static\n     * @memberOf _\n     * @alias unzip\n     * @category Arrays\n     * @param {...Array} [array] Arrays to process.\n     * @returns {Array} Returns a new array of grouped elements.\n     * @example\n     *\n     * _.zip(['fred', 'barney'], [30, 40], [true, false]);\n     * // => [['fred', 30, true], ['barney', 40, false]]\n     */\n    function zip() {\n      var array = arguments.length > 1 ? arguments : arguments[0],\n          index = -1,\n          length = array ? max(pluck(array, 'length')) : 0,\n          result = Array(length < 0 ? 0 : length);\n\n      while (++index < length) {\n        result[index] = pluck(array, index);\n      }\n      return result;\n    }\n\n    /**\n     * Creates an object composed from arrays of `keys` and `values`. Provide\n     * either a single two dimensional array, i.e. `[[key1, value1], [key2, value2]]`\n     * or two arrays, one of `keys` and one of corresponding `values`.\n     *\n     * @static\n     * @memberOf _\n     * @alias object\n     * @category Arrays\n     * @param {Array} keys The array of keys.\n     * @param {Array} [values=[]] The array of values.\n     * @returns {Object} Returns an object composed of the given keys and\n     *  corresponding values.\n     * @example\n     *\n     * _.zipObject(['fred', 'barney'], [30, 40]);\n     * // => { 'fred': 30, 'barney': 40 }\n     */\n    function zipObject(keys, values) {\n      var index = -1,\n          length = keys ? keys.length : 0,\n          result = {};\n\n      if (!values && length && !isArray(keys[0])) {\n        values = [];\n      }\n      while (++index < length) {\n        var key = keys[index];\n        if (values) {\n          result[key] = values[index];\n        } else if (key) {\n          result[key[0]] = key[1];\n        }\n      }\n      return result;\n    }\n\n    /*--------------------------------------------------------------------------*/\n\n    /**\n     * Creates a function that executes `func`, with  the `this` binding and\n     * arguments of the created function, only after being called `n` times.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {number} n The number of times the function must be called before\n     *  `func` is executed.\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new restricted function.\n     * @example\n     *\n     * var saves = ['profile', 'settings'];\n     *\n     * var done = _.after(saves.length, function() {\n     *   console.log('Done saving!');\n     * });\n     *\n     * _.forEach(saves, function(type) {\n     *   asyncSave({ 'type': type, 'complete': done });\n     * });\n     * // => logs 'Done saving!', after all saves have completed\n     */\n    function after(n, func) {\n      if (!isFunction(func)) {\n        throw new TypeError;\n      }\n      return function() {\n        if (--n < 1) {\n          return func.apply(this, arguments);\n        }\n      };\n    }\n\n    /**\n     * Creates a function that, when called, invokes `func` with the `this`\n     * binding of `thisArg` and prepends any additional `bind` arguments to those\n     * provided to the bound function.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {Function} func The function to bind.\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @param {...*} [arg] Arguments to be partially applied.\n     * @returns {Function} Returns the new bound function.\n     * @example\n     *\n     * var func = function(greeting) {\n     *   return greeting + ' ' + this.name;\n     * };\n     *\n     * func = _.bind(func, { 'name': 'fred' }, 'hi');\n     * func();\n     * // => 'hi fred'\n     */\n    function bind(func, thisArg) {\n      return arguments.length > 2\n        ? createWrapper(func, 17, slice(arguments, 2), null, thisArg)\n        : createWrapper(func, 1, null, null, thisArg);\n    }\n\n    /**\n     * Binds methods of an object to the object itself, overwriting the existing\n     * method. Method names may be specified as individual arguments or as arrays\n     * of method names. If no method names are provided all the function properties\n     * of `object` will be bound.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {Object} object The object to bind and assign the bound methods to.\n     * @param {...string} [methodName] The object method names to\n     *  bind, specified as individual method names or arrays of method names.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var view = {\n     *   'label': 'docs',\n     *   'onClick': function() { console.log('clicked ' + this.label); }\n     * };\n     *\n     * _.bindAll(view);\n     * jQuery('#docs').on('click', view.onClick);\n     * // => logs 'clicked docs', when the button is clicked\n     */\n    function bindAll(object) {\n      var funcs = arguments.length > 1 ? baseFlatten(arguments, true, false, 1) : functions(object),\n          index = -1,\n          length = funcs.length;\n\n      while (++index < length) {\n        var key = funcs[index];\n        object[key] = createWrapper(object[key], 1, null, null, object);\n      }\n      return object;\n    }\n\n    /**\n     * Creates a function that, when called, invokes the method at `object[key]`\n     * and prepends any additional `bindKey` arguments to those provided to the bound\n     * function. This method differs from `_.bind` by allowing bound functions to\n     * reference methods that will be redefined or don't yet exist.\n     * See http://michaux.ca/articles/lazy-function-definition-pattern.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {Object} object The object the method belongs to.\n     * @param {string} key The key of the method.\n     * @param {...*} [arg] Arguments to be partially applied.\n     * @returns {Function} Returns the new bound function.\n     * @example\n     *\n     * var object = {\n     *   'name': 'fred',\n     *   'greet': function(greeting) {\n     *     return greeting + ' ' + this.name;\n     *   }\n     * };\n     *\n     * var func = _.bindKey(object, 'greet', 'hi');\n     * func();\n     * // => 'hi fred'\n     *\n     * object.greet = function(greeting) {\n     *   return greeting + 'ya ' + this.name + '!';\n     * };\n     *\n     * func();\n     * // => 'hiya fred!'\n     */\n    function bindKey(object, key) {\n      return arguments.length > 2\n        ? createWrapper(key, 19, slice(arguments, 2), null, object)\n        : createWrapper(key, 3, null, null, object);\n    }\n\n    /**\n     * Creates a function that is the composition of the provided functions,\n     * where each function consumes the return value of the function that follows.\n     * For example, composing the functions `f()`, `g()`, and `h()` produces `f(g(h()))`.\n     * Each function is executed with the `this` binding of the composed function.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {...Function} [func] Functions to compose.\n     * @returns {Function} Returns the new composed function.\n     * @example\n     *\n     * var realNameMap = {\n     *   'pebbles': 'penelope'\n     * };\n     *\n     * var format = function(name) {\n     *   name = realNameMap[name.toLowerCase()] || name;\n     *   return name.charAt(0).toUpperCase() + name.slice(1).toLowerCase();\n     * };\n     *\n     * var greet = function(formatted) {\n     *   return 'Hiya ' + formatted + '!';\n     * };\n     *\n     * var welcome = _.compose(greet, format);\n     * welcome('pebbles');\n     * // => 'Hiya Penelope!'\n     */\n    function compose() {\n      var funcs = arguments,\n          length = funcs.length;\n\n      while (length--) {\n        if (!isFunction(funcs[length])) {\n          throw new TypeError;\n        }\n      }\n      return function() {\n        var args = arguments,\n            length = funcs.length;\n\n        while (length--) {\n          args = [funcs[length].apply(this, args)];\n        }\n        return args[0];\n      };\n    }\n\n    /**\n     * Creates a function which accepts one or more arguments of `func` that when\n     * invoked either executes `func` returning its result, if all `func` arguments\n     * have been provided, or returns a function that accepts one or more of the\n     * remaining `func` arguments, and so on. The arity of `func` can be specified\n     * if `func.length` is not sufficient.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {Function} func The function to curry.\n     * @param {number} [arity=func.length] The arity of `func`.\n     * @returns {Function} Returns the new curried function.\n     * @example\n     *\n     * var curried = _.curry(function(a, b, c) {\n     *   console.log(a + b + c);\n     * });\n     *\n     * curried(1)(2)(3);\n     * // => 6\n     *\n     * curried(1, 2)(3);\n     * // => 6\n     *\n     * curried(1, 2, 3);\n     * // => 6\n     */\n    function curry(func, arity) {\n      arity = typeof arity == 'number' ? arity : (+arity || func.length);\n      return createWrapper(func, 4, null, null, null, arity);\n    }\n\n    /**\n     * Creates a function that will delay the execution of `func` until after\n     * `wait` milliseconds have elapsed since the last time it was invoked.\n     * Provide an options object to indicate that `func` should be invoked on\n     * the leading and/or trailing edge of the `wait` timeout. Subsequent calls\n     * to the debounced function will return the result of the last `func` call.\n     *\n     * Note: If `leading` and `trailing` options are `true` `func` will be called\n     * on the trailing edge of the timeout only if the the debounced function is\n     * invoked more than once during the `wait` timeout.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {Function} func The function to debounce.\n     * @param {number} wait The number of milliseconds to delay.\n     * @param {Object} [options] The options object.\n     * @param {boolean} [options.leading=false] Specify execution on the leading edge of the timeout.\n     * @param {number} [options.maxWait] The maximum time `func` is allowed to be delayed before it's called.\n     * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.\n     * @returns {Function} Returns the new debounced function.\n     * @example\n     *\n     * // avoid costly calculations while the window size is in flux\n     * var lazyLayout = _.debounce(calculateLayout, 150);\n     * jQuery(window).on('resize', lazyLayout);\n     *\n     * // execute `sendMail` when the click event is fired, debouncing subsequent calls\n     * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {\n     *   'leading': true,\n     *   'trailing': false\n     * });\n     *\n     * // ensure `batchLog` is executed once after 1 second of debounced calls\n     * var source = new EventSource('/stream');\n     * source.addEventListener('message', _.debounce(batchLog, 250, {\n     *   'maxWait': 1000\n     * }, false);\n     */\n    function debounce(func, wait, options) {\n      var args,\n          maxTimeoutId,\n          result,\n          stamp,\n          thisArg,\n          timeoutId,\n          trailingCall,\n          lastCalled = 0,\n          maxWait = false,\n          trailing = true;\n\n      if (!isFunction(func)) {\n        throw new TypeError;\n      }\n      wait = nativeMax(0, wait) || 0;\n      if (options === true) {\n        var leading = true;\n        trailing = false;\n      } else if (isObject(options)) {\n        leading = options.leading;\n        maxWait = 'maxWait' in options && (nativeMax(wait, options.maxWait) || 0);\n        trailing = 'trailing' in options ? options.trailing : trailing;\n      }\n      var delayed = function() {\n        var remaining = wait - (now() - stamp);\n        if (remaining <= 0) {\n          if (maxTimeoutId) {\n            clearTimeout(maxTimeoutId);\n          }\n          var isCalled = trailingCall;\n          maxTimeoutId = timeoutId = trailingCall = undefined;\n          if (isCalled) {\n            lastCalled = now();\n            result = func.apply(thisArg, args);\n            if (!timeoutId && !maxTimeoutId) {\n              args = thisArg = null;\n            }\n          }\n        } else {\n          timeoutId = setTimeout(delayed, remaining);\n        }\n      };\n\n      var maxDelayed = function() {\n        if (timeoutId) {\n          clearTimeout(timeoutId);\n        }\n        maxTimeoutId = timeoutId = trailingCall = undefined;\n        if (trailing || (maxWait !== wait)) {\n          lastCalled = now();\n          result = func.apply(thisArg, args);\n          if (!timeoutId && !maxTimeoutId) {\n            args = thisArg = null;\n          }\n        }\n      };\n\n      return function() {\n        args = arguments;\n        stamp = now();\n        thisArg = this;\n        trailingCall = trailing && (timeoutId || !leading);\n\n        if (maxWait === false) {\n          var leadingCall = leading && !timeoutId;\n        } else {\n          if (!maxTimeoutId && !leading) {\n            lastCalled = stamp;\n          }\n          var remaining = maxWait - (stamp - lastCalled),\n              isCalled = remaining <= 0;\n\n          if (isCalled) {\n            if (maxTimeoutId) {\n              maxTimeoutId = clearTimeout(maxTimeoutId);\n            }\n            lastCalled = stamp;\n            result = func.apply(thisArg, args);\n          }\n          else if (!maxTimeoutId) {\n            maxTimeoutId = setTimeout(maxDelayed, remaining);\n          }\n        }\n        if (isCalled && timeoutId) {\n          timeoutId = clearTimeout(timeoutId);\n        }\n        else if (!timeoutId && wait !== maxWait) {\n          timeoutId = setTimeout(delayed, wait);\n        }\n        if (leadingCall) {\n          isCalled = true;\n          result = func.apply(thisArg, args);\n        }\n        if (isCalled && !timeoutId && !maxTimeoutId) {\n          args = thisArg = null;\n        }\n        return result;\n      };\n    }\n\n    /**\n     * Defers executing the `func` function until the current call stack has cleared.\n     * Additional arguments will be provided to `func` when it is invoked.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {Function} func The function to defer.\n     * @param {...*} [arg] Arguments to invoke the function with.\n     * @returns {number} Returns the timer id.\n     * @example\n     *\n     * _.defer(function(text) { console.log(text); }, 'deferred');\n     * // logs 'deferred' after one or more milliseconds\n     */\n    function defer(func) {\n      if (!isFunction(func)) {\n        throw new TypeError;\n      }\n      var args = slice(arguments, 1);\n      return setTimeout(function() { func.apply(undefined, args); }, 1);\n    }\n\n    /**\n     * Executes the `func` function after `wait` milliseconds. Additional arguments\n     * will be provided to `func` when it is invoked.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {Function} func The function to delay.\n     * @param {number} wait The number of milliseconds to delay execution.\n     * @param {...*} [arg] Arguments to invoke the function with.\n     * @returns {number} Returns the timer id.\n     * @example\n     *\n     * _.delay(function(text) { console.log(text); }, 1000, 'later');\n     * // => logs 'later' after one second\n     */\n    function delay(func, wait) {\n      if (!isFunction(func)) {\n        throw new TypeError;\n      }\n      var args = slice(arguments, 2);\n      return setTimeout(function() { func.apply(undefined, args); }, wait);\n    }\n\n    /**\n     * Creates a function that memoizes the result of `func`. If `resolver` is\n     * provided it will be used to determine the cache key for storing the result\n     * based on the arguments provided to the memoized function. By default, the\n     * first argument provided to the memoized function is used as the cache key.\n     * The `func` is executed with the `this` binding of the memoized function.\n     * The result cache is exposed as the `cache` property on the memoized function.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {Function} func The function to have its output memoized.\n     * @param {Function} [resolver] A function used to resolve the cache key.\n     * @returns {Function} Returns the new memoizing function.\n     * @example\n     *\n     * var fibonacci = _.memoize(function(n) {\n     *   return n < 2 ? n : fibonacci(n - 1) + fibonacci(n - 2);\n     * });\n     *\n     * fibonacci(9)\n     * // => 34\n     *\n     * var data = {\n     *   'fred': { 'name': 'fred', 'age': 40 },\n     *   'pebbles': { 'name': 'pebbles', 'age': 1 }\n     * };\n     *\n     * // modifying the result cache\n     * var get = _.memoize(function(name) { return data[name]; }, _.identity);\n     * get('pebbles');\n     * // => { 'name': 'pebbles', 'age': 1 }\n     *\n     * get.cache.pebbles.name = 'penelope';\n     * get('pebbles');\n     * // => { 'name': 'penelope', 'age': 1 }\n     */\n    function memoize(func, resolver) {\n      if (!isFunction(func)) {\n        throw new TypeError;\n      }\n      var memoized = function() {\n        var cache = memoized.cache,\n            key = resolver ? resolver.apply(this, arguments) : keyPrefix + arguments[0];\n\n        return hasOwnProperty.call(cache, key)\n          ? cache[key]\n          : (cache[key] = func.apply(this, arguments));\n      }\n      memoized.cache = {};\n      return memoized;\n    }\n\n    /**\n     * Creates a function that is restricted to execute `func` once. Repeat calls to\n     * the function will return the value of the first call. The `func` is executed\n     * with the `this` binding of the created function.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new restricted function.\n     * @example\n     *\n     * var initialize = _.once(createApplication);\n     * initialize();\n     * initialize();\n     * // `initialize` executes `createApplication` once\n     */\n    function once(func) {\n      var ran,\n          result;\n\n      if (!isFunction(func)) {\n        throw new TypeError;\n      }\n      return function() {\n        if (ran) {\n          return result;\n        }\n        ran = true;\n        result = func.apply(this, arguments);\n\n        // clear the `func` variable so the function may be garbage collected\n        func = null;\n        return result;\n      };\n    }\n\n    /**\n     * Creates a function that, when called, invokes `func` with any additional\n     * `partial` arguments prepended to those provided to the new function. This\n     * method is similar to `_.bind` except it does **not** alter the `this` binding.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {Function} func The function to partially apply arguments to.\n     * @param {...*} [arg] Arguments to be partially applied.\n     * @returns {Function} Returns the new partially applied function.\n     * @example\n     *\n     * var greet = function(greeting, name) { return greeting + ' ' + name; };\n     * var hi = _.partial(greet, 'hi');\n     * hi('fred');\n     * // => 'hi fred'\n     */\n    function partial(func) {\n      return createWrapper(func, 16, slice(arguments, 1));\n    }\n\n    /**\n     * This method is like `_.partial` except that `partial` arguments are\n     * appended to those provided to the new function.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {Function} func The function to partially apply arguments to.\n     * @param {...*} [arg] Arguments to be partially applied.\n     * @returns {Function} Returns the new partially applied function.\n     * @example\n     *\n     * var defaultsDeep = _.partialRight(_.merge, _.defaults);\n     *\n     * var options = {\n     *   'variable': 'data',\n     *   'imports': { 'jq': $ }\n     * };\n     *\n     * defaultsDeep(options, _.templateSettings);\n     *\n     * options.variable\n     * // => 'data'\n     *\n     * options.imports\n     * // => { '_': _, 'jq': $ }\n     */\n    function partialRight(func) {\n      return createWrapper(func, 32, null, slice(arguments, 1));\n    }\n\n    /**\n     * Creates a function that, when executed, will only call the `func` function\n     * at most once per every `wait` milliseconds. Provide an options object to\n     * indicate that `func` should be invoked on the leading and/or trailing edge\n     * of the `wait` timeout. Subsequent calls to the throttled function will\n     * return the result of the last `func` call.\n     *\n     * Note: If `leading` and `trailing` options are `true` `func` will be called\n     * on the trailing edge of the timeout only if the the throttled function is\n     * invoked more than once during the `wait` timeout.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {Function} func The function to throttle.\n     * @param {number} wait The number of milliseconds to throttle executions to.\n     * @param {Object} [options] The options object.\n     * @param {boolean} [options.leading=true] Specify execution on the leading edge of the timeout.\n     * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.\n     * @returns {Function} Returns the new throttled function.\n     * @example\n     *\n     * // avoid excessively updating the position while scrolling\n     * var throttled = _.throttle(updatePosition, 100);\n     * jQuery(window).on('scroll', throttled);\n     *\n     * // execute `renewToken` when the click event is fired, but not more than once every 5 minutes\n     * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {\n     *   'trailing': false\n     * }));\n     */\n    function throttle(func, wait, options) {\n      var leading = true,\n          trailing = true;\n\n      if (!isFunction(func)) {\n        throw new TypeError;\n      }\n      if (options === false) {\n        leading = false;\n      } else if (isObject(options)) {\n        leading = 'leading' in options ? options.leading : leading;\n        trailing = 'trailing' in options ? options.trailing : trailing;\n      }\n      debounceOptions.leading = leading;\n      debounceOptions.maxWait = wait;\n      debounceOptions.trailing = trailing;\n\n      return debounce(func, wait, debounceOptions);\n    }\n\n    /**\n     * Creates a function that provides `value` to the wrapper function as its\n     * first argument. Additional arguments provided to the function are appended\n     * to those provided to the wrapper function. The wrapper is executed with\n     * the `this` binding of the created function.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {*} value The value to wrap.\n     * @param {Function} wrapper The wrapper function.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var p = _.wrap(_.escape, function(func, text) {\n     *   return '<p>' + func(text) + '</p>';\n     * });\n     *\n     * p('Fred, Wilma, & Pebbles');\n     * // => '<p>Fred, Wilma, &amp; Pebbles</p>'\n     */\n    function wrap(value, wrapper) {\n      return createWrapper(wrapper, 16, [value]);\n    }\n\n    /*--------------------------------------------------------------------------*/\n\n    /**\n     * Creates a function that returns `value`.\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @param {*} value The value to return from the new function.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var object = { 'name': 'fred' };\n     * var getter = _.constant(object);\n     * getter() === object;\n     * // => true\n     */\n    function constant(value) {\n      return function() {\n        return value;\n      };\n    }\n\n    /**\n     * Produces a callback bound to an optional `thisArg`. If `func` is a property\n     * name the created callback will return the property value for a given element.\n     * If `func` is an object the created callback will return `true` for elements\n     * that contain the equivalent object properties, otherwise it will return `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @param {*} [func=identity] The value to convert to a callback.\n     * @param {*} [thisArg] The `this` binding of the created callback.\n     * @param {number} [argCount] The number of arguments the callback accepts.\n     * @returns {Function} Returns a callback function.\n     * @example\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36 },\n     *   { 'name': 'fred',   'age': 40 }\n     * ];\n     *\n     * // wrap to create custom callback shorthands\n     * _.createCallback = _.wrap(_.createCallback, function(func, callback, thisArg) {\n     *   var match = /^(.+?)__([gl]t)(.+)$/.exec(callback);\n     *   return !match ? func(callback, thisArg) : function(object) {\n     *     return match[2] == 'gt' ? object[match[1]] > match[3] : object[match[1]] < match[3];\n     *   };\n     * });\n     *\n     * _.filter(characters, 'age__gt38');\n     * // => [{ 'name': 'fred', 'age': 40 }]\n     */\n    function createCallback(func, thisArg, argCount) {\n      var type = typeof func;\n      if (func == null || type == 'function') {\n        return baseCreateCallback(func, thisArg, argCount);\n      }\n      // handle \"_.pluck\" style callback shorthands\n      if (type != 'object') {\n        return property(func);\n      }\n      var props = keys(func),\n          key = props[0],\n          a = func[key];\n\n      // handle \"_.where\" style callback shorthands\n      if (props.length == 1 && a === a && !isObject(a)) {\n        // fast path the common case of providing an object with a single\n        // property containing a primitive value\n        return function(object) {\n          var b = object[key];\n          return a === b && (a !== 0 || (1 / a == 1 / b));\n        };\n      }\n      return function(object) {\n        var length = props.length,\n            result = false;\n\n        while (length--) {\n          if (!(result = baseIsEqual(object[props[length]], func[props[length]], null, true))) {\n            break;\n          }\n        }\n        return result;\n      };\n    }\n\n    /**\n     * Converts the characters `&`, `<`, `>`, `\"`, and `'` in `string` to their\n     * corresponding HTML entities.\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @param {string} string The string to escape.\n     * @returns {string} Returns the escaped string.\n     * @example\n     *\n     * _.escape('Fred, Wilma, & Pebbles');\n     * // => 'Fred, Wilma, &amp; Pebbles'\n     */\n    function escape(string) {\n      return string == null ? '' : String(string).replace(reUnescapedHtml, escapeHtmlChar);\n    }\n\n    /**\n     * This method returns the first argument provided to it.\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @param {*} value Any value.\n     * @returns {*} Returns `value`.\n     * @example\n     *\n     * var object = { 'name': 'fred' };\n     * _.identity(object) === object;\n     * // => true\n     */\n    function identity(value) {\n      return value;\n    }\n\n    /**\n     * Adds function properties of a source object to the destination object.\n     * If `object` is a function methods will be added to its prototype as well.\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @param {Function|Object} [object=lodash] object The destination object.\n     * @param {Object} source The object of functions to add.\n     * @param {Object} [options] The options object.\n     * @param {boolean} [options.chain=true] Specify whether the functions added are chainable.\n     * @example\n     *\n     * function capitalize(string) {\n     *   return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();\n     * }\n     *\n     * _.mixin({ 'capitalize': capitalize });\n     * _.capitalize('fred');\n     * // => 'Fred'\n     *\n     * _('fred').capitalize().value();\n     * // => 'Fred'\n     *\n     * _.mixin({ 'capitalize': capitalize }, { 'chain': false });\n     * _('fred').capitalize();\n     * // => 'Fred'\n     */\n    function mixin(object, source, options) {\n      var chain = true,\n          methodNames = source && functions(source);\n\n      if (!source || (!options && !methodNames.length)) {\n        if (options == null) {\n          options = source;\n        }\n        ctor = lodashWrapper;\n        source = object;\n        object = lodash;\n        methodNames = functions(source);\n      }\n      if (options === false) {\n        chain = false;\n      } else if (isObject(options) && 'chain' in options) {\n        chain = options.chain;\n      }\n      var ctor = object,\n          isFunc = isFunction(ctor);\n\n      forEach(methodNames, function(methodName) {\n        var func = object[methodName] = source[methodName];\n        if (isFunc) {\n          ctor.prototype[methodName] = function() {\n            var chainAll = this.__chain__,\n                value = this.__wrapped__,\n                args = [value];\n\n            push.apply(args, arguments);\n            var result = func.apply(object, args);\n            if (chain || chainAll) {\n              if (value === result && isObject(result)) {\n                return this;\n              }\n              result = new ctor(result);\n              result.__chain__ = chainAll;\n            }\n            return result;\n          };\n        }\n      });\n    }\n\n    /**\n     * Reverts the '_' variable to its previous value and returns a reference to\n     * the `lodash` function.\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @returns {Function} Returns the `lodash` function.\n     * @example\n     *\n     * var lodash = _.noConflict();\n     */\n    function noConflict() {\n      context._ = oldDash;\n      return this;\n    }\n\n    /**\n     * A no-operation function.\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @example\n     *\n     * var object = { 'name': 'fred' };\n     * _.noop(object) === undefined;\n     * // => true\n     */\n    function noop() {\n      // no operation performed\n    }\n\n    /**\n     * Gets the number of milliseconds that have elapsed since the Unix epoch\n     * (1 January 1970 00:00:00 UTC).\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @example\n     *\n     * var stamp = _.now();\n     * _.defer(function() { console.log(_.now() - stamp); });\n     * // => logs the number of milliseconds it took for the deferred function to be called\n     */\n    var now = isNative(now = Date.now) && now || function() {\n      return new Date().getTime();\n    };\n\n    /**\n     * Converts the given value into an integer of the specified radix.\n     * If `radix` is `undefined` or `0` a `radix` of `10` is used unless the\n     * `value` is a hexadecimal, in which case a `radix` of `16` is used.\n     *\n     * Note: This method avoids differences in native ES3 and ES5 `parseInt`\n     * implementations. See http://es5.github.io/#E.\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @param {string} value The value to parse.\n     * @param {number} [radix] The radix used to interpret the value to parse.\n     * @returns {number} Returns the new integer value.\n     * @example\n     *\n     * _.parseInt('08');\n     * // => 8\n     */\n    var parseInt = nativeParseInt(whitespace + '08') == 8 ? nativeParseInt : function(value, radix) {\n      // Firefox < 21 and Opera < 15 follow the ES3 specified implementation of `parseInt`\n      return nativeParseInt(isString(value) ? value.replace(reLeadingSpacesAndZeros, '') : value, radix || 0);\n    };\n\n    /**\n     * Creates a \"_.pluck\" style function, which returns the `key` value of a\n     * given object.\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @param {string} key The name of the property to retrieve.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var characters = [\n     *   { 'name': 'fred',   'age': 40 },\n     *   { 'name': 'barney', 'age': 36 }\n     * ];\n     *\n     * var getName = _.property('name');\n     *\n     * _.map(characters, getName);\n     * // => ['barney', 'fred']\n     *\n     * _.sortBy(characters, getName);\n     * // => [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred',   'age': 40 }]\n     */\n    function property(key) {\n      return function(object) {\n        return object[key];\n      };\n    }\n\n    /**\n     * Produces a random number between `min` and `max` (inclusive). If only one\n     * argument is provided a number between `0` and the given number will be\n     * returned. If `floating` is truey or either `min` or `max` are floats a\n     * floating-point number will be returned instead of an integer.\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @param {number} [min=0] The minimum possible value.\n     * @param {number} [max=1] The maximum possible value.\n     * @param {boolean} [floating=false] Specify returning a floating-point number.\n     * @returns {number} Returns a random number.\n     * @example\n     *\n     * _.random(0, 5);\n     * // => an integer between 0 and 5\n     *\n     * _.random(5);\n     * // => also an integer between 0 and 5\n     *\n     * _.random(5, true);\n     * // => a floating-point number between 0 and 5\n     *\n     * _.random(1.2, 5.2);\n     * // => a floating-point number between 1.2 and 5.2\n     */\n    function random(min, max, floating) {\n      var noMin = min == null,\n          noMax = max == null;\n\n      if (floating == null) {\n        if (typeof min == 'boolean' && noMax) {\n          floating = min;\n          min = 1;\n        }\n        else if (!noMax && typeof max == 'boolean') {\n          floating = max;\n          noMax = true;\n        }\n      }\n      if (noMin && noMax) {\n        max = 1;\n      }\n      min = +min || 0;\n      if (noMax) {\n        max = min;\n        min = 0;\n      } else {\n        max = +max || 0;\n      }\n      if (floating || min % 1 || max % 1) {\n        var rand = nativeRandom();\n        return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand +'').length - 1)))), max);\n      }\n      return baseRandom(min, max);\n    }\n\n    /**\n     * Resolves the value of property `key` on `object`. If `key` is a function\n     * it will be invoked with the `this` binding of `object` and its result returned,\n     * else the property value is returned. If `object` is falsey then `undefined`\n     * is returned.\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @param {Object} object The object to inspect.\n     * @param {string} key The name of the property to resolve.\n     * @returns {*} Returns the resolved value.\n     * @example\n     *\n     * var object = {\n     *   'cheese': 'crumpets',\n     *   'stuff': function() {\n     *     return 'nonsense';\n     *   }\n     * };\n     *\n     * _.result(object, 'cheese');\n     * // => 'crumpets'\n     *\n     * _.result(object, 'stuff');\n     * // => 'nonsense'\n     */\n    function result(object, key) {\n      if (object) {\n        var value = object[key];\n        return isFunction(value) ? object[key]() : value;\n      }\n    }\n\n    /**\n     * A micro-templating method that handles arbitrary delimiters, preserves\n     * whitespace, and correctly escapes quotes within interpolated code.\n     *\n     * Note: In the development build, `_.template` utilizes sourceURLs for easier\n     * debugging. See http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl\n     *\n     * For more information on precompiling templates see:\n     * https://lodash.com/custom-builds\n     *\n     * For more information on Chrome extension sandboxes see:\n     * http://developer.chrome.com/stable/extensions/sandboxingEval.html\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @param {string} text The template text.\n     * @param {Object} data The data object used to populate the text.\n     * @param {Object} [options] The options object.\n     * @param {RegExp} [options.escape] The \"escape\" delimiter.\n     * @param {RegExp} [options.evaluate] The \"evaluate\" delimiter.\n     * @param {Object} [options.imports] An object to import into the template as local variables.\n     * @param {RegExp} [options.interpolate] The \"interpolate\" delimiter.\n     * @param {string} [sourceURL] The sourceURL of the template's compiled source.\n     * @param {string} [variable] The data object variable name.\n     * @returns {Function|string} Returns a compiled function when no `data` object\n     *  is given, else it returns the interpolated text.\n     * @example\n     *\n     * // using the \"interpolate\" delimiter to create a compiled template\n     * var compiled = _.template('hello <%= name %>');\n     * compiled({ 'name': 'fred' });\n     * // => 'hello fred'\n     *\n     * // using the \"escape\" delimiter to escape HTML in data property values\n     * _.template('<b><%- value %></b>', { 'value': '<script>' });\n     * // => '<b>&lt;script&gt;</b>'\n     *\n     * // using the \"evaluate\" delimiter to generate HTML\n     * var list = '<% _.forEach(people, function(name) { %><li><%- name %></li><% }); %>';\n     * _.template(list, { 'people': ['fred', 'barney'] });\n     * // => '<li>fred</li><li>barney</li>'\n     *\n     * // using the ES6 delimiter as an alternative to the default \"interpolate\" delimiter\n     * _.template('hello ${ name }', { 'name': 'pebbles' });\n     * // => 'hello pebbles'\n     *\n     * // using the internal `print` function in \"evaluate\" delimiters\n     * _.template('<% print(\"hello \" + name); %>!', { 'name': 'barney' });\n     * // => 'hello barney!'\n     *\n     * // using a custom template delimiters\n     * _.templateSettings = {\n     *   'interpolate': /{{([\\s\\S]+?)}}/g\n     * };\n     *\n     * _.template('hello {{ name }}!', { 'name': 'mustache' });\n     * // => 'hello mustache!'\n     *\n     * // using the `imports` option to import jQuery\n     * var list = '<% jq.each(people, function(name) { %><li><%- name %></li><% }); %>';\n     * _.template(list, { 'people': ['fred', 'barney'] }, { 'imports': { 'jq': jQuery } });\n     * // => '<li>fred</li><li>barney</li>'\n     *\n     * // using the `sourceURL` option to specify a custom sourceURL for the template\n     * var compiled = _.template('hello <%= name %>', null, { 'sourceURL': '/basic/greeting.jst' });\n     * compiled(data);\n     * // => find the source of \"greeting.jst\" under the Sources tab or Resources panel of the web inspector\n     *\n     * // using the `variable` option to ensure a with-statement isn't used in the compiled template\n     * var compiled = _.template('hi <%= data.name %>!', null, { 'variable': 'data' });\n     * compiled.source;\n     * // => function(data) {\n     *   var __t, __p = '', __e = _.escape;\n     *   __p += 'hi ' + ((__t = ( data.name )) == null ? '' : __t) + '!';\n     *   return __p;\n     * }\n     *\n     * // using the `source` property to inline compiled templates for meaningful\n     * // line numbers in error messages and a stack trace\n     * fs.writeFileSync(path.join(cwd, 'jst.js'), '\\\n     *   var JST = {\\\n     *     \"main\": ' + _.template(mainText).source + '\\\n     *   };\\\n     * ');\n     */\n    function template(text, data, options) {\n      // based on John Resig's `tmpl` implementation\n      // http://ejohn.org/blog/javascript-micro-templating/\n      // and Laura Doktorova's doT.js\n      // https://github.com/olado/doT\n      var settings = lodash.templateSettings;\n      text = String(text || '');\n\n      // avoid missing dependencies when `iteratorTemplate` is not defined\n      options = defaults({}, options, settings);\n\n      var imports = defaults({}, options.imports, settings.imports),\n          importsKeys = keys(imports),\n          importsValues = values(imports);\n\n      var isEvaluating,\n          index = 0,\n          interpolate = options.interpolate || reNoMatch,\n          source = \"__p += '\";\n\n      // compile the regexp to match each delimiter\n      var reDelimiters = RegExp(\n        (options.escape || reNoMatch).source + '|' +\n        interpolate.source + '|' +\n        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +\n        (options.evaluate || reNoMatch).source + '|$'\n      , 'g');\n\n      text.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {\n        interpolateValue || (interpolateValue = esTemplateValue);\n\n        // escape characters that cannot be included in string literals\n        source += text.slice(index, offset).replace(reUnescapedString, escapeStringChar);\n\n        // replace delimiters with snippets\n        if (escapeValue) {\n          source += \"' +\\n__e(\" + escapeValue + \") +\\n'\";\n        }\n        if (evaluateValue) {\n          isEvaluating = true;\n          source += \"';\\n\" + evaluateValue + \";\\n__p += '\";\n        }\n        if (interpolateValue) {\n          source += \"' +\\n((__t = (\" + interpolateValue + \")) == null ? '' : __t) +\\n'\";\n        }\n        index = offset + match.length;\n\n        // the JS engine embedded in Adobe products requires returning the `match`\n        // string in order to produce the correct `offset` value\n        return match;\n      });\n\n      source += \"';\\n\";\n\n      // if `variable` is not specified, wrap a with-statement around the generated\n      // code to add the data object to the top of the scope chain\n      var variable = options.variable,\n          hasVariable = variable;\n\n      if (!hasVariable) {\n        variable = 'obj';\n        source = 'with (' + variable + ') {\\n' + source + '\\n}\\n';\n      }\n      // cleanup code by stripping empty strings\n      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)\n        .replace(reEmptyStringMiddle, '$1')\n        .replace(reEmptyStringTrailing, '$1;');\n\n      // frame code as the function body\n      source = 'function(' + variable + ') {\\n' +\n        (hasVariable ? '' : variable + ' || (' + variable + ' = {});\\n') +\n        \"var __t, __p = '', __e = _.escape\" +\n        (isEvaluating\n          ? ', __j = Array.prototype.join;\\n' +\n            \"function print() { __p += __j.call(arguments, '') }\\n\"\n          : ';\\n'\n        ) +\n        source +\n        'return __p\\n}';\n\n      // Use a sourceURL for easier debugging.\n      // http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl\n      var sourceURL = '\\n/*\\n//# sourceURL=' + (options.sourceURL || '/lodash/template/source[' + (templateCounter++) + ']') + '\\n*/';\n\n      try {\n        var result = Function(importsKeys, 'return ' + source + sourceURL).apply(undefined, importsValues);\n      } catch(e) {\n        e.source = source;\n        throw e;\n      }\n      if (data) {\n        return result(data);\n      }\n      // provide the compiled function's source by its `toString` method, in\n      // supported environments, or the `source` property as a convenience for\n      // inlining compiled templates during the build process\n      result.source = source;\n      return result;\n    }\n\n    /**\n     * Executes the callback `n` times, returning an array of the results\n     * of each callback execution. The callback is bound to `thisArg` and invoked\n     * with one argument; (index).\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @param {number} n The number of times to execute the callback.\n     * @param {Function} callback The function called per iteration.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Array} Returns an array of the results of each `callback` execution.\n     * @example\n     *\n     * var diceRolls = _.times(3, _.partial(_.random, 1, 6));\n     * // => [3, 6, 4]\n     *\n     * _.times(3, function(n) { mage.castSpell(n); });\n     * // => calls `mage.castSpell(n)` three times, passing `n` of `0`, `1`, and `2` respectively\n     *\n     * _.times(3, function(n) { this.cast(n); }, mage);\n     * // => also calls `mage.castSpell(n)` three times\n     */\n    function times(n, callback, thisArg) {\n      n = (n = +n) > -1 ? n : 0;\n      var index = -1,\n          result = Array(n);\n\n      callback = baseCreateCallback(callback, thisArg, 1);\n      while (++index < n) {\n        result[index] = callback(index);\n      }\n      return result;\n    }\n\n    /**\n     * The inverse of `_.escape` this method converts the HTML entities\n     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to their\n     * corresponding characters.\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @param {string} string The string to unescape.\n     * @returns {string} Returns the unescaped string.\n     * @example\n     *\n     * _.unescape('Fred, Barney &amp; Pebbles');\n     * // => 'Fred, Barney & Pebbles'\n     */\n    function unescape(string) {\n      return string == null ? '' : String(string).replace(reEscapedHtml, unescapeHtmlChar);\n    }\n\n    /**\n     * Generates a unique ID. If `prefix` is provided the ID will be appended to it.\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @param {string} [prefix] The value to prefix the ID with.\n     * @returns {string} Returns the unique ID.\n     * @example\n     *\n     * _.uniqueId('contact_');\n     * // => 'contact_104'\n     *\n     * _.uniqueId();\n     * // => '105'\n     */\n    function uniqueId(prefix) {\n      var id = ++idCounter;\n      return String(prefix == null ? '' : prefix) + id;\n    }\n\n    /*--------------------------------------------------------------------------*/\n\n    /**\n     * Creates a `lodash` object that wraps the given value with explicit\n     * method chaining enabled.\n     *\n     * @static\n     * @memberOf _\n     * @category Chaining\n     * @param {*} value The value to wrap.\n     * @returns {Object} Returns the wrapper object.\n     * @example\n     *\n     * var characters = [\n     *   { 'name': 'barney',  'age': 36 },\n     *   { 'name': 'fred',    'age': 40 },\n     *   { 'name': 'pebbles', 'age': 1 }\n     * ];\n     *\n     * var youngest = _.chain(characters)\n     *     .sortBy('age')\n     *     .map(function(chr) { return chr.name + ' is ' + chr.age; })\n     *     .first()\n     *     .value();\n     * // => 'pebbles is 1'\n     */\n    function chain(value) {\n      value = new lodashWrapper(value);\n      value.__chain__ = true;\n      return value;\n    }\n\n    /**\n     * Invokes `interceptor` with the `value` as the first argument and then\n     * returns `value`. The purpose of this method is to \"tap into\" a method\n     * chain in order to perform operations on intermediate results within\n     * the chain.\n     *\n     * @static\n     * @memberOf _\n     * @category Chaining\n     * @param {*} value The value to provide to `interceptor`.\n     * @param {Function} interceptor The function to invoke.\n     * @returns {*} Returns `value`.\n     * @example\n     *\n     * _([1, 2, 3, 4])\n     *  .tap(function(array) { array.pop(); })\n     *  .reverse()\n     *  .value();\n     * // => [3, 2, 1]\n     */\n    function tap(value, interceptor) {\n      interceptor(value);\n      return value;\n    }\n\n    /**\n     * Enables explicit method chaining on the wrapper object.\n     *\n     * @name chain\n     * @memberOf _\n     * @category Chaining\n     * @returns {*} Returns the wrapper object.\n     * @example\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36 },\n     *   { 'name': 'fred',   'age': 40 }\n     * ];\n     *\n     * // without explicit chaining\n     * _(characters).first();\n     * // => { 'name': 'barney', 'age': 36 }\n     *\n     * // with explicit chaining\n     * _(characters).chain()\n     *   .first()\n     *   .pick('age')\n     *   .value();\n     * // => { 'age': 36 }\n     */\n    function wrapperChain() {\n      this.__chain__ = true;\n      return this;\n    }\n\n    /**\n     * Produces the `toString` result of the wrapped value.\n     *\n     * @name toString\n     * @memberOf _\n     * @category Chaining\n     * @returns {string} Returns the string result.\n     * @example\n     *\n     * _([1, 2, 3]).toString();\n     * // => '1,2,3'\n     */\n    function wrapperToString() {\n      return String(this.__wrapped__);\n    }\n\n    /**\n     * Extracts the wrapped value.\n     *\n     * @name valueOf\n     * @memberOf _\n     * @alias value\n     * @category Chaining\n     * @returns {*} Returns the wrapped value.\n     * @example\n     *\n     * _([1, 2, 3]).valueOf();\n     * // => [1, 2, 3]\n     */\n    function wrapperValueOf() {\n      return this.__wrapped__;\n    }\n\n    /*--------------------------------------------------------------------------*/\n\n    // add functions that return wrapped values when chaining\n    lodash.after = after;\n    lodash.assign = assign;\n    lodash.at = at;\n    lodash.bind = bind;\n    lodash.bindAll = bindAll;\n    lodash.bindKey = bindKey;\n    lodash.chain = chain;\n    lodash.compact = compact;\n    lodash.compose = compose;\n    lodash.constant = constant;\n    lodash.countBy = countBy;\n    lodash.create = create;\n    lodash.createCallback = createCallback;\n    lodash.curry = curry;\n    lodash.debounce = debounce;\n    lodash.defaults = defaults;\n    lodash.defer = defer;\n    lodash.delay = delay;\n    lodash.difference = difference;\n    lodash.filter = filter;\n    lodash.flatten = flatten;\n    lodash.forEach = forEach;\n    lodash.forEachRight = forEachRight;\n    lodash.forIn = forIn;\n    lodash.forInRight = forInRight;\n    lodash.forOwn = forOwn;\n    lodash.forOwnRight = forOwnRight;\n    lodash.functions = functions;\n    lodash.groupBy = groupBy;\n    lodash.indexBy = indexBy;\n    lodash.initial = initial;\n    lodash.intersection = intersection;\n    lodash.invert = invert;\n    lodash.invoke = invoke;\n    lodash.keys = keys;\n    lodash.map = map;\n    lodash.mapValues = mapValues;\n    lodash.max = max;\n    lodash.memoize = memoize;\n    lodash.merge = merge;\n    lodash.min = min;\n    lodash.omit = omit;\n    lodash.once = once;\n    lodash.pairs = pairs;\n    lodash.partial = partial;\n    lodash.partialRight = partialRight;\n    lodash.pick = pick;\n    lodash.pluck = pluck;\n    lodash.property = property;\n    lodash.pull = pull;\n    lodash.range = range;\n    lodash.reject = reject;\n    lodash.remove = remove;\n    lodash.rest = rest;\n    lodash.shuffle = shuffle;\n    lodash.sortBy = sortBy;\n    lodash.tap = tap;\n    lodash.throttle = throttle;\n    lodash.times = times;\n    lodash.toArray = toArray;\n    lodash.transform = transform;\n    lodash.union = union;\n    lodash.uniq = uniq;\n    lodash.values = values;\n    lodash.where = where;\n    lodash.without = without;\n    lodash.wrap = wrap;\n    lodash.xor = xor;\n    lodash.zip = zip;\n    lodash.zipObject = zipObject;\n\n    // add aliases\n    lodash.collect = map;\n    lodash.drop = rest;\n    lodash.each = forEach;\n    lodash.eachRight = forEachRight;\n    lodash.extend = assign;\n    lodash.methods = functions;\n    lodash.object = zipObject;\n    lodash.select = filter;\n    lodash.tail = rest;\n    lodash.unique = uniq;\n    lodash.unzip = zip;\n\n    // add functions to `lodash.prototype`\n    mixin(lodash);\n\n    /*--------------------------------------------------------------------------*/\n\n    // add functions that return unwrapped values when chaining\n    lodash.clone = clone;\n    lodash.cloneDeep = cloneDeep;\n    lodash.contains = contains;\n    lodash.escape = escape;\n    lodash.every = every;\n    lodash.find = find;\n    lodash.findIndex = findIndex;\n    lodash.findKey = findKey;\n    lodash.findLast = findLast;\n    lodash.findLastIndex = findLastIndex;\n    lodash.findLastKey = findLastKey;\n    lodash.has = has;\n    lodash.identity = identity;\n    lodash.indexOf = indexOf;\n    lodash.isArguments = isArguments;\n    lodash.isArray = isArray;\n    lodash.isBoolean = isBoolean;\n    lodash.isDate = isDate;\n    lodash.isElement = isElement;\n    lodash.isEmpty = isEmpty;\n    lodash.isEqual = isEqual;\n    lodash.isFinite = isFinite;\n    lodash.isFunction = isFunction;\n    lodash.isNaN = isNaN;\n    lodash.isNull = isNull;\n    lodash.isNumber = isNumber;\n    lodash.isObject = isObject;\n    lodash.isPlainObject = isPlainObject;\n    lodash.isRegExp = isRegExp;\n    lodash.isString = isString;\n    lodash.isUndefined = isUndefined;\n    lodash.lastIndexOf = lastIndexOf;\n    lodash.mixin = mixin;\n    lodash.noConflict = noConflict;\n    lodash.noop = noop;\n    lodash.now = now;\n    lodash.parseInt = parseInt;\n    lodash.random = random;\n    lodash.reduce = reduce;\n    lodash.reduceRight = reduceRight;\n    lodash.result = result;\n    lodash.runInContext = runInContext;\n    lodash.size = size;\n    lodash.some = some;\n    lodash.sortedIndex = sortedIndex;\n    lodash.template = template;\n    lodash.unescape = unescape;\n    lodash.uniqueId = uniqueId;\n\n    // add aliases\n    lodash.all = every;\n    lodash.any = some;\n    lodash.detect = find;\n    lodash.findWhere = find;\n    lodash.foldl = reduce;\n    lodash.foldr = reduceRight;\n    lodash.include = contains;\n    lodash.inject = reduce;\n\n    mixin(function() {\n      var source = {}\n      forOwn(lodash, function(func, methodName) {\n        if (!lodash.prototype[methodName]) {\n          source[methodName] = func;\n        }\n      });\n      return source;\n    }(), false);\n\n    /*--------------------------------------------------------------------------*/\n\n    // add functions capable of returning wrapped and unwrapped values when chaining\n    lodash.first = first;\n    lodash.last = last;\n    lodash.sample = sample;\n\n    // add aliases\n    lodash.take = first;\n    lodash.head = first;\n\n    forOwn(lodash, function(func, methodName) {\n      var callbackable = methodName !== 'sample';\n      if (!lodash.prototype[methodName]) {\n        lodash.prototype[methodName]= function(n, guard) {\n          var chainAll = this.__chain__,\n              result = func(this.__wrapped__, n, guard);\n\n          return !chainAll && (n == null || (guard && !(callbackable && typeof n == 'function')))\n            ? result\n            : new lodashWrapper(result, chainAll);\n        };\n      }\n    });\n\n    /*--------------------------------------------------------------------------*/\n\n    /**\n     * The semantic version number.\n     *\n     * @static\n     * @memberOf _\n     * @type string\n     */\n    lodash.VERSION = '2.4.2';\n\n    // add \"Chaining\" functions to the wrapper\n    lodash.prototype.chain = wrapperChain;\n    lodash.prototype.toString = wrapperToString;\n    lodash.prototype.value = wrapperValueOf;\n    lodash.prototype.valueOf = wrapperValueOf;\n\n    // add `Array` functions that return unwrapped values\n    forEach(['join', 'pop', 'shift'], function(methodName) {\n      var func = arrayRef[methodName];\n      lodash.prototype[methodName] = function() {\n        var chainAll = this.__chain__,\n            result = func.apply(this.__wrapped__, arguments);\n\n        return chainAll\n          ? new lodashWrapper(result, chainAll)\n          : result;\n      };\n    });\n\n    // add `Array` functions that return the existing wrapped value\n    forEach(['push', 'reverse', 'sort', 'unshift'], function(methodName) {\n      var func = arrayRef[methodName];\n      lodash.prototype[methodName] = function() {\n        func.apply(this.__wrapped__, arguments);\n        return this;\n      };\n    });\n\n    // add `Array` functions that return new wrapped values\n    forEach(['concat', 'slice', 'splice'], function(methodName) {\n      var func = arrayRef[methodName];\n      lodash.prototype[methodName] = function() {\n        return new lodashWrapper(func.apply(this.__wrapped__, arguments), this.__chain__);\n      };\n    });\n\n    return lodash;\n  }\n\n  /*--------------------------------------------------------------------------*/\n\n  // expose Lo-Dash\n  var _ = runInContext();\n\n  // some AMD build optimizers like r.js check for condition patterns like the following:\n  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {\n    // Expose Lo-Dash to the global object even when an AMD loader is present in\n    // case Lo-Dash is loaded with a RequireJS shim config.\n    // See http://requirejs.org/docs/api.html#config-shim\n    root._ = _;\n\n    // define as an anonymous module so, through path mapping, it can be\n    // referenced as the \"underscore\" module\n    define(function() {\n      return _;\n    });\n  }\n  // check for `exports` after `define` in case a build optimizer adds an `exports` object\n  else if (freeExports && freeModule) {\n    // in Node.js or RingoJS\n    if (moduleExports) {\n      (freeModule.exports = _)._ = _;\n    }\n    // in Narwhal or Rhino -require\n    else {\n      freeExports._ = _;\n    }\n  }\n  else {\n    // in a browser or Rhino\n    root._ = _;\n  }\n}.call(this));\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails-generate/node_modules/merge-defaults/index.js":"var _ = require('lodash');\n\n/**\n * defaultsDeep\n *\n * Implement a deep version of `_.defaults`.\n *\n * This method is hopefully temporary, until lodash has something\n * similar that can be called in a single method.  For now, it's\n * worth it to use a temporary module for readability.\n * (i.e. I know what `_.defaults` means offhand- not true for `_.partialRight`)\n */\n\n// In case the end user decided to do `_.defaults = require('merge-defaults')`,\n// before doing anything else, let's make SURE we have a reference to the original\n// `_.defaults()` method definition.\nvar origLodashDefaults = _.defaults;\n\n// Corrected: see https://github.com/lodash/lodash/issues/540\nmodule.exports = _.partialRight(_.merge, function () {\n\n  // Ensure dates and arrays are not recursively merged\n  if (_.isArray(arguments[0]) || _.isDate(arguments[0])) {\n    return arguments[0];\n  }\n  return origLodashDefaults.apply(_, Array.prototype.slice.call(arguments));\n});\n\n\n// module.exports = _.partialRight(_.merge, _.defaults);\n\n// module.exports = _.partialRight(_.merge, function deep(a, b) {\n//   // Ensure dates and arrays are not recursively merged\n//   if (_.isArray(a) || _.isDate(a)) {\n//     return a;\n//   }\n//   else return _.merge(a, b, deep);\n// });","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails-generate/node_modules/async/lib/async.js":"/*global setImmediate: false, setTimeout: false, console: false */\n(function () {\n\n    var async = {};\n\n    // global on the server, window in the browser\n    var root, previous_async;\n\n    root = this;\n    if (root != null) {\n      previous_async = root.async;\n    }\n\n    async.noConflict = function () {\n        root.async = previous_async;\n        return async;\n    };\n\n    function only_once(fn) {\n        var called = false;\n        return function() {\n            if (called) throw new Error(\"Callback was already called.\");\n            called = true;\n            fn.apply(root, arguments);\n        }\n    }\n\n    //// cross-browser compatiblity functions ////\n\n    var _each = function (arr, iterator) {\n        if (arr.forEach) {\n            return arr.forEach(iterator);\n        }\n        for (var i = 0; i < arr.length; i += 1) {\n            iterator(arr[i], i, arr);\n        }\n    };\n\n    var _map = function (arr, iterator) {\n        if (arr.map) {\n            return arr.map(iterator);\n        }\n        var results = [];\n        _each(arr, function (x, i, a) {\n            results.push(iterator(x, i, a));\n        });\n        return results;\n    };\n\n    var _reduce = function (arr, iterator, memo) {\n        if (arr.reduce) {\n            return arr.reduce(iterator, memo);\n        }\n        _each(arr, function (x, i, a) {\n            memo = iterator(memo, x, i, a);\n        });\n        return memo;\n    };\n\n    var _keys = function (obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        }\n        var keys = [];\n        for (var k in obj) {\n            if (obj.hasOwnProperty(k)) {\n                keys.push(k);\n            }\n        }\n        return keys;\n    };\n\n    //// exported async module functions ////\n\n    //// nextTick implementation with browser-compatible fallback ////\n    if (typeof process === 'undefined' || !(process.nextTick)) {\n        if (typeof setImmediate === 'function') {\n            async.nextTick = function (fn) {\n                // not a direct alias for IE10 compatibility\n                setImmediate(fn);\n            };\n            async.setImmediate = async.nextTick;\n        }\n        else {\n            async.nextTick = function (fn) {\n                setTimeout(fn, 0);\n            };\n            async.setImmediate = async.nextTick;\n        }\n    }\n    else {\n        async.nextTick = process.nextTick;\n        if (typeof setImmediate !== 'undefined') {\n            async.setImmediate = function (fn) {\n              // not a direct alias for IE10 compatibility\n              setImmediate(fn);\n            };\n        }\n        else {\n            async.setImmediate = async.nextTick;\n        }\n    }\n\n    async.each = function (arr, iterator, callback) {\n        callback = callback || function () {};\n        if (!arr.length) {\n            return callback();\n        }\n        var completed = 0;\n        _each(arr, function (x) {\n            iterator(x, only_once(function (err) {\n                if (err) {\n                    callback(err);\n                    callback = function () {};\n                }\n                else {\n                    completed += 1;\n                    if (completed >= arr.length) {\n                        callback(null);\n                    }\n                }\n            }));\n        });\n    };\n    async.forEach = async.each;\n\n    async.eachSeries = function (arr, iterator, callback) {\n        callback = callback || function () {};\n        if (!arr.length) {\n            return callback();\n        }\n        var completed = 0;\n        var iterate = function () {\n            iterator(arr[completed], function (err) {\n                if (err) {\n                    callback(err);\n                    callback = function () {};\n                }\n                else {\n                    completed += 1;\n                    if (completed >= arr.length) {\n                        callback(null);\n                    }\n                    else {\n                        iterate();\n                    }\n                }\n            });\n        };\n        iterate();\n    };\n    async.forEachSeries = async.eachSeries;\n\n    async.eachLimit = function (arr, limit, iterator, callback) {\n        var fn = _eachLimit(limit);\n        fn.apply(null, [arr, iterator, callback]);\n    };\n    async.forEachLimit = async.eachLimit;\n\n    var _eachLimit = function (limit) {\n\n        return function (arr, iterator, callback) {\n            callback = callback || function () {};\n            if (!arr.length || limit <= 0) {\n                return callback();\n            }\n            var completed = 0;\n            var started = 0;\n            var running = 0;\n\n            (function replenish () {\n                if (completed >= arr.length) {\n                    return callback();\n                }\n\n                while (running < limit && started < arr.length) {\n                    started += 1;\n                    running += 1;\n                    iterator(arr[started - 1], function (err) {\n                        if (err) {\n                            callback(err);\n                            callback = function () {};\n                        }\n                        else {\n                            completed += 1;\n                            running -= 1;\n                            if (completed >= arr.length) {\n                                callback();\n                            }\n                            else {\n                                replenish();\n                            }\n                        }\n                    });\n                }\n            })();\n        };\n    };\n\n\n    var doParallel = function (fn) {\n        return function () {\n            var args = Array.prototype.slice.call(arguments);\n            return fn.apply(null, [async.each].concat(args));\n        };\n    };\n    var doParallelLimit = function(limit, fn) {\n        return function () {\n            var args = Array.prototype.slice.call(arguments);\n            return fn.apply(null, [_eachLimit(limit)].concat(args));\n        };\n    };\n    var doSeries = function (fn) {\n        return function () {\n            var args = Array.prototype.slice.call(arguments);\n            return fn.apply(null, [async.eachSeries].concat(args));\n        };\n    };\n\n\n    var _asyncMap = function (eachfn, arr, iterator, callback) {\n        var results = [];\n        arr = _map(arr, function (x, i) {\n            return {index: i, value: x};\n        });\n        eachfn(arr, function (x, callback) {\n            iterator(x.value, function (err, v) {\n                results[x.index] = v;\n                callback(err);\n            });\n        }, function (err) {\n            callback(err, results);\n        });\n    };\n    async.map = doParallel(_asyncMap);\n    async.mapSeries = doSeries(_asyncMap);\n    async.mapLimit = function (arr, limit, iterator, callback) {\n        return _mapLimit(limit)(arr, iterator, callback);\n    };\n\n    var _mapLimit = function(limit) {\n        return doParallelLimit(limit, _asyncMap);\n    };\n\n    // reduce only has a series version, as doing reduce in parallel won't\n    // work in many situations.\n    async.reduce = function (arr, memo, iterator, callback) {\n        async.eachSeries(arr, function (x, callback) {\n            iterator(memo, x, function (err, v) {\n                memo = v;\n                callback(err);\n            });\n        }, function (err) {\n            callback(err, memo);\n        });\n    };\n    // inject alias\n    async.inject = async.reduce;\n    // foldl alias\n    async.foldl = async.reduce;\n\n    async.reduceRight = function (arr, memo, iterator, callback) {\n        var reversed = _map(arr, function (x) {\n            return x;\n        }).reverse();\n        async.reduce(reversed, memo, iterator, callback);\n    };\n    // foldr alias\n    async.foldr = async.reduceRight;\n\n    var _filter = function (eachfn, arr, iterator, callback) {\n        var results = [];\n        arr = _map(arr, function (x, i) {\n            return {index: i, value: x};\n        });\n        eachfn(arr, function (x, callback) {\n            iterator(x.value, function (v) {\n                if (v) {\n                    results.push(x);\n                }\n                callback();\n            });\n        }, function (err) {\n            callback(_map(results.sort(function (a, b) {\n                return a.index - b.index;\n            }), function (x) {\n                return x.value;\n            }));\n        });\n    };\n    async.filter = doParallel(_filter);\n    async.filterSeries = doSeries(_filter);\n    // select alias\n    async.select = async.filter;\n    async.selectSeries = async.filterSeries;\n\n    var _reject = function (eachfn, arr, iterator, callback) {\n        var results = [];\n        arr = _map(arr, function (x, i) {\n            return {index: i, value: x};\n        });\n        eachfn(arr, function (x, callback) {\n            iterator(x.value, function (v) {\n                if (!v) {\n                    results.push(x);\n                }\n                callback();\n            });\n        }, function (err) {\n            callback(_map(results.sort(function (a, b) {\n                return a.index - b.index;\n            }), function (x) {\n                return x.value;\n            }));\n        });\n    };\n    async.reject = doParallel(_reject);\n    async.rejectSeries = doSeries(_reject);\n\n    var _detect = function (eachfn, arr, iterator, main_callback) {\n        eachfn(arr, function (x, callback) {\n            iterator(x, function (result) {\n                if (result) {\n                    main_callback(x);\n                    main_callback = function () {};\n                }\n                else {\n                    callback();\n                }\n            });\n        }, function (err) {\n            main_callback();\n        });\n    };\n    async.detect = doParallel(_detect);\n    async.detectSeries = doSeries(_detect);\n\n    async.some = function (arr, iterator, main_callback) {\n        async.each(arr, function (x, callback) {\n            iterator(x, function (v) {\n                if (v) {\n                    main_callback(true);\n                    main_callback = function () {};\n                }\n                callback();\n            });\n        }, function (err) {\n            main_callback(false);\n        });\n    };\n    // any alias\n    async.any = async.some;\n\n    async.every = function (arr, iterator, main_callback) {\n        async.each(arr, function (x, callback) {\n            iterator(x, function (v) {\n                if (!v) {\n                    main_callback(false);\n                    main_callback = function () {};\n                }\n                callback();\n            });\n        }, function (err) {\n            main_callback(true);\n        });\n    };\n    // all alias\n    async.all = async.every;\n\n    async.sortBy = function (arr, iterator, callback) {\n        async.map(arr, function (x, callback) {\n            iterator(x, function (err, criteria) {\n                if (err) {\n                    callback(err);\n                }\n                else {\n                    callback(null, {value: x, criteria: criteria});\n                }\n            });\n        }, function (err, results) {\n            if (err) {\n                return callback(err);\n            }\n            else {\n                var fn = function (left, right) {\n                    var a = left.criteria, b = right.criteria;\n                    return a < b ? -1 : a > b ? 1 : 0;\n                };\n                callback(null, _map(results.sort(fn), function (x) {\n                    return x.value;\n                }));\n            }\n        });\n    };\n\n    async.auto = function (tasks, callback) {\n        callback = callback || function () {};\n        var keys = _keys(tasks);\n        if (!keys.length) {\n            return callback(null);\n        }\n\n        var results = {};\n\n        var listeners = [];\n        var addListener = function (fn) {\n            listeners.unshift(fn);\n        };\n        var removeListener = function (fn) {\n            for (var i = 0; i < listeners.length; i += 1) {\n                if (listeners[i] === fn) {\n                    listeners.splice(i, 1);\n                    return;\n                }\n            }\n        };\n        var taskComplete = function () {\n            _each(listeners.slice(0), function (fn) {\n                fn();\n            });\n        };\n\n        addListener(function () {\n            if (_keys(results).length === keys.length) {\n                callback(null, results);\n                callback = function () {};\n            }\n        });\n\n        _each(keys, function (k) {\n            var task = (tasks[k] instanceof Function) ? [tasks[k]]: tasks[k];\n            var taskCallback = function (err) {\n                var args = Array.prototype.slice.call(arguments, 1);\n                if (args.length <= 1) {\n                    args = args[0];\n                }\n                if (err) {\n                    var safeResults = {};\n                    _each(_keys(results), function(rkey) {\n                        safeResults[rkey] = results[rkey];\n                    });\n                    safeResults[k] = args;\n                    callback(err, safeResults);\n                    // stop subsequent errors hitting callback multiple times\n                    callback = function () {};\n                }\n                else {\n                    results[k] = args;\n                    async.setImmediate(taskComplete);\n                }\n            };\n            var requires = task.slice(0, Math.abs(task.length - 1)) || [];\n            var ready = function () {\n                return _reduce(requires, function (a, x) {\n                    return (a && results.hasOwnProperty(x));\n                }, true) && !results.hasOwnProperty(k);\n            };\n            if (ready()) {\n                task[task.length - 1](taskCallback, results);\n            }\n            else {\n                var listener = function () {\n                    if (ready()) {\n                        removeListener(listener);\n                        task[task.length - 1](taskCallback, results);\n                    }\n                };\n                addListener(listener);\n            }\n        });\n    };\n\n    async.waterfall = function (tasks, callback) {\n        callback = callback || function () {};\n        if (tasks.constructor !== Array) {\n          var err = new Error('First argument to waterfall must be an array of functions');\n          return callback(err);\n        }\n        if (!tasks.length) {\n            return callback();\n        }\n        var wrapIterator = function (iterator) {\n            return function (err) {\n                if (err) {\n                    callback.apply(null, arguments);\n                    callback = function () {};\n                }\n                else {\n                    var args = Array.prototype.slice.call(arguments, 1);\n                    var next = iterator.next();\n                    if (next) {\n                        args.push(wrapIterator(next));\n                    }\n                    else {\n                        args.push(callback);\n                    }\n                    async.setImmediate(function () {\n                        iterator.apply(null, args);\n                    });\n                }\n            };\n        };\n        wrapIterator(async.iterator(tasks))();\n    };\n\n    var _parallel = function(eachfn, tasks, callback) {\n        callback = callback || function () {};\n        if (tasks.constructor === Array) {\n            eachfn.map(tasks, function (fn, callback) {\n                if (fn) {\n                    fn(function (err) {\n                        var args = Array.prototype.slice.call(arguments, 1);\n                        if (args.length <= 1) {\n                            args = args[0];\n                        }\n                        callback.call(null, err, args);\n                    });\n                }\n            }, callback);\n        }\n        else {\n            var results = {};\n            eachfn.each(_keys(tasks), function (k, callback) {\n                tasks[k](function (err) {\n                    var args = Array.prototype.slice.call(arguments, 1);\n                    if (args.length <= 1) {\n                        args = args[0];\n                    }\n                    results[k] = args;\n                    callback(err);\n                });\n            }, function (err) {\n                callback(err, results);\n            });\n        }\n    };\n\n    async.parallel = function (tasks, callback) {\n        _parallel({ map: async.map, each: async.each }, tasks, callback);\n    };\n\n    async.parallelLimit = function(tasks, limit, callback) {\n        _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);\n    };\n\n    async.series = function (tasks, callback) {\n        callback = callback || function () {};\n        if (tasks.constructor === Array) {\n            async.mapSeries(tasks, function (fn, callback) {\n                if (fn) {\n                    fn(function (err) {\n                        var args = Array.prototype.slice.call(arguments, 1);\n                        if (args.length <= 1) {\n                            args = args[0];\n                        }\n                        callback.call(null, err, args);\n                    });\n                }\n            }, callback);\n        }\n        else {\n            var results = {};\n            async.eachSeries(_keys(tasks), function (k, callback) {\n                tasks[k](function (err) {\n                    var args = Array.prototype.slice.call(arguments, 1);\n                    if (args.length <= 1) {\n                        args = args[0];\n                    }\n                    results[k] = args;\n                    callback(err);\n                });\n            }, function (err) {\n                callback(err, results);\n            });\n        }\n    };\n\n    async.iterator = function (tasks) {\n        var makeCallback = function (index) {\n            var fn = function () {\n                if (tasks.length) {\n                    tasks[index].apply(null, arguments);\n                }\n                return fn.next();\n            };\n            fn.next = function () {\n                return (index < tasks.length - 1) ? makeCallback(index + 1): null;\n            };\n            return fn;\n        };\n        return makeCallback(0);\n    };\n\n    async.apply = function (fn) {\n        var args = Array.prototype.slice.call(arguments, 1);\n        return function () {\n            return fn.apply(\n                null, args.concat(Array.prototype.slice.call(arguments))\n            );\n        };\n    };\n\n    var _concat = function (eachfn, arr, fn, callback) {\n        var r = [];\n        eachfn(arr, function (x, cb) {\n            fn(x, function (err, y) {\n                r = r.concat(y || []);\n                cb(err);\n            });\n        }, function (err) {\n            callback(err, r);\n        });\n    };\n    async.concat = doParallel(_concat);\n    async.concatSeries = doSeries(_concat);\n\n    async.whilst = function (test, iterator, callback) {\n        if (test()) {\n            iterator(function (err) {\n                if (err) {\n                    return callback(err);\n                }\n                async.whilst(test, iterator, callback);\n            });\n        }\n        else {\n            callback();\n        }\n    };\n\n    async.doWhilst = function (iterator, test, callback) {\n        iterator(function (err) {\n            if (err) {\n                return callback(err);\n            }\n            if (test()) {\n                async.doWhilst(iterator, test, callback);\n            }\n            else {\n                callback();\n            }\n        });\n    };\n\n    async.until = function (test, iterator, callback) {\n        if (!test()) {\n            iterator(function (err) {\n                if (err) {\n                    return callback(err);\n                }\n                async.until(test, iterator, callback);\n            });\n        }\n        else {\n            callback();\n        }\n    };\n\n    async.doUntil = function (iterator, test, callback) {\n        iterator(function (err) {\n            if (err) {\n                return callback(err);\n            }\n            if (!test()) {\n                async.doUntil(iterator, test, callback);\n            }\n            else {\n                callback();\n            }\n        });\n    };\n\n    async.queue = function (worker, concurrency) {\n        if (concurrency === undefined) {\n            concurrency = 1;\n        }\n        function _insert(q, data, pos, callback) {\n          if(data.constructor !== Array) {\n              data = [data];\n          }\n          _each(data, function(task) {\n              var item = {\n                  data: task,\n                  callback: typeof callback === 'function' ? callback : null\n              };\n\n              if (pos) {\n                q.tasks.unshift(item);\n              } else {\n                q.tasks.push(item);\n              }\n\n              if (q.saturated && q.tasks.length === concurrency) {\n                  q.saturated();\n              }\n              async.setImmediate(q.process);\n          });\n        }\n\n        var workers = 0;\n        var q = {\n            tasks: [],\n            concurrency: concurrency,\n            saturated: null,\n            empty: null,\n            drain: null,\n            push: function (data, callback) {\n              _insert(q, data, false, callback);\n            },\n            unshift: function (data, callback) {\n              _insert(q, data, true, callback);\n            },\n            process: function () {\n                if (workers < q.concurrency && q.tasks.length) {\n                    var task = q.tasks.shift();\n                    if (q.empty && q.tasks.length === 0) {\n                        q.empty();\n                    }\n                    workers += 1;\n                    var next = function () {\n                        workers -= 1;\n                        if (task.callback) {\n                            task.callback.apply(task, arguments);\n                        }\n                        if (q.drain && q.tasks.length + workers === 0) {\n                            q.drain();\n                        }\n                        q.process();\n                    };\n                    var cb = only_once(next);\n                    worker(task.data, cb);\n                }\n            },\n            length: function () {\n                return q.tasks.length;\n            },\n            running: function () {\n                return workers;\n            }\n        };\n        return q;\n    };\n\n    async.cargo = function (worker, payload) {\n        var working     = false,\n            tasks       = [];\n\n        var cargo = {\n            tasks: tasks,\n            payload: payload,\n            saturated: null,\n            empty: null,\n            drain: null,\n            push: function (data, callback) {\n                if(data.constructor !== Array) {\n                    data = [data];\n                }\n                _each(data, function(task) {\n                    tasks.push({\n                        data: task,\n                        callback: typeof callback === 'function' ? callback : null\n                    });\n                    if (cargo.saturated && tasks.length === payload) {\n                        cargo.saturated();\n                    }\n                });\n                async.setImmediate(cargo.process);\n            },\n            process: function process() {\n                if (working) return;\n                if (tasks.length === 0) {\n                    if(cargo.drain) cargo.drain();\n                    return;\n                }\n\n                var ts = typeof payload === 'number'\n                            ? tasks.splice(0, payload)\n                            : tasks.splice(0);\n\n                var ds = _map(ts, function (task) {\n                    return task.data;\n                });\n\n                if(cargo.empty) cargo.empty();\n                working = true;\n                worker(ds, function () {\n                    working = false;\n\n                    var args = arguments;\n                    _each(ts, function (data) {\n                        if (data.callback) {\n                            data.callback.apply(null, args);\n                        }\n                    });\n\n                    process();\n                });\n            },\n            length: function () {\n                return tasks.length;\n            },\n            running: function () {\n                return working;\n            }\n        };\n        return cargo;\n    };\n\n    var _console_fn = function (name) {\n        return function (fn) {\n            var args = Array.prototype.slice.call(arguments, 1);\n            fn.apply(null, args.concat([function (err) {\n                var args = Array.prototype.slice.call(arguments, 1);\n                if (typeof console !== 'undefined') {\n                    if (err) {\n                        if (console.error) {\n                            console.error(err);\n                        }\n                    }\n                    else if (console[name]) {\n                        _each(args, function (x) {\n                            console[name](x);\n                        });\n                    }\n                }\n            }]));\n        };\n    };\n    async.log = _console_fn('log');\n    async.dir = _console_fn('dir');\n    /*async.info = _console_fn('info');\n    async.warn = _console_fn('warn');\n    async.error = _console_fn('error');*/\n\n    async.memoize = function (fn, hasher) {\n        var memo = {};\n        var queues = {};\n        hasher = hasher || function (x) {\n            return x;\n        };\n        var memoized = function () {\n            var args = Array.prototype.slice.call(arguments);\n            var callback = args.pop();\n            var key = hasher.apply(null, args);\n            if (key in memo) {\n                callback.apply(null, memo[key]);\n            }\n            else if (key in queues) {\n                queues[key].push(callback);\n            }\n            else {\n                queues[key] = [callback];\n                fn.apply(null, args.concat([function () {\n                    memo[key] = arguments;\n                    var q = queues[key];\n                    delete queues[key];\n                    for (var i = 0, l = q.length; i < l; i++) {\n                      q[i].apply(null, arguments);\n                    }\n                }]));\n            }\n        };\n        memoized.memo = memo;\n        memoized.unmemoized = fn;\n        return memoized;\n    };\n\n    async.unmemoize = function (fn) {\n      return function () {\n        return (fn.unmemoized || fn).apply(null, arguments);\n      };\n    };\n\n    async.times = function (count, iterator, callback) {\n        var counter = [];\n        for (var i = 0; i < count; i++) {\n            counter.push(i);\n        }\n        return async.map(counter, iterator, callback);\n    };\n\n    async.timesSeries = function (count, iterator, callback) {\n        var counter = [];\n        for (var i = 0; i < count; i++) {\n            counter.push(i);\n        }\n        return async.mapSeries(counter, iterator, callback);\n    };\n\n    async.compose = function (/* functions... */) {\n        var fns = Array.prototype.reverse.call(arguments);\n        return function () {\n            var that = this;\n            var args = Array.prototype.slice.call(arguments);\n            var callback = args.pop();\n            async.reduce(fns, args, function (newargs, fn, cb) {\n                fn.apply(that, newargs.concat([function () {\n                    var err = arguments[0];\n                    var nextargs = Array.prototype.slice.call(arguments, 1);\n                    cb(err, nextargs);\n                }]))\n            },\n            function (err, results) {\n                callback.apply(that, [err].concat(results));\n            });\n        };\n    };\n\n    var _applyEach = function (eachfn, fns /*args...*/) {\n        var go = function () {\n            var that = this;\n            var args = Array.prototype.slice.call(arguments);\n            var callback = args.pop();\n            return eachfn(fns, function (fn, cb) {\n                fn.apply(that, args.concat([cb]));\n            },\n            callback);\n        };\n        if (arguments.length > 2) {\n            var args = Array.prototype.slice.call(arguments, 2);\n            return go.apply(this, args);\n        }\n        else {\n            return go;\n        }\n    };\n    async.applyEach = doParallel(_applyEach);\n    async.applyEachSeries = doSeries(_applyEach);\n\n    async.forever = function (fn, callback) {\n        function next(err) {\n            if (err) {\n                if (callback) {\n                    return callback(err);\n                }\n                throw err;\n            }\n            fn(next);\n        }\n        next();\n    };\n\n    // AMD / RequireJS\n    if (typeof define !== 'undefined' && define.amd) {\n        define([], function () {\n            return async;\n        });\n    }\n    // Node.js\n    else if (typeof module !== 'undefined' && module.exports) {\n        module.exports = async;\n    }\n    // included directly via <script> tag\n    else {\n        root.async = async;\n    }\n\n}());\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/bin/sails-www.js":"#!/usr/bin/env node\n\n\n/**\n * Module dependencies\n */\n\nvar nodepath = require('path');\nvar _ = require('@sailshq/lodash');\nvar CaptainsLog = require('captains-log');\nvar Sails = require('../lib/app');\nvar rconf = require('../lib/app/configuration/rc');\nvar GruntHookDef = require('../lib/hooks/grunt');\nvar Err = require('../errors');\n\n\n\n\n/**\n * `sails www`\n *\n * Run the `build` or `buildProd` Grunt task (depending on whether this is the production environment)\n * for the Sails app in the current working directory.\n *\n * @stability 2\n * @see http://sailsjs.org/documentation/reference/command-line-interface/sails-www\n */\n\nmodule.exports = function() {\n  var log = CaptainsLog(rconf.log);\n\n  // The destination path.\n  var wwwPath = nodepath.resolve(process.cwd(), './www');\n\n  // Note that we _load_ but _don't lift_ the app.  That means that the HTTP/Socket.io\n  // servers will not actually listen on ports.\n  var sails = Sails();\n  sails.load(_.merge({}, rconf, {\n    // We leave Grunt disabled\n    // (since we do all the Grunting ourselves using the raw hook definition below)\n    hooks: { grunt: false }\n  }), function whenAppIsLoaded(err) {\n    if (err) {\n      return Err.fatal.failedToLoadSails(err);\n    }\n\n    // Determine the appropriate Grunt task to run based on `sails.config.environment`\n    // (which is itself based on NODE_ENV).\n    var overrideGruntTask;\n    if (sails.config.environment === 'production') {\n      overrideGruntTask = 'buildProd';\n    }\n    else {\n      overrideGruntTask = 'build';\n    }\n    log.info('Compiling assets into standalone `www` directory with `grunt ' + overrideGruntTask + '`...');\n\n    // Pass in our app (`sails`) to the hook definition (factory function) in order to get\n    // a \"hydrated\" Grunt hook (a dictionary with methods and other fine goods)\n    var hydratedGruntHook = GruntHookDef(sails);\n\n    // Now use that sopping hook definition to run the appropriate Grunt task.\n    // (by the way, `runTask` is technically a private method, and so should not\n    //  be relied upon in userland code outside of Sails core.  Its usage may be\n    //  tweaked in a subsequent release.)\n    hydratedGruntHook.runTask(overrideGruntTask);\n\n    // Listen for `hook:grunt:error` event from the Grunt hook-- if fired,\n    // this means the Grunt child process exited with a non-zero status code.\n    // (meaning that someting went awry.)\n    sails.on('hook:grunt:error', function(err) {\n      log.error('Error occured running `grunt ' + overrideGruntTask + '`');\n      log.error('Please resolve any issues and try running `sails www` again.');\n      log.error('Details:');\n      log.error(err);\n      process.exit(1);\n    });\n\n    // Listen for `hook:grunt:done` event from the Grunt hook-- if fired,\n    // this means the Grunt child process exited with a zero status code.\n    // (meaning that everything worked as expected!)\n    sails.on('hook:grunt:done', function() {\n      log.info();\n      log.info('Created `www` directory at:');\n      log.info(wwwPath);\n      process.exit(0);\n    });\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/errors/fatal.js":"/**\n * Module dependencies\n */\nvar nodeutil = require('util');\nvar nodepath = require('path');\nvar chalk = require('chalk');\n\n// Build logger using best-available information\n// when this module is initially required.\nvar log = require('captains-log')(require('../lib/app/configuration/rc'));\n\n/**\n * Fatal Errors\n */\nmodule.exports = {\n\n  // Lift-time and load-time errors\n  failedToLoadSails: function(err) {\n    log.error(err);\n    log.error('Could not load Sails.');\n    log.error('Are you using the latest stable version?');\n    _terminateProcess(1);\n  },\n\n  noPackageJSON: function() {\n    log.error('Cannot read package.json in the current directory (' + process.cwd() + ')');\n    log.error('Are you sure this is a Sails app?');\n    _terminateProcess(1);\n  },\n\n  notSailsApp: function() {\n    log.error('The package.json in the current directory does not list Sails as a dependency...');\n    log.error('Are you sure `' + process.cwd() + '` is a Sails app?');\n    _terminateProcess(1);\n  },\n\n  badLocalDependency: function(pathTo_localSails, requiredVersion) {\n    log.error(\n      'The local Sails dependency installed at `' + pathTo.localSails + '` ' +\n      'has a corrupted, missing, or un-parsable package.json file.'\n    );\n    log.error('You may consider running:');\n    log.error('rm -rf ' + pathTo_localSails + ' && npm install sails@' + app.dependencies.sails);\n    _terminateProcess(1);\n  },\n\n  // TODO: replace the inline version of this error\n  // app/loadHooks.js:42\n  malformedHook: function() {\n    log.error('Malformed hook! (' + id + ')');\n    log.error('Hooks should be a function with one argument (`sails`)');\n    _terminateProcess(1);\n  },\n\n  // TODO: replace the inline version of this error\n  // app/load.js:146\n  hooksTookTooLong: function() {\n    var hooksTookTooLongErr = 'Hooks are taking way too long to get ready...  ' +\n      'Something might be amiss.\\nAre you using any custom hooks?\\nIf so, make sure the hook\\'s ' +\n      '`initialize()` method is triggering its callback.';\n    log.error(hooksTookTooLongErr);\n    process.exit(1);\n  },\n\n\n\n  // Invalid user module errors\n  invalidCustomResponse: function(responseIdentity) {\n    log.error('Cannot define custom response `' + responseIdentity + '`.');\n    log.error('`res.' + responseIdentity + '` has special meaning in Connect/Express/Sails.');\n    log.error('Please remove the `' + responseIdentity + '` file from the `responses` directory.');\n    _terminateProcess(1);\n  },\n\n\n\n  // This doesn't technically _need_ to be a fatal error- it just is\n  // because certain grunt modules (e.g. grunt-contrib-watch) don't restart\n  // when an error occurs.\n  __GruntAborted__: function(consoleMsg, stackTrace) {\n\n    var gruntErr =\n      '\\n------------------------------------------------------------------------\\n' +\n      consoleMsg + '\\n' + (stackTrace || '') +\n      '\\n------------------------------------------------------------------------';\n    log.error(gruntErr);\n    log.blank();\n\n    log.error('Looks like a Grunt error occurred--');\n    log.error('Please fix it, then **restart Sails** to continue running tasks (e.g. watching for changes in assets)');\n    log.error('Or if you\\'re stuck, check out the troubleshooting tips below.');\n    log.blank();\n\n    log.error(chalk.underline('Troubleshooting tips:'));\n    var relativePublicPath = (nodepath.resolve(process.cwd(), './.tmp'));\n    var uid = process.getuid && process.getuid() || 'YOUR_COMPUTER_USER_NAME';\n    log.error();\n    log.error(' *-> Are \"grunt\" and related grunt task modules installed locally?  Run `npm install` if you\\'re not sure.');\n    log.error();\n    log.error(' *-> You might have a malformed LESS, SASS, CoffeeScript file, etc.');\n    log.error();\n    log.error(' *-> Or maybe you don\\'t have permissions to access the `.tmp` directory?');\n    log.error('     e.g., `' + relativePublicPath + '`', '?');\n    log.error();\n    log.error('     If you think this might be the case, try running:');\n    log.error('     sudo chown -R', uid, relativePublicPath);\n    log.blank();\n\n    // See note above this function - for now, this will not\n    // actually terminate the process.  The rest of Sails should\n    // continue to run.\n    // return _terminateProcess(1);\n  },\n\n\n  __UnknownPolicy__: function(policy, source, pathToPolicies) {\n    source = source || 'config.policies';\n\n    log.error('Unknown policy, \"' + policy + '\", referenced in `' + source + '`.');\n    log.error('Are you sure that policy exists?');\n    log.error('It would be located at: `' + pathToPolicies + '/' + policy + '.js`');\n    return _terminateProcess(1);\n  },\n\n  __InvalidConnection__: function(connection, sourceModelId) {\n    log.error('In model (' + sourceModelId + '), invalid connection ::', connection);\n    log.error('Must contain an `adapter` key referencing the adapter to use.');\n    return _terminateProcess(1);\n  },\n\n  __UnknownConnection__: function(connectionId, sourceModelId) {\n    log.error('Unknown connection, \"' + connectionId + '\", referenced in model `' + sourceModelId + '`.');\n    log.error('Are you sure that connection exists?  It should be defined in `sails.config.connections`.');\n\n    // var probableAdapterModuleName = connectionId.toLowerCase();\n    // if ( ! probableAdapterModuleName.match(/^(sails-|waterline-)/) ) {\n    // \tprobableAdapterModuleName = 'sails-' + probableAdapterModuleName;\n    // }\n    // log.error('Otherwise, if you\\'re trying to use an adapter named `' + connectionId + '`, please run ' +\n    // \t'`npm install ' + probableAdapterModuleName + '@' + sails.majorVersion + '.' + sails.minorVersion + '.x`');\n    return _terminateProcess(1);\n  },\n\n\n  __ModelIsMissingConnection__: function(sourceModelId) {\n    log.error(nodeutil.format('One of your models (%s) doesn\\'t have a connection.', sourceModelId));\n    log.error('Do you have a default `connection` in your `config/models.js` file?');\n    return _terminateProcess(1);\n  },\n\n  __UnknownAdapter__: function(adapterId, sourceModelId, sailsMajorV, sailsMinorV) {\n    log.error('Trying to use unknown adapter, \"' + adapterId + '\", in model `' + sourceModelId + '`.');\n    log.error('Are you sure that adapter is installed in this Sails app?');\n    log.error('If you wrote a custom adapter with identity=\"' + adapterId + '\", it should be in this app\\'s adapters directory.');\n\n    var probableAdapterModuleName = adapterId.toLowerCase();\n    if (!probableAdapterModuleName.match(/^(sails-|waterline-)/)) {\n      probableAdapterModuleName = 'sails-' + probableAdapterModuleName;\n    }\n    log.error('Otherwise, if you\\'re trying to use an adapter named `' + adapterId + '`, please run ' +\n      '`npm install ' + probableAdapterModuleName + ' --save'/*'@' + sailsMajorV + '.' + sailsMinorV + '.x`'*/);\n    return _terminateProcess(1);\n  },\n\n  __InvalidAdapter__: function(attemptedModuleName, supplementalErrMsg) {\n    log.error('There was an error attempting to require(\"' + attemptedModuleName + '\")');\n    log.error('Is this a valid Sails/Waterline adapter?  The following error was encountered ::');\n    log.error(supplementalErrMsg);\n\n    return _terminateProcess(1);\n  }\n};\n\n\n\n/**\n *\n * TODO: Make all of this more elegant.\n * ========================================================\n * + Ideally we don't call `process.exit()` at all.\n * We should consistently use `sails.lower()` for unhandleable core\n * errors and just trigger the appropriate callback w/ an error for\n * core lift/load and any CLI errors.\n *\n * + Then we won't have to worry as much about dangling child processes\n * and things like that. Plus it's more testable that way.\n *\n * In practice, the best way to do this may be an error domain or an\n * event emitted on the sails object (or both!)\n * ========================================================\n *\n *\n *\n * TODO: Merge w/ app/teardown.js\n * ========================================================\n * (probably achievable by doing the aforementioned cleanup)\n * ========================================================\n */\n\n\n\n/**\n * _terminateProcess\n *\n * Terminate the process as elegantly as possible.\n * If process.env is 'test', throw instead.\n *\n * @param  {[type]} code [console error code]\n * @param  {[type]} opts [currently unused]\n */\nfunction _terminateProcess(code, opts) {\n  if (process.env.NODE_ENV === 'test') {\n    var Signal = new Error({\n      type: 'terminate',\n      code: code,\n      options: {\n        todo: 'put the stuff from the original errors in here'\n      }\n    });\n    throw Signal;\n  }\n\n  return process.exit(code);\n}\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/errors/index.js":"// Merge together error sub-modules\nmodule.exports = {\n  fatal: require('./fatal'),\n  warn: require('./warn')\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/errors/warn.js":"/**\n * Module dependencies\n */\n\nvar nodepath = require('path');\n\n// Build logger using best-available information\n// when this module is initially required.\nvar log = require('captains-log')(require('../lib/app/configuration/rc'));\n\n\n/**\n * Warnings\n */\nmodule.exports = {\n\n  incompatibleLocalSails: function(requiredVersion, localVersion) {\n    log.warn('Trying to lift app using a local copy of `sails`');\n    log.warn('(located in ' + nodepath.resolve(process.cwd(), 'node_modules/sails') + ')');\n    log.warn();\n    log.warn('But the package.json in the current directory indicates a dependency');\n    log.warn('on Sails `' + requiredVersion + '`, and the locally installed Sails is `' + localVersion + '`!');\n    log.warn();\n    log.warn('If you run into compatibility issues, try installing ' + requiredVersion + ' locally:');\n    log.warn('    $ npm install sails@' + requiredVersion);\n    log.warn();\n    log.blank();\n  },\n\n\n\n  // Verbose-only warnings:\n\n  noPackageJSON: function() {\n    log.warn('Cannot read package.json in the current directory (' + process.cwd() + ')');\n    log.warn('Are you sure this is a Sails app?');\n    log.warn();\n  },\n\n  notSailsApp: function() {\n    log.warn('The package.json in the current directory does not list Sails as a dependency...');\n    log.warn('Are you sure `' + process.cwd() + '` is a Sails app?');\n    log.warn();\n  },\n\n  badLocalDependency: function(pathTo_localSails, requiredVersion) {\n    log.warn(\n      'The local Sails dependency installed at `' + pathTo_localSails + '` ' +\n      'has a corrupted, missing, or un-parsable package.json file.'\n    );\n    log.warn('You may consider running:');\n    log.warn('rm -rf ' + pathTo_localSails + ' && npm install sails@' + requiredVersion);\n    log.warn();\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/preinstall_npmcheck.js":"/**\n * npm pre-install script.\n *\n * This script checks if the installed npm-version matches the required engine\n * defined in the package.json.\n */\n\nvar exec = require('child_process').exec;\nvar project = require('./../package.json');\n\n\n// Validate npm version before installing Sails.\nif (project.engines && project.engines.npm) exec('npm -v', validateNpmVersion);\n\n/**\n * Callback for the 'npm -v' execution.\n * @param  err    Possible command execution error.\n * @param  stdout Command execution result.\n */\nfunction validateNpmVersion(err, stdout) {\n\n  // Throw-up process errors.\n  if (err) return exitWithMessage(err);\n\n  // Parse Semver for current and required.\n  var semver = getSemver(stdout);\n  var requiredNpmSemver = getSemver(project.engines.npm, true);\n\n  // Get only the release numbering.\n  var version = semver && semver[1];\n  var requiredNpmVersion = requiredNpmSemver && requiredNpmSemver[1];\n\n  // If no version is identified, stop install.\n  if (!version) exitWithMessage([\n    'Unable to check your npm-version',\n    '',\n    'Please reinstall npm to use Sails.js'\n  ]);\n\n  // Handle old npm installations.\n  if (!satisfiesVersion(version, requiredNpmVersion)) exitWithMessage([\n    'Your current npm version (' + version + ') is not supported:',\n    'Sails requires at least version ' + project.engines.npm,\n    '',\n    'Try uploading npm before installing Sails.'\n  ]);\n\n  console.log('Sails.js Installation: Checking npm-version successful');\n\n  // Exit process with success.\n  process.exit(0);\n}\n\n/**\n * Exit proccess with a given error beautifully.\n */\nfunction exitWithMessage(err, code) {\n\n  // Exit error header.\n  console.log('\\033[31mSails.js Installation - Error');\n  console.log('--------------------------------------------------------\\033[00m');\n\n  // Exit (possibly multiple) error lines.\n  (typeof err === 'string' ? [err] : err).forEach(function (err) {\n    console.log(err);\n  });\n\n  // Exit error footer.\n  console.log('\\033[31m--------------------------------------------------------');\n\n  // Exit processing with a 1 (error) default code.\n  process.exit(code === undefined ? 1 : code);\n}\n\n/**\n * Parse version string into semver array.\n * @param {string} version\n * @param {boolean} range If version is a range, make sure to consider up-front\n *                        specification.\n * @return {Array}  An array with the version's parts or null if not valid.\n */\nfunction getSemver(version, range) {\n\n  // Fulfil possibly missing zeros, if range is allowed.\n  if (range) {\n    version = version.split('.');\n    var missing = 3 - version.length;\n\n    for(;missing > 0; missing--) {\n      version.push(0);\n    }\n\n    version = version.join('.');\n  }\n\n  var versionRegex = '(([0-9]{1,})\\\\.([0-9]{1,})\\\\.([0-9]{1,}))(?:-?(.*))';\n  var regex = new RegExp('^' + (range ? '(?:.*)' : '') + versionRegex + '$');\n\n  return version.replace(/\\s+/g, '').match(regex);\n}\n\n/**\n * Makes a simple '>=' version comparison.\n * @param  {string} version\n * @param  {string} compare\n * @return {boolean}\n */\nfunction satisfiesVersion(version, compare) {\n  version = version.split('.');\n  compare = compare.split('.');\n  var satisfied;\n\n  return compare.every(function (value, i) {\n    if (satisfied !== undefined) return satisfied;\n    if (version[i] > value) return satisfied = true;\n    if (version[i] < value) return satisfied = false;\n\n    return true;\n  }) && satisfied !== false;\n}\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/app/getBaseurl.js":"/**\n * Module dependencies\n */\n\nvar _ = require('@sailshq/lodash');\n\n\n\n\n/**\n * Calculate the base URL (useful in emails, etc.)\n * @return {String} [description]\n */\n\nmodule.exports = function getBaseurl() {\n  var sails = this;\n\n  var usingSSL = sails.config.ssl === true || (sails.config.ssl && ((sails.config.ssl.key && sails.config.ssl.cert) || sails.config.ssl.pfx));\n  var host = sails.getHost() || 'localhost';\n  var port = sails.config.proxyPort || sails.config.port;\n  var probablyUsingSSL = (port === 443);\n\n  // If host doesn't contain `http*` already, include the protocol string.\n  var protocolString = '';\n  if (!_.contains(host,'http')) {\n    protocolString = ((usingSSL || probablyUsingSSL) ? 'https' : 'http') + '://';\n  }\n  var portString = (port === 80 || port === 443 ? '' : ':' + port);\n  var localAppURL = protocolString + host + portString;\n\n  return localAppURL;\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/app/get-route-for.js":"/**\n * Module dependencies\n */\n\nvar util = require('util');\nvar _ = require('@sailshq/lodash');\nvar sailsUtil = require('sails-util');\n\n\n/**\n * getRouteFor()\n *\n * Look up more information about the first explicit route defined in this app\n * which has the given route target.\n *\n * Note that this function _only searches explicit routes_ which have been configured\n * manually (e.g. in `config/routes.js`).  For more info, see:\n * https://github.com/balderdashy/sails/issues/3402#issuecomment-171633341\n *\n * @this {SailsApp}\n * ----------------------------------------------------------------------------------------\n *\n * Usage:\n *\n * ```\n * getRouteFor('DuckController.quack');\n * getRouteFor({ target: 'DuckController.quack' });\n * // =>\n * // {\n * //   url: '/ducks/:id/quack',\n * //   method: 'post'\n * // }\n * ```\n */\nmodule.exports = function getRouteFor(routeQuery){\n\n  // Get reference to sails app instance.\n  var sails = this;\n\n  // Validate and normalize usage.\n  var routeTargetToLookup;\n  if ( _.isString(routeQuery) ) {\n    routeTargetToLookup = routeQuery;\n  }\n  else if ( _.isObject(routeQuery) && _.isString(routeQuery.target) ) {\n    routeTargetToLookup = routeQuery.target;\n  }\n  else {\n    var invalidUsageErr = new Error('Usage error: `sails.getRouteFor()` expects a string route target (e.g. \"DuckController.quack\") or a dictionary with a target property (e.g. `{target: \"DuckController.quack\"}`).  But instead, it received a `'+typeof routeQuery+'`: '+util.inspect(routeQuery, {depth: null}) );\n    invalidUsageErr.code = 'E_USAGE';\n    throw invalidUsageErr;\n  }\n\n  // Split the provided route target string to look up on its dot, getting its controller and action parts.\n  var routeTargetToLookupPieces = routeTargetToLookup.split('.');\n\n  // If it doesn't have a dot, throw a usage error.\n  if ( routeTargetToLookupPieces.length < 2 ) {\n    var ambiguousUsageErr = new Error('Usage error: Ambiguous usage- target specified to `sails.getRouteFor()` is not a valid route target string (e.g. \"DuckController.quack\") because there is no dot (\".\")');\n    ambiguousUsageErr.code = 'E_USAGE';\n    throw ambiguousUsageErr;\n  }\n\n  // Now look up the first route with this target (`routeTargetToLookup`).\n  var firstMatchingRouteAddress;\n  _.any(sails.router.explicitRoutes, function (routeTarget, key) {\n    // If route target syntax is a string, compare it directly with the provided `routeTargetToLookup`.\n    if ( _.isString(routeTarget) ) {\n      if (routeTarget===routeTargetToLookup ) {\n        firstMatchingRouteAddress = key;\n        return true;\n      }\n      else {\n        // TODO: If that check fails, try removing \"Controller\" suffix from both `routeTargetToLookup` and the controller in the `routeTarget` and comparing those. Note that this means you _should not define `ControllerController.js`_!\n        // * * * ACTUALLY, see: https://github.com/balderdashy/sails/issues/3402#issuecomment-173255376   * * *\n      }\n    }\n    else if ( _.isObject(routeTarget) ) {\n      // If route target syntax itself contains a string `target` key, compare it directly with the provided `routeTargetToLookup`.\n      if ( _.isString(routeTarget.target) && routeTarget.target===routeTargetToLookup ) {\n        // TODO: If that check fails, try removing \"Controller\" suffix from both `routeTargetToLookup` and the controller in the `routeTarget` and comparing those. Note that this means you _should not define `ControllerController.js`_!\n        // * * * ACTUALLY, see: https://github.com/balderdashy/sails/issues/3402#issuecomment-173255376   * * *\n        firstMatchingRouteAddress = key;\n        return true;\n      }\n      // If route target syntax contains `controller`+`action` keys, then check those against the relevant pieces of the provided `routeTargetToLookup`.\n      else if ( _.isString(routeTarget.controller) && _.isString(routeTarget.action) && routeTarget.controller===routeTargetToLookupPieces[0] && routeTarget.action===routeTargetToLookupPieces[1] ) {\n        // TODO: If that check fails, try removing \"Controller\" suffix from both `routeTargetToLookup` and the controller in the `routeTarget` and comparing those. Note that this means you _should not define `ControllerController.js`_!\n        // * * * ACTUALLY, see: https://github.com/balderdashy/sails/issues/3402#issuecomment-173255376   * * *\n        firstMatchingRouteAddress = key;\n        return true;\n      }\n      // If route target syntax contains only `controller`, compare assuming the \"index\" action against the relevant pieces of the provided `routeTargetToLookup`.\n      else if ( _.isString(routeTarget.controller) && !routeTarget.action && routeTarget.controller===routeTargetToLookupPieces[0] && 'index'===routeTargetToLookupPieces[1] ) {\n        // TODO: If that check fails, try removing \"Controller\" suffix from both `routeTargetToLookup` and the controller in the `routeTarget` and comparing those. Note that this means you _should not define `ControllerController.js`_!\n        // * * * ACTUALLY, see: https://github.com/balderdashy/sails/issues/3402#issuecomment-173255376   * * *\n        firstMatchingRouteAddress = key;\n        return true;\n      }\n      // Note that we ignore non-matches or anything utterly insane.\n    }\n  });\n\n\n  // If no route was found, throw an error.\n  if (!firstMatchingRouteAddress) {\n    var unrecognizedTargetErr = new Error('Route not found: No explicit route could be found in this app with the specified target (`'+routeTargetToLookup+'`).');\n    unrecognizedTargetErr.code = 'E_NOT_FOUND';\n    throw unrecognizedTargetErr;\n  }\n\n  // Now that the raw route address been located, we'll normalize it:\n  //\n  // If route address is '*', it will be automatically corrected to `/*` when bound, so also reflect that here.\n  firstMatchingRouteAddress = firstMatchingRouteAddress === '*' ? '/*' : firstMatchingRouteAddress;\n\n  // Then we parse it into its HTTP method and URL pattern parts.\n  var parsedAddress = sailsUtil.detectVerb(firstMatchingRouteAddress);\n\n  // At this point we being building the final return value- the route info dictionary.\n  var routeInfo = {};\n  routeInfo.method = parsedAddress.verb || '';\n  routeInfo.url = parsedAddress.path;\n\n\n  // And finally return the route info.\n  return routeInfo;\n\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/app/get-url-for.js":"/**\n * Module dependencies\n */\n\n// N/A\n\n\n/**\n * getUrlFor()\n *\n * Look up the URL of this app's first explicit route with the given route target.\n *\n * Note that this function _only searches explicit routes_ which have been configured\n * manually (e.g. in `config/routes.js`).  For more info, see:\n * https://github.com/balderdashy/sails/issues/3402#issuecomment-171633341\n *\n *\n * @this {SailsApp}\n * ----------------------------------------------------------------------------------------\n *\n * Usage:\n *\n * ```\n * getUrlFor('DuckController.quack');\n * // => '/ducks/:id/quack'\n *\n * getUrlFor({ target: 'DuckController.quack' });\n * // => '/ducks/:id/quack'\n * ```\n */\nmodule.exports = function getUrlFor(routeQuery){\n\n  // Get reference to sails app instance.\n  var sails = this;\n\n  // Now attempt to look up the first route that matches the specified argument\n  // and if it works, then return its URL.\n  return sails.getRouteFor(routeQuery).url;\n\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/app/lift.js":"/**\n * Module dependencies.\n */\n\nvar async = require('async');\nvar _ = require('@sailshq/lodash');\nvar chalk = require('chalk');\n\n/**\n * Sails.prototype.lift()\n *\n * Loads the app, then starts all attached servers.\n *\n * @api public\n */\n\nmodule.exports = function lift(configOverride, cb) {\n  var sails = this;\n\n  // configOverride is optional\n  if (_.isFunction(configOverride)) {\n    cb = configOverride;\n    configOverride = {};\n  }\n\n  // Callback is optional\n  cb = cb || function(err) {\n    if (err) return sails.log.error(err);\n  };\n\n  async.series([\n\n    function(cb) {\n      sails.load(configOverride, cb);\n    },\n\n    sails.initialize\n\n  ], function sailsReady(err, async_data) { //TODO: unused variable async_data\n    if (err) {\n      return sails.lower(function (errorLoweringSails){\n        if (errorLoweringSails) {\n          sails.log.error('When trying to lower the app as a result of a failed lift, encountered an error:',errorLoweringSails);\n        }\n        cb(err);\n      });\n    }\n\n    _printSuccessMsg(sails);\n\n    // try {console.timeEnd('core_lift');}catch(e){}\n\n    sails.emit('lifted');\n    sails.isLifted = true;\n    return cb(null, sails);\n  });\n};\n\n\n\n// Gather app meta-info and log startup message (the boat).\nfunction _printSuccessMsg(sails) {\n\n  // If `config.noShip` is set, skip the startup message.\n  if (!(sails.config.log && sails.config.log.noShip)) {\n\n    sails.log.ship && sails.log.ship();\n    sails.log.info(('Server lifted in `' + sails.config.appPath + '`'));\n    sails.log.info(chalk.underline('To see your app, visit ' + (sails._getBaseUrl() || '')));\n    sails.log.info(('To shut down Sails, press <CTRL> + C at any time.'));\n    sails.log.blank();\n    sails.log(chalk.grey(Array(56).join('-')));\n    sails.log(chalk.grey(':: ' + new Date()));\n    sails.log.blank();\n    sails.log('Environment : ' + sails.config.environment);\n\n    // Only log the host if an explicit host is set\n    if (sails.getHost()) {\n      sails.log('Host        : ' + sails.getHost()); // 12 - 4 = 8 spaces\n    }\n    sails.log('Port        : ' + sails.config.port); // 12 - 4 = 8 spaces\n    sails.log(chalk.grey(Array(56).join('-')));\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/app/lower.js":"/**\n * Module dependencies.\n */\n\nvar async = require('async');\nvar _ = require('@sailshq/lodash');\n\n\n/**\n * Sails.prototype.lower()\n *\n * The inverse of `lift()`, this method\n * shuts down all attached servers.\n *\n * It also unbinds listeners and terminates child processes.\n *\n * @api public\n */\n\nmodule.exports = function lower(options, cb) {\n  var sails = this;\n\n  sails.log.verbose('Lowering sails...');\n\n  // `options` is optional.\n  if ('function' === typeof options) {\n    cb = options;\n    options = null;\n  }\n\n  // Callback is optional\n  cb = cb || function(err) {\n    if (err)  { return sails.log.error(err); }\n  };\n\n  options = options || {};\n  options.delay = options.delay || 100;\n\n  // Flag `sails._exiting` as soon as the app has begun to shutdown.\n  // This may be used by core hooks and other parts of core.\n  // (e.g. to stop handling HTTP requests and prevent ugly error msgs)\n  sails._exiting = true;\n\n  var beforeShutdown = (sails.config && sails.config.beforeShutdown) || function(cb) {\n    return cb();\n  };\n\n  // Wait until beforeShutdown logic runs\n  beforeShutdown(function(err) {\n\n    // If an error occurred, don't stop-- still go ahead and take care of other teardown tasks.\n    if (err) {\n      sails.log.error(err);\n    }\n\n    // Try to kill all child processes\n    _.each(sails.childProcesses, function kill(childProcess) {\n      sails.log.verbose('Sent kill signal to child process (' + childProcess.pid + ')...');\n      try {\n        childProcess.kill('SIGINT');\n      } catch (e) {\n        sails.log.error('While lowering Sails app: received error killing child process: ', e.stack);\n      }\n    });\n\n    // Shut down HTTP server\n    sails.emit('lower');\n    // (Note for future: would be cleaner to provide a way to defer this to the http\n    // and sockets hooks-- i.e. having hooks expose a `teardown(cb)` interceptor. Keep\n    // in mind we'd need a way to distinguish between a graceful shutdown and a force\n    // kill.  In a force kill situation, it's never ok for the process to hang.)\n\n    async.series([\n\n      function shutdownSockets(cb) {\n\n        // If the sockets hook is disabled, skip this.\n        // Also skip if the socket server is piggybacking on the main HTTP server, to avoid\n        // the onClose event possibly being called multiple times (because you can't tell\n        // socket.io to close without it trying to close the http server).  If we're piggybacking\n        // we'll call sails.io.close in the main \"shutdownHTTP\" code below.\n        if (!_.isObject(sails.hooks) || !sails.hooks.sockets || (sails.io && sails.io.httpServer && sails.hooks.http.server === sails.io.httpServer)) {\n          return cb();\n        }\n\n        var timeOut;\n\n        try {\n          sails.log.verbose('Shutting down socket server...');\n          timeOut = setTimeout(function() {\n            sails.io.httpServer.removeListener('close', onClose);\n            return cb();\n          }, 100);\n          sails.io.httpServer.unref();\n          sails.io.httpServer.once('close', onClose);\n          sails.io.close();\n        } catch (e) {\n          sails.log.verbose('Error occurred closing socket server: ', e);\n          clearTimeout(timeOut);\n          cb();\n        }\n\n        function onClose() {\n          sails.log.verbose('Socket server shut down successfully.');\n          clearTimeout(timeOut);\n          cb();\n        }\n\n      },\n\n      function shutdownHTTP(cb) {\n        if (!_.isObject(sails.hooks) || !sails.hooks.http) {\n          return cb();\n        }\n\n        var timeOut;\n\n        try {\n          sails.log.verbose('Shutting down HTTP server...');\n\n          // Allow process to exit once this server is closed\n          sails.hooks.http.server.unref();\n\n          // If we have a socket server and it's piggybacking on the main HTTP server, tell\n          // socket.io to close now.  This may call `.close()` on the HTTP server, which will\n          // happen again below, but the second synchronous call to .close() will have no\n          // additional effect.  Leaving this as-is in case future versions of socket.io\n          // DON'T automatically close the http server for you.\n          if (sails.io && sails.io.httpServer && sails.hooks.http.server === sails.io.httpServer) {\n            sails.io.close();\n          }\n\n          // If the \"hard shutdown\" option is on, destroy the server immediately,\n          // severing all connections\n          if (options.hardShutdown) {\n            sails.hooks.http.destroy();\n          }\n          // Otherwise just stop the server from accepting new connections,\n          // and wait options.delay for the existing connections to close\n          // gracefully before destroying.\n          else {\n            timeOut = setTimeout(sails.hooks.http.destroy, options.delay);\n            sails.hooks.http.server.close();\n          }\n\n          // Wait for the existing connections to close\n          sails.hooks.http.server.once('close', function () {\n            sails.log.verbose('HTTP server shut down successfully.');\n            clearTimeout(timeOut);\n            cb();\n          });\n\n        } catch (e) {\n          sails.log.verbose('Error occurred closing HTTP server: ', e);\n          clearTimeout(timeOut);\n          cb();\n        }\n      },\n\n      function removeListeners(cb) {\n        // Manually remove all event listeners\n        _.each(_.keys(sails._events)||[], function (eventName){\n          sails.removeAllListeners(eventName);\n        });\n\n        var listeners = sails._processListeners;\n        if (listeners) {\n          process.removeListener('SIGUSR2', listeners.sigusr2);\n          process.removeListener('SIGINT', listeners.sigint);\n          process.removeListener('SIGTERM', listeners.sigterm);\n          process.removeListener('exit', listeners.exit);\n        }\n        sails._processListeners = null;\n\n        // If `sails.config.process.removeAllListeners` is set, do that.\n        // This is no longer necessary due to https://github.com/balderdashy/sails/pull/2693\n        // Deprecating for v0.12.\n        if (sails.config && sails.config.process && sails.config.process.removeAllListeners) {\n          sails.log.debug('sails.config.process.removeAllListeners is deprecated; please remove listeners indivually!');\n          process.removeAllListeners();\n        }\n\n        cb();\n      },\n    ], function (err) {\n      if (err) {\n        // This should never happen because `err` is never passed in any of the async\n        // functions above.  Still, just to be safe, we set up an error log.\n        sails.log.error('While lowering Sails app: received unexpected error:', err.stack);\n        return cb(err);\n      }\n\n      // If `sails._setNodeEnvAutomatically` is set, then we should revert it to what it was\n      // beforehand (`sails._originalNodeEnv`), even if it wasn't set at all.\n      // (see load.js for more background)\n      if (sails._setNodeEnvAutomatically) {\n        process.env['NODE_ENV'] = sails._originalNodeEnv;\n      }\n\n      return cb();\n\n    });//</async.series>\n\n  });//</beforeShutdown()>\n\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/app/request.js":"/**\n * Module dependencies.\n */\n\nvar _ = require('@sailshq/lodash');\nvar util = require('util');\nvar QS = require('querystring');\nvar Transform = require('stream').Transform;\n\n\n/**\n * Originate a new client request instance and lob it at this Sails\n * app at the specified route `address`.\n *\n * Particularly useful for running unit/integration tests without\n * actually having to bind the HTTP and/or WebSocket servers to\n * a TCP port.\n *\n * @param  {String} address\n * @param  {Object} body\n * @param  {Function} cb\n * @return {Stream.Readable}\n *\n * @api public\n */\n\nmodule.exports = function request( /* address, body, cb */ ) {\n\n  var sails = this;\n\n  //\n  // Body params may be passed in to DELETE, HEAD, and GET requests,\n  // even though these types of requests don't normally contain a body.\n  // (this method just serializes them as if they were sent in the querystring)\n  //\n\n\n  // Normalize usage\n  var address = arguments[0];\n  var body;\n  var cb;\n\n  var method;\n  var headers;\n  var url;\n\n  // Usage:\n  // sails.request(opts, cb)\n  //  opts.url\n  //  opts.method\n  //  opts.params\n  //  opts.headers\n  //\n  // (`opts.url` is required)\n  if (_.isObject(arguments[0]) && arguments[0].url) {\n    url = arguments[0].url;\n    method = arguments[0].method;\n    headers = arguments[0].headers || {};\n    body = arguments[0].params || arguments[0].data || {};\n  }\n  // console.log('called sails.request() ');\n  // console.log('headers: ',headers);\n  // console.log('method: ',method);\n\n\n  // Usage:\n  // sails.request(address, [params], cb)\n  if (arguments[2]) {\n    cb = arguments[2];\n    body = arguments[1];\n  }\n  if (_.isFunction(arguments[1])) {\n    cb = arguments[1];\n  } else if (arguments[1]) {\n    body = arguments[1];\n  }\n\n  // If route has an HTTP verb (e.g. `get /foo/bar`, `put /bar/foo`, etc.) parse it out,\n  // (unless method or url was explicitly defined)\n  method = method || sails.util.detectVerb(address).verb;\n  method = method ? method.toUpperCase() : 'GET';\n  url = url || sails.util.detectVerb(address).original;\n\n  // Parse query string (`req.query`)\n  var queryStringPos = url.indexOf('?');\n\n  // If this is a GET, HEAD, or DELETE request, treat the \"body\"\n  // as parameters which should be serialized into the querystring.\n  if (_.isObject(body) && _.contains(['GET', 'HEAD', 'DELETE'], method)) {\n\n    var stringifiedParams = QS.stringify(body);\n\n    if (queryStringPos === -1) {\n      url += '?' + stringifiedParams;\n    } else {\n      url = url.substring(0, queryStringPos) + '?' + stringifiedParams;\n    }\n  }\n\n\n\n  // Build HTTP Client Response stream\n  var clientRes = new MockClientResponse();\n  clientRes.on('finish', function() {\n\n    // console.log('clientRes finished. Headers:',clientRes.headers);\n\n    // Only dump the buffer if a callback was supplied\n    if (cb) {\n\n      // Attempt to read the response buffer into a string\n      try {\n        clientRes.body = clientRes.read();\n        if (clientRes.body !== null) {\n          clientRes.body = clientRes.body.toString();\n          clientRes.body = JSON.parse(clientRes.body);\n        }\n      } catch (e) {}\n\n      // Don't include body if it is empty\n      if (!clientRes.body) {delete clientRes.body;}\n\n      // If status code is indicative of an error, send the\n      // response body or status code as the first error argument.\n      if (clientRes.statusCode < 200 || clientRes.statusCode >= 400) {\n        var error = new Error(util.inspect(clientRes.body || clientRes.statusCode));\n        if (clientRes.body) {error.body = clientRes.body;}\n        error.status = clientRes.statusCode;\n        return cb(error);\n      }\n      else {\n        return cb(null, clientRes, clientRes.body);\n      }\n    }\n  });\n  clientRes.on('error', function(err) {\n    err = err || new Error('Error on response stream');\n    if (cb) return cb(err);\n    else return clientRes.emit('error', err);\n  });\n\n  // To kick things off, pass `opts` (as req) and `res` to the Sails router\n  sails.router.route({\n    method: method,\n    url: url,\n    body: body,\n    headers: headers || {}\n  }, {\n    _clientRes: clientRes\n  });\n\n  // Return clientRes stream\n  return clientRes;\n\n};\n\n\n\nfunction MockClientResponse() {\n  Transform.call(this);\n}\nutil.inherits(MockClientResponse, Transform);\nMockClientResponse.prototype._transform = function(chunk, encoding, next) {\n  this.push(chunk);\n  next();\n};\n\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/app/private/bootstrap.js":"/**\n * Module dependencies\n */\n\nvar util = require('util');\n\n\n/**\n * runBootstrap\n *\n * TODO: move this into a new `bootstrap` hook so that it may be flipped\n * on and off explicitly w/o loading/depending on user config\n *\n * @param  {Function} cb [description]\n *\n * @api private\n */\n\nmodule.exports = function runBootstrap(cb) {\n\n  var sails = this;\n\n  // Run bootstrap script if specified\n  // Otherwise, do nothing and continue\n  if (!sails.config.bootstrap) {\n    return cb();\n  }\n\n  sails.log.verbose('Running the setup logic in `sails.config.bootstrap(cb)`...');\n\n  // IF bootstrap takes too long, display warning message\n  // (just in case user forgot to call their bootstrap's `cb`)\n  var timeoutMs = sails.config.bootstrapTimeout || 2000;\n  var timer = setTimeout(function bootstrapTookTooLong() {\n    sails.log.warn(util.format(\n    'Bootstrap is taking unusually long to execute its callback (%d milliseconds).\\n'+\n    'Perhaps you forgot to call it?  The callback is the first argument of the function, `cb`.',\n    timeoutMs));\n  }, timeoutMs);\n\n  var ranBootstrapFn = false;\n\n  try {\n    return sails.config.bootstrap(function bootstrapDone(err) {\n      if (ranBootstrapFn) {\n        sails.log.error('You called the callback in `sails.config.bootstrap` more than once!');\n        return;\n      }\n      ranBootstrapFn = true;\n      clearTimeout(timer);\n      return cb(err);\n    });\n  }\n  catch (e) {\n    if (ranBootstrapFn) {\n      sails.log.error('The bootstrap function threw an error after its callback was called ::',e);\n      return;\n    }\n    ranBootstrapFn = true;\n    clearTimeout(timer);\n    return cb(e);\n  }\n\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/app/private/exposeGlobals.js":"/**\n * Module dependencies.\n */\n\nvar _ = require('@sailshq/lodash');\nvar async = require('async');\n\n\n/**\n * exposeGlobals()\n *\n * Expose certain global variables\n * (if config says so)\n *\n * @api private\n */\n\nmodule.exports = function exposeGlobals() {\n  var sails = this;\n\n\n  // Globals explicitly disabled\n  if (sails.config.globals === false) {\n    sails.log.verbose('No global variables will be exposed.');\n    return;\n  }\n\n  sails.log.verbose('Exposing global variables... (you can customize/disable this by modifying the properties in `sails.config.globals`.  Set it to `false` to disable all globals.)');\n\n  sails.config.globals = sails.config.globals || {};\n\n  // Provide global access (if allowed in config)\n  if (sails.config.globals._ !== false) {\n    global['_'] = _;\n  }\n  if (sails.config.globals.async !== false) {\n    global['async'] = async;\n  }\n  if (sails.config.globals.sails !== false) {\n    global['sails'] = sails;\n  }\n\n  // `services` hook takes care of globalizing services (if enabled)\n\n  // `orm` hook takes care of globalizing models and adapters (if enabled)\n\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/app/private/getHost.js":"/**\n * Sails.prototype.getHost()\n *\n * @return {String} the configured hostname of the server\n * (IMPORTANT: returns undefined if not specifically configured)\n */\n\nmodule.exports = function getHost() {\n  var sails = this;\n\n  var hasExplicitHost = sails.config.hooks.http && sails.config.explicitHost;\n  var host = sails.config.proxyHost || hasExplicitHost || sails.config.host;\n  return host;\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/app/private/initialize.js":"/**\n * Module dependencies\n */\n\nvar util = require('util');\nvar _ = require('@sailshq/lodash');\nvar async = require('async');\n\n\n\n\n/**\n * Sails.prototype.initialize()\n *\n * Start the Sails server\n * NOTE: sails.load() should be run first.\n *\n * @param {Function?} callback  [optional]\n *\n * @api private\n */\n\nmodule.exports = function initialize(cb) {\n\n  var sails = this;\n\n  // Callback is optional\n  cb = cb || function(err) {\n    if (err) { sails.log.error(err); }\n  };\n\n  // Indicate that server is starting\n  sails.log.verbose('Starting app at ' + sails.config.appPath + '...');\n\n  var listeners = {\n    sigusr2: function() {\n      sails.lower(function() {\n        process.kill(process.pid, 'SIGUSR2');\n      });\n    },\n    sigint: function() {\n      sails.lower(function (){\n        process.exit();\n      });\n    },\n    sigterm: function() {\n      sails.lower(function (){\n        process.exit();\n      });\n    },\n    exit: function() {\n      if (!sails._exiting) {\n        sails.lower();\n      }\n    }\n  };\n\n  // Add \"beforeShutdown\" events\n  process.once('SIGUSR2', listeners.sigusr2);\n\n  process.on('SIGINT', listeners.sigint);\n  process.on('SIGTERM', listeners.sigterm);\n  process.on('exit', listeners.exit);\n\n  sails._processListeners = listeners;\n\n  // Run the app bootstrap\n  sails.runBootstrap(function afterBootstrap(err) {\n    if (err) {\n      sails.log.error('Bootstrap encountered an error: (see below)');\n      return cb(err);\n    }\n\n    // Fire the `ready` event for backwards-compatibility.\n    // (this will be removed in a future version of Sails!)\n    sails.emit('ready');\n\n\n    // Now loop over each hook, and if it exposes a `handleLift` function, then run it.\n    // (this is used by attached servers, etc.)\n    if (!_.isObject(sails.hooks)) { return cb(new Error('Consistency violation: `sails.hooks` should be a dictionary.')); }\n    async.each(Object.keys(sails.hooks), function (hookName, next){\n      if (!_.isFunction(sails.hooks[hookName].handleLift)) {\n        return next();\n      }\n      return sails.hooks[hookName].handleLift(next);\n    }, function (err){\n      if (err) { return cb(err); }\n      return cb(null, sails);\n    });\n\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/app/private/inspect.js":"/**\n * Module dependencies\n */\n\nvar util = require('util');\nvar _ = require('@sailshq/lodash');\n\n\n\n/**\n * Sails.prototype.inspect()\n *\n * The string that should be returned when this `Sails` instance\n * is passed to `util.inspect()` (i.e. when logged w/ `console.log()`)\n *\n * @return {String}\n */\n\nmodule.exports = function inspect () {\n  var sails = this;\n\n  return util.format('\\n'+\n  '  |>   %s', this.toString()) + '\\n' +\n  '\\\\___/  For help, see: http://sailsjs.org/documentation/concepts/'+\n  '\\n\\n' +\n  'Tip: Use `sails.config` to access your app\\'s runtime configuration.'+\n  '\\n\\n' +\n  util.format('%d Models:\\n', _(sails.models).toArray().value().length) +\n  _(sails.models).toArray().filter(function (it) {return !it.junctionTable;}).pluck('globalId').value() +\n  '\\n\\n' +\n  util.format('%d Controllers:\\n', _(sails.controllers).toArray().value().length)+\n  _(sails.controllers).toArray().pluck('globalId').map(function (it) {return it+'Controller';}).value() +\n  '\\n\\n' +\n  // 'Routes:\\n'+\n  // _(sails.routes).toArray().filter(function (it) {return !it.junctionTable;}).pluck('globalId').map(function (it) {return it+'Controller';}).value() +\n  // '\\n\\n' +\n  util.format('%d Hooks:\\n', _(sails.hooks).toArray().value().length)+\n  _(sails.hooks).toArray().pluck('identity').value() +\n  '\\n' +\n  '';\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/app/private/isLocalSailsValid.js":"/**\n * Module dependencies\n */\n\nvar fs = require('fs');\nvar CaptainsLog = require('captains-log');\nvar sailsutil = require('sails-util');\nvar semver = require('semver');\nvar Err = require('../../../errors');\n\n\n\n/**\n * Check if the specified installation of Sails is valid for the specified project.\n *\n * @param sailsPath\n * @param appPath\n */\n\nmodule.exports = function isLocalSailsValid(sailsPath, appPath) {\n\n  var sails = this;\n\n  // Has no package.json file\n  if (!fs.existsSync(appPath + '/package.json')) {\n    Err.warn.noPackageJSON();\n  }\n\n  // Load this app's package.json and dependencies\n  var appPackageJSON = sailsutil.getPackageSync(appPath);\n  var appDependencies = appPackageJSON.dependencies;\n\n\n  // Package.json exists, but doesn't list Sails as a dependency\n  if (!(appDependencies && appDependencies.sails)) {\n    Err.warn.notSailsApp();\n    return;\n  }\n\n  // Ensure the target Sails exists\n  if (!fs.existsSync(sailsPath)) {\n    return false;\n  }\n\n  // Read the package.json in the local installation of Sails\n  var sailsPackageJSON = sailsutil.getPackageSync(sailsPath);\n\n  // Local Sails has a corrupted package.json\n  if (!sailsPackageJSON) {\n    Err.warn.badLocalDependency(sailsPath, appDependencies.sails);\n    return;\n  }\n\n\n  // Lookup sails dependency requirement in app's package.json\n  var requiredSailsVersion = appDependencies.sails;\n\n  //\n  // TODO: use npm's built-in version comparator instead of taking care of\n  // all these edge cases:\n  //\n\n  // If you're using a `git://` sails dependency, you probably know\n  // what you're doing, but we'll let you know just in case.\n  var expectsGitVersion = requiredSailsVersion.match(/^git:\\/\\/.+/);\n  if (expectsGitVersion) {\n    var log = sails.log ? sails.log : CaptainsLog();\n\n    log.blank();\n    log.debug('NOTE:');\n    log.debug('This app depends on an unreleased version of Sails:');\n    log.debug(requiredSailsVersion);\n    log.blank();\n  }\n\n  // Ignore `latest` and `beta` (kind of like how we handle specified git:// deps)\n  var expectsLatest = requiredSailsVersion === 'latest';\n  if (expectsLatest) {\n    // ...\n  }\n  var expectsBeta = requiredSailsVersion === 'beta';\n  if (expectsBeta) {\n    // ...\n  }\n\n  // Error out if it has the wrong version in its package.json\n  if (!expectsLatest && !expectsBeta && !expectsGitVersion) {\n\n    // Use semver for version comparison\n    if (!semver.satisfies(sailsPackageJSON.version, requiredSailsVersion)) {\n      Err.warn.incompatibleLocalSails(requiredSailsVersion, sailsPackageJSON.version);\n    }\n  }\n\n  // If we made it this far, the target Sails installation must be OK\n  return true;\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/app/private/isSailsAppSync.js":"/**\n * Module dependencies\n */\n\nvar fs = require('fs'),\n  path = require('path'),\n  sailsutil = require('sails-util');\n\n\n\n/**\n * Check if the specified appPath contains something that looks like a Sails app.\n *\n * @param {String} appPath\n */\n\nmodule.exports = function isSailsAppSync(appPath) {\n\n  // Has no package.json file\n  if (!fs.existsSync(path.join(appPath, 'package.json'))) {\n    return false;\n  }\n\n  // Package.json exists, but doesn't list Sails as a dependency\n  var appPackageJSON = sailsutil.getPackageSync(appPath);\n  var appDependencies = appPackageJSON.dependencies;\n  if (!(appDependencies && appDependencies.sails)) {\n    return false;\n  }\n\n  return true;\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/app/private/toJSON.js":"/**\n * Module dependencies\n */\n\nvar _ = require('@sailshq/lodash');\n\n\n/**\n * [exports description]\n * @return {[type]} [description]\n */\n\nmodule.exports = function toJSON () {\n  return _.reduce(this, function (pojo, val, key) {\n    if (key === 'config') {\n      pojo[key] = val;\n    }\n    if (key === 'hooks') {\n      pojo[key] = _.reduce(val, function (memo, hook, ident) {\n        memo.push(ident);\n        return memo;\n      }, []);\n    }\n    if (key === 'models') {\n      pojo[key] = _.reduce(val, function (memo, model, ident) { //TODO: unused variable ident\n        if (!model.junctionTable) {\n          memo.push({\n            attributes: model.attributes,\n            identity: model.identity,\n            globalId: model.globalId,\n            connection: model.connection,\n            schema: model.schema,\n            tableName: model.tableName\n          });\n        }\n        return memo;\n      }, []);\n    }\n\n    return pojo;\n  }, {});\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/hooks/blueprints/actionUtil.js":"/**\n * Module dependencies\n */\n\nvar util = require('util');\nvar _ = require('@sailshq/lodash');\nvar isString = _.isString;\nvar isArray = _.isArray;\nvar isObject = _.isObject;\nvar isUndefined = _.isUndefined;\nvar mergeDefaults = require('merge-defaults');\nvar validateWhereClauseStrict = require('./criteria-validator/validate-where-clause-strict');\n\n// Parameter used for jsonp callback is constant, as far as\n// blueprints are concerned (for now.)\nvar JSONP_CALLBACK_PARAM = 'callback';\n\n\n/**\n * Utility methods used in built-in blueprint actions.\n *\n * @type {Object}\n */\nvar actionUtil = {\n\n  /**\n   * Given a Waterline query and an express request, populate\n   * the appropriate/specified association attributes and\n   * return it so it can be chained further ( i.e. so you can\n   * .exec() it )\n   *\n   * @param  {Query} query         [waterline query object]\n   * @param  {Request} req\n   * @return {Query}\n   */\n  populateRequest: function(query, req) {\n    var DEFAULT_POPULATE_LIMIT = req._sails.config.blueprints.defaultLimit || 30;\n    var _options = req.options;\n    var aliasFilter = req.param('populate');\n    var shouldPopulate = _options.populate;\n\n    // Convert the string representation of the filter list to an Array. We\n    // need this to provide flexibility in the request param. This way both\n    // list string representations are supported:\n    //   /model?populate=alias1,alias2,alias3\n    //   /model?populate=[alias1,alias2,alias3]\n    if (typeof aliasFilter === 'string') {\n      aliasFilter = aliasFilter.replace(/\\[|\\]/g, '');\n      aliasFilter = (aliasFilter) ? aliasFilter.split(',') : [];\n    }\n\n    var associations = [];\n\n    _.each(_options.associations, function(association) {\n      // If an alias filter was provided, override the blueprint config.\n      if (aliasFilter) {\n        shouldPopulate = _.contains(aliasFilter, association.alias);\n      }\n\n      // Only populate associations if a population filter has been supplied\n      // with the request or if `populate` is set within the blueprint config.\n      // Population filters will override any value stored in the config.\n      //\n      // Additionally, allow an object to be specified, where the key is the\n      // name of the association attribute, and value is true/false\n      // (true to populate, false to not)\n      if (shouldPopulate) {\n        var populationLimit =\n          _options['populate_' + association.alias + '_limit'] ||\n          _options.populate_limit ||\n          _options.limit ||\n          DEFAULT_POPULATE_LIMIT;\n\n        associations.push({\n          alias: association.alias,\n          limit: populationLimit\n        });\n      }\n    });\n\n    return actionUtil.populateQuery(query, associations, req._sails);\n  },\n\n  /**\n   * Given a Waterline query and Waterline model, populate the\n   * appropriate/specified association attributes and return it\n   * so it can be chained further ( i.e. so you can .exec() it )\n   *\n   * @param  {Query} query         [waterline query object]\n   * @param  {Model} model         [waterline model object]\n   * @return {Query}\n   */\n  populateModel: function(query, model) {\n    return actionUtil.populateQuery(query, model.associations);\n  },\n\n\n /**\n  * Given a Waterline query, populate the appropriate/specified\n  * association attributes and return it so it can be chained\n  * further ( i.e. so you can .exec() it )\n  *\n  * @param  {Query} query         [waterline query object]\n  * @param  {Array} associations  [array of objects with an alias\n  *                                and (optional) limit key]\n  * @return {Query}\n  */\n  populateQuery: function(query, associations, sails) {\n    var DEFAULT_POPULATE_LIMIT = (sails && sails.config.blueprints.defaultLimit) || 30;\n\n    return _.reduce(associations, function(query, association) {\n      return query.populate(association.alias, {\n        limit: association.limit || DEFAULT_POPULATE_LIMIT\n      });\n    }, query);\n  },\n\n  /**\n   * Subscribe deep (associations)\n   *\n   * @param  {[type]} associations [description]\n   * @param  {[type]} record       [description]\n   * @return {[type]}              [description]\n   */\n  subscribeDeep: function ( req, record ) {\n    _.each(req.options.associations, function (assoc) {\n\n      // Look up identity of associated model\n      var ident = assoc[assoc.type];\n      var AssociatedModel = req._sails.models[ident];\n\n      if (req.options.autoWatch) {\n        AssociatedModel.watch(req);\n      }\n\n      // Subscribe to each associated model instance in a collection\n      if (assoc.type === 'collection') {\n        _.each(record[assoc.alias], function (associatedInstance) {\n          AssociatedModel.subscribe(req, associatedInstance);\n        });\n      }\n      // If there is an associated to-one model instance, subscribe to it\n      else if (assoc.type === 'model' && record[assoc.alias]) {\n        AssociatedModel.subscribe(req, record[assoc.alias]);\n      }\n    });\n  },\n\n\n  /**\n   * Parse primary key value for use in a Waterline criteria\n   * (e.g. for `find`, `update`, or `destroy`)\n   *\n   * @param  {Request} req\n   * @return {Integer|String}\n   */\n  parsePk: function ( req ) {\n\n    var pk = req.options.id || (req.options.where && req.options.where.id) || req.param('id');\n\n    // TODO: make this smarter...\n    // (e.g. look for actual primary key of model and look for it\n    //  in the absence of `id`.)\n    // See coercePK for reference (although be aware it is not currently in use)\n\n    // exclude criteria on id field\n    pk = _.isPlainObject(pk) ? undefined : pk;\n    return pk;\n  },\n\n\n\n  /**\n   * Parse primary key value from parameters.\n   * Throw an error if it cannot be retrieved.\n   *\n   * @param  {Request} req\n   * @return {Integer|String}\n   */\n  requirePk: function (req) {\n    var pk = module.exports.parsePk(req);\n\n    // Validate the required `id` parameter\n    if ( !pk ) {\n\n      var err = new Error(\n      'No `id` parameter provided.'+\n      '(Note: even if the model\\'s primary key is not named `id`- '+\n      '`id` should be used as the name of the parameter- it will be '+\n      'mapped to the proper primary key name)'\n      );\n      err.status = 400;\n      throw err;\n    }\n\n    return pk;\n  },\n\n\n\n  /**\n   * Parse `criteria` for a Waterline `find` or `update` from all\n   * request parameters.\n   *\n   * @param  {Request} req\n   *\n   * @returns {Dictionary}\n   *          The normalized WHERE clause\n   *\n   * @throws {Error} If WHERE clause cannot be parsed.\n   *         @property {String} `code: 'E_WHERE_CLAUSE_UNPARSEABLE'`\n   */\n  parseCriteria: function ( req ) {\n\n    // Allow customizable blacklist for params NOT to include as criteria.\n    req.options.criteria = req.options.criteria || {};\n    req.options.criteria.blacklist = req.options.criteria.blacklist || ['limit', 'skip', 'sort', 'populate'];\n\n    // Validate blacklist to provide a more helpful error msg.\n    var blacklist = req.options.criteria && req.options.criteria.blacklist;\n    if (blacklist && !isArray(blacklist)) {\n      throw new Error('Invalid `req.options.criteria.blacklist`. Should be an array of strings (parameter names.)');\n    }\n\n    // Look for explicitly specified `where` parameter.\n    var where = req.params.all().where;\n\n    // If `where` parameter is a string, try to interpret it as JSON\n    if (isString(where)) {\n      where = tryToParseJSON(where);\n    }\n\n    // If `where` has not been specified, but other unbound parameter variables\n    // **ARE** specified, build the `where` option using them.\n    if (!where) {\n\n      // Prune params which aren't fit to be used as `where` criteria\n      // to build a proper where query\n      where = req.params.all();\n\n      // Omit built-in runtime config (like query modifiers)\n      where = _.omit(where, blacklist || ['limit', 'skip', 'sort']);\n\n      // Omit any params w/ undefined values\n      where = _.omit(where, function(p) {\n        if (isUndefined(p)) {return true;}\n      });\n\n      // Omit jsonp callback param (but only if jsonp is enabled)\n      var jsonpOpts = req.options.jsonp && !req.isSocket;\n      jsonpOpts = isObject(jsonpOpts) ? jsonpOpts : { callback: JSONP_CALLBACK_PARAM };\n      if (jsonpOpts) {\n        where = _.omit(where, [jsonpOpts.callback]);\n      }\n    }\n\n    // Merge w/ req.options.where.\n    where = _.merge({}, req.options.where || {}, where) || undefined;\n\n    // Check `WHERE` clause for unsupported usage.\n    // (throws if bad structure is detected)\n    validateWhereClauseStrict(where);\n\n    // Return final `where`.\n    return where;\n  },\n\n\n  /**\n   * Parse `values` for a Waterline `create` or `update` from all\n   * request parameters.\n   *\n   * @param  {Request} req\n   * @return {Object}\n   */\n  parseValues: function (req) {\n\n    // Allow customizable blacklist for params NOT to include as values.\n    req.options.values = req.options.values || {};\n    req.options.values.blacklist = req.options.values.blacklist;\n\n    // Validate blacklist to provide a more helpful error msg.\n    var blacklist = req.options.values.blacklist;\n    if (blacklist && !isArray(blacklist)) {\n      throw new Error('Invalid `req.options.values.blacklist`. Should be an array of strings (parameter names.)');\n    }\n\n    // Start an array to hold values\n    var values;\n\n    // Make an array out of the request body data if it wasn't one already;\n    // this allows us to process multiple entities (e.g. for use with a \"create\" blueprint) the same way\n    // that we process singular entities.\n    var bodyData = isArray(req.body) ? req.body : [req.allParams()];\n\n    // Process each item in the bodyData array, merging with req.options, omitting blacklisted properties, etc.\n    var valuesArray = _.map(bodyData, function(element){\n      var values;\n      // Merge properties of the element into req.options.value, omitting the blacklist\n      values = mergeDefaults(element, _.omit(req.options.values, 'blacklist'));\n      // Omit properties that are in the blacklist (like query modifiers)\n      values = _.omit(values, blacklist || []);\n      // Omit any properties w/ undefined values\n      values = _.omit(values, function(p) {\n        if (isUndefined(p)) {\n          return true;\n        }\n      });\n\n      return values;\n    });\n\n    // If req.body is an array, simply return our array of processed values\n    if (isArray(req.body)) {return valuesArray;}\n\n    // Otherwaise grab the first (and only) value from valuesArray\n    values = valuesArray[0];\n\n    // Omit jsonp callback param (but only if jsonp is enabled)\n    var jsonpOpts = req.options.jsonp && !req.isSocket;\n    jsonpOpts = isObject(jsonpOpts) ? jsonpOpts : { callback: JSONP_CALLBACK_PARAM };\n    if (jsonpOpts) {\n      values = _.omit(values, [jsonpOpts.callback]);\n    }\n\n    return values;\n  },\n\n\n\n  /**\n   * Determine the model class to use w/ this blueprint action.\n   * @param  {Request} req\n   * @return {WLCollection}\n   */\n  parseModel: function (req) {\n\n    // Ensure a model can be deduced from the request options.\n    var model = req.options.model || req.options.controller;\n    if (!model) throw new Error(util.format('No \"model\" specified in route options.'));\n\n    var Model = req._sails.models[model];\n    if ( !Model ) throw new Error(util.format('Invalid route option, \"model\".\\nI don\\'t know about any models named: `%s`',model));\n\n    return Model;\n  },\n\n\n\n  /**\n   * @param  {Request} req\n   */\n  parseSort: function (req) {\n    var sort = req.param('sort') || req.options.sort;\n    if (isUndefined(sort)) {return undefined;}\n\n    // If `sort` is a string, attempt to JSON.parse() it.\n    // (e.g. `{\"name\": 1}`)\n    if (isString(sort)) {\n      try {\n        sort = JSON.parse(sort);\n      }\n      // If it is not valid JSON, then fall back to interpreting it as-is.\n      // (e.g. \"name ASC\")\n      catch(e) {}\n    }\n    return sort;\n  },\n\n  /**\n   * @param  {Request} req\n   */\n  parseLimit: function (req) {\n    var DEFAULT_LIMIT = req._sails.config.blueprints.defaultLimit || 30;\n    var limit = req.param('limit') || (typeof req.options.limit !== 'undefined' ? req.options.limit : DEFAULT_LIMIT);\n    if (limit) { limit = +limit; }\n    return limit;\n  },\n\n\n  /**\n   * @param  {Request} req\n   */\n  parseSkip: function (req) {\n    var DEFAULT_SKIP = 0;\n    var skip = req.param('skip') || (typeof req.options.skip !== 'undefined' ? req.options.skip : DEFAULT_SKIP);\n    if (skip) { skip = +skip; }\n    return skip;\n  }\n};\n\n\n\n\n\n\n// TODO:\n//\n// Replace the following helper with the version in sails.util:\n\n// Attempt to parse JSON\n// If the parse fails, return the error object\n// If JSON is falsey, return null\n// (this is so that it will be ignored if not specified)\nfunction tryToParseJSON (json) {\n  if (!isString(json)) return null;\n  try {\n    return JSON.parse(json);\n  }\n  catch (e) { return e; }\n}\n\nmodule.exports = actionUtil;\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/hooks/blueprints/criteria-validator/validate-where-clause-strict.js":"/**\n * Module dependencies\n */\n\nvar util = require('util');\nvar _ = require('@sailshq/lodash');\nvar flaverr = require('flaverr');\nvar isEqFilter = require('./private/is-eq-filter');\n\n\n// A prefix string to use at the beginning of error messages\n// relating to this `where` clause being unparseable.\nvar E_WHERE_CLAUSE_UNPARSEABLE_MSG_PREFIX =\n'Could not parse the provided `where` clause.  Refer to the Sails documentation '+\n'for up-to-date info on supported query language syntax:\\n'+\n'(http://sailsjs.com/documentation/concepts/models-and-orm/query-language)\\n'+\n'Details: ';\n\n\n// Predicate modifiers\nvar PREDICATE_OPERATORS = [\n  'or',\n  'and'\n];\n\n// \"Not in\" operators\n// (these overlap with sub-attr modifiers-- see below)\nvar NIN_OPERATORS = [\n  '!', 'not'\n];\n\n\n// Sub-attribute modifiers\nvar SUB_ATTR_MODIFIERS = [\n  '<', 'lessThan',\n  '<=', 'lessThanOrEqual',\n  '>', 'greaterThan',\n  '>=', 'greaterThanOrEqual',\n\n  '!', 'not', // << these overlap with `not in` operators\n\n  // The following sub-attribute modifiers also have another,\n  // more narrow classification: string search modifiers.\n  'like',\n  'contains',\n  'startsWith',\n  'endsWith'\n];\n\n// String search modifiers\n// (these overlap with sub-attr modifiers-- see above)\nvar STRING_SEARCH_MODIFIERS = [\n  'like',\n  'contains',\n  'startsWith',\n  'endsWith'\n];\n\n\n/**\n * validateWhereClauseStrict()\n *\n * Check the `WHERE` clause for obviously unsupported usage.\n *\n * This does not do any schema-aware validation-- its job is merely\n * to check for structural issues, and to provide a better experience\n * when integrating from userland code.\n *\n * @param  {Dictionary} where\n *         A hypothetically well-formed `where` clause from\n *         a Waterline criteria.\n *\n * @throws {Error} If WHERE clause cannot be parsed.\n *         @property {String} `code: 'E_WHERE_CLAUSE_UNPARSEABLE'`\n */\nmodule.exports = function validateWhereClauseStrict(where) {\n\n  if (!_.isObject(where) || _.isArray(where) || _.isFunction(where)) {\n    throw flaverr('E_WHERE_CLAUSE_UNPARSEABLE', new Error(E_WHERE_CLAUSE_UNPARSEABLE_MSG_PREFIX + 'Expected `where` to be a dictionary, but got: `'+util.inspect(where,{depth: null})+'`'));\n  }\n\n  // Recursively iterate through the provided `where` clause, starting with each top-level key.\n  (function _recursiveStep(clause){\n\n    _.each(clause, function (rhs, key){\n\n      //  \n      //        \n      //       \n      //               \n      //             \n      //               \n      // If this is an OR or AND predicate...\n      if (_.contains(PREDICATE_OPERATORS, key)) {\n\n        // RHS of a predicate must always be an array.\n        if (!_.isArray(rhs)) {\n          throw flaverr('E_WHERE_CLAUSE_UNPARSEABLE', new Error(E_WHERE_CLAUSE_UNPARSEABLE_MSG_PREFIX + 'Expected an array at `'+key+'`, but instead got:'+util.inspect(rhs,{depth: null})+'\\n(`'+key+'` should always be provided with an array on the right-hand side.)'));\n        }//-\n\n        // If the array is empty, then this is puzzling.\n        // e.g. `{ or: [] }`\n        if (_.keys(rhs).length === 0) {\n          // But we will tolerate it for now for compatibility.\n          // (it's not _exactly_ invalid, per se.)\n        }\n\n        // >-\n        // Loop over each sub-clause within this OR/AND predicate.\n        _.each(rhs, function (subClause){\n\n          // Check that each sub-clause is a plain dictionary, no funny business.\n          if (!_.isObject(subClause) || _.isArray(subClause) || _.isFunction(subClause)) {\n            throw flaverr('E_WHERE_CLAUSE_UNPARSEABLE', new Error(E_WHERE_CLAUSE_UNPARSEABLE_MSG_PREFIX + 'Expected each item within a `'+key+'` predicate\\'s array to be a dictionary, but got: `'+util.inspect(subClause,{depth: null})+'`'));\n          }\n\n          // Recursive call\n          _recursiveStep(subClause);\n\n        });//</each sub-clause inside of predicate>\n\n      }\n      //     \n      //         \n      //       \n      // Else if this is an IN (equal to any) filter...\n      else if (_.isArray(rhs)) {\n\n        // If the array is empty, then this is puzzling.\n        // e.g. `{ fullName: [] }`\n        if (_.keys(rhs).length === 0) {\n          // But we will tolerate it for now for compatibility.\n          // (it's not _exactly_ invalid, per se.)\n        }\n\n        // Validate each item in the `in` array as an equivalency filter.\n        _.each(rhs, function (subFilter){\n\n          if (!isEqFilter(subFilter)) {\n            throw flaverr('E_WHERE_CLAUSE_UNPARSEABLE', new Error(E_WHERE_CLAUSE_UNPARSEABLE_MSG_PREFIX + 'Unexpected value at `'+key+'`:'+util.inspect(subFilter,{depth: null})+'\\n(Sub-filters within an `in` must be provided as primitive values like strings, numbers, booleans, and null.)'));\n          }\n\n        });\n\n      }\n      //              \n      //                         \n      //                          \n      //                        \n      //                                \n      //           o                \n      // Else if the right-hand side is a dictionary...\n      else if (_.isObject(rhs) && !_.isArray(rhs) && !_.isFunction(rhs)) {\n\n        // If the dictionary is empty, then this is puzzling.\n        // e.g. { fullName: {} }\n        if (_.keys(rhs).length === 0) {\n          throw flaverr('E_WHERE_CLAUSE_UNPARSEABLE', new Error(E_WHERE_CLAUSE_UNPARSEABLE_MSG_PREFIX + 'Unexpected value at `'+key+'`:'+util.inspect(rhs,{depth: null})+'\\n(If a dictionary is provided, it is expected to consist of sub-attribute modifiers like `contains`, etc.  But this dictionary is empty!)'));\n        }\n\n        // Check to verify that it is a valid dictionary with a sub-attribute modifier.\n        _.each(rhs, function (subFilter, subAttrModifierKey) {\n\n          // If this is a documented sub-attribute modifier, then validate it as such.\n          if (_.contains(SUB_ATTR_MODIFIERS, subAttrModifierKey)) {\n\n            // If the sub-filter is an array...\n            //\n            // > The RHS value for sub-attr modifier is only allowed to be an array for\n            // > the `not` modifier. (This is to allow for use as a \"NOT IN\" filter.)\n            // > Otherwise, arrays are prohibited.\n            if (_.isArray(subFilter)) {\n\n              // If this is _actually_ a `not in` filter (e.g. a \"!\" with an array on the RHS)...\n              // e.g.\n              // ```\n              // fullName: {\n              //   '!': ['murphy brown', 'kermit']\n              // }\n              // ```\n              if (_.contains(NIN_OPERATORS, subAttrModifierKey)) {\n\n                // If the array is empty, then this is puzzling.\n                // e.g. `{ fullName: { '!': [] } }`\n                if (_.keys(subFilter).length === 0) {\n                  // But we will tolerate it for now for compatibility.\n                  // (it's not _exactly_ invalid, per se.)\n                }\n\n                // Loop over the \"not in\" values in the array\n                _.each(subFilter, function (blacklistItem){\n\n                  // We handle this here as a special case.\n                  if (!isEqFilter(blacklistItem)) {\n                    throw flaverr('E_WHERE_CLAUSE_UNPARSEABLE', new Error(E_WHERE_CLAUSE_UNPARSEABLE_MSG_PREFIX + 'Unexpected value within the blacklist array provided at sub-attribute modifier (`'+subAttrModifierKey+'`) for `'+key+'`:'+util.inspect(blacklistItem,{depth: null})+'\\n(Blacklist items within a `not in` array must be provided as primitive values like strings, numbers, booleans, and null.)'));\n                  }\n\n                });//</_.each() :: item in the \"NOT IN\" blacklist array>\n              }\n              // Otherwise, this is some other attr modifier...which means this is invalid,\n              // since arrays are prohibited.\n              else {\n                throw flaverr('E_WHERE_CLAUSE_UNPARSEABLE', new Error(E_WHERE_CLAUSE_UNPARSEABLE_MSG_PREFIX + 'Unexpected array at sub-attribute modifier (`'+subAttrModifierKey+'`) for `'+key+'`:'+util.inspect(subFilter,{depth: null})+'\\n(An array cannot be used as the right-hand side of a `'+subAttrModifierKey+'` sub-attribute modifier.  Instead, try using `or` at the top level.  Refer to the Sails docs for details.)'));\n              }\n\n            }\n            // Otherwise the sub-filter for this sub-attr modifier should\n            // be validated according to its modifer.\n            else {\n\n              // If this sub-attribute modifier is specific to strings\n              // (e.g. \"contains\") then only allow strings, numbers, and booleans.  (Dates and null should not be used.)\n              if (_.contains(STRING_SEARCH_MODIFIERS, subAttrModifierKey)) {\n                if (!_.isString(subFilter) && !_.isNumber(subFilter) && !_.isBoolean(subFilter)){\n                  throw flaverr('E_WHERE_CLAUSE_UNPARSEABLE', new Error(E_WHERE_CLAUSE_UNPARSEABLE_MSG_PREFIX + 'Unexpected value at sub-attribute modifier (`'+subAttrModifierKey+'`) for `'+key+'`:'+util.inspect(subFilter,{depth: null})+'\\n(The right-hand side of a string search modifier like `'+subAttrModifierKey+'` must always be a string, number, or boolean.)'));\n                }\n              }\n              // Otherwise this is a miscellaneous sub-attr modifier,\n              // so validate it as an eq filter.\n              else {\n                if (!isEqFilter(subFilter)) {\n                  throw flaverr('E_WHERE_CLAUSE_UNPARSEABLE', new Error(E_WHERE_CLAUSE_UNPARSEABLE_MSG_PREFIX + 'Unexpected value at sub-attribute modifier (`'+subAttrModifierKey+'`) for `'+key+'`:'+util.inspect(subFilter,{depth: null})+'\\n(The right-hand side of a `'+subAttrModifierKey+'` must be a primitive value, like a string, number, boolean, or null.)'));\n                }\n              }//</else (validate this sub-attr modifier's RHS as an eq filter)>\n\n            }//</else (validation rule depends on what modifier this is)>\n\n          }//</if this is a recognized sub-attr modifier>\n          //\n          // Otherwise, this is NOT a recognized sub-attribute modifier and it makes us uncomfortable.\n          else {\n            throw flaverr('E_WHERE_CLAUSE_UNPARSEABLE', new Error(E_WHERE_CLAUSE_UNPARSEABLE_MSG_PREFIX + 'Unrecognized sub-attribute modifier (`'+subAttrModifierKey+'`) for `'+key+'`.  Make sure to use a recognized sub-attribute modifier such as `startsWith`, `<=`, `!`, etc. )'));\n          }\n\n        });//</each sub-attr modifier>\n\n      }//</RHS is a dictionary>\n      //\n      //            \n      //                \n      //            \n      // Last but not least, when nothing else matches...\n      else {\n\n        // Check the right-hand side as a normal equivalency filter.\n        if (!isEqFilter(rhs)) {\n          throw flaverr('E_WHERE_CLAUSE_UNPARSEABLE', new Error(E_WHERE_CLAUSE_UNPARSEABLE_MSG_PREFIX + 'Unexpected value at `'+key+'`:'+util.inspect(rhs,{depth: null})+'\\n(When filtering by exact match, use a primitive value: a string, number, boolean, or null.)'));\n        }\n\n      }//</else:: is normal equivalency filter>\n\n    });//</_.each() : check each top-level key>\n\n  })//</self-invoking recursive function (def)>\n  //\n  // Kick off our recursion with the `where` clause:\n  (where);\n\n\n};\n\n\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/hooks/blueprints/criteria-validator/private/is-eq-filter.js":"/**\n * Module dependencies\n */\n\nvar _ = require('@sailshq/lodash');\n\n\n/**\n * isEqFilter()\n *\n * Return whether or not the specified value is a valid equivalency filter.\n *\n * > This does not do any schema-aware validation-- its job is merely\n * > to check for structural issues, and to provide a better experience\n * > when integrating from userland code.\n *\n * @param  {Dictionary} value\n *         A supposed equivalency filter from the `where` clause of\n *         a Waterline criteria.\n *\n * @returns {Boolean}\n *          True if the value is a valid equivalency filter; false otherwise.\n */\nmodule.exports = function isEqFilter(value) {\n\n  // We tolerate the presence of `undefined`.\n  // > (it is ignored anyway)\n  if (_.isUndefined(value)) {\n    return true;\n  }\n  // Primitives make good equivalency filters.\n  else if (_.isNull(value) || _.isString(value) || _.isNumber(value) || _.isBoolean(value)) {\n    return true;\n  }\n  // We tolerate Date instances as equivalency filters.\n  // > This will likely be discouraged in a future version of Sails+Waterline.\n  // > Instead, it'll be encouraged to store numeric JS timestamps. (That is, the\n  // > # of miliseconds since the unix epoch.  Or in other words: `Date.getTime()`).\n  else if (_.isDate() || _.isString(value) || _.isNumber(value) || _.isBoolean(value)) {\n    return true;\n  }\n  // But everything else (dictionaries, arrays, functions, crazy objects, regexps, etc.)\n  // is NOT ok.  These kinds of values do not make good equivalency filters.\n  else {\n    return false;\n  }\n\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/hooks/blueprints/coercePK.js":"/**\n * Module dependencies.\n */\n\nvar _       = require('@sailshq/lodash');\n\n\nmodule.exports = function (sails) {\n\n    /**\n     * @param {Natural|String} id\n     * @param {String} controllerId\n     * @param {String} actionId\n     * @returns id ::\n     *      If `id` is undefined, no `id` was provided\n     *      If `id` is false, `id` is invalid, and probably unintentional\n     *      Otherwise, `id` is valid and probably intentional\n     */\n    return function validId (id, controllerId, actionId) {\n\n        // Interlace app-global `config.controllers` with this controller's `_config`\n        var controllerConfig = _.merge({}, \n            sails.config.controllers, \n            sails.controllers[controllerId]._config || {});\n\n\n        // The other CRUD methods are special reserved words-- in which case we always pass\n        // As long as the CRUD 'shortcuts' are enabled, you cannot search for models\n        // with an id of 'find', 'update', 'create', or 'destroy'\n        if (    controllerConfig.blueprints.shortcuts && (\n                id === 'find'   ||\n                id === 'update' ||\n                id === 'create' ||\n                id === 'destroy' )) {\n            return false;\n        }\n\n\n        // If expectIntegerId check is disabled, `id` is always ok\n        if ( !controllerConfig.blueprints.expectIntegerId ) {\n            return id;\n        }\n\n        // Ensure that id is numeric (unless this check is disabled)\n        var castId = +id;\n        if (id && _.isNaN(castId)) {\n\n            // If it's not, move on to next middleware\n            // but emit a console warning explaining the situation\n            // (if the app is in development mode):\n            if (sails.config.environment === 'development') {\n                sails.log.warn('\\n',\n                            'Just then, you were prevented from being routed \\n',\n                            'to the `' + actionId + '` blueprint for controller: ' + controllerId + \n                            ' using `id='+id+'`.\\n',\n                            'This is because REST blueprint routes expect natural number ids by default, '+\n                            'and so the `' + actionId + '()` middleware was skipped- \\n',\n                            'If you\\'d like to disable this restriction, you can do so by setting \\n',\n                            '`expectIntegerId: false` in the blueprint config for this controller.');\n            }\n            return false;\n        }\n\n        // Id is an integer\n        return parseInt(id, 10);\n    };\n};\n\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/hooks/blueprints/onRoute.js":"/**\n * Module dependencies.\n */\n\nvar _ = require('@sailshq/lodash');\n\n\n\n// NOTE:\n// Since controllers load blueprint actions by default anyways, this route syntax handler\n// can be replaced with `{action: 'find'}, {action: 'create'}, ...` etc.\n\n\n/**\n * Expose route parser.\n * @type {Function}\n */\nmodule.exports = function(sails) {\n\n  /**\n   * interpretRouteSyntax\n   *\n   * \"Teach\" router to understand direct references to blueprints\n   * as a target to sails.router.bind()\n   * (i.e. in the `routes.js` file)\n   *\n   * @param  {[type]} route [description]\n   * @return {[type]}       [description]\n   * @api private\n   */\n  return function interpretRouteSyntax(route) {\n    var target = route.target,\n      path = route.path,\n      verb = route.verb,\n      options = route.options;\n\n    // Support referencing blueprints in explicit routes\n    // (`{ blueprint: 'create' }` et. al.)\n    if (\n      _.isObject(target) &&\n      !_.isFunction(target) &&\n      !_.isArray(target) &&\n      _.isString(target.blueprint)) {\n\n      // On a match, merge leftover items in the target object into route options:\n      options = _.merge(options, _.omit(target, 'blueprint'));\n      // Note: this (^) could be moved up into lib/router/bind.js, since its\n      // only pertinent for core options such as `skipAssets`.  There would need\n      // to be changes in other hooks as well.\n\n      return bindBlueprintAction(path, target.blueprint, verb, options);\n    }\n\n    // Ignore unknown route syntax\n    // If it needs to be understood by another hook, the hook would have also received\n    // the typeUnknown event, so we're done.\n    return;\n  };\n\n\n\n  /**\n   * Bind explicit route to a blueprint action.\n   *\n   * @param  {[type]} path   [description]\n   * @param  {[type]} blueprintActionID [description]\n   * @param  {[type]} verb   [description]\n   * @param  {[type]} options   [description]\n   * @return {[type]}        [description]\n   * @api private\n   */\n  function bindBlueprintAction(path, blueprintActionID, verb, options) {\n\n    // Look up appropriate blueprint action and make sure it exists\n    var blueprint = sails.middleware.blueprints[blueprintActionID];\n\n    // If a 'blueprint' was specified, but it doesn't exist, warn the user and ignore it.\n    if (!(blueprint && _.isFunction(blueprint))) {\n      sails.log.error(\n        blueprintActionID,\n        ':: Ignoring attempt to bind route (' + path + ') to unknown blueprint action (`' + blueprintActionID + '`).'\n      );\n      return;\n    }\n\n    // If a model wasn't provided with the options, try and guess it\n    if (!options.model) {\n      var matches = path.match(/^\\/(\\w+).*$/);\n      if (matches && matches[1] && sails.models[matches[1]]) {\n        options.model = matches[1];\n      } else {\n        sails.log.error(\n          blueprintActionID,\n          ':: Ignoring attempt to bind route (' + path + ') to blueprint action (`' + blueprintActionID + '`), but no valid model was specified and we couldn\\'t guess one based on the path.'\n        );\n        return;\n      }\n    }\n\n    // If associations weren't provided with the options, try and get them\n    if (!options.associations) {\n      options = _.merge({\n        associations: _.cloneDeep(sails.models[options.model].associations)\n      }, options);\n    }\n    // Otherwise make sure it's an array of strings of valid association aliases\n    else {\n      options.associations = options.associations.map(function(alias) {\n        if (!_.isString(alias)) {\n          sails.log.error(\n            blueprintActionID,\n            ':: Ignoring invalid association option for ' + path + '.'\n          );\n          return;\n        }\n        var association;\n        if (!(association = _.findWhere(sails.models[options.model].associations, {\n            alias: alias\n          }))) {\n          sails.log.error(\n            blueprintActionID,\n            ':: Ignoring invalid association option `' + alias + '` for ' + path + '.'\n          );\n          return;\n        }\n        return association;\n      });\n    }\n\n    // If \"populate\" wasn't provided in the options, use the default\n    if (_.isUndefined(options.populate)) {\n      options.populate = sails.config.blueprints.populate;\n    }\n\n    sails.router.bind(path, blueprint, verb, options);\n\n    return;\n  }\n\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/hooks/controllers/to-interpret-route-syntax.js":"/**\n * Module dependencies.\n */\n\nvar _ = require('@sailshq/lodash');\nvar sailsUtil = require('sails-util');\n\n\n/**\n * @param  {SailsApp} sails  [Sails app]\n * @return {Function}\n */\nmodule.exports = function to(sails) {\n\n  /**\n   * `interpretRouteSyntax()`\n   *\n   * \"Teach\" router to understand references to controllers.\n   * This is the event handler for the 'route:typeUnknown' emitted on `sails`.\n   *\n   * @param  {Dictionary} route\n   *         @property {String} verb\n   *         @property {String} path\n   *         @property {Dictionary} target\n   *         @property {Dictionary} options\n   *\n   * @api private\n   */\n  return function interpretRouteSyntax (route) {\n    var target = route.target;\n    var path = route.path;\n    var verb = route.verb;\n    var options = route.options;\n\n\n    // Support various dictionary target notations, e.g.:\n    // `{ controller: 'UserController' }`\n    if (_.isObject(target) && !_.isFunction(target) && !_.isArray(target)) {\n\n      // Merge target into `options` to get hold of relevant route options:\n      options = _.merge(options, target);\n      // Note: this (^) could be moved up into lib/router/bind.js, since its\n      // only pertinent for core options such as `skipAssets`.  There would need\n      // to be changes in other hooks as well.\n\n      // Support { controller: 'FooController' } notation (with or without `action`)\n      if ( !_.isUndefined(target.controller) ) {\n        return bindController(path, target, verb, options);\n      }\n\n      // Support resourceful sub-mappings for verbless routes\n      // e.g. '/someRoute': { post: 'FooController.bar', get: '...', /* ... */ }\n      // If verb was manually specified in route address (e.g. `get /someRoute`), ignore the sub-mappings.\n      //\n      ////////////////////////////////////////////////////////////////////////////////////\n      // Support for this routing syntax will be deprecated in Sails v1.0.\n      ////////////////////////////////////////////////////////////////////////////////////\n      if ( !options.detectedVerb ) {\n        if ( target.get ) { sails.router.bind (path, target['get'],'get', options); }\n        if ( target.post ) { sails.router.bind (path, target['post'],'post', options); }\n        if ( target.put ) { sails.router.bind (path, target['put'],'put', options); }\n        if ( target['delete'] ) { sails.router.bind (path, target['delete'],'delete', options); }\n        // If there is a legitimate use case for it, add other HTTP verbs here for completeness.\n      }\n\n      // Lone action syntax, e.g.:\n      // '/someRoute': { action: 'find', model: 'foo' }\n      //\n      // (useful for explicitly routing a URL to a blueprint action)\n      //\n      ////////////////////////////////////////////////////////////////////////////////////\n      // Support for this routing syntax will be deprecated in Sails v1.0.\n      ////////////////////////////////////////////////////////////////////////////////////\n      else if ( !_.isUndefined(target.action) ) {\n\n        // Merge target def. into route options:\n        options.action = target.action;\n\n        return bindBlueprintAction(path, target.action, verb, options);\n      }\n    }\n\n\n    // Support string ('FooController.bar') notation\n    else if (_.isString(target)) {\n\n      // Handle dot notation\n      var parsedTarget = target.match(/^([^.]+)\\.?([^.]*)?$/);\n\n      // If target matches a controller (or, if views hook enabled, a view)\n      // go ahead and assume that this is a dot notation route\n      var controllerId = sailsUtil.normalizeControllerId(parsedTarget[1]);\n      var actionId = _.isString(parsedTarget[2]) ? parsedTarget[2].toLowerCase() : 'index';\n\n      // If this is a known controller, bind it\n      if ( controllerId && (\n        sails.middleware.controllers[controllerId] ||\n        (sails.config.hooks.views.blueprints && sails.middleware.views[controllerId])\n        )\n      ) {\n        return bindController (path, {\n          controller: controllerId,\n          action: actionId\n        }, verb, options);\n      }\n    }\n\n    // Ignore unknown route syntax\n    // If it needs to be understood by another hook, the hook would have also received\n    // the typeUnknown event, so we're done.\n    return;\n  };\n\n\n\n  /**\n   * Bind route to a controller/action.\n   *\n   * @param  {[type]} path   [description]\n   * @param  {[type]} target [description]\n   * @param  {[type]} verb   [description]\n   * @param  {[type]} options[description]\n   * @return {[type]}        [description]\n   * @api private\n   */\n  function bindController ( path, target, verb, options ) {\n\n    // Normalize controller and action ids\n    var controllerId = sailsUtil.normalizeControllerId(target.controller);\n    var actionId = _.isString(target.action) ? target.action.toLowerCase() : null;\n\n\n    // Look up appropriate controller/action and make sure it exists\n    var controller = sails.middleware.controllers[controllerId];\n\n    // Fall back to matching view\n    if (!controller) {\n      controller = sails.middleware.views[controllerId];\n    }\n\n    // If a controller and/or action was specified,\n    // but it's not a match, warn the user\n    if ( ! ( controller && _.isObject(controller) )) {\n      sails.after('lifted', function () {\n        sails.log.error(\n          'Ignored attempt to bind route (' + path + ') to unknown controller ::',\n          controllerId+'.'\n        );\n      });\n      return;\n    }\n    if ( actionId && !controller[actionId] ) {\n      sails.after('lifted', function () {\n        sails.log.error(\n          'Ignored attempt to bind route (' + path + ') to unknown controller.action ::',\n          controllerId + '.' + (actionId || 'index')\n        );\n      });\n      return;\n    }\n\n    // (if unspecified, default actionId to 'index'\n    actionId = actionId || 'index';\n\n    // Merge the target controller/action into our route options:\n    options.controller = controllerId;\n    options.action = actionId;\n\n\n    // Determine the model connected to this controller either by:\n    // -> on the routes config\n    // -> on the controller\n    //\n    ////////////////////////////////////////////////////////////////////////////////////\n    // Support for specifying `model` on the route target will be deprecated in Sails v1.0.\n    // (instead you will be able to override the action directly)\n    ////////////////////////////////////////////////////////////////////////////////////\n    var modelId = options.model || controllerId;\n\n\n\n    // If the orm hook is enabled, it has already been loaded by this time,\n    // so just double-check to see if the attached model exists in `sails.models`.\n    //\n    ////////////////////////////////////////////////////////////////////////////////////\n    // In Sails v1.0, this logic will be implemented by the blueprints hook rather than here.\n    ////////////////////////////////////////////////////////////////////////////////////\n    if (sails.hooks.orm && sails.models && sails.models[modelId]) {\n\n      // If a model with matching identity exists,\n      // extend route options with the id of the model.\n      options.model = modelId;\n\n      var Model = sails.models[modelId];\n\n      // Mix in the known associations for this model to the route options.\n      options = _.merge({ associations: _.cloneDeep(Model.associations) }, options);\n\n      // Mix in the relevant blueprint config\n      options = _.defaults(options, {\n        populate: sails.config.blueprints.populate,\n        defaultLimit: sails.config.blueprints.defaultLimit\n      });\n\n    }\n\n\n    // Now bind the specified action-- our \"subTarget\"\n    var subTarget = controller[actionId];\n    //\n    // But first, if this is not an array, then wrap it in one (non-destructive)\n    if ( !_.isArray(subTarget) ) {\n      subTarget = [ subTarget ];\n    }\n    //\n    // Now we have an array of functions, so bind each one to the route address in order.\n    _.each(subTarget, function bindEachMiddlewareInSubTarget (fn) {\n      sails.router.bind(path, controllerHandler(fn), verb, options);\n    });\n\n\n\n    // Wrap up the controller middleware to supply access to\n    // the original target when requests comes in\n    function controllerHandler (originalFn) {\n\n      if ( !_.isFunction(originalFn) ) {\n        sails.after('lifted', function () {\n          sails.log.error(\n            'In '+controllerId + '.' + actionId+', ignored invalid attempt to bind route to a non-function controller:',\n            originalFn, 'for path: ', path, verb ? ('and verb: ' + verb) : '');\n        });\n        return;\n      }\n\n      // Bind intercepted middleware function to route\n      return originalFn;\n    }\n\n    return;\n  }\n\n\n  /**\n   * Bind specified blueprint action to the specified route.\n   *\n   * @param  {[type]} path              [description]\n   * @param  {[type]} blueprintActionID [description]\n   * @param  {[type]} verb              [description]\n   * @param  {[type]} options           [description]\n   * @return {[type]}                   [description]\n   */\n  function bindBlueprintAction (path, blueprintActionID, verb, options){\n\n    // Look up appropriate blueprint action and make sure it exists\n    var blueprint = sails.middleware.blueprints[blueprintActionID];\n\n    // If a 'blueprint' was specified, but it doesn't exist, warn the user and ignore it.\n    if ( ! ( blueprint && _.isFunction(blueprint) )) {\n      sails.after('lifted', function () {\n        sails.log.error(\n          'Ignored attempt to bind route (' + path + ') to unknown blueprint action (`'+blueprintActionID+'`).'\n        );\n      });\n      return;\n    }\n\n    sails.router.bind(path, blueprint, verb, options);\n  }\n\n};\n\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/hooks/controllers/to-load-and-register-controllers.js":"/**\n * Module dependencies.\n */\n\nvar _ = require('@sailshq/lodash');\nvar sailsUtil = require('sails-util');\n\n\n/**\n * @param  {SailsApp} sails  [Sails app]\n * @param  {Hook} hook       [instantiated hook]\n * @return {Function}\n */\nmodule.exports = function to(sails, hook) {\n\n  /**\n   * `loadAndRegisterControllers()`\n   *\n   * Wipe everything and (re)load middleware from controllers. Merge any\n   * controllers already defined in the sails.controllers namespace.\n   *\n   * @api private\n   */\n  return function loadAndRegisterControllers (cb) {\n\n    // Remove all controllers from middleware hash,\n    // but retain the reference between this and sails.middleware.controllers\n    _.each(_.keys(hook.middleware), function(key) {\n      delete hook.middleware[key];\n    });\n\n    // Load app controllers\n    sails.modules.loadControllers(function modulesLoaded(err, modules) {\n      if (err) return cb(err);\n\n      sails.controllers = _.merge(sails.controllers, modules);\n\n      // Register controllers\n      _.each(sails.controllers, function(controller, controllerId) {\n\n        // Override whatever was here before\n        if (!sailsUtil.isDictionary(hook.middleware[controllerId])) {\n          hook.middleware[controllerId] = {};\n        }\n\n        // Register this controller's actions\n        _.each(controller, function(action, actionId) {\n\n          // action ids are case insensitive\n          actionId = actionId.toLowerCase();\n\n          // If the action is set to `false`, explicitly disable it\n          if (action === false) {\n            delete hook.middleware[controllerId][actionId];\n            return;\n          }\n\n          // Ignore non-actions (special properties)\n          //\n          // Properties like these are injected by `moduleloader`\n          // Ideally they should be hidden in the prototype or omitted instead\n          // of this blanket approach.  This approach has worked for a long time,\n          // but should not be relied upon- even within core (since a change is likely\n          // in Sails v1.0)\n          if (_.isString(action) || _.isBoolean(action)) {\n            return;\n          }\n\n          // Otherwise mix it in (this will override CRUD blueprints from above)\n          action._middlewareType = 'ACTION: ' + controllerId + '/' + actionId;\n          hook.middleware[controllerId][actionId] = action;\n          hook.explicitActions[controllerId] = hook.explicitActions[controllerId] || {};\n          hook.explicitActions[controllerId][actionId] = true;\n        });\n\n      });\n\n      return cb();\n    });\n  };\n\n};\n\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/hooks/cors/clear-headers.js":"module.exports = function (req, res, next) {\n\n  // If we can set headers, do so.\n  // (Note: This is for backwards-compatibility. `res.set()` should always exist now.\n  //  This check can be removed in a future version of Sails- just needs tests first.)\n  if (res.set) {\n    res.set('Access-Control-Allow-Origin', '');\n    res.set('Access-Control-Allow-Credentials', '');\n    res.set('Access-Control-Allow-Methods', '');\n    res.set('Access-Control-Allow-Headers', '');\n    res.set('Access-Control-Expose-Headers', '');\n  }\n\n  next();\n\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/hooks/cors/to-prepare-send-headers.js":"/**\n * Module dependencies.\n */\n\nvar _ = require('@sailshq/lodash');\nvar clearHeaders = require('./clear-headers');\n\n\n/**\n * toPrepareSendHeaders()\n *\n * @param  {SailsApp} sails\n *\n * @return {Function}\n *         not-yet-configured middleware (\"protoware\") that can be called to get req/res/next mware function\n */\nmodule.exports = function (sails) {\n\n\n  /**\n   * @optional  {Dictionary}  _routeCorsConfig\n   *\n   * @optional  {Boolean} isOptionsRoute\n   *            if set, use the `access-control-request-method` header\n   *            as the method when looking up the route's CORS configuration\n   *\n   * @return {Function}\n   *         A configured middleware function which sets the appropriate headers.\n   */\n  return function toPrepareSendHeaders(_routeCorsConfig, isOptionsRoute) {\n\n    if (!_routeCorsConfig) {\n      _routeCorsConfig = {};\n    }\n    var _sendHeaders = function(req, res, next) {\n      var routeCorsConfig;\n      // If this is an options route handler, pull the config to use based on the method\n      // that would be used in the follow-on request\n      if (isOptionsRoute) {\n        var method = (req.headers['access-control-request-method'] || '').toLowerCase() || 'default';\n        routeCorsConfig = _routeCorsConfig[method] || {};\n        if (routeCorsConfig == 'clear') {\n          return clearHeaders(req, res, next);\n        }\n      }\n      // Otherwise just use the config that was passed down\n      else {\n        routeCorsConfig = _routeCorsConfig;\n      }\n      // If we have an origin header...\n      if (req.headers && req.headers.origin) {\n\n        // Get the allowed origins\n        var origins = (routeCorsConfig.origin || sails.config.cors.origin).split(',');\n\n        // Match the origin of the request against the allowed origins\n        var foundOrigin = false;\n        _.each(origins, function(origin) {\n\n          origin = origin.trim();\n          // If we find a whitelisted origin, send the Access-Control-Allow-Origin header\n          // to greenlight the request.\n          if (origin == req.headers.origin || origin == '*') {\n            res.set('Access-Control-Allow-Origin', req.headers.origin);\n            foundOrigin = true;\n            return false;\n          }\n          return true;\n        });\n\n        if (!foundOrigin) {\n          // For HTTP requests, set the Access-Control-Allow-Origin header to '', which the browser will\n          // interpret as, 'no way Jose.'\n          res.set('Access-Control-Allow-Origin', '');\n        }\n\n        // Determine whether or not to allow cookies to be passed cross-origin\n        res.set('Access-Control-Allow-Credentials', !_.isUndefined(routeCorsConfig.credentials) ? routeCorsConfig.credentials : sails.config.cors.credentials);\n\n        // This header lets a server whitelist headers that browsers are allowed to access\n        res.set('Access-Control-Expose-Headers', !_.isUndefined(routeCorsConfig.exposeHeaders) ? routeCorsConfig.exposeHeaders : sails.config.cors.exposeHeaders);\n\n        // Handle preflight requests\n        if (req.method == 'OPTIONS') {\n          res.set('Access-Control-Allow-Methods', !_.isUndefined(routeCorsConfig.methods) ? routeCorsConfig.methods : sails.config.cors.methods);\n          res.set('Access-Control-Allow-Headers', !_.isUndefined(routeCorsConfig.headers) ? routeCorsConfig.headers : sails.config.cors.headers);\n        }\n\n      }\n\n      next();\n\n    };\n\n    _sendHeaders._middlewareType = 'CORS HOOK: sendHeaders';\n    return _sendHeaders;\n\n  };\n\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/hooks/grunt/grunt-wrapper.js":"/**\n * A hack to exec grunt without knowing exactly where it is.\n *\n * grunt-cli could be installed as a peer to sails, so we don't know\n * where its bin script might be. But require can find it. We have this thin\n * wrapper to be a script we can exec, and it will execute the grunt-cli,\n * wherever it may be installed.\n */\n\nrequire('grunt-cli/bin/grunt');\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/hooks/http/get-configured-http-middleware-fns.js":"/**\n * Module dependencies\n */\n\nvar Path = require('path');\nvar util = require('util');\nvar _ = require('@sailshq/lodash');\nvar pathToRegexp = require('path-to-regexp');\n\n\n\n/**\n * getBuiltInHttpMiddleware()\n *\n * Return a dictionary containing all built-in middleware in Sails,\n * applying configuration along the way.\n *\n * @param  {Router} expressRouterMiddleware [i.e. `app.router`]\n * @param  {SailsApp} sails\n * @return {Dictionary}\n *         @property {Function} *\n *             @param {Request} req\n *             @param {Response} res\n *             @param {Function} next\n */\nmodule.exports = function getBuiltInHttpMiddleware (expressRouterMiddleware, sails) {\n\n  // Note that the environment of a Sails app is officially determined by\n  // `sails.config.environment`. Normally, that is identical to what you'll\n  // find inside `process.env.NODE_ENV`.\n  //\n  // However it is possible for NODE_ENV and `sails.config.environment to vary\n  // (e.g. `sails.config.environment==='staging'` and `process.env.NODE_ENV==='production'`).\n  //\n  // Some middleware _depends on the NODE_ENV environment variable_ to determine\n  // its behavior.  Since NODE_ENV may have been set automatically, this is why the\n  // relevant requires are included _within_ this function, rather than up top.\n  //\n  // This is also why the NODE_ENV environment variable is used here to determine\n  // whether or not to consider the app \"in production\".  This way, if you set\n  // `NODE_ENV=production` explicitly, you can still use something like \"staging\"\n  // or \"sandbox\" for your `sails.config.environment` in order to take advantage\n  // of env-specific config files; while still having dependencies work like they\n  // will in production (since NODE_ENV is set).\n  //\n  var IS_NODE_ENV_PRODUCTION = (process.env.NODE_ENV === 'production');\n\n\n\n  return _.defaults(sails.config.http.middleware || {}, {\n\n    // Configure flat file server to serve static files\n    // (By default, all explicit+shadow routes take precedence over flat files)\n    www: (function() {\n      var flatFileMiddleware = require('serve-static')(sails.config.paths['public'], {\n        maxAge: sails.config.http.cache\n      });\n\n      return flatFileMiddleware;\n    })(),\n\n    // If a Connect session store is configured, hook it up to Express\n    session: (function() {\n      if (sails.config.session && sails.config.session.store) {\n        var configuredSessionMiddleware;\n        try {\n          // Set \"resave\" and \"saveUninitialized\" options or else express-session gives you a stern warning.\n          var opts = _.merge({\n            resave: true,\n            saveUninitialized: true\n          }, sails.config.session);\n          configuredSessionMiddleware = require('express-session')(opts);\n        }\n        catch (e) {\n          sails.log.error('Error occurred while setting up session middleware:',e);\n          return undefined;\n        }\n        return function (req, res, next){\n\n          // If configured to do so (i.e. there is at least one entry in the `sails.hooks.session.routesDisabled` blacklist)\n          // then check this request against each entry in the blacklist and skip running session middleware if this is a match.\n          var isSessionDisabled = _.any(sails.hooks.session.routesDisabled, function (disabledRouteInfo){\n\n            // Figure out if the request's method matches.\n            var isMethodExactMatch = req.method === disabledRouteInfo.method;\n            var isMethodImplicitMatch = disabledRouteInfo.method === '' && _.contains(['GET', 'POST', 'PUT', 'DELETE', 'PATCH'], req.method);\n            // If not, then skip this disabled route- it's not a match.\n            if (!isMethodExactMatch && !isMethodImplicitMatch && disabledRouteInfo.method === '*') {\n              return;\n            }\n\n            // Then figure out if the request's url path matches.\n            var isUrlPathMatch = req.path.match(disabledRouteInfo.urlPatternRegExp);\n            return isUrlPathMatch;\n          });//</_.any()>\n\n          // If the session is disabled, then skip running the middleware.\n          if (isSessionDisabled) {\n            return next();\n          }\n\n          configuredSessionMiddleware(req,res,function (err) {\n            if (!err) {\n              return next();\n            }\n            var errMsg = 'Error occurred in session middleware :: ' + util.inspect((err&&err.stack)?err.stack:err, false, null);\n            sails.log.error(errMsg);\n            return res.send(400, errMsg);\n          });\n        };\n      }\n    })(),\n\n\n    // Build configured favicon mwr function.\n    favicon: (function (){\n      var toServeFavicon = require('serve-favicon');\n      var pathToDefaultFavicon = Path.resolve(__dirname,'./default-favicon.ico');\n      var serveFaviconMwr = toServeFavicon(pathToDefaultFavicon);\n      return serveFaviconMwr;\n    })(),\n\n\n    /**\n     * Track request start time as soon as possible\n     *\n     * We also might consider including connect.logger by default\n     * (https://github.com/senchalabs/connect/blob/master/lib/middleware/logger.js)\n     *\n     * Or morgan.\n     */\n    startRequestTimer: !IS_NODE_ENV_PRODUCTION && function startRequestTimer(req, res, next) {\n      req._startTime = new Date();\n      next();\n    },\n\n    cookieParser: (function() {\n      // backwards compatibility for old express.cookieParser config\n      var cookieParser =\n        sails.config.http.cookieParser || sails.config.http.middleware.cookieParser;\n      var sessionSecret = sails.config.session && sails.config.session.secret;\n\n      // If available, Sails uses the configured session secret for signing cookies.\n      if (sessionSecret) {\n        // Ensure secret is a string.  This check happens in the session hook as well,\n        // but sails.config.session.secret may still be provided even if the session hook\n        // is turned off, so to be extra anal we'll check here as well.\n        if (!_.isString(sessionSecret)) {\n          throw new Error('If provided, sails.config.session.secret should be a string.');\n        }\n        return cookieParser && cookieParser(sessionSecret);\n      }\n      // If no session secret was provided in config\n      // (e.g. if session hook is disabled and config/session.js is removed)\n      // then we do not enable signed cookies by providing a cookie secret.\n      // (note that of course signed cookies can still be enabled in a Sails app:\n      // see conceptual docs on disabling the session hook for info)\n      else {\n        return cookieParser && cookieParser();\n      }\n    })(),\n\n    compress: IS_NODE_ENV_PRODUCTION && require('compression')(),\n\n    // Use body parser, if enabled\n    bodyParser: (function() {\n\n      var opts = {};\n      var fn;\n\n      // Handle original bodyParser config:\n      ////////////////////////////////////////////////////////\n      // If a body parser was configured, use it\n      if (sails.config.http.bodyParser) {\n        fn = sails.config.http.bodyParser;\n        return fn(opts);\n      } else if (sails.config.http.bodyParser === false) {\n        // Allow for explicit disabling of bodyParser using traditional\n        // `express.bodyParser` conf\n        return undefined;\n      }\n\n      // Default to built-in bodyParser:\n      fn = require('skipper');\n      return fn(opts);\n\n    })(),\n\n    // Should be installed immediately after the bodyParser- prevents bubbling to\n    // the default error handler which will attempt to use body parameters, which may\n    // cause unexpected issues.\n    //\n    // (included here so it still protects against this edge case if bodyParser\n    // is overridden in userland.  Should probably be phased out at some point,\n    // since it could be accomplished more elegantly- btu for now it's practical.)\n    handleBodyParserError: function handleBodyParserError(err, req, res, next) {\n      var bodyParserFailureErrorMsg = 'Unable to parse HTTP body- error occurred :: ' + util.inspect((err&&err.stack)?err.stack:err, false, null);\n      sails.log.error(bodyParserFailureErrorMsg);\n      if (IS_NODE_ENV_PRODUCTION && sails.config.keepResponseErrors !== true) {\n        return res.send(400);\n      }\n      return res.send(400, bodyParserFailureErrorMsg);\n    },\n\n\n    // Allow simulation of PUT and DELETE HTTP methods for user agents\n    // which don't support it natively (looks for a `_method` param)\n    methodOverride: (function() {\n      if (sails.config.http.methodOverride) {\n        return sails.config.http.methodOverride();\n      }\n    })(),\n\n    // This is the Express router middleware.\n    // When it runs, it matches incoming requests against all of this Sails app's\n    // explicit routes and shadows.\n    router: expressRouterMiddleware,\n\n    // Add powered-by Sails header\n    poweredBy: function xPoweredBy(req, res, next) {\n      res.header('X-Powered-By', 'Sails <sailsjs.org>');\n      next();\n    },\n\n    // 404 and 500 middleware should be attached at the very end\n    // (after `router`, `www`, and `favicon`)\n    404: function handleUnmatchedRequest(req, res, next) {\n\n      // Explicitly ignore error arg to avoid inadvertently\n      // turning this into an error handler\n      sails.emit('router:request:404', req, res);\n    },\n    500: function handleError(err, req, res, next) {\n      sails.emit('router:request:500', err, req, res);\n    }\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/hooks/http/start.js":"/**\n * Module dependencies.\n */\n\nvar async = require('async');\n\n\n\nmodule.exports = function (sails) {\n\n  return function startServer (cb) {\n\n    // Used to warn about possible issues if starting the server is taking a long time\n    var liftAbortTimer;\n    var liftTimeout = sails.config.liftTimeout || 4000;\n    // TODO: pull this defaulting into `defaults`\n    // and also ensure this config is properly documented.\n\n    async.auto({\n\n      // Start Express server\n      start: function (next) {\n\n        var explicitHost = sails.config.explicitHost;\n\n        // If host is explicitly declared, include it in express's listen() call\n        if (explicitHost) {\n          sails.log.verbose('Restricting access to explicit host: '+explicitHost);\n          sails.hooks.http.server.listen(sails.config.port, explicitHost, next);\n        }\n        else {\n          // Listen for error events that may be emitted as the server attempts to start\n          sails.hooks.http.server.on('error', failedToStart);\n          sails.hooks.http.server.listen(sails.config.port, function(err) {\n            // Remove the error listener so future error events emitted by the server\n            // don't get handled by the \"failedToStart\" function below.\n            sails.hooks.http.server.removeListener('error', failedToStart);\n            return next(err);\n          });\n        }\n\n        // Start timer in case this takes suspiciously long...\n        liftAbortTimer = setTimeout(failedToStart, liftTimeout);\n\n        // If the server fails to start because of an error, or if it's just taking\n        // too long, show some troubleshooting notes and bail out.\n        function failedToStart(err) {\n\n          // If this was called because of an actual error, clear the timeout\n          // so failedToStart doesn't get called again.\n          if (err) {\n            clearTimeout(liftAbortTimer);\n          }\n\n          // If sails is exiting already, don't worry about the timer going off.\n          if (sails._exiting) {return;}\n\n          // Figure out if this user is on Windows\n          var isWin = !!process.platform.match(/^win/);\n\n          // If server isn't starting, provide general troubleshooting information,\n          // sharpened with a few simple heuristics:\n          console.log('');\n          if (err) {\n            sails.log.error('Server failed to start.');\n            if (err.code) {\n              sails.log.error('(received error: ' + err.code + ')');\n            }\n          } else {\n            sails.log.error('Server is taking a while to start up (it\\'s been 4 seconds).');\n          }\n\n          sails.log.error();\n          sails.log.error('Troubleshooting tips:');\n          sails.log.error();\n\n          // 0. Just a slow Grunt task\n          if (sails.hooks.grunt && ! (err && err.code === 'EADDRINUSE')) {\n            if (process.env.NODE_ENV === 'production') {\n              sails.log.error(\n                ' -> Do you have a slow Grunt task?  You are running in production mode where, by default, tasks are configured to minify the JavaScript and CSS/LESS files in your assets/ directory.  Sometimes, these processes can be slow, particularly if you have lots of these types of files.'\n              );\n            }\n            else {\n              sails.log.error(\n                ' -> Do you have a slow Grunt task, or lots of assets?'\n              );\n            }\n            sails.log.error();\n          }\n\n          // 1. Unauthorized\n          if (sails.config.port < 1024) {\n            sails.log.error(\n            ' -> Do you have permission to use port ' + sails.config.port + ' on this system?',\n            // Don't mention `sudo` to Windows users-- I hear you guys get touchy about that sort of thing :)\n            (isWin) ? '' : '(you might try `sudo`)'\n            );\n\n            sails.log.error();\n          }\n\n          // 2. Invalid or unauthorized explicitHost configuration.\n          if (explicitHost) {\n            sails.log.error(\n            ' -> You might remove your explicit host configuration and try lifting again (you specified',\n            '`'+explicitHost+'`',\n            '.)');\n\n            sails.log.error();\n          }\n\n          // 3. Something else is running on this port\n          sails.log.error(\n          ' -> Is something else already running on port', sails.config.port,\n          (explicitHost ? (' with hostname ' + explicitHost) : '') + '?'\n          );\n          sails.log.error();\n\n          // 4. invalid explicitHost\n          if (!explicitHost) {\n            sails.log.error(\n            ' -> Are you deploying on a platform that requires an explicit hostname,',\n            'like OpenShift?');\n            sails.log.error(\n            '    (Try setting the `explicitHost` config to the hostname where the server will be accessible.)'\n            );\n            sails.log.error(\n            '    (e.g. `mydomain.com` or `183.24.244.42`)'\n            );\n          }\n          console.log('');\n\n          // Lower Sails to do any necessary cleanup\n          sails.lower(function(){\n            // Exit with a non-zero value to indicate an error\n            process.exit(1);\n            // TODO: For a more graceful shutdown, we should instead consider:\n            // return next(new Error('blah blah'));\n          });\n        }//</failedToStart>\n      },\n\n      verify: ['start', function (next) {\n        var explicitHost = sails.config.explicitHost;\n\n        // Check for port conflicts\n        // Ignore this check if explicit host is set, since other more complicated things might be going on.\n        if( !explicitHost && !sails.hooks.http.server.address() ) {\n          var portBusyErrorMsg = '';\n          portBusyErrorMsg += 'Trying to start server on port ' + sails.config.port + ' but can\\'t...';\n          portBusyErrorMsg += 'Something else is probably running on that port!' + '\\n';\n          portBusyErrorMsg += 'Please disable the other server, or choose a different port and try again.';\n          sails.log.error(portBusyErrorMsg);\n          throw new Error(portBusyErrorMsg);\n          // TODO: For a more graceful shutdown, we should instead consider:\n          // return next(new Error(portBusyErrorMsg));\n        }\n\n        next();\n      }]\n\n    }, function expressListening (err) {\n      clearTimeout(liftAbortTimer);\n      if (err) { return cb(err); }\n\n      // Announce that express is now listening on a port\n      sails.emit('hook:http:listening');\n      return cb();\n    });\n  };\n\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/hooks/http/view.js":"/**\n * Module dependencies\n */\n\nvar util = require('util');\nvar path = require('path');\nvar glob = require('glob');\nvar ExpressView = require('@sailshq/express/lib/view');\nvar expressUtils = require('@sailshq/express/lib/utils');\n\n\n\nvar globPath = function(viewPath) {\n  // return glob.sync(path, {\n  //  nocase: true\n  // });\n  return glob.sync(path.basename(viewPath), {\n    cwd: path.dirname(viewPath),\n    nocase: true\n  });\n};\n\n/**\n * `exists()`\n *\n * Helper function to check existence of the specified path amongst the app's views.\n * @param  {String} viewPath\n * @return {Boolean}\n */\nvar exists = function(viewPath) {\n  return globPath(viewPath).length > 0;\n};\n\n\n/**\n * @constructs {SailsView}\n */\nfunction SailsView (name, options) {\n  ExpressView.call(this, name, options);\n}\nutil.inherits(SailsView, ExpressView);\n\nSailsView.prototype.lookup = function(viewPath) {\n  var viewExt = this.ext;\n  var rootPath = this.root;\n\n  // <path>.<engine>\n  if (!expressUtils.isAbsolute(viewPath)) {\n    viewPath = path.join(rootPath, viewPath);\n  }\n  if (exists(viewPath)) {\n    return viewPath; //return globPath(viewPath)[0];\n  }\n\n  // <path>/index.<engine>\n  viewPath = path.join(path.dirname(viewPath), path.basename(viewPath, viewExt), 'index' + viewExt);\n  if (exists(viewPath)) {\n    return viewPath; //return globPath(path)[0];\n  }\n};\n\n\nmodule.exports = SailsView;\n\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/hooks/logger/ship.js":"/**\n * Draw an ASCII image of a ship\n */\nmodule.exports = function _drawShip(message, log) {\n  log = log || console.log;\n\n  // There are 20 characters before the ship's mast on the 2nd line,\n  // starting from the 'v' (inclusive)\n  var mesageLen = message.length;\n  var numSpaces = 19 - mesageLen;\n  for (var i = 0; i < numSpaces; i++) {\n    message += ' ';\n  }\n\n  return function() {\n    log('');\n    log('               .-..-.');\n    log('');\n    log('   ' + 'Sails   ' + '           ' + '<' + '|' + '    .-..-.');\n    log('   ' + message + ' |\\\\');\n    log('                      /|.\\\\');\n    log('                     / || \\\\');\n    log('                   ,\\'  |\\'  \\\\');\n    log('                .-\\'.-==|/_--\\'');\n    log('                `--\\'-------\\' ');\n    log('   __---___--___---___--___---___--___');\n    log(' ____---___--___---___--___---___--___-__');\n    log('');\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/hooks/pubsub/drink.js":"/**\n * Drink from the firehose.\n */\n\nmodule.exports = function (sails) {\n\n\treturn function subscribeToFirehose (socket) {\n\t\tsails.sockets.join( socket, 'sails_firehose' );\n\t};\n\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/hooks/pubsub/spit.js":"/**\n * Stop drinking from the firehose.\n */\n\nmodule.exports = function (sails) {\n\n\treturn function unsubscribeFromFirehose ( socket ) {\n\t\tsails.sockets.leave(socket, 'sails_firehose');\n\t};\n\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/hooks/pubsub/squirt.js":"/**\n * Squirt the firehose.\n */\n\nmodule.exports = function (sails) {\n\n\treturn function publishToFirehose ( data ) {\n    if (sails.config.environment == 'development') {\n\t\t  sails.sockets.broadcast('sails_firehose', 'firehose', data);\n    }\n\t};\n\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/hooks/request/locals.js":"/**\n * Module dependencies\n */\nvar _ = require('@sailshq/lodash'),\n    util = require('sails-util');\n\n\n/**\n * default locals\n *\n * Always share some basic metadata with views.\n * Roughly analogous to `app.locals` in Express.\n * \n * > Application local variables are provided to all templates rendered\n * > within the application. This is useful for providing helper functions\n * > to templates, as well as app-level data.\n * >\n * > http://expressjs.com/api.html#app.locals\n * \n * @param {Request} req\n * @param {Response} res\n * @api private\n */\n\nmodule.exports = function _mixinLocals(req, res) {\n\n    // TODO:\n    // Actually take advantage of `app.locals`\n    // for this logic.\n\n    // TODO:\n    // we might look at pruning the stuff being\n    // passed in here, to improve the optimizations\n    // of Express's production view cache.\n\n    _.extend(res.locals, {\n        _: _,\n        util: util,\n        session: req.session,\n        req: req,\n        res: res,\n        sails: req._sails\n    });\n\n    // May be deprecated in an upcoming release:\n    res.locals.title = req._sails.config.appName;\n    if (req.options.action) {\n        ' | ' + util.str.capitalize(req.param('action'));\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/hooks/request/metadata.js":"/**\n * Host, port, etc.\n * (fails silently if http or sockets is not enabled)\n *\n * @param {Request} req\n * @param {Response} res\n * @api private\n */\n\nmodule.exports = function _mixinServerMetadata(req, res) {\n\n\t// TODO: try to use `sockets` if `http` is not available\n\t// (currently, this function does not run for socket requests--\n\t// these functions are added in the socket hook.  Eventually,\n\t// it would be better if that logic was normalized here, makes\n\t// us get all DRY or something.)\n\n\t// Access to server port, if available\n  if (req._sails.hooks.http) {\n    var nodeHTTPServer = req._sails.hooks.http.server;\n    var nodeHTTPServerAddress = (nodeHTTPServer && nodeHTTPServer.address && nodeHTTPServer.address()) || {};\n    req.port = req.port || (nodeHTTPServerAddress && nodeHTTPServerAddress.port) || 80;\n  }\n\n  // Set req.port and req.baseUrl using the Host header and req.protocol\n  //\n  // We trust req.protocol to be set by Express. But Express only delivers\n  // the host devoid of a port, so we have to delve into HTTP headers to pick\n  // out the host port ourselves.\n  var trustProxy = req.app && req.app.get('trust proxy') || false;\n  var host;\n  if (trustProxy) {\n    host = (req.header && req.header('X-Forwarded-Host') || '').split(/,\\s*/)[0];\n  }\n  host = host || (req.header && req.header('Host')) || 'could.not.determine.host';\n\n  var protocol = req.protocol;\n  var defaultPort;\n  if (protocol == 'https' || protocol == 'wss') {\n    defaultPort = 443;\n  } else {\n    defaultPort = 80;\n  }\n  var hostPort = parseInt(host.split(/:/)[1], 10) || defaultPort;\n\n  req.port = hostPort;\n  req.baseUrl = req.protocol + '://' + host;\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/hooks/request/params.all.js":"/**\n * Module dependencies\n */\nvar _ = require('@sailshq/lodash');\nvar defaultsDeep = require('merge-defaults');\n\n\n\n/**\n * _mixinReqParamsAll\n *\n * Mixes in `req.params.all()`, a convenience method to grab all parameters,\n * whether they're in the path (req.params), query string (req.query),\n * or request body (req.body).\n *\n * Note: this has to be determined per-route, not per request,\n * in order to refer to the proper route/path parameters.\n * e.g. if a request comes in and matches `GET /about` AND `GET /:username`\n * then the set of all params varies depending on which handler is being run.\n * Now that said, since changing the implementation to avoid precalculating\n * unless allParams is actually called, this may not necessarily need to be\n * the case anymore. More exhaustive testing would be required to make that change.\n *\n *\n * @param {Request} req\n * @param {Response} res\n * @api private\n */\n\nmodule.exports = function _mixinReqParamsAll(req, res) {\n\n  // Add `req.allParams()` method.\n  req.allParams = function () {\n    // Combines parameters from the query string, and encoded request body\n    // to compose a monolithic object of named parameters, irrespective of source\n    var queryParams = _.cloneDeep(req.query) || {};\n    var bodyParams = _.cloneDeep(req.body) || {};\n    var allParams = {};\n    defaultsDeep(allParams, queryParams);\n    defaultsDeep(allParams, bodyParams);\n\n\n    // Mixin route params, as long as they have defined values\n    _.each(Object.keys(req.params), function(paramName) {\n      if (allParams[paramName] || !_.isUndefined(req.params[paramName])) {\n        allParams[paramName] = allParams[paramName] || req.params[paramName];\n      }\n    });\n    return allParams;\n  };\n\n  /////////////////////////////////////////////////////////////////////////////////////////////////////////\n  // Note:\n  // req.params.all() will be deprecated in Sails v1.0 in favor of `req.allParams()`.\n  /////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  // Define a new non-enumerable property: req.params.all()\n  // and make it a synonym to `req.allParams()`\n  // (but only if `req.params.all` doesn't already exist!)\n  if (!req.params.all) {\n    Object.defineProperty(req.params, 'all', {\n      value: req.allParams\n    });\n  }\n\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/hooks/request/qualifiers.js":"/**\n * Module dependencies\n */\n\nvar STRINGFILE = require('sails-stringfile');\n\n\n\n/**\n * Mix in convenience flags about this request\n *\n * @param {Request} req\n * @param {Response} res\n * @api private\n */\n\nmodule.exports = function _mixinReqQualifiers(req, res) {\n  var accept = req.get('Accept') || '';\n\n  // Flag indicating whether HTML was explicitly mentioned in the Accepts header\n  req.explicitlyAcceptsHTML = (accept.indexOf('html') !== -1);\n\n  // Flag indicating whether a request would like to receive a JSON response\n  //\n  // This qualification is determined based on a handful of heuristics, including:\n  //  if this looks like an AJAX request\n  //  if this is a virtual request from a socket\n  //  if this request DOESN'T explicitly want HTML\n  //  if this request has a \"json\" content-type AND ALSO has its \"Accept\" header set\n  //  if this request has the option \"wantsJSON\" set\n  req.wantsJSON = req.xhr;\n  req.wantsJSON = req.wantsJSON || req.isSocket;\n  req.wantsJSON = req.wantsJSON || !req.explicitlyAcceptsHTML;\n  req.wantsJSON = req.wantsJSON || (req.is('json') && req.get('Accept'));\n  req.wantsJSON = req.wantsJSON || req.options.wantsJSON;\n\n\n  // Deprecated properties\n  bindReqDeprecationNotice(req, 'isJson');\n  bindReqDeprecationNotice(req, 'isAjax');\n  bindResDeprecationNotice(res, 'viewExists');\n};\n\n\n\n/**\n * Bind deprecation notices for `req.*` properties from 0.8.x,\n * but only in development env, and only if the property\n * doesn't already exist (i.e. in case a user-defined\n * hook bound it on the `req` object.)\n *\n * @param  {Request} req\n * @param  {String} key\n */\nfunction bindReqDeprecationNotice(req, key) {\n  if (process.env.NODE_ENV === 'production' || req[key]) return;\n\n  // Attach a getter\n  Object.defineProperty(req, key, {\n    value: function showDeprecationNotice() {\n      var e = STRINGFILE.get('upgrade.req.' + key);\n      throw new Error(e);\n    }\n  });\n}\n\n\n/**\n * Bind deprecation notices for `res.*` properties from 0.8.x,\n * but only in development env, and only if the property\n * doesn't already exist (i.e. in case a user-defined\n * hook bound it on the `res` object.)\n *\n * @param  {Response} res\n * @param  {String} key\n */\nfunction bindResDeprecationNotice(res, key) {\n  if (process.env.NODE_ENV === 'production' || res[key]) return;\n\n  // Attach a getter\n  Object.defineProperty(res, key, {\n    value: function showDeprecationNotice() {\n      var e = STRINGFILE.get('upgrade.res.' + key);\n      throw new Error(e);\n    }\n  });\n}\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails-stringfile/index.js":"/**\n * Module dependencies\n */\nvar _ = require('lodash')\n\t, util = require('util')\n\t, deprecation = require('./deprecation')\n\t, links = require('./links')\n\t, gettext = require('./gettext');\n\n\n\nmodule.exports = gettext;\n_.extend(gettext, {\n\tget: gettext,\n\tlogDeprecationNotice: deprecation.logDeprecationNotice,\n\tlogUpgradeNotice: deprecation.logUpgradeNotice,\n\tlogMoreInfoLink: links.logMoreInfoLink,\n\tlogLinks: links.logLinks,\n\tterminalLinkHelp: links.terminalLinkHelp\n});","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails-stringfile/node_modules/lodash/dist/lodash.js":"/**\n * @license\n * Lo-Dash 2.4.2 (Custom Build) <https://lodash.com/>\n * Build: `lodash modern -o ./dist/lodash.js`\n * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <https://lodash.com/license>\n */\n;(function() {\n\n  /** Used as a safe reference for `undefined` in pre ES5 environments */\n  var undefined;\n\n  /** Used to pool arrays and objects used internally */\n  var arrayPool = [],\n      objectPool = [];\n\n  /** Used to generate unique IDs */\n  var idCounter = 0;\n\n  /** Used to prefix keys to avoid issues with `__proto__` and properties on `Object.prototype` */\n  var keyPrefix = +new Date + '';\n\n  /** Used as the size when optimizations are enabled for large arrays */\n  var largeArraySize = 75;\n\n  /** Used as the max size of the `arrayPool` and `objectPool` */\n  var maxPoolSize = 40;\n\n  /** Used to detect and test whitespace */\n  var whitespace = (\n    // whitespace\n    ' \\t\\x0B\\f\\xA0\\ufeff' +\n\n    // line terminators\n    '\\n\\r\\u2028\\u2029' +\n\n    // unicode category \"Zs\" space separators\n    '\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000'\n  );\n\n  /** Used to match empty string literals in compiled template source */\n  var reEmptyStringLeading = /\\b__p \\+= '';/g,\n      reEmptyStringMiddle = /\\b(__p \\+=) '' \\+/g,\n      reEmptyStringTrailing = /(__e\\(.*?\\)|\\b__t\\)) \\+\\n'';/g;\n\n  /**\n   * Used to match ES6 template delimiters\n   * http://people.mozilla.org/~jorendorff/es6-draft.html#sec-literals-string-literals\n   */\n  var reEsTemplate = /\\$\\{([^\\\\}]*(?:\\\\.[^\\\\}]*)*)\\}/g;\n\n  /** Used to match regexp flags from their coerced string values */\n  var reFlags = /\\w*$/;\n\n  /** Used to detected named functions */\n  var reFuncName = /^\\s*function[ \\n\\r\\t]+\\w/;\n\n  /** Used to match \"interpolate\" template delimiters */\n  var reInterpolate = /<%=([\\s\\S]+?)%>/g;\n\n  /** Used to match leading whitespace and zeros to be removed */\n  var reLeadingSpacesAndZeros = RegExp('^[' + whitespace + ']*0+(?=.$)');\n\n  /** Used to ensure capturing order of template delimiters */\n  var reNoMatch = /($^)/;\n\n  /** Used to detect functions containing a `this` reference */\n  var reThis = /\\bthis\\b/;\n\n  /** Used to match unescaped characters in compiled string literals */\n  var reUnescapedString = /['\\n\\r\\t\\u2028\\u2029\\\\]/g;\n\n  /** Used to assign default `context` object properties */\n  var contextProps = [\n    'Array', 'Boolean', 'Date', 'Function', 'Math', 'Number', 'Object',\n    'RegExp', 'String', '_', 'attachEvent', 'clearTimeout', 'isFinite', 'isNaN',\n    'parseInt', 'setTimeout'\n  ];\n\n  /** Used to make template sourceURLs easier to identify */\n  var templateCounter = 0;\n\n  /** `Object#toString` result shortcuts */\n  var argsClass = '[object Arguments]',\n      arrayClass = '[object Array]',\n      boolClass = '[object Boolean]',\n      dateClass = '[object Date]',\n      funcClass = '[object Function]',\n      numberClass = '[object Number]',\n      objectClass = '[object Object]',\n      regexpClass = '[object RegExp]',\n      stringClass = '[object String]';\n\n  /** Used to identify object classifications that `_.clone` supports */\n  var cloneableClasses = {};\n  cloneableClasses[funcClass] = false;\n  cloneableClasses[argsClass] = cloneableClasses[arrayClass] =\n  cloneableClasses[boolClass] = cloneableClasses[dateClass] =\n  cloneableClasses[numberClass] = cloneableClasses[objectClass] =\n  cloneableClasses[regexpClass] = cloneableClasses[stringClass] = true;\n\n  /** Used as an internal `_.debounce` options object */\n  var debounceOptions = {\n    'leading': false,\n    'maxWait': 0,\n    'trailing': false\n  };\n\n  /** Used as the property descriptor for `__bindData__` */\n  var descriptor = {\n    'configurable': false,\n    'enumerable': false,\n    'value': null,\n    'writable': false\n  };\n\n  /** Used to determine if values are of the language type Object */\n  var objectTypes = {\n    'boolean': false,\n    'function': true,\n    'object': true,\n    'number': false,\n    'string': false,\n    'undefined': false\n  };\n\n  /** Used to escape characters for inclusion in compiled string literals */\n  var stringEscapes = {\n    '\\\\': '\\\\',\n    \"'\": \"'\",\n    '\\n': 'n',\n    '\\r': 'r',\n    '\\t': 't',\n    '\\u2028': 'u2028',\n    '\\u2029': 'u2029'\n  };\n\n  /** Used as a reference to the global object */\n  var root = (objectTypes[typeof window] && window) || this;\n\n  /** Detect free variable `exports` */\n  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;\n\n  /** Detect free variable `module` */\n  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;\n\n  /** Detect the popular CommonJS extension `module.exports` */\n  var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;\n\n  /** Detect free variable `global` from Node.js or Browserified code and use it as `root` */\n  var freeGlobal = objectTypes[typeof global] && global;\n  if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {\n    root = freeGlobal;\n  }\n\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * The base implementation of `_.indexOf` without support for binary searches\n   * or `fromIndex` constraints.\n   *\n   * @private\n   * @param {Array} array The array to search.\n   * @param {*} value The value to search for.\n   * @param {number} [fromIndex=0] The index to search from.\n   * @returns {number} Returns the index of the matched value or `-1`.\n   */\n  function baseIndexOf(array, value, fromIndex) {\n    var index = (fromIndex || 0) - 1,\n        length = array ? array.length : 0;\n\n    while (++index < length) {\n      if (array[index] === value) {\n        return index;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * An implementation of `_.contains` for cache objects that mimics the return\n   * signature of `_.indexOf` by returning `0` if the value is found, else `-1`.\n   *\n   * @private\n   * @param {Object} cache The cache object to inspect.\n   * @param {*} value The value to search for.\n   * @returns {number} Returns `0` if `value` is found, else `-1`.\n   */\n  function cacheIndexOf(cache, value) {\n    var type = typeof value;\n    cache = cache.cache;\n\n    if (type == 'boolean' || value == null) {\n      return cache[value] ? 0 : -1;\n    }\n    if (type != 'number' && type != 'string') {\n      type = 'object';\n    }\n    var key = type == 'number' ? value : keyPrefix + value;\n    cache = (cache = cache[type]) && cache[key];\n\n    return type == 'object'\n      ? (cache && baseIndexOf(cache, value) > -1 ? 0 : -1)\n      : (cache ? 0 : -1);\n  }\n\n  /**\n   * Adds a given value to the corresponding cache object.\n   *\n   * @private\n   * @param {*} value The value to add to the cache.\n   */\n  function cachePush(value) {\n    var cache = this.cache,\n        type = typeof value;\n\n    if (type == 'boolean' || value == null) {\n      cache[value] = true;\n    } else {\n      if (type != 'number' && type != 'string') {\n        type = 'object';\n      }\n      var key = type == 'number' ? value : keyPrefix + value,\n          typeCache = cache[type] || (cache[type] = {});\n\n      if (type == 'object') {\n        (typeCache[key] || (typeCache[key] = [])).push(value);\n      } else {\n        typeCache[key] = true;\n      }\n    }\n  }\n\n  /**\n   * Used by `_.max` and `_.min` as the default callback when a given\n   * collection is a string value.\n   *\n   * @private\n   * @param {string} value The character to inspect.\n   * @returns {number} Returns the code unit of given character.\n   */\n  function charAtCallback(value) {\n    return value.charCodeAt(0);\n  }\n\n  /**\n   * Used by `sortBy` to compare transformed `collection` elements, stable sorting\n   * them in ascending order.\n   *\n   * @private\n   * @param {Object} a The object to compare to `b`.\n   * @param {Object} b The object to compare to `a`.\n   * @returns {number} Returns the sort order indicator of `1` or `-1`.\n   */\n  function compareAscending(a, b) {\n    var ac = a.criteria,\n        bc = b.criteria,\n        index = -1,\n        length = ac.length;\n\n    while (++index < length) {\n      var value = ac[index],\n          other = bc[index];\n\n      if (value !== other) {\n        if (value > other || typeof value == 'undefined') {\n          return 1;\n        }\n        if (value < other || typeof other == 'undefined') {\n          return -1;\n        }\n      }\n    }\n    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications\n    // that causes it, under certain circumstances, to return the same value for\n    // `a` and `b`. See https://github.com/jashkenas/underscore/pull/1247\n    //\n    // This also ensures a stable sort in V8 and other engines.\n    // See http://code.google.com/p/v8/issues/detail?id=90\n    return a.index - b.index;\n  }\n\n  /**\n   * Creates a cache object to optimize linear searches of large arrays.\n   *\n   * @private\n   * @param {Array} [array=[]] The array to search.\n   * @returns {null|Object} Returns the cache object or `null` if caching should not be used.\n   */\n  function createCache(array) {\n    var index = -1,\n        length = array.length,\n        first = array[0],\n        mid = array[(length / 2) | 0],\n        last = array[length - 1];\n\n    if (first && typeof first == 'object' &&\n        mid && typeof mid == 'object' && last && typeof last == 'object') {\n      return false;\n    }\n    var cache = getObject();\n    cache['false'] = cache['null'] = cache['true'] = cache['undefined'] = false;\n\n    var result = getObject();\n    result.array = array;\n    result.cache = cache;\n    result.push = cachePush;\n\n    while (++index < length) {\n      result.push(array[index]);\n    }\n    return result;\n  }\n\n  /**\n   * Used by `template` to escape characters for inclusion in compiled\n   * string literals.\n   *\n   * @private\n   * @param {string} match The matched character to escape.\n   * @returns {string} Returns the escaped character.\n   */\n  function escapeStringChar(match) {\n    return '\\\\' + stringEscapes[match];\n  }\n\n  /**\n   * Gets an array from the array pool or creates a new one if the pool is empty.\n   *\n   * @private\n   * @returns {Array} The array from the pool.\n   */\n  function getArray() {\n    return arrayPool.pop() || [];\n  }\n\n  /**\n   * Gets an object from the object pool or creates a new one if the pool is empty.\n   *\n   * @private\n   * @returns {Object} The object from the pool.\n   */\n  function getObject() {\n    return objectPool.pop() || {\n      'array': null,\n      'cache': null,\n      'criteria': null,\n      'false': false,\n      'index': 0,\n      'null': false,\n      'number': null,\n      'object': null,\n      'push': null,\n      'string': null,\n      'true': false,\n      'undefined': false,\n      'value': null\n    };\n  }\n\n  /**\n   * Releases the given array back to the array pool.\n   *\n   * @private\n   * @param {Array} [array] The array to release.\n   */\n  function releaseArray(array) {\n    array.length = 0;\n    if (arrayPool.length < maxPoolSize) {\n      arrayPool.push(array);\n    }\n  }\n\n  /**\n   * Releases the given object back to the object pool.\n   *\n   * @private\n   * @param {Object} [object] The object to release.\n   */\n  function releaseObject(object) {\n    var cache = object.cache;\n    if (cache) {\n      releaseObject(cache);\n    }\n    object.array = object.cache = object.criteria = object.object = object.number = object.string = object.value = null;\n    if (objectPool.length < maxPoolSize) {\n      objectPool.push(object);\n    }\n  }\n\n  /**\n   * Slices the `collection` from the `start` index up to, but not including,\n   * the `end` index.\n   *\n   * Note: This function is used instead of `Array#slice` to support node lists\n   * in IE < 9 and to ensure dense arrays are returned.\n   *\n   * @private\n   * @param {Array|Object|string} collection The collection to slice.\n   * @param {number} start The start index.\n   * @param {number} end The end index.\n   * @returns {Array} Returns the new array.\n   */\n  function slice(array, start, end) {\n    start || (start = 0);\n    if (typeof end == 'undefined') {\n      end = array ? array.length : 0;\n    }\n    var index = -1,\n        length = end - start || 0,\n        result = Array(length < 0 ? 0 : length);\n\n    while (++index < length) {\n      result[index] = array[start + index];\n    }\n    return result;\n  }\n\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * Create a new `lodash` function using the given context object.\n   *\n   * @static\n   * @memberOf _\n   * @category Utilities\n   * @param {Object} [context=root] The context object.\n   * @returns {Function} Returns the `lodash` function.\n   */\n  function runInContext(context) {\n    // Avoid issues with some ES3 environments that attempt to use values, named\n    // after built-in constructors like `Object`, for the creation of literals.\n    // ES5 clears this up by stating that literals must use built-in constructors.\n    // See http://es5.github.io/#x11.1.5.\n    context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;\n\n    /** Native constructor references */\n    var Array = context.Array,\n        Boolean = context.Boolean,\n        Date = context.Date,\n        Function = context.Function,\n        Math = context.Math,\n        Number = context.Number,\n        Object = context.Object,\n        RegExp = context.RegExp,\n        String = context.String,\n        TypeError = context.TypeError;\n\n    /**\n     * Used for `Array` method references.\n     *\n     * Normally `Array.prototype` would suffice, however, using an array literal\n     * avoids issues in Narwhal.\n     */\n    var arrayRef = [];\n\n    /** Used for native method references */\n    var objectProto = Object.prototype;\n\n    /** Used to restore the original `_` reference in `noConflict` */\n    var oldDash = context._;\n\n    /** Used to resolve the internal [[Class]] of values */\n    var toString = objectProto.toString;\n\n    /** Used to detect if a method is native */\n    var reNative = RegExp('^' +\n      String(toString)\n        .replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')\n        .replace(/toString| for [^\\]]+/g, '.*?') + '$'\n    );\n\n    /** Native method shortcuts */\n    var ceil = Math.ceil,\n        clearTimeout = context.clearTimeout,\n        floor = Math.floor,\n        fnToString = Function.prototype.toString,\n        getPrototypeOf = isNative(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf,\n        hasOwnProperty = objectProto.hasOwnProperty,\n        push = arrayRef.push,\n        setTimeout = context.setTimeout,\n        splice = arrayRef.splice,\n        unshift = arrayRef.unshift;\n\n    /** Used to set meta data on functions */\n    var defineProperty = (function() {\n      // IE 8 only accepts DOM elements\n      try {\n        var o = {},\n            func = isNative(func = Object.defineProperty) && func,\n            result = func(o, o, o) && func;\n      } catch(e) { }\n      return result;\n    }());\n\n    /* Native method shortcuts for methods with the same name as other `lodash` methods */\n    var nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate,\n        nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray,\n        nativeIsFinite = context.isFinite,\n        nativeIsNaN = context.isNaN,\n        nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys,\n        nativeMax = Math.max,\n        nativeMin = Math.min,\n        nativeParseInt = context.parseInt,\n        nativeRandom = Math.random;\n\n    /** Used to lookup a built-in constructor by [[Class]] */\n    var ctorByClass = {};\n    ctorByClass[arrayClass] = Array;\n    ctorByClass[boolClass] = Boolean;\n    ctorByClass[dateClass] = Date;\n    ctorByClass[funcClass] = Function;\n    ctorByClass[objectClass] = Object;\n    ctorByClass[numberClass] = Number;\n    ctorByClass[regexpClass] = RegExp;\n    ctorByClass[stringClass] = String;\n\n    /*--------------------------------------------------------------------------*/\n\n    /**\n     * Creates a `lodash` object which wraps the given value to enable intuitive\n     * method chaining.\n     *\n     * In addition to Lo-Dash methods, wrappers also have the following `Array` methods:\n     * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`, `splice`,\n     * and `unshift`\n     *\n     * Chaining is supported in custom builds as long as the `value` method is\n     * implicitly or explicitly included in the build.\n     *\n     * The chainable wrapper functions are:\n     * `after`, `assign`, `bind`, `bindAll`, `bindKey`, `chain`, `compact`,\n     * `compose`, `concat`, `countBy`, `create`, `createCallback`, `curry`,\n     * `debounce`, `defaults`, `defer`, `delay`, `difference`, `filter`, `flatten`,\n     * `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`,\n     * `functions`, `groupBy`, `indexBy`, `initial`, `intersection`, `invert`,\n     * `invoke`, `keys`, `map`, `max`, `memoize`, `merge`, `min`, `object`, `omit`,\n     * `once`, `pairs`, `partial`, `partialRight`, `pick`, `pluck`, `pull`, `push`,\n     * `range`, `reject`, `remove`, `rest`, `reverse`, `shuffle`, `slice`, `sort`,\n     * `sortBy`, `splice`, `tap`, `throttle`, `times`, `toArray`, `transform`,\n     * `union`, `uniq`, `unshift`, `unzip`, `values`, `where`, `without`, `wrap`,\n     * and `zip`\n     *\n     * The non-chainable wrapper functions are:\n     * `clone`, `cloneDeep`, `contains`, `escape`, `every`, `find`, `findIndex`,\n     * `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `has`, `identity`,\n     * `indexOf`, `isArguments`, `isArray`, `isBoolean`, `isDate`, `isElement`,\n     * `isEmpty`, `isEqual`, `isFinite`, `isFunction`, `isNaN`, `isNull`, `isNumber`,\n     * `isObject`, `isPlainObject`, `isRegExp`, `isString`, `isUndefined`, `join`,\n     * `lastIndexOf`, `mixin`, `noConflict`, `parseInt`, `pop`, `random`, `reduce`,\n     * `reduceRight`, `result`, `shift`, `size`, `some`, `sortedIndex`, `runInContext`,\n     * `template`, `unescape`, `uniqueId`, and `value`\n     *\n     * The wrapper functions `first` and `last` return wrapped values when `n` is\n     * provided, otherwise they return unwrapped values.\n     *\n     * Explicit chaining can be enabled by using the `_.chain` method.\n     *\n     * @name _\n     * @constructor\n     * @category Chaining\n     * @param {*} value The value to wrap in a `lodash` instance.\n     * @returns {Object} Returns a `lodash` instance.\n     * @example\n     *\n     * var wrapped = _([1, 2, 3]);\n     *\n     * // returns an unwrapped value\n     * wrapped.reduce(function(sum, num) {\n     *   return sum + num;\n     * });\n     * // => 6\n     *\n     * // returns a wrapped value\n     * var squares = wrapped.map(function(num) {\n     *   return num * num;\n     * });\n     *\n     * _.isArray(squares);\n     * // => false\n     *\n     * _.isArray(squares.value());\n     * // => true\n     */\n    function lodash(value) {\n      // don't wrap if already wrapped, even if wrapped by a different `lodash` constructor\n      return (value && typeof value == 'object' && !isArray(value) && hasOwnProperty.call(value, '__wrapped__'))\n       ? value\n       : new lodashWrapper(value);\n    }\n\n    /**\n     * A fast path for creating `lodash` wrapper objects.\n     *\n     * @private\n     * @param {*} value The value to wrap in a `lodash` instance.\n     * @param {boolean} chainAll A flag to enable chaining for all methods\n     * @returns {Object} Returns a `lodash` instance.\n     */\n    function lodashWrapper(value, chainAll) {\n      this.__chain__ = !!chainAll;\n      this.__wrapped__ = value;\n    }\n    // ensure `new lodashWrapper` is an instance of `lodash`\n    lodashWrapper.prototype = lodash.prototype;\n\n    /**\n     * An object used to flag environments features.\n     *\n     * @static\n     * @memberOf _\n     * @type Object\n     */\n    var support = lodash.support = {};\n\n    /**\n     * Detect if functions can be decompiled by `Function#toString`\n     * (all but PS3 and older Opera mobile browsers & avoided in Windows 8 apps).\n     *\n     * @memberOf _.support\n     * @type boolean\n     */\n    support.funcDecomp = !isNative(context.WinRTError) && reThis.test(runInContext);\n\n    /**\n     * Detect if `Function#name` is supported (all but IE).\n     *\n     * @memberOf _.support\n     * @type boolean\n     */\n    support.funcNames = typeof Function.name == 'string';\n\n    /**\n     * By default, the template delimiters used by Lo-Dash are similar to those in\n     * embedded Ruby (ERB). Change the following template settings to use alternative\n     * delimiters.\n     *\n     * @static\n     * @memberOf _\n     * @type Object\n     */\n    lodash.templateSettings = {\n\n      /**\n       * Used to detect `data` property values to be HTML-escaped.\n       *\n       * @memberOf _.templateSettings\n       * @type RegExp\n       */\n      'escape': /<%-([\\s\\S]+?)%>/g,\n\n      /**\n       * Used to detect code to be evaluated.\n       *\n       * @memberOf _.templateSettings\n       * @type RegExp\n       */\n      'evaluate': /<%([\\s\\S]+?)%>/g,\n\n      /**\n       * Used to detect `data` property values to inject.\n       *\n       * @memberOf _.templateSettings\n       * @type RegExp\n       */\n      'interpolate': reInterpolate,\n\n      /**\n       * Used to reference the data object in the template text.\n       *\n       * @memberOf _.templateSettings\n       * @type string\n       */\n      'variable': '',\n\n      /**\n       * Used to import variables into the compiled template.\n       *\n       * @memberOf _.templateSettings\n       * @type Object\n       */\n      'imports': {\n\n        /**\n         * A reference to the `lodash` function.\n         *\n         * @memberOf _.templateSettings.imports\n         * @type Function\n         */\n        '_': lodash\n      }\n    };\n\n    /*--------------------------------------------------------------------------*/\n\n    /**\n     * The base implementation of `_.bind` that creates the bound function and\n     * sets its meta data.\n     *\n     * @private\n     * @param {Array} bindData The bind data array.\n     * @returns {Function} Returns the new bound function.\n     */\n    function baseBind(bindData) {\n      var func = bindData[0],\n          partialArgs = bindData[2],\n          thisArg = bindData[4];\n\n      function bound() {\n        // `Function#bind` spec\n        // http://es5.github.io/#x15.3.4.5\n        if (partialArgs) {\n          // avoid `arguments` object deoptimizations by using `slice` instead\n          // of `Array.prototype.slice.call` and not assigning `arguments` to a\n          // variable as a ternary expression\n          var args = slice(partialArgs);\n          push.apply(args, arguments);\n        }\n        // mimic the constructor's `return` behavior\n        // http://es5.github.io/#x13.2.2\n        if (this instanceof bound) {\n          // ensure `new bound` is an instance of `func`\n          var thisBinding = baseCreate(func.prototype),\n              result = func.apply(thisBinding, args || arguments);\n          return isObject(result) ? result : thisBinding;\n        }\n        return func.apply(thisArg, args || arguments);\n      }\n      setBindData(bound, bindData);\n      return bound;\n    }\n\n    /**\n     * The base implementation of `_.clone` without argument juggling or support\n     * for `thisArg` binding.\n     *\n     * @private\n     * @param {*} value The value to clone.\n     * @param {boolean} [isDeep=false] Specify a deep clone.\n     * @param {Function} [callback] The function to customize cloning values.\n     * @param {Array} [stackA=[]] Tracks traversed source objects.\n     * @param {Array} [stackB=[]] Associates clones with source counterparts.\n     * @returns {*} Returns the cloned value.\n     */\n    function baseClone(value, isDeep, callback, stackA, stackB) {\n      if (callback) {\n        var result = callback(value);\n        if (typeof result != 'undefined') {\n          return result;\n        }\n      }\n      // inspect [[Class]]\n      var isObj = isObject(value);\n      if (isObj) {\n        var className = toString.call(value);\n        if (!cloneableClasses[className]) {\n          return value;\n        }\n        var ctor = ctorByClass[className];\n        switch (className) {\n          case boolClass:\n          case dateClass:\n            return new ctor(+value);\n\n          case numberClass:\n          case stringClass:\n            return new ctor(value);\n\n          case regexpClass:\n            result = ctor(value.source, reFlags.exec(value));\n            result.lastIndex = value.lastIndex;\n            return result;\n        }\n      } else {\n        return value;\n      }\n      var isArr = isArray(value);\n      if (isDeep) {\n        // check for circular references and return corresponding clone\n        var initedStack = !stackA;\n        stackA || (stackA = getArray());\n        stackB || (stackB = getArray());\n\n        var length = stackA.length;\n        while (length--) {\n          if (stackA[length] == value) {\n            return stackB[length];\n          }\n        }\n        result = isArr ? ctor(value.length) : {};\n      }\n      else {\n        result = isArr ? slice(value) : assign({}, value);\n      }\n      // add array properties assigned by `RegExp#exec`\n      if (isArr) {\n        if (hasOwnProperty.call(value, 'index')) {\n          result.index = value.index;\n        }\n        if (hasOwnProperty.call(value, 'input')) {\n          result.input = value.input;\n        }\n      }\n      // exit for shallow clone\n      if (!isDeep) {\n        return result;\n      }\n      // add the source value to the stack of traversed objects\n      // and associate it with its clone\n      stackA.push(value);\n      stackB.push(result);\n\n      // recursively populate clone (susceptible to call stack limits)\n      (isArr ? forEach : forOwn)(value, function(objValue, key) {\n        result[key] = baseClone(objValue, isDeep, callback, stackA, stackB);\n      });\n\n      if (initedStack) {\n        releaseArray(stackA);\n        releaseArray(stackB);\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.create` without support for assigning\n     * properties to the created object.\n     *\n     * @private\n     * @param {Object} prototype The object to inherit from.\n     * @returns {Object} Returns the new object.\n     */\n    function baseCreate(prototype, properties) {\n      return isObject(prototype) ? nativeCreate(prototype) : {};\n    }\n    // fallback for browsers without `Object.create`\n    if (!nativeCreate) {\n      baseCreate = (function() {\n        function Object() {}\n        return function(prototype) {\n          if (isObject(prototype)) {\n            Object.prototype = prototype;\n            var result = new Object;\n            Object.prototype = null;\n          }\n          return result || context.Object();\n        };\n      }());\n    }\n\n    /**\n     * The base implementation of `_.createCallback` without support for creating\n     * \"_.pluck\" or \"_.where\" style callbacks.\n     *\n     * @private\n     * @param {*} [func=identity] The value to convert to a callback.\n     * @param {*} [thisArg] The `this` binding of the created callback.\n     * @param {number} [argCount] The number of arguments the callback accepts.\n     * @returns {Function} Returns a callback function.\n     */\n    function baseCreateCallback(func, thisArg, argCount) {\n      if (typeof func != 'function') {\n        return identity;\n      }\n      // exit early for no `thisArg` or already bound by `Function#bind`\n      if (typeof thisArg == 'undefined' || !('prototype' in func)) {\n        return func;\n      }\n      var bindData = func.__bindData__;\n      if (typeof bindData == 'undefined') {\n        if (support.funcNames) {\n          bindData = !func.name;\n        }\n        bindData = bindData || !support.funcDecomp;\n        if (!bindData) {\n          var source = fnToString.call(func);\n          if (!support.funcNames) {\n            bindData = !reFuncName.test(source);\n          }\n          if (!bindData) {\n            // checks if `func` references the `this` keyword and stores the result\n            bindData = reThis.test(source);\n            setBindData(func, bindData);\n          }\n        }\n      }\n      // exit early if there are no `this` references or `func` is bound\n      if (bindData === false || (bindData !== true && bindData[1] & 1)) {\n        return func;\n      }\n      switch (argCount) {\n        case 1: return function(value) {\n          return func.call(thisArg, value);\n        };\n        case 2: return function(a, b) {\n          return func.call(thisArg, a, b);\n        };\n        case 3: return function(value, index, collection) {\n          return func.call(thisArg, value, index, collection);\n        };\n        case 4: return function(accumulator, value, index, collection) {\n          return func.call(thisArg, accumulator, value, index, collection);\n        };\n      }\n      return bind(func, thisArg);\n    }\n\n    /**\n     * The base implementation of `createWrapper` that creates the wrapper and\n     * sets its meta data.\n     *\n     * @private\n     * @param {Array} bindData The bind data array.\n     * @returns {Function} Returns the new function.\n     */\n    function baseCreateWrapper(bindData) {\n      var func = bindData[0],\n          bitmask = bindData[1],\n          partialArgs = bindData[2],\n          partialRightArgs = bindData[3],\n          thisArg = bindData[4],\n          arity = bindData[5];\n\n      var isBind = bitmask & 1,\n          isBindKey = bitmask & 2,\n          isCurry = bitmask & 4,\n          isCurryBound = bitmask & 8,\n          key = func;\n\n      function bound() {\n        var thisBinding = isBind ? thisArg : this;\n        if (partialArgs) {\n          var args = slice(partialArgs);\n          push.apply(args, arguments);\n        }\n        if (partialRightArgs || isCurry) {\n          args || (args = slice(arguments));\n          if (partialRightArgs) {\n            push.apply(args, partialRightArgs);\n          }\n          if (isCurry && args.length < arity) {\n            bitmask |= 16 & ~32;\n            return baseCreateWrapper([func, (isCurryBound ? bitmask : bitmask & ~3), args, null, thisArg, arity]);\n          }\n        }\n        args || (args = arguments);\n        if (isBindKey) {\n          func = thisBinding[key];\n        }\n        if (this instanceof bound) {\n          thisBinding = baseCreate(func.prototype);\n          var result = func.apply(thisBinding, args);\n          return isObject(result) ? result : thisBinding;\n        }\n        return func.apply(thisBinding, args);\n      }\n      setBindData(bound, bindData);\n      return bound;\n    }\n\n    /**\n     * The base implementation of `_.difference` that accepts a single array\n     * of values to exclude.\n     *\n     * @private\n     * @param {Array} array The array to process.\n     * @param {Array} [values] The array of values to exclude.\n     * @returns {Array} Returns a new array of filtered values.\n     */\n    function baseDifference(array, values) {\n      var index = -1,\n          indexOf = getIndexOf(),\n          length = array ? array.length : 0,\n          isLarge = length >= largeArraySize && indexOf === baseIndexOf,\n          result = [];\n\n      if (isLarge) {\n        var cache = createCache(values);\n        if (cache) {\n          indexOf = cacheIndexOf;\n          values = cache;\n        } else {\n          isLarge = false;\n        }\n      }\n      while (++index < length) {\n        var value = array[index];\n        if (indexOf(values, value) < 0) {\n          result.push(value);\n        }\n      }\n      if (isLarge) {\n        releaseObject(values);\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.flatten` without support for callback\n     * shorthands or `thisArg` binding.\n     *\n     * @private\n     * @param {Array} array The array to flatten.\n     * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.\n     * @param {boolean} [isStrict=false] A flag to restrict flattening to arrays and `arguments` objects.\n     * @param {number} [fromIndex=0] The index to start from.\n     * @returns {Array} Returns a new flattened array.\n     */\n    function baseFlatten(array, isShallow, isStrict, fromIndex) {\n      var index = (fromIndex || 0) - 1,\n          length = array ? array.length : 0,\n          result = [];\n\n      while (++index < length) {\n        var value = array[index];\n\n        if (value && typeof value == 'object' && typeof value.length == 'number'\n            && (isArray(value) || isArguments(value))) {\n          // recursively flatten arrays (susceptible to call stack limits)\n          if (!isShallow) {\n            value = baseFlatten(value, isShallow, isStrict);\n          }\n          var valIndex = -1,\n              valLength = value.length,\n              resIndex = result.length;\n\n          result.length += valLength;\n          while (++valIndex < valLength) {\n            result[resIndex++] = value[valIndex];\n          }\n        } else if (!isStrict) {\n          result.push(value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.isEqual`, without support for `thisArg` binding,\n     * that allows partial \"_.where\" style comparisons.\n     *\n     * @private\n     * @param {*} a The value to compare.\n     * @param {*} b The other value to compare.\n     * @param {Function} [callback] The function to customize comparing values.\n     * @param {Function} [isWhere=false] A flag to indicate performing partial comparisons.\n     * @param {Array} [stackA=[]] Tracks traversed `a` objects.\n     * @param {Array} [stackB=[]] Tracks traversed `b` objects.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     */\n    function baseIsEqual(a, b, callback, isWhere, stackA, stackB) {\n      // used to indicate that when comparing objects, `a` has at least the properties of `b`\n      if (callback) {\n        var result = callback(a, b);\n        if (typeof result != 'undefined') {\n          return !!result;\n        }\n      }\n      // exit early for identical values\n      if (a === b) {\n        // treat `+0` vs. `-0` as not equal\n        return a !== 0 || (1 / a == 1 / b);\n      }\n      var type = typeof a,\n          otherType = typeof b;\n\n      // exit early for unlike primitive values\n      if (a === a &&\n          !(a && objectTypes[type]) &&\n          !(b && objectTypes[otherType])) {\n        return false;\n      }\n      // exit early for `null` and `undefined` avoiding ES3's Function#call behavior\n      // http://es5.github.io/#x15.3.4.4\n      if (a == null || b == null) {\n        return a === b;\n      }\n      // compare [[Class]] names\n      var className = toString.call(a),\n          otherClass = toString.call(b);\n\n      if (className == argsClass) {\n        className = objectClass;\n      }\n      if (otherClass == argsClass) {\n        otherClass = objectClass;\n      }\n      if (className != otherClass) {\n        return false;\n      }\n      switch (className) {\n        case boolClass:\n        case dateClass:\n          // coerce dates and booleans to numbers, dates to milliseconds and booleans\n          // to `1` or `0` treating invalid dates coerced to `NaN` as not equal\n          return +a == +b;\n\n        case numberClass:\n          // treat `NaN` vs. `NaN` as equal\n          return (a != +a)\n            ? b != +b\n            // but treat `+0` vs. `-0` as not equal\n            : (a == 0 ? (1 / a == 1 / b) : a == +b);\n\n        case regexpClass:\n        case stringClass:\n          // coerce regexes to strings (http://es5.github.io/#x15.10.6.4)\n          // treat string primitives and their corresponding object instances as equal\n          return a == String(b);\n      }\n      var isArr = className == arrayClass;\n      if (!isArr) {\n        // unwrap any `lodash` wrapped values\n        var aWrapped = hasOwnProperty.call(a, '__wrapped__'),\n            bWrapped = hasOwnProperty.call(b, '__wrapped__');\n\n        if (aWrapped || bWrapped) {\n          return baseIsEqual(aWrapped ? a.__wrapped__ : a, bWrapped ? b.__wrapped__ : b, callback, isWhere, stackA, stackB);\n        }\n        // exit for functions and DOM nodes\n        if (className != objectClass) {\n          return false;\n        }\n        // in older versions of Opera, `arguments` objects have `Array` constructors\n        var ctorA = a.constructor,\n            ctorB = b.constructor;\n\n        // non `Object` object instances with different constructors are not equal\n        if (ctorA != ctorB &&\n              !(isFunction(ctorA) && ctorA instanceof ctorA && isFunction(ctorB) && ctorB instanceof ctorB) &&\n              ('constructor' in a && 'constructor' in b)\n            ) {\n          return false;\n        }\n      }\n      // assume cyclic structures are equal\n      // the algorithm for detecting cyclic structures is adapted from ES 5.1\n      // section 15.12.3, abstract operation `JO` (http://es5.github.io/#x15.12.3)\n      var initedStack = !stackA;\n      stackA || (stackA = getArray());\n      stackB || (stackB = getArray());\n\n      var length = stackA.length;\n      while (length--) {\n        if (stackA[length] == a) {\n          return stackB[length] == b;\n        }\n      }\n      var size = 0;\n      result = true;\n\n      // add `a` and `b` to the stack of traversed objects\n      stackA.push(a);\n      stackB.push(b);\n\n      // recursively compare objects and arrays (susceptible to call stack limits)\n      if (isArr) {\n        // compare lengths to determine if a deep comparison is necessary\n        length = a.length;\n        size = b.length;\n        result = size == length;\n\n        if (result || isWhere) {\n          // deep compare the contents, ignoring non-numeric properties\n          while (size--) {\n            var index = length,\n                value = b[size];\n\n            if (isWhere) {\n              while (index--) {\n                if ((result = baseIsEqual(a[index], value, callback, isWhere, stackA, stackB))) {\n                  break;\n                }\n              }\n            } else if (!(result = baseIsEqual(a[size], value, callback, isWhere, stackA, stackB))) {\n              break;\n            }\n          }\n        }\n      }\n      else {\n        // deep compare objects using `forIn`, instead of `forOwn`, to avoid `Object.keys`\n        // which, in this case, is more costly\n        forIn(b, function(value, key, b) {\n          if (hasOwnProperty.call(b, key)) {\n            // count the number of properties.\n            size++;\n            // deep compare each property value.\n            return (result = hasOwnProperty.call(a, key) && baseIsEqual(a[key], value, callback, isWhere, stackA, stackB));\n          }\n        });\n\n        if (result && !isWhere) {\n          // ensure both objects have the same number of properties\n          forIn(a, function(value, key, a) {\n            if (hasOwnProperty.call(a, key)) {\n              // `size` will be `-1` if `a` has more properties than `b`\n              return (result = --size > -1);\n            }\n          });\n        }\n      }\n      stackA.pop();\n      stackB.pop();\n\n      if (initedStack) {\n        releaseArray(stackA);\n        releaseArray(stackB);\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.merge` without argument juggling or support\n     * for `thisArg` binding.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @param {Function} [callback] The function to customize merging properties.\n     * @param {Array} [stackA=[]] Tracks traversed source objects.\n     * @param {Array} [stackB=[]] Associates values with source counterparts.\n     */\n    function baseMerge(object, source, callback, stackA, stackB) {\n      (isArray(source) ? forEach : forOwn)(source, function(source, key) {\n        var found,\n            isArr,\n            result = source,\n            value = object[key];\n\n        if (source && ((isArr = isArray(source)) || isPlainObject(source))) {\n          // avoid merging previously merged cyclic sources\n          var stackLength = stackA.length;\n          while (stackLength--) {\n            if ((found = stackA[stackLength] == source)) {\n              value = stackB[stackLength];\n              break;\n            }\n          }\n          if (!found) {\n            var isShallow;\n            if (callback) {\n              result = callback(value, source);\n              if ((isShallow = typeof result != 'undefined')) {\n                value = result;\n              }\n            }\n            if (!isShallow) {\n              value = isArr\n                ? (isArray(value) ? value : [])\n                : (isPlainObject(value) ? value : {});\n            }\n            // add `source` and associated `value` to the stack of traversed objects\n            stackA.push(source);\n            stackB.push(value);\n\n            // recursively merge objects and arrays (susceptible to call stack limits)\n            if (!isShallow) {\n              baseMerge(value, source, callback, stackA, stackB);\n            }\n          }\n        }\n        else {\n          if (callback) {\n            result = callback(value, source);\n            if (typeof result == 'undefined') {\n              result = source;\n            }\n          }\n          if (typeof result != 'undefined') {\n            value = result;\n          }\n        }\n        object[key] = value;\n      });\n    }\n\n    /**\n     * The base implementation of `_.random` without argument juggling or support\n     * for returning floating-point numbers.\n     *\n     * @private\n     * @param {number} min The minimum possible value.\n     * @param {number} max The maximum possible value.\n     * @returns {number} Returns a random number.\n     */\n    function baseRandom(min, max) {\n      return min + floor(nativeRandom() * (max - min + 1));\n    }\n\n    /**\n     * The base implementation of `_.uniq` without support for callback shorthands\n     * or `thisArg` binding.\n     *\n     * @private\n     * @param {Array} array The array to process.\n     * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.\n     * @param {Function} [callback] The function called per iteration.\n     * @returns {Array} Returns a duplicate-value-free array.\n     */\n    function baseUniq(array, isSorted, callback) {\n      var index = -1,\n          indexOf = getIndexOf(),\n          length = array ? array.length : 0,\n          result = [];\n\n      var isLarge = !isSorted && length >= largeArraySize && indexOf === baseIndexOf,\n          seen = (callback || isLarge) ? getArray() : result;\n\n      if (isLarge) {\n        var cache = createCache(seen);\n        indexOf = cacheIndexOf;\n        seen = cache;\n      }\n      while (++index < length) {\n        var value = array[index],\n            computed = callback ? callback(value, index, array) : value;\n\n        if (isSorted\n              ? !index || seen[seen.length - 1] !== computed\n              : indexOf(seen, computed) < 0\n            ) {\n          if (callback || isLarge) {\n            seen.push(computed);\n          }\n          result.push(value);\n        }\n      }\n      if (isLarge) {\n        releaseArray(seen.array);\n        releaseObject(seen);\n      } else if (callback) {\n        releaseArray(seen);\n      }\n      return result;\n    }\n\n    /**\n     * Creates a function that aggregates a collection, creating an object composed\n     * of keys generated from the results of running each element of the collection\n     * through a callback. The given `setter` function sets the keys and values\n     * of the composed object.\n     *\n     * @private\n     * @param {Function} setter The setter function.\n     * @returns {Function} Returns the new aggregator function.\n     */\n    function createAggregator(setter) {\n      return function(collection, callback, thisArg) {\n        var result = {};\n        callback = lodash.createCallback(callback, thisArg, 3);\n\n        var index = -1,\n            length = collection ? collection.length : 0;\n\n        if (typeof length == 'number') {\n          while (++index < length) {\n            var value = collection[index];\n            setter(result, value, callback(value, index, collection), collection);\n          }\n        } else {\n          forOwn(collection, function(value, key, collection) {\n            setter(result, value, callback(value, key, collection), collection);\n          });\n        }\n        return result;\n      };\n    }\n\n    /**\n     * Creates a function that, when called, either curries or invokes `func`\n     * with an optional `this` binding and partially applied arguments.\n     *\n     * @private\n     * @param {Function|string} func The function or method name to reference.\n     * @param {number} bitmask The bitmask of method flags to compose.\n     *  The bitmask may be composed of the following flags:\n     *  1 - `_.bind`\n     *  2 - `_.bindKey`\n     *  4 - `_.curry`\n     *  8 - `_.curry` (bound)\n     *  16 - `_.partial`\n     *  32 - `_.partialRight`\n     * @param {Array} [partialArgs] An array of arguments to prepend to those\n     *  provided to the new function.\n     * @param {Array} [partialRightArgs] An array of arguments to append to those\n     *  provided to the new function.\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @param {number} [arity] The arity of `func`.\n     * @returns {Function} Returns the new function.\n     */\n    function createWrapper(func, bitmask, partialArgs, partialRightArgs, thisArg, arity) {\n      var isBind = bitmask & 1,\n          isBindKey = bitmask & 2,\n          isCurry = bitmask & 4,\n          isCurryBound = bitmask & 8,\n          isPartial = bitmask & 16,\n          isPartialRight = bitmask & 32;\n\n      if (!isBindKey && !isFunction(func)) {\n        throw new TypeError;\n      }\n      if (isPartial && !partialArgs.length) {\n        bitmask &= ~16;\n        isPartial = partialArgs = false;\n      }\n      if (isPartialRight && !partialRightArgs.length) {\n        bitmask &= ~32;\n        isPartialRight = partialRightArgs = false;\n      }\n      var bindData = func && func.__bindData__;\n      if (bindData && bindData !== true) {\n        // clone `bindData`\n        bindData = slice(bindData);\n        if (bindData[2]) {\n          bindData[2] = slice(bindData[2]);\n        }\n        if (bindData[3]) {\n          bindData[3] = slice(bindData[3]);\n        }\n        // set `thisBinding` is not previously bound\n        if (isBind && !(bindData[1] & 1)) {\n          bindData[4] = thisArg;\n        }\n        // set if previously bound but not currently (subsequent curried functions)\n        if (!isBind && bindData[1] & 1) {\n          bitmask |= 8;\n        }\n        // set curried arity if not yet set\n        if (isCurry && !(bindData[1] & 4)) {\n          bindData[5] = arity;\n        }\n        // append partial left arguments\n        if (isPartial) {\n          push.apply(bindData[2] || (bindData[2] = []), partialArgs);\n        }\n        // append partial right arguments\n        if (isPartialRight) {\n          unshift.apply(bindData[3] || (bindData[3] = []), partialRightArgs);\n        }\n        // merge flags\n        bindData[1] |= bitmask;\n        return createWrapper.apply(null, bindData);\n      }\n      // fast path for `_.bind`\n      var creater = (bitmask == 1 || bitmask === 17) ? baseBind : baseCreateWrapper;\n      return creater([func, bitmask, partialArgs, partialRightArgs, thisArg, arity]);\n    }\n\n    /**\n     * Used by `escape` to convert characters to HTML entities.\n     *\n     * @private\n     * @param {string} match The matched character to escape.\n     * @returns {string} Returns the escaped character.\n     */\n    function escapeHtmlChar(match) {\n      return htmlEscapes[match];\n    }\n\n    /**\n     * Gets the appropriate \"indexOf\" function. If the `_.indexOf` method is\n     * customized, this method returns the custom method, otherwise it returns\n     * the `baseIndexOf` function.\n     *\n     * @private\n     * @returns {Function} Returns the \"indexOf\" function.\n     */\n    function getIndexOf() {\n      var result = (result = lodash.indexOf) === indexOf ? baseIndexOf : result;\n      return result;\n    }\n\n    /**\n     * Checks if `value` is a native function.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the `value` is a native function, else `false`.\n     */\n    function isNative(value) {\n      return typeof value == 'function' && reNative.test(value);\n    }\n\n    /**\n     * Sets `this` binding data on a given function.\n     *\n     * @private\n     * @param {Function} func The function to set data on.\n     * @param {Array} value The data array to set.\n     */\n    var setBindData = !defineProperty ? noop : function(func, value) {\n      descriptor.value = value;\n      defineProperty(func, '__bindData__', descriptor);\n      descriptor.value = null;\n    };\n\n    /**\n     * A fallback implementation of `isPlainObject` which checks if a given value\n     * is an object created by the `Object` constructor, assuming objects created\n     * by the `Object` constructor have no inherited enumerable properties and that\n     * there are no `Object.prototype` extensions.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n     */\n    function shimIsPlainObject(value) {\n      var ctor,\n          result;\n\n      // avoid non Object objects, `arguments` objects, and DOM elements\n      if (!(value && toString.call(value) == objectClass) ||\n          (ctor = value.constructor, isFunction(ctor) && !(ctor instanceof ctor))) {\n        return false;\n      }\n      // In most environments an object's own properties are iterated before\n      // its inherited properties. If the last iterated property is an object's\n      // own property then there are no inherited enumerable properties.\n      forIn(value, function(value, key) {\n        result = key;\n      });\n      return typeof result == 'undefined' || hasOwnProperty.call(value, result);\n    }\n\n    /**\n     * Used by `unescape` to convert HTML entities to characters.\n     *\n     * @private\n     * @param {string} match The matched character to unescape.\n     * @returns {string} Returns the unescaped character.\n     */\n    function unescapeHtmlChar(match) {\n      return htmlUnescapes[match];\n    }\n\n    /*--------------------------------------------------------------------------*/\n\n    /**\n     * Checks if `value` is an `arguments` object.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the `value` is an `arguments` object, else `false`.\n     * @example\n     *\n     * (function() { return _.isArguments(arguments); })(1, 2, 3);\n     * // => true\n     *\n     * _.isArguments([1, 2, 3]);\n     * // => false\n     */\n    function isArguments(value) {\n      return value && typeof value == 'object' && typeof value.length == 'number' &&\n        toString.call(value) == argsClass || false;\n    }\n\n    /**\n     * Checks if `value` is an array.\n     *\n     * @static\n     * @memberOf _\n     * @type Function\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the `value` is an array, else `false`.\n     * @example\n     *\n     * (function() { return _.isArray(arguments); })();\n     * // => false\n     *\n     * _.isArray([1, 2, 3]);\n     * // => true\n     */\n    var isArray = nativeIsArray || function(value) {\n      return value && typeof value == 'object' && typeof value.length == 'number' &&\n        toString.call(value) == arrayClass || false;\n    };\n\n    /**\n     * A fallback implementation of `Object.keys` which produces an array of the\n     * given object's own enumerable property names.\n     *\n     * @private\n     * @type Function\n     * @param {Object} object The object to inspect.\n     * @returns {Array} Returns an array of property names.\n     */\n    var shimKeys = function(object) {\n      var index, iterable = object, result = [];\n      if (!iterable) return result;\n      if (!(objectTypes[typeof object])) return result;\n        for (index in iterable) {\n          if (hasOwnProperty.call(iterable, index)) {\n            result.push(index);\n          }\n        }\n      return result\n    };\n\n    /**\n     * Creates an array composed of the own enumerable property names of an object.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The object to inspect.\n     * @returns {Array} Returns an array of property names.\n     * @example\n     *\n     * _.keys({ 'one': 1, 'two': 2, 'three': 3 });\n     * // => ['one', 'two', 'three'] (property order is not guaranteed across environments)\n     */\n    var keys = !nativeKeys ? shimKeys : function(object) {\n      if (!isObject(object)) {\n        return [];\n      }\n      return nativeKeys(object);\n    };\n\n    /**\n     * Used to convert characters to HTML entities:\n     *\n     * Though the `>` character is escaped for symmetry, characters like `>` and `/`\n     * don't require escaping in HTML and have no special meaning unless they're part\n     * of a tag or an unquoted attribute value.\n     * http://mathiasbynens.be/notes/ambiguous-ampersands (under \"semi-related fun fact\")\n     */\n    var htmlEscapes = {\n      '&': '&amp;',\n      '<': '&lt;',\n      '>': '&gt;',\n      '\"': '&quot;',\n      \"'\": '&#39;'\n    };\n\n    /** Used to convert HTML entities to characters */\n    var htmlUnescapes = invert(htmlEscapes);\n\n    /** Used to match HTML entities and HTML characters */\n    var reEscapedHtml = RegExp('(' + keys(htmlUnescapes).join('|') + ')', 'g'),\n        reUnescapedHtml = RegExp('[' + keys(htmlEscapes).join('') + ']', 'g');\n\n    /*--------------------------------------------------------------------------*/\n\n    /**\n     * Assigns own enumerable properties of source object(s) to the destination\n     * object. Subsequent sources will overwrite property assignments of previous\n     * sources. If a callback is provided it will be executed to produce the\n     * assigned values. The callback is bound to `thisArg` and invoked with two\n     * arguments; (objectValue, sourceValue).\n     *\n     * @static\n     * @memberOf _\n     * @type Function\n     * @alias extend\n     * @category Objects\n     * @param {Object} object The destination object.\n     * @param {...Object} [source] The source objects.\n     * @param {Function} [callback] The function to customize assigning values.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Object} Returns the destination object.\n     * @example\n     *\n     * _.assign({ 'name': 'fred' }, { 'employer': 'slate' });\n     * // => { 'name': 'fred', 'employer': 'slate' }\n     *\n     * var defaults = _.partialRight(_.assign, function(a, b) {\n     *   return typeof a == 'undefined' ? b : a;\n     * });\n     *\n     * var object = { 'name': 'barney' };\n     * defaults(object, { 'name': 'fred', 'employer': 'slate' });\n     * // => { 'name': 'barney', 'employer': 'slate' }\n     */\n    var assign = function(object, source, guard) {\n      var index, iterable = object, result = iterable;\n      if (!iterable) return result;\n      var args = arguments,\n          argsIndex = 0,\n          argsLength = typeof guard == 'number' ? 2 : args.length;\n      if (argsLength > 3 && typeof args[argsLength - 2] == 'function') {\n        var callback = baseCreateCallback(args[--argsLength - 1], args[argsLength--], 2);\n      } else if (argsLength > 2 && typeof args[argsLength - 1] == 'function') {\n        callback = args[--argsLength];\n      }\n      while (++argsIndex < argsLength) {\n        iterable = args[argsIndex];\n        if (iterable && objectTypes[typeof iterable]) {\n        var ownIndex = -1,\n            ownProps = objectTypes[typeof iterable] && keys(iterable),\n            length = ownProps ? ownProps.length : 0;\n\n        while (++ownIndex < length) {\n          index = ownProps[ownIndex];\n          result[index] = callback ? callback(result[index], iterable[index]) : iterable[index];\n        }\n        }\n      }\n      return result\n    };\n\n    /**\n     * Creates a clone of `value`. If `isDeep` is `true` nested objects will also\n     * be cloned, otherwise they will be assigned by reference. If a callback\n     * is provided it will be executed to produce the cloned values. If the\n     * callback returns `undefined` cloning will be handled by the method instead.\n     * The callback is bound to `thisArg` and invoked with one argument; (value).\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to clone.\n     * @param {boolean} [isDeep=false] Specify a deep clone.\n     * @param {Function} [callback] The function to customize cloning values.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {*} Returns the cloned value.\n     * @example\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36 },\n     *   { 'name': 'fred',   'age': 40 }\n     * ];\n     *\n     * var shallow = _.clone(characters);\n     * shallow[0] === characters[0];\n     * // => true\n     *\n     * var deep = _.clone(characters, true);\n     * deep[0] === characters[0];\n     * // => false\n     *\n     * _.mixin({\n     *   'clone': _.partialRight(_.clone, function(value) {\n     *     return _.isElement(value) ? value.cloneNode(false) : undefined;\n     *   })\n     * });\n     *\n     * var clone = _.clone(document.body);\n     * clone.childNodes.length;\n     * // => 0\n     */\n    function clone(value, isDeep, callback, thisArg) {\n      // allows working with \"Collections\" methods without using their `index`\n      // and `collection` arguments for `isDeep` and `callback`\n      if (typeof isDeep != 'boolean' && isDeep != null) {\n        thisArg = callback;\n        callback = isDeep;\n        isDeep = false;\n      }\n      return baseClone(value, isDeep, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));\n    }\n\n    /**\n     * Creates a deep clone of `value`. If a callback is provided it will be\n     * executed to produce the cloned values. If the callback returns `undefined`\n     * cloning will be handled by the method instead. The callback is bound to\n     * `thisArg` and invoked with one argument; (value).\n     *\n     * Note: This method is loosely based on the structured clone algorithm. Functions\n     * and DOM nodes are **not** cloned. The enumerable properties of `arguments` objects and\n     * objects created by constructors other than `Object` are cloned to plain `Object` objects.\n     * See http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to deep clone.\n     * @param {Function} [callback] The function to customize cloning values.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {*} Returns the deep cloned value.\n     * @example\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36 },\n     *   { 'name': 'fred',   'age': 40 }\n     * ];\n     *\n     * var deep = _.cloneDeep(characters);\n     * deep[0] === characters[0];\n     * // => false\n     *\n     * var view = {\n     *   'label': 'docs',\n     *   'node': element\n     * };\n     *\n     * var clone = _.cloneDeep(view, function(value) {\n     *   return _.isElement(value) ? value.cloneNode(true) : undefined;\n     * });\n     *\n     * clone.node == view.node;\n     * // => false\n     */\n    function cloneDeep(value, callback, thisArg) {\n      return baseClone(value, true, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));\n    }\n\n    /**\n     * Creates an object that inherits from the given `prototype` object. If a\n     * `properties` object is provided its own enumerable properties are assigned\n     * to the created object.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} prototype The object to inherit from.\n     * @param {Object} [properties] The properties to assign to the object.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * function Shape() {\n     *   this.x = 0;\n     *   this.y = 0;\n     * }\n     *\n     * function Circle() {\n     *   Shape.call(this);\n     * }\n     *\n     * Circle.prototype = _.create(Shape.prototype, { 'constructor': Circle });\n     *\n     * var circle = new Circle;\n     * circle instanceof Circle;\n     * // => true\n     *\n     * circle instanceof Shape;\n     * // => true\n     */\n    function create(prototype, properties) {\n      var result = baseCreate(prototype);\n      return properties ? assign(result, properties) : result;\n    }\n\n    /**\n     * Assigns own enumerable properties of source object(s) to the destination\n     * object for all destination properties that resolve to `undefined`. Once a\n     * property is set, additional defaults of the same property will be ignored.\n     *\n     * @static\n     * @memberOf _\n     * @type Function\n     * @category Objects\n     * @param {Object} object The destination object.\n     * @param {...Object} [source] The source objects.\n     * @param- {Object} [guard] Allows working with `_.reduce` without using its\n     *  `key` and `object` arguments as sources.\n     * @returns {Object} Returns the destination object.\n     * @example\n     *\n     * var object = { 'name': 'barney' };\n     * _.defaults(object, { 'name': 'fred', 'employer': 'slate' });\n     * // => { 'name': 'barney', 'employer': 'slate' }\n     */\n    var defaults = function(object, source, guard) {\n      var index, iterable = object, result = iterable;\n      if (!iterable) return result;\n      var args = arguments,\n          argsIndex = 0,\n          argsLength = typeof guard == 'number' ? 2 : args.length;\n      while (++argsIndex < argsLength) {\n        iterable = args[argsIndex];\n        if (iterable && objectTypes[typeof iterable]) {\n        var ownIndex = -1,\n            ownProps = objectTypes[typeof iterable] && keys(iterable),\n            length = ownProps ? ownProps.length : 0;\n\n        while (++ownIndex < length) {\n          index = ownProps[ownIndex];\n          if (typeof result[index] == 'undefined') result[index] = iterable[index];\n        }\n        }\n      }\n      return result\n    };\n\n    /**\n     * This method is like `_.findIndex` except that it returns the key of the\n     * first element that passes the callback check, instead of the element itself.\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The object to search.\n     * @param {Function|Object|string} [callback=identity] The function called per\n     *  iteration. If a property name or object is provided it will be used to\n     *  create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {string|undefined} Returns the key of the found element, else `undefined`.\n     * @example\n     *\n     * var characters = {\n     *   'barney': {  'age': 36, 'blocked': false },\n     *   'fred': {    'age': 40, 'blocked': true },\n     *   'pebbles': { 'age': 1,  'blocked': false }\n     * };\n     *\n     * _.findKey(characters, function(chr) {\n     *   return chr.age < 40;\n     * });\n     * // => 'barney' (property order is not guaranteed across environments)\n     *\n     * // using \"_.where\" callback shorthand\n     * _.findKey(characters, { 'age': 1 });\n     * // => 'pebbles'\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.findKey(characters, 'blocked');\n     * // => 'fred'\n     */\n    function findKey(object, callback, thisArg) {\n      var result;\n      callback = lodash.createCallback(callback, thisArg, 3);\n      forOwn(object, function(value, key, object) {\n        if (callback(value, key, object)) {\n          result = key;\n          return false;\n        }\n      });\n      return result;\n    }\n\n    /**\n     * This method is like `_.findKey` except that it iterates over elements\n     * of a `collection` in the opposite order.\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The object to search.\n     * @param {Function|Object|string} [callback=identity] The function called per\n     *  iteration. If a property name or object is provided it will be used to\n     *  create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {string|undefined} Returns the key of the found element, else `undefined`.\n     * @example\n     *\n     * var characters = {\n     *   'barney': {  'age': 36, 'blocked': true },\n     *   'fred': {    'age': 40, 'blocked': false },\n     *   'pebbles': { 'age': 1,  'blocked': true }\n     * };\n     *\n     * _.findLastKey(characters, function(chr) {\n     *   return chr.age < 40;\n     * });\n     * // => returns `pebbles`, assuming `_.findKey` returns `barney`\n     *\n     * // using \"_.where\" callback shorthand\n     * _.findLastKey(characters, { 'age': 40 });\n     * // => 'fred'\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.findLastKey(characters, 'blocked');\n     * // => 'pebbles'\n     */\n    function findLastKey(object, callback, thisArg) {\n      var result;\n      callback = lodash.createCallback(callback, thisArg, 3);\n      forOwnRight(object, function(value, key, object) {\n        if (callback(value, key, object)) {\n          result = key;\n          return false;\n        }\n      });\n      return result;\n    }\n\n    /**\n     * Iterates over own and inherited enumerable properties of an object,\n     * executing the callback for each property. The callback is bound to `thisArg`\n     * and invoked with three arguments; (value, key, object). Callbacks may exit\n     * iteration early by explicitly returning `false`.\n     *\n     * @static\n     * @memberOf _\n     * @type Function\n     * @category Objects\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [callback=identity] The function called per iteration.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * function Shape() {\n     *   this.x = 0;\n     *   this.y = 0;\n     * }\n     *\n     * Shape.prototype.move = function(x, y) {\n     *   this.x += x;\n     *   this.y += y;\n     * };\n     *\n     * _.forIn(new Shape, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => logs 'x', 'y', and 'move' (property order is not guaranteed across environments)\n     */\n    var forIn = function(collection, callback, thisArg) {\n      var index, iterable = collection, result = iterable;\n      if (!iterable) return result;\n      if (!objectTypes[typeof iterable]) return result;\n      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);\n        for (index in iterable) {\n          if (callback(iterable[index], index, collection) === false) return result;\n        }\n      return result\n    };\n\n    /**\n     * This method is like `_.forIn` except that it iterates over elements\n     * of a `collection` in the opposite order.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [callback=identity] The function called per iteration.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * function Shape() {\n     *   this.x = 0;\n     *   this.y = 0;\n     * }\n     *\n     * Shape.prototype.move = function(x, y) {\n     *   this.x += x;\n     *   this.y += y;\n     * };\n     *\n     * _.forInRight(new Shape, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => logs 'move', 'y', and 'x' assuming `_.forIn ` logs 'x', 'y', and 'move'\n     */\n    function forInRight(object, callback, thisArg) {\n      var pairs = [];\n\n      forIn(object, function(value, key) {\n        pairs.push(key, value);\n      });\n\n      var length = pairs.length;\n      callback = baseCreateCallback(callback, thisArg, 3);\n      while (length--) {\n        if (callback(pairs[length--], pairs[length], object) === false) {\n          break;\n        }\n      }\n      return object;\n    }\n\n    /**\n     * Iterates over own enumerable properties of an object, executing the callback\n     * for each property. The callback is bound to `thisArg` and invoked with three\n     * arguments; (value, key, object). Callbacks may exit iteration early by\n     * explicitly returning `false`.\n     *\n     * @static\n     * @memberOf _\n     * @type Function\n     * @category Objects\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [callback=identity] The function called per iteration.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * _.forOwn({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {\n     *   console.log(key);\n     * });\n     * // => logs '0', '1', and 'length' (property order is not guaranteed across environments)\n     */\n    var forOwn = function(collection, callback, thisArg) {\n      var index, iterable = collection, result = iterable;\n      if (!iterable) return result;\n      if (!objectTypes[typeof iterable]) return result;\n      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);\n        var ownIndex = -1,\n            ownProps = objectTypes[typeof iterable] && keys(iterable),\n            length = ownProps ? ownProps.length : 0;\n\n        while (++ownIndex < length) {\n          index = ownProps[ownIndex];\n          if (callback(iterable[index], index, collection) === false) return result;\n        }\n      return result\n    };\n\n    /**\n     * This method is like `_.forOwn` except that it iterates over elements\n     * of a `collection` in the opposite order.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [callback=identity] The function called per iteration.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * _.forOwnRight({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {\n     *   console.log(key);\n     * });\n     * // => logs 'length', '1', and '0' assuming `_.forOwn` logs '0', '1', and 'length'\n     */\n    function forOwnRight(object, callback, thisArg) {\n      var props = keys(object),\n          length = props.length;\n\n      callback = baseCreateCallback(callback, thisArg, 3);\n      while (length--) {\n        var key = props[length];\n        if (callback(object[key], key, object) === false) {\n          break;\n        }\n      }\n      return object;\n    }\n\n    /**\n     * Creates a sorted array of property names of all enumerable properties,\n     * own and inherited, of `object` that have function values.\n     *\n     * @static\n     * @memberOf _\n     * @alias methods\n     * @category Objects\n     * @param {Object} object The object to inspect.\n     * @returns {Array} Returns an array of property names that have function values.\n     * @example\n     *\n     * _.functions(_);\n     * // => ['all', 'any', 'bind', 'bindAll', 'clone', 'compact', 'compose', ...]\n     */\n    function functions(object) {\n      var result = [];\n      forIn(object, function(value, key) {\n        if (isFunction(value)) {\n          result.push(key);\n        }\n      });\n      return result.sort();\n    }\n\n    /**\n     * Checks if the specified property name exists as a direct property of `object`,\n     * instead of an inherited property.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The object to inspect.\n     * @param {string} key The name of the property to check.\n     * @returns {boolean} Returns `true` if key is a direct property, else `false`.\n     * @example\n     *\n     * _.has({ 'a': 1, 'b': 2, 'c': 3 }, 'b');\n     * // => true\n     */\n    function has(object, key) {\n      return object ? hasOwnProperty.call(object, key) : false;\n    }\n\n    /**\n     * Creates an object composed of the inverted keys and values of the given object.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The object to invert.\n     * @returns {Object} Returns the created inverted object.\n     * @example\n     *\n     * _.invert({ 'first': 'fred', 'second': 'barney' });\n     * // => { 'fred': 'first', 'barney': 'second' }\n     */\n    function invert(object) {\n      var index = -1,\n          props = keys(object),\n          length = props.length,\n          result = {};\n\n      while (++index < length) {\n        var key = props[index];\n        result[object[key]] = key;\n      }\n      return result;\n    }\n\n    /**\n     * Checks if `value` is a boolean value.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the `value` is a boolean value, else `false`.\n     * @example\n     *\n     * _.isBoolean(null);\n     * // => false\n     */\n    function isBoolean(value) {\n      return value === true || value === false ||\n        value && typeof value == 'object' && toString.call(value) == boolClass || false;\n    }\n\n    /**\n     * Checks if `value` is a date.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the `value` is a date, else `false`.\n     * @example\n     *\n     * _.isDate(new Date);\n     * // => true\n     */\n    function isDate(value) {\n      return value && typeof value == 'object' && toString.call(value) == dateClass || false;\n    }\n\n    /**\n     * Checks if `value` is a DOM element.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the `value` is a DOM element, else `false`.\n     * @example\n     *\n     * _.isElement(document.body);\n     * // => true\n     */\n    function isElement(value) {\n      return value && value.nodeType === 1 || false;\n    }\n\n    /**\n     * Checks if `value` is empty. Arrays, strings, or `arguments` objects with a\n     * length of `0` and objects with no own enumerable properties are considered\n     * \"empty\".\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Array|Object|string} value The value to inspect.\n     * @returns {boolean} Returns `true` if the `value` is empty, else `false`.\n     * @example\n     *\n     * _.isEmpty([1, 2, 3]);\n     * // => false\n     *\n     * _.isEmpty({});\n     * // => true\n     *\n     * _.isEmpty('');\n     * // => true\n     */\n    function isEmpty(value) {\n      var result = true;\n      if (!value) {\n        return result;\n      }\n      var className = toString.call(value),\n          length = value.length;\n\n      if ((className == arrayClass || className == stringClass || className == argsClass ) ||\n          (className == objectClass && typeof length == 'number' && isFunction(value.splice))) {\n        return !length;\n      }\n      forOwn(value, function() {\n        return (result = false);\n      });\n      return result;\n    }\n\n    /**\n     * Performs a deep comparison between two values to determine if they are\n     * equivalent to each other. If a callback is provided it will be executed\n     * to compare values. If the callback returns `undefined` comparisons will\n     * be handled by the method instead. The callback is bound to `thisArg` and\n     * invoked with two arguments; (a, b).\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} a The value to compare.\n     * @param {*} b The other value to compare.\n     * @param {Function} [callback] The function to customize comparing values.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     * @example\n     *\n     * var object = { 'name': 'fred' };\n     * var copy = { 'name': 'fred' };\n     *\n     * object == copy;\n     * // => false\n     *\n     * _.isEqual(object, copy);\n     * // => true\n     *\n     * var words = ['hello', 'goodbye'];\n     * var otherWords = ['hi', 'goodbye'];\n     *\n     * _.isEqual(words, otherWords, function(a, b) {\n     *   var reGreet = /^(?:hello|hi)$/i,\n     *       aGreet = _.isString(a) && reGreet.test(a),\n     *       bGreet = _.isString(b) && reGreet.test(b);\n     *\n     *   return (aGreet || bGreet) ? (aGreet == bGreet) : undefined;\n     * });\n     * // => true\n     */\n    function isEqual(a, b, callback, thisArg) {\n      return baseIsEqual(a, b, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 2));\n    }\n\n    /**\n     * Checks if `value` is, or can be coerced to, a finite number.\n     *\n     * Note: This is not the same as native `isFinite` which will return true for\n     * booleans and empty strings. See http://es5.github.io/#x15.1.2.5.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the `value` is finite, else `false`.\n     * @example\n     *\n     * _.isFinite(-101);\n     * // => true\n     *\n     * _.isFinite('10');\n     * // => true\n     *\n     * _.isFinite(true);\n     * // => false\n     *\n     * _.isFinite('');\n     * // => false\n     *\n     * _.isFinite(Infinity);\n     * // => false\n     */\n    function isFinite(value) {\n      return nativeIsFinite(value) && !nativeIsNaN(parseFloat(value));\n    }\n\n    /**\n     * Checks if `value` is a function.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the `value` is a function, else `false`.\n     * @example\n     *\n     * _.isFunction(_);\n     * // => true\n     */\n    function isFunction(value) {\n      return typeof value == 'function';\n    }\n\n    /**\n     * Checks if `value` is the language type of Object.\n     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the `value` is an object, else `false`.\n     * @example\n     *\n     * _.isObject({});\n     * // => true\n     *\n     * _.isObject([1, 2, 3]);\n     * // => true\n     *\n     * _.isObject(1);\n     * // => false\n     */\n    function isObject(value) {\n      // check if the value is the ECMAScript language type of Object\n      // http://es5.github.io/#x8\n      // and avoid a V8 bug\n      // http://code.google.com/p/v8/issues/detail?id=2291\n      return !!(value && objectTypes[typeof value]);\n    }\n\n    /**\n     * Checks if `value` is `NaN`.\n     *\n     * Note: This is not the same as native `isNaN` which will return `true` for\n     * `undefined` and other non-numeric values. See http://es5.github.io/#x15.1.2.4.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the `value` is `NaN`, else `false`.\n     * @example\n     *\n     * _.isNaN(NaN);\n     * // => true\n     *\n     * _.isNaN(new Number(NaN));\n     * // => true\n     *\n     * isNaN(undefined);\n     * // => true\n     *\n     * _.isNaN(undefined);\n     * // => false\n     */\n    function isNaN(value) {\n      // `NaN` as a primitive is the only value that is not equal to itself\n      // (perform the [[Class]] check first to avoid errors with some host objects in IE)\n      return isNumber(value) && value != +value;\n    }\n\n    /**\n     * Checks if `value` is `null`.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the `value` is `null`, else `false`.\n     * @example\n     *\n     * _.isNull(null);\n     * // => true\n     *\n     * _.isNull(undefined);\n     * // => false\n     */\n    function isNull(value) {\n      return value === null;\n    }\n\n    /**\n     * Checks if `value` is a number.\n     *\n     * Note: `NaN` is considered a number. See http://es5.github.io/#x8.5.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the `value` is a number, else `false`.\n     * @example\n     *\n     * _.isNumber(8.4 * 5);\n     * // => true\n     */\n    function isNumber(value) {\n      return typeof value == 'number' ||\n        value && typeof value == 'object' && toString.call(value) == numberClass || false;\n    }\n\n    /**\n     * Checks if `value` is an object created by the `Object` constructor.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n     * @example\n     *\n     * function Shape() {\n     *   this.x = 0;\n     *   this.y = 0;\n     * }\n     *\n     * _.isPlainObject(new Shape);\n     * // => false\n     *\n     * _.isPlainObject([1, 2, 3]);\n     * // => false\n     *\n     * _.isPlainObject({ 'x': 0, 'y': 0 });\n     * // => true\n     */\n    var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function(value) {\n      if (!(value && toString.call(value) == objectClass)) {\n        return false;\n      }\n      var valueOf = value.valueOf,\n          objProto = isNative(valueOf) && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);\n\n      return objProto\n        ? (value == objProto || getPrototypeOf(value) == objProto)\n        : shimIsPlainObject(value);\n    };\n\n    /**\n     * Checks if `value` is a regular expression.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the `value` is a regular expression, else `false`.\n     * @example\n     *\n     * _.isRegExp(/fred/);\n     * // => true\n     */\n    function isRegExp(value) {\n      return value && typeof value == 'object' && toString.call(value) == regexpClass || false;\n    }\n\n    /**\n     * Checks if `value` is a string.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the `value` is a string, else `false`.\n     * @example\n     *\n     * _.isString('fred');\n     * // => true\n     */\n    function isString(value) {\n      return typeof value == 'string' ||\n        value && typeof value == 'object' && toString.call(value) == stringClass || false;\n    }\n\n    /**\n     * Checks if `value` is `undefined`.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the `value` is `undefined`, else `false`.\n     * @example\n     *\n     * _.isUndefined(void 0);\n     * // => true\n     */\n    function isUndefined(value) {\n      return typeof value == 'undefined';\n    }\n\n    /**\n     * Creates an object with the same keys as `object` and values generated by\n     * running each own enumerable property of `object` through the callback.\n     * The callback is bound to `thisArg` and invoked with three arguments;\n     * (value, key, object).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The object to iterate over.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Array} Returns a new object with values of the results of each `callback` execution.\n     * @example\n     *\n     * _.mapValues({ 'a': 1, 'b': 2, 'c': 3} , function(num) { return num * 3; });\n     * // => { 'a': 3, 'b': 6, 'c': 9 }\n     *\n     * var characters = {\n     *   'fred': { 'name': 'fred', 'age': 40 },\n     *   'pebbles': { 'name': 'pebbles', 'age': 1 }\n     * };\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.mapValues(characters, 'age');\n     * // => { 'fred': 40, 'pebbles': 1 }\n     */\n    function mapValues(object, callback, thisArg) {\n      var result = {};\n      callback = lodash.createCallback(callback, thisArg, 3);\n\n      forOwn(object, function(value, key, object) {\n        result[key] = callback(value, key, object);\n      });\n      return result;\n    }\n\n    /**\n     * Recursively merges own enumerable properties of the source object(s), that\n     * don't resolve to `undefined` into the destination object. Subsequent sources\n     * will overwrite property assignments of previous sources. If a callback is\n     * provided it will be executed to produce the merged values of the destination\n     * and source properties. If the callback returns `undefined` merging will\n     * be handled by the method instead. The callback is bound to `thisArg` and\n     * invoked with two arguments; (objectValue, sourceValue).\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The destination object.\n     * @param {...Object} [source] The source objects.\n     * @param {Function} [callback] The function to customize merging properties.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Object} Returns the destination object.\n     * @example\n     *\n     * var names = {\n     *   'characters': [\n     *     { 'name': 'barney' },\n     *     { 'name': 'fred' }\n     *   ]\n     * };\n     *\n     * var ages = {\n     *   'characters': [\n     *     { 'age': 36 },\n     *     { 'age': 40 }\n     *   ]\n     * };\n     *\n     * _.merge(names, ages);\n     * // => { 'characters': [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred', 'age': 40 }] }\n     *\n     * var food = {\n     *   'fruits': ['apple'],\n     *   'vegetables': ['beet']\n     * };\n     *\n     * var otherFood = {\n     *   'fruits': ['banana'],\n     *   'vegetables': ['carrot']\n     * };\n     *\n     * _.merge(food, otherFood, function(a, b) {\n     *   return _.isArray(a) ? a.concat(b) : undefined;\n     * });\n     * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot] }\n     */\n    function merge(object) {\n      var args = arguments,\n          length = 2;\n\n      if (!isObject(object)) {\n        return object;\n      }\n      // allows working with `_.reduce` and `_.reduceRight` without using\n      // their `index` and `collection` arguments\n      if (typeof args[2] != 'number') {\n        length = args.length;\n      }\n      if (length > 3 && typeof args[length - 2] == 'function') {\n        var callback = baseCreateCallback(args[--length - 1], args[length--], 2);\n      } else if (length > 2 && typeof args[length - 1] == 'function') {\n        callback = args[--length];\n      }\n      var sources = slice(arguments, 1, length),\n          index = -1,\n          stackA = getArray(),\n          stackB = getArray();\n\n      while (++index < length) {\n        baseMerge(object, sources[index], callback, stackA, stackB);\n      }\n      releaseArray(stackA);\n      releaseArray(stackB);\n      return object;\n    }\n\n    /**\n     * Creates a shallow clone of `object` excluding the specified properties.\n     * Property names may be specified as individual arguments or as arrays of\n     * property names. If a callback is provided it will be executed for each\n     * property of `object` omitting the properties the callback returns truey\n     * for. The callback is bound to `thisArg` and invoked with three arguments;\n     * (value, key, object).\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The source object.\n     * @param {Function|...string|string[]} [callback] The properties to omit or the\n     *  function called per iteration.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Object} Returns an object without the omitted properties.\n     * @example\n     *\n     * _.omit({ 'name': 'fred', 'age': 40 }, 'age');\n     * // => { 'name': 'fred' }\n     *\n     * _.omit({ 'name': 'fred', 'age': 40 }, function(value) {\n     *   return typeof value == 'number';\n     * });\n     * // => { 'name': 'fred' }\n     */\n    function omit(object, callback, thisArg) {\n      var result = {};\n      if (typeof callback != 'function') {\n        var props = [];\n        forIn(object, function(value, key) {\n          props.push(key);\n        });\n        props = baseDifference(props, baseFlatten(arguments, true, false, 1));\n\n        var index = -1,\n            length = props.length;\n\n        while (++index < length) {\n          var key = props[index];\n          result[key] = object[key];\n        }\n      } else {\n        callback = lodash.createCallback(callback, thisArg, 3);\n        forIn(object, function(value, key, object) {\n          if (!callback(value, key, object)) {\n            result[key] = value;\n          }\n        });\n      }\n      return result;\n    }\n\n    /**\n     * Creates a two dimensional array of an object's key-value pairs,\n     * i.e. `[[key1, value1], [key2, value2]]`.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The object to inspect.\n     * @returns {Array} Returns new array of key-value pairs.\n     * @example\n     *\n     * _.pairs({ 'barney': 36, 'fred': 40 });\n     * // => [['barney', 36], ['fred', 40]] (property order is not guaranteed across environments)\n     */\n    function pairs(object) {\n      var index = -1,\n          props = keys(object),\n          length = props.length,\n          result = Array(length);\n\n      while (++index < length) {\n        var key = props[index];\n        result[index] = [key, object[key]];\n      }\n      return result;\n    }\n\n    /**\n     * Creates a shallow clone of `object` composed of the specified properties.\n     * Property names may be specified as individual arguments or as arrays of\n     * property names. If a callback is provided it will be executed for each\n     * property of `object` picking the properties the callback returns truey\n     * for. The callback is bound to `thisArg` and invoked with three arguments;\n     * (value, key, object).\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The source object.\n     * @param {Function|...string|string[]} [callback] The function called per\n     *  iteration or property names to pick, specified as individual property\n     *  names or arrays of property names.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Object} Returns an object composed of the picked properties.\n     * @example\n     *\n     * _.pick({ 'name': 'fred', '_userid': 'fred1' }, 'name');\n     * // => { 'name': 'fred' }\n     *\n     * _.pick({ 'name': 'fred', '_userid': 'fred1' }, function(value, key) {\n     *   return key.charAt(0) != '_';\n     * });\n     * // => { 'name': 'fred' }\n     */\n    function pick(object, callback, thisArg) {\n      var result = {};\n      if (typeof callback != 'function') {\n        var index = -1,\n            props = baseFlatten(arguments, true, false, 1),\n            length = isObject(object) ? props.length : 0;\n\n        while (++index < length) {\n          var key = props[index];\n          if (key in object) {\n            result[key] = object[key];\n          }\n        }\n      } else {\n        callback = lodash.createCallback(callback, thisArg, 3);\n        forIn(object, function(value, key, object) {\n          if (callback(value, key, object)) {\n            result[key] = value;\n          }\n        });\n      }\n      return result;\n    }\n\n    /**\n     * An alternative to `_.reduce` this method transforms `object` to a new\n     * `accumulator` object which is the result of running each of its own\n     * enumerable properties through a callback, with each callback execution\n     * potentially mutating the `accumulator` object. The callback is bound to\n     * `thisArg` and invoked with four arguments; (accumulator, value, key, object).\n     * Callbacks may exit iteration early by explicitly returning `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Array|Object} object The object to iterate over.\n     * @param {Function} [callback=identity] The function called per iteration.\n     * @param {*} [accumulator] The custom accumulator value.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {*} Returns the accumulated value.\n     * @example\n     *\n     * var squares = _.transform([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], function(result, num) {\n     *   num *= num;\n     *   if (num % 2) {\n     *     return result.push(num) < 3;\n     *   }\n     * });\n     * // => [1, 9, 25]\n     *\n     * var mapped = _.transform({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {\n     *   result[key] = num * 3;\n     * });\n     * // => { 'a': 3, 'b': 6, 'c': 9 }\n     */\n    function transform(object, callback, accumulator, thisArg) {\n      var isArr = isArray(object);\n      if (accumulator == null) {\n        if (isArr) {\n          accumulator = [];\n        } else {\n          var ctor = object && object.constructor,\n              proto = ctor && ctor.prototype;\n\n          accumulator = baseCreate(proto);\n        }\n      }\n      if (callback) {\n        callback = lodash.createCallback(callback, thisArg, 4);\n        (isArr ? forEach : forOwn)(object, function(value, index, object) {\n          return callback(accumulator, value, index, object);\n        });\n      }\n      return accumulator;\n    }\n\n    /**\n     * Creates an array composed of the own enumerable property values of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The object to inspect.\n     * @returns {Array} Returns an array of property values.\n     * @example\n     *\n     * _.values({ 'one': 1, 'two': 2, 'three': 3 });\n     * // => [1, 2, 3] (property order is not guaranteed across environments)\n     */\n    function values(object) {\n      var index = -1,\n          props = keys(object),\n          length = props.length,\n          result = Array(length);\n\n      while (++index < length) {\n        result[index] = object[props[index]];\n      }\n      return result;\n    }\n\n    /*--------------------------------------------------------------------------*/\n\n    /**\n     * Creates an array of elements from the specified indexes, or keys, of the\n     * `collection`. Indexes may be specified as individual arguments or as arrays\n     * of indexes.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {...(number|number[]|string|string[])} [index] The indexes of `collection`\n     *   to retrieve, specified as individual indexes or arrays of indexes.\n     * @returns {Array} Returns a new array of elements corresponding to the\n     *  provided indexes.\n     * @example\n     *\n     * _.at(['a', 'b', 'c', 'd', 'e'], [0, 2, 4]);\n     * // => ['a', 'c', 'e']\n     *\n     * _.at(['fred', 'barney', 'pebbles'], 0, 2);\n     * // => ['fred', 'pebbles']\n     */\n    function at(collection) {\n      var args = arguments,\n          index = -1,\n          props = baseFlatten(args, true, false, 1),\n          length = (args[2] && args[2][args[1]] === collection) ? 1 : props.length,\n          result = Array(length);\n\n      while(++index < length) {\n        result[index] = collection[props[index]];\n      }\n      return result;\n    }\n\n    /**\n     * Checks if a given value is present in a collection using strict equality\n     * for comparisons, i.e. `===`. If `fromIndex` is negative, it is used as the\n     * offset from the end of the collection.\n     *\n     * @static\n     * @memberOf _\n     * @alias include\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {*} target The value to check for.\n     * @param {number} [fromIndex=0] The index to search from.\n     * @returns {boolean} Returns `true` if the `target` element is found, else `false`.\n     * @example\n     *\n     * _.contains([1, 2, 3], 1);\n     * // => true\n     *\n     * _.contains([1, 2, 3], 1, 2);\n     * // => false\n     *\n     * _.contains({ 'name': 'fred', 'age': 40 }, 'fred');\n     * // => true\n     *\n     * _.contains('pebbles', 'eb');\n     * // => true\n     */\n    function contains(collection, target, fromIndex) {\n      var index = -1,\n          indexOf = getIndexOf(),\n          length = collection ? collection.length : 0,\n          result = false;\n\n      fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex) || 0;\n      if (isArray(collection)) {\n        result = indexOf(collection, target, fromIndex) > -1;\n      } else if (typeof length == 'number') {\n        result = (isString(collection) ? collection.indexOf(target, fromIndex) : indexOf(collection, target, fromIndex)) > -1;\n      } else {\n        forOwn(collection, function(value) {\n          if (++index >= fromIndex) {\n            return !(result = value === target);\n          }\n        });\n      }\n      return result;\n    }\n\n    /**\n     * Creates an object composed of keys generated from the results of running\n     * each element of `collection` through the callback. The corresponding value\n     * of each key is the number of times the key was returned by the callback.\n     * The callback is bound to `thisArg` and invoked with three arguments;\n     * (value, index|key, collection).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Object} Returns the composed aggregate object.\n     * @example\n     *\n     * _.countBy([4.3, 6.1, 6.4], function(num) { return Math.floor(num); });\n     * // => { '4': 1, '6': 2 }\n     *\n     * _.countBy([4.3, 6.1, 6.4], function(num) { return this.floor(num); }, Math);\n     * // => { '4': 1, '6': 2 }\n     *\n     * _.countBy(['one', 'two', 'three'], 'length');\n     * // => { '3': 2, '5': 1 }\n     */\n    var countBy = createAggregator(function(result, value, key) {\n      (hasOwnProperty.call(result, key) ? result[key]++ : result[key] = 1);\n    });\n\n    /**\n     * Checks if the given callback returns truey value for **all** elements of\n     * a collection. The callback is bound to `thisArg` and invoked with three\n     * arguments; (value, index|key, collection).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @alias all\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {boolean} Returns `true` if all elements passed the callback check,\n     *  else `false`.\n     * @example\n     *\n     * _.every([true, 1, null, 'yes']);\n     * // => false\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36 },\n     *   { 'name': 'fred',   'age': 40 }\n     * ];\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.every(characters, 'age');\n     * // => true\n     *\n     * // using \"_.where\" callback shorthand\n     * _.every(characters, { 'age': 36 });\n     * // => false\n     */\n    function every(collection, callback, thisArg) {\n      var result = true;\n      callback = lodash.createCallback(callback, thisArg, 3);\n\n      var index = -1,\n          length = collection ? collection.length : 0;\n\n      if (typeof length == 'number') {\n        while (++index < length) {\n          if (!(result = !!callback(collection[index], index, collection))) {\n            break;\n          }\n        }\n      } else {\n        forOwn(collection, function(value, index, collection) {\n          return (result = !!callback(value, index, collection));\n        });\n      }\n      return result;\n    }\n\n    /**\n     * Iterates over elements of a collection, returning an array of all elements\n     * the callback returns truey for. The callback is bound to `thisArg` and\n     * invoked with three arguments; (value, index|key, collection).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @alias select\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Array} Returns a new array of elements that passed the callback check.\n     * @example\n     *\n     * var evens = _.filter([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });\n     * // => [2, 4, 6]\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36, 'blocked': false },\n     *   { 'name': 'fred',   'age': 40, 'blocked': true }\n     * ];\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.filter(characters, 'blocked');\n     * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]\n     *\n     * // using \"_.where\" callback shorthand\n     * _.filter(characters, { 'age': 36 });\n     * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]\n     */\n    function filter(collection, callback, thisArg) {\n      var result = [];\n      callback = lodash.createCallback(callback, thisArg, 3);\n\n      var index = -1,\n          length = collection ? collection.length : 0;\n\n      if (typeof length == 'number') {\n        while (++index < length) {\n          var value = collection[index];\n          if (callback(value, index, collection)) {\n            result.push(value);\n          }\n        }\n      } else {\n        forOwn(collection, function(value, index, collection) {\n          if (callback(value, index, collection)) {\n            result.push(value);\n          }\n        });\n      }\n      return result;\n    }\n\n    /**\n     * Iterates over elements of a collection, returning the first element that\n     * the callback returns truey for. The callback is bound to `thisArg` and\n     * invoked with three arguments; (value, index|key, collection).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @alias detect, findWhere\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {*} Returns the found element, else `undefined`.\n     * @example\n     *\n     * var characters = [\n     *   { 'name': 'barney',  'age': 36, 'blocked': false },\n     *   { 'name': 'fred',    'age': 40, 'blocked': true },\n     *   { 'name': 'pebbles', 'age': 1,  'blocked': false }\n     * ];\n     *\n     * _.find(characters, function(chr) {\n     *   return chr.age < 40;\n     * });\n     * // => { 'name': 'barney', 'age': 36, 'blocked': false }\n     *\n     * // using \"_.where\" callback shorthand\n     * _.find(characters, { 'age': 1 });\n     * // =>  { 'name': 'pebbles', 'age': 1, 'blocked': false }\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.find(characters, 'blocked');\n     * // => { 'name': 'fred', 'age': 40, 'blocked': true }\n     */\n    function find(collection, callback, thisArg) {\n      callback = lodash.createCallback(callback, thisArg, 3);\n\n      var index = -1,\n          length = collection ? collection.length : 0;\n\n      if (typeof length == 'number') {\n        while (++index < length) {\n          var value = collection[index];\n          if (callback(value, index, collection)) {\n            return value;\n          }\n        }\n      } else {\n        var result;\n        forOwn(collection, function(value, index, collection) {\n          if (callback(value, index, collection)) {\n            result = value;\n            return false;\n          }\n        });\n        return result;\n      }\n    }\n\n    /**\n     * This method is like `_.find` except that it iterates over elements\n     * of a `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {*} Returns the found element, else `undefined`.\n     * @example\n     *\n     * _.findLast([1, 2, 3, 4], function(num) {\n     *   return num % 2 == 1;\n     * });\n     * // => 3\n     */\n    function findLast(collection, callback, thisArg) {\n      var result;\n      callback = lodash.createCallback(callback, thisArg, 3);\n      forEachRight(collection, function(value, index, collection) {\n        if (callback(value, index, collection)) {\n          result = value;\n          return false;\n        }\n      });\n      return result;\n    }\n\n    /**\n     * Iterates over elements of a collection, executing the callback for each\n     * element. The callback is bound to `thisArg` and invoked with three arguments;\n     * (value, index|key, collection). Callbacks may exit iteration early by\n     * explicitly returning `false`.\n     *\n     * Note: As with other \"Collections\" methods, objects with a `length` property\n     * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`\n     * may be used for object iteration.\n     *\n     * @static\n     * @memberOf _\n     * @alias each\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function} [callback=identity] The function called per iteration.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Array|Object|string} Returns `collection`.\n     * @example\n     *\n     * _([1, 2, 3]).forEach(function(num) { console.log(num); }).join(',');\n     * // => logs each number and returns '1,2,3'\n     *\n     * _.forEach({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { console.log(num); });\n     * // => logs each number and returns the object (property order is not guaranteed across environments)\n     */\n    function forEach(collection, callback, thisArg) {\n      var index = -1,\n          length = collection ? collection.length : 0;\n\n      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);\n      if (typeof length == 'number') {\n        while (++index < length) {\n          if (callback(collection[index], index, collection) === false) {\n            break;\n          }\n        }\n      } else {\n        forOwn(collection, callback);\n      }\n      return collection;\n    }\n\n    /**\n     * This method is like `_.forEach` except that it iterates over elements\n     * of a `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @alias eachRight\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function} [callback=identity] The function called per iteration.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Array|Object|string} Returns `collection`.\n     * @example\n     *\n     * _([1, 2, 3]).forEachRight(function(num) { console.log(num); }).join(',');\n     * // => logs each number from right to left and returns '3,2,1'\n     */\n    function forEachRight(collection, callback, thisArg) {\n      var length = collection ? collection.length : 0;\n      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);\n      if (typeof length == 'number') {\n        while (length--) {\n          if (callback(collection[length], length, collection) === false) {\n            break;\n          }\n        }\n      } else {\n        var props = keys(collection);\n        length = props.length;\n        forOwn(collection, function(value, key, collection) {\n          key = props ? props[--length] : --length;\n          return callback(collection[key], key, collection);\n        });\n      }\n      return collection;\n    }\n\n    /**\n     * Creates an object composed of keys generated from the results of running\n     * each element of a collection through the callback. The corresponding value\n     * of each key is an array of the elements responsible for generating the key.\n     * The callback is bound to `thisArg` and invoked with three arguments;\n     * (value, index|key, collection).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Object} Returns the composed aggregate object.\n     * @example\n     *\n     * _.groupBy([4.2, 6.1, 6.4], function(num) { return Math.floor(num); });\n     * // => { '4': [4.2], '6': [6.1, 6.4] }\n     *\n     * _.groupBy([4.2, 6.1, 6.4], function(num) { return this.floor(num); }, Math);\n     * // => { '4': [4.2], '6': [6.1, 6.4] }\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.groupBy(['one', 'two', 'three'], 'length');\n     * // => { '3': ['one', 'two'], '5': ['three'] }\n     */\n    var groupBy = createAggregator(function(result, value, key) {\n      (hasOwnProperty.call(result, key) ? result[key] : result[key] = []).push(value);\n    });\n\n    /**\n     * Creates an object composed of keys generated from the results of running\n     * each element of the collection through the given callback. The corresponding\n     * value of each key is the last element responsible for generating the key.\n     * The callback is bound to `thisArg` and invoked with three arguments;\n     * (value, index|key, collection).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Object} Returns the composed aggregate object.\n     * @example\n     *\n     * var keys = [\n     *   { 'dir': 'left', 'code': 97 },\n     *   { 'dir': 'right', 'code': 100 }\n     * ];\n     *\n     * _.indexBy(keys, 'dir');\n     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }\n     *\n     * _.indexBy(keys, function(key) { return String.fromCharCode(key.code); });\n     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }\n     *\n     * _.indexBy(characters, function(key) { this.fromCharCode(key.code); }, String);\n     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }\n     */\n    var indexBy = createAggregator(function(result, value, key) {\n      result[key] = value;\n    });\n\n    /**\n     * Invokes the method named by `methodName` on each element in the `collection`\n     * returning an array of the results of each invoked method. Additional arguments\n     * will be provided to each invoked method. If `methodName` is a function it\n     * will be invoked for, and `this` bound to, each element in the `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|string} methodName The name of the method to invoke or\n     *  the function invoked per iteration.\n     * @param {...*} [arg] Arguments to invoke the method with.\n     * @returns {Array} Returns a new array of the results of each invoked method.\n     * @example\n     *\n     * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');\n     * // => [[1, 5, 7], [1, 2, 3]]\n     *\n     * _.invoke([123, 456], String.prototype.split, '');\n     * // => [['1', '2', '3'], ['4', '5', '6']]\n     */\n    function invoke(collection, methodName) {\n      var args = slice(arguments, 2),\n          index = -1,\n          isFunc = typeof methodName == 'function',\n          length = collection ? collection.length : 0,\n          result = Array(typeof length == 'number' ? length : 0);\n\n      forEach(collection, function(value) {\n        result[++index] = (isFunc ? methodName : value[methodName]).apply(value, args);\n      });\n      return result;\n    }\n\n    /**\n     * Creates an array of values by running each element in the collection\n     * through the callback. The callback is bound to `thisArg` and invoked with\n     * three arguments; (value, index|key, collection).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @alias collect\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Array} Returns a new array of the results of each `callback` execution.\n     * @example\n     *\n     * _.map([1, 2, 3], function(num) { return num * 3; });\n     * // => [3, 6, 9]\n     *\n     * _.map({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { return num * 3; });\n     * // => [3, 6, 9] (property order is not guaranteed across environments)\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36 },\n     *   { 'name': 'fred',   'age': 40 }\n     * ];\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.map(characters, 'name');\n     * // => ['barney', 'fred']\n     */\n    function map(collection, callback, thisArg) {\n      var index = -1,\n          length = collection ? collection.length : 0;\n\n      callback = lodash.createCallback(callback, thisArg, 3);\n      if (typeof length == 'number') {\n        var result = Array(length);\n        while (++index < length) {\n          result[index] = callback(collection[index], index, collection);\n        }\n      } else {\n        result = [];\n        forOwn(collection, function(value, key, collection) {\n          result[++index] = callback(value, key, collection);\n        });\n      }\n      return result;\n    }\n\n    /**\n     * Retrieves the maximum value of a collection. If the collection is empty or\n     * falsey `-Infinity` is returned. If a callback is provided it will be executed\n     * for each value in the collection to generate the criterion by which the value\n     * is ranked. The callback is bound to `thisArg` and invoked with three\n     * arguments; (value, index, collection).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {*} Returns the maximum value.\n     * @example\n     *\n     * _.max([4, 2, 8, 6]);\n     * // => 8\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36 },\n     *   { 'name': 'fred',   'age': 40 }\n     * ];\n     *\n     * _.max(characters, function(chr) { return chr.age; });\n     * // => { 'name': 'fred', 'age': 40 };\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.max(characters, 'age');\n     * // => { 'name': 'fred', 'age': 40 };\n     */\n    function max(collection, callback, thisArg) {\n      var computed = -Infinity,\n          result = computed;\n\n      // allows working with functions like `_.map` without using\n      // their `index` argument as a callback\n      if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {\n        callback = null;\n      }\n      if (callback == null && isArray(collection)) {\n        var index = -1,\n            length = collection.length;\n\n        while (++index < length) {\n          var value = collection[index];\n          if (value > result) {\n            result = value;\n          }\n        }\n      } else {\n        callback = (callback == null && isString(collection))\n          ? charAtCallback\n          : lodash.createCallback(callback, thisArg, 3);\n\n        forEach(collection, function(value, index, collection) {\n          var current = callback(value, index, collection);\n          if (current > computed) {\n            computed = current;\n            result = value;\n          }\n        });\n      }\n      return result;\n    }\n\n    /**\n     * Retrieves the minimum value of a collection. If the collection is empty or\n     * falsey `Infinity` is returned. If a callback is provided it will be executed\n     * for each value in the collection to generate the criterion by which the value\n     * is ranked. The callback is bound to `thisArg` and invoked with three\n     * arguments; (value, index, collection).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {*} Returns the minimum value.\n     * @example\n     *\n     * _.min([4, 2, 8, 6]);\n     * // => 2\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36 },\n     *   { 'name': 'fred',   'age': 40 }\n     * ];\n     *\n     * _.min(characters, function(chr) { return chr.age; });\n     * // => { 'name': 'barney', 'age': 36 };\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.min(characters, 'age');\n     * // => { 'name': 'barney', 'age': 36 };\n     */\n    function min(collection, callback, thisArg) {\n      var computed = Infinity,\n          result = computed;\n\n      // allows working with functions like `_.map` without using\n      // their `index` argument as a callback\n      if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {\n        callback = null;\n      }\n      if (callback == null && isArray(collection)) {\n        var index = -1,\n            length = collection.length;\n\n        while (++index < length) {\n          var value = collection[index];\n          if (value < result) {\n            result = value;\n          }\n        }\n      } else {\n        callback = (callback == null && isString(collection))\n          ? charAtCallback\n          : lodash.createCallback(callback, thisArg, 3);\n\n        forEach(collection, function(value, index, collection) {\n          var current = callback(value, index, collection);\n          if (current < computed) {\n            computed = current;\n            result = value;\n          }\n        });\n      }\n      return result;\n    }\n\n    /**\n     * Retrieves the value of a specified property from all elements in the collection.\n     *\n     * @static\n     * @memberOf _\n     * @type Function\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {string} property The name of the property to pluck.\n     * @returns {Array} Returns a new array of property values.\n     * @example\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36 },\n     *   { 'name': 'fred',   'age': 40 }\n     * ];\n     *\n     * _.pluck(characters, 'name');\n     * // => ['barney', 'fred']\n     */\n    var pluck = map;\n\n    /**\n     * Reduces a collection to a value which is the accumulated result of running\n     * each element in the collection through the callback, where each successive\n     * callback execution consumes the return value of the previous execution. If\n     * `accumulator` is not provided the first element of the collection will be\n     * used as the initial `accumulator` value. The callback is bound to `thisArg`\n     * and invoked with four arguments; (accumulator, value, index|key, collection).\n     *\n     * @static\n     * @memberOf _\n     * @alias foldl, inject\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function} [callback=identity] The function called per iteration.\n     * @param {*} [accumulator] Initial value of the accumulator.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {*} Returns the accumulated value.\n     * @example\n     *\n     * var sum = _.reduce([1, 2, 3], function(sum, num) {\n     *   return sum + num;\n     * });\n     * // => 6\n     *\n     * var mapped = _.reduce({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {\n     *   result[key] = num * 3;\n     *   return result;\n     * }, {});\n     * // => { 'a': 3, 'b': 6, 'c': 9 }\n     */\n    function reduce(collection, callback, accumulator, thisArg) {\n      if (!collection) return accumulator;\n      var noaccum = arguments.length < 3;\n      callback = lodash.createCallback(callback, thisArg, 4);\n\n      var index = -1,\n          length = collection.length;\n\n      if (typeof length == 'number') {\n        if (noaccum) {\n          accumulator = collection[++index];\n        }\n        while (++index < length) {\n          accumulator = callback(accumulator, collection[index], index, collection);\n        }\n      } else {\n        forOwn(collection, function(value, index, collection) {\n          accumulator = noaccum\n            ? (noaccum = false, value)\n            : callback(accumulator, value, index, collection)\n        });\n      }\n      return accumulator;\n    }\n\n    /**\n     * This method is like `_.reduce` except that it iterates over elements\n     * of a `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @alias foldr\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function} [callback=identity] The function called per iteration.\n     * @param {*} [accumulator] Initial value of the accumulator.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {*} Returns the accumulated value.\n     * @example\n     *\n     * var list = [[0, 1], [2, 3], [4, 5]];\n     * var flat = _.reduceRight(list, function(a, b) { return a.concat(b); }, []);\n     * // => [4, 5, 2, 3, 0, 1]\n     */\n    function reduceRight(collection, callback, accumulator, thisArg) {\n      var noaccum = arguments.length < 3;\n      callback = lodash.createCallback(callback, thisArg, 4);\n      forEachRight(collection, function(value, index, collection) {\n        accumulator = noaccum\n          ? (noaccum = false, value)\n          : callback(accumulator, value, index, collection);\n      });\n      return accumulator;\n    }\n\n    /**\n     * The opposite of `_.filter` this method returns the elements of a\n     * collection that the callback does **not** return truey for.\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Array} Returns a new array of elements that failed the callback check.\n     * @example\n     *\n     * var odds = _.reject([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });\n     * // => [1, 3, 5]\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36, 'blocked': false },\n     *   { 'name': 'fred',   'age': 40, 'blocked': true }\n     * ];\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.reject(characters, 'blocked');\n     * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]\n     *\n     * // using \"_.where\" callback shorthand\n     * _.reject(characters, { 'age': 36 });\n     * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]\n     */\n    function reject(collection, callback, thisArg) {\n      callback = lodash.createCallback(callback, thisArg, 3);\n      return filter(collection, function(value, index, collection) {\n        return !callback(value, index, collection);\n      });\n    }\n\n    /**\n     * Retrieves a random element or `n` random elements from a collection.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to sample.\n     * @param {number} [n] The number of elements to sample.\n     * @param- {Object} [guard] Allows working with functions like `_.map`\n     *  without using their `index` arguments as `n`.\n     * @returns {Array} Returns the random sample(s) of `collection`.\n     * @example\n     *\n     * _.sample([1, 2, 3, 4]);\n     * // => 2\n     *\n     * _.sample([1, 2, 3, 4], 2);\n     * // => [3, 1]\n     */\n    function sample(collection, n, guard) {\n      if (collection && typeof collection.length != 'number') {\n        collection = values(collection);\n      }\n      if (n == null || guard) {\n        return collection ? collection[baseRandom(0, collection.length - 1)] : undefined;\n      }\n      var result = shuffle(collection);\n      result.length = nativeMin(nativeMax(0, n), result.length);\n      return result;\n    }\n\n    /**\n     * Creates an array of shuffled values, using a version of the Fisher-Yates\n     * shuffle. See http://en.wikipedia.org/wiki/Fisher-Yates_shuffle.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to shuffle.\n     * @returns {Array} Returns a new shuffled collection.\n     * @example\n     *\n     * _.shuffle([1, 2, 3, 4, 5, 6]);\n     * // => [4, 1, 6, 3, 5, 2]\n     */\n    function shuffle(collection) {\n      var index = -1,\n          length = collection ? collection.length : 0,\n          result = Array(typeof length == 'number' ? length : 0);\n\n      forEach(collection, function(value) {\n        var rand = baseRandom(0, ++index);\n        result[index] = result[rand];\n        result[rand] = value;\n      });\n      return result;\n    }\n\n    /**\n     * Gets the size of the `collection` by returning `collection.length` for arrays\n     * and array-like objects or the number of own enumerable properties for objects.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to inspect.\n     * @returns {number} Returns `collection.length` or number of own enumerable properties.\n     * @example\n     *\n     * _.size([1, 2]);\n     * // => 2\n     *\n     * _.size({ 'one': 1, 'two': 2, 'three': 3 });\n     * // => 3\n     *\n     * _.size('pebbles');\n     * // => 7\n     */\n    function size(collection) {\n      var length = collection ? collection.length : 0;\n      return typeof length == 'number' ? length : keys(collection).length;\n    }\n\n    /**\n     * Checks if the callback returns a truey value for **any** element of a\n     * collection. The function returns as soon as it finds a passing value and\n     * does not iterate over the entire collection. The callback is bound to\n     * `thisArg` and invoked with three arguments; (value, index|key, collection).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @alias any\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {boolean} Returns `true` if any element passed the callback check,\n     *  else `false`.\n     * @example\n     *\n     * _.some([null, 0, 'yes', false], Boolean);\n     * // => true\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36, 'blocked': false },\n     *   { 'name': 'fred',   'age': 40, 'blocked': true }\n     * ];\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.some(characters, 'blocked');\n     * // => true\n     *\n     * // using \"_.where\" callback shorthand\n     * _.some(characters, { 'age': 1 });\n     * // => false\n     */\n    function some(collection, callback, thisArg) {\n      var result;\n      callback = lodash.createCallback(callback, thisArg, 3);\n\n      var index = -1,\n          length = collection ? collection.length : 0;\n\n      if (typeof length == 'number') {\n        while (++index < length) {\n          if ((result = callback(collection[index], index, collection))) {\n            break;\n          }\n        }\n      } else {\n        forOwn(collection, function(value, index, collection) {\n          return !(result = callback(value, index, collection));\n        });\n      }\n      return !!result;\n    }\n\n    /**\n     * Creates an array of elements, sorted in ascending order by the results of\n     * running each element in a collection through the callback. This method\n     * performs a stable sort, that is, it will preserve the original sort order\n     * of equal elements. The callback is bound to `thisArg` and invoked with\n     * three arguments; (value, index|key, collection).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an array of property names is provided for `callback` the collection\n     * will be sorted by each property value.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Array|Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Array} Returns a new array of sorted elements.\n     * @example\n     *\n     * _.sortBy([1, 2, 3], function(num) { return Math.sin(num); });\n     * // => [3, 1, 2]\n     *\n     * _.sortBy([1, 2, 3], function(num) { return this.sin(num); }, Math);\n     * // => [3, 1, 2]\n     *\n     * var characters = [\n     *   { 'name': 'barney',  'age': 36 },\n     *   { 'name': 'fred',    'age': 40 },\n     *   { 'name': 'barney',  'age': 26 },\n     *   { 'name': 'fred',    'age': 30 }\n     * ];\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.map(_.sortBy(characters, 'age'), _.values);\n     * // => [['barney', 26], ['fred', 30], ['barney', 36], ['fred', 40]]\n     *\n     * // sorting by multiple properties\n     * _.map(_.sortBy(characters, ['name', 'age']), _.values);\n     * // = > [['barney', 26], ['barney', 36], ['fred', 30], ['fred', 40]]\n     */\n    function sortBy(collection, callback, thisArg) {\n      var index = -1,\n          isArr = isArray(callback),\n          length = collection ? collection.length : 0,\n          result = Array(typeof length == 'number' ? length : 0);\n\n      if (!isArr) {\n        callback = lodash.createCallback(callback, thisArg, 3);\n      }\n      forEach(collection, function(value, key, collection) {\n        var object = result[++index] = getObject();\n        if (isArr) {\n          object.criteria = map(callback, function(key) { return value[key]; });\n        } else {\n          (object.criteria = getArray())[0] = callback(value, key, collection);\n        }\n        object.index = index;\n        object.value = value;\n      });\n\n      length = result.length;\n      result.sort(compareAscending);\n      while (length--) {\n        var object = result[length];\n        result[length] = object.value;\n        if (!isArr) {\n          releaseArray(object.criteria);\n        }\n        releaseObject(object);\n      }\n      return result;\n    }\n\n    /**\n     * Converts the `collection` to an array.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to convert.\n     * @returns {Array} Returns the new converted array.\n     * @example\n     *\n     * (function() { return _.toArray(arguments).slice(1); })(1, 2, 3, 4);\n     * // => [2, 3, 4]\n     */\n    function toArray(collection) {\n      if (collection && typeof collection.length == 'number') {\n        return slice(collection);\n      }\n      return values(collection);\n    }\n\n    /**\n     * Performs a deep comparison of each element in a `collection` to the given\n     * `properties` object, returning an array of all elements that have equivalent\n     * property values.\n     *\n     * @static\n     * @memberOf _\n     * @type Function\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Object} props The object of property values to filter by.\n     * @returns {Array} Returns a new array of elements that have the given properties.\n     * @example\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36, 'pets': ['hoppy'] },\n     *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }\n     * ];\n     *\n     * _.where(characters, { 'age': 36 });\n     * // => [{ 'name': 'barney', 'age': 36, 'pets': ['hoppy'] }]\n     *\n     * _.where(characters, { 'pets': ['dino'] });\n     * // => [{ 'name': 'fred', 'age': 40, 'pets': ['baby puss', 'dino'] }]\n     */\n    var where = filter;\n\n    /*--------------------------------------------------------------------------*/\n\n    /**\n     * Creates an array with all falsey values removed. The values `false`, `null`,\n     * `0`, `\"\"`, `undefined`, and `NaN` are all falsey.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to compact.\n     * @returns {Array} Returns a new array of filtered values.\n     * @example\n     *\n     * _.compact([0, 1, false, 2, '', 3]);\n     * // => [1, 2, 3]\n     */\n    function compact(array) {\n      var index = -1,\n          length = array ? array.length : 0,\n          result = [];\n\n      while (++index < length) {\n        var value = array[index];\n        if (value) {\n          result.push(value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Creates an array excluding all values of the provided arrays using strict\n     * equality for comparisons, i.e. `===`.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to process.\n     * @param {...Array} [values] The arrays of values to exclude.\n     * @returns {Array} Returns a new array of filtered values.\n     * @example\n     *\n     * _.difference([1, 2, 3, 4, 5], [5, 2, 10]);\n     * // => [1, 3, 4]\n     */\n    function difference(array) {\n      return baseDifference(array, baseFlatten(arguments, true, true, 1));\n    }\n\n    /**\n     * This method is like `_.find` except that it returns the index of the first\n     * element that passes the callback check, instead of the element itself.\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to search.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {number} Returns the index of the found element, else `-1`.\n     * @example\n     *\n     * var characters = [\n     *   { 'name': 'barney',  'age': 36, 'blocked': false },\n     *   { 'name': 'fred',    'age': 40, 'blocked': true },\n     *   { 'name': 'pebbles', 'age': 1,  'blocked': false }\n     * ];\n     *\n     * _.findIndex(characters, function(chr) {\n     *   return chr.age < 20;\n     * });\n     * // => 2\n     *\n     * // using \"_.where\" callback shorthand\n     * _.findIndex(characters, { 'age': 36 });\n     * // => 0\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.findIndex(characters, 'blocked');\n     * // => 1\n     */\n    function findIndex(array, callback, thisArg) {\n      var index = -1,\n          length = array ? array.length : 0;\n\n      callback = lodash.createCallback(callback, thisArg, 3);\n      while (++index < length) {\n        if (callback(array[index], index, array)) {\n          return index;\n        }\n      }\n      return -1;\n    }\n\n    /**\n     * This method is like `_.findIndex` except that it iterates over elements\n     * of a `collection` from right to left.\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to search.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {number} Returns the index of the found element, else `-1`.\n     * @example\n     *\n     * var characters = [\n     *   { 'name': 'barney',  'age': 36, 'blocked': true },\n     *   { 'name': 'fred',    'age': 40, 'blocked': false },\n     *   { 'name': 'pebbles', 'age': 1,  'blocked': true }\n     * ];\n     *\n     * _.findLastIndex(characters, function(chr) {\n     *   return chr.age > 30;\n     * });\n     * // => 1\n     *\n     * // using \"_.where\" callback shorthand\n     * _.findLastIndex(characters, { 'age': 36 });\n     * // => 0\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.findLastIndex(characters, 'blocked');\n     * // => 2\n     */\n    function findLastIndex(array, callback, thisArg) {\n      var length = array ? array.length : 0;\n      callback = lodash.createCallback(callback, thisArg, 3);\n      while (length--) {\n        if (callback(array[length], length, array)) {\n          return length;\n        }\n      }\n      return -1;\n    }\n\n    /**\n     * Gets the first element or first `n` elements of an array. If a callback\n     * is provided elements at the beginning of the array are returned as long\n     * as the callback returns truey. The callback is bound to `thisArg` and\n     * invoked with three arguments; (value, index, array).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @alias head, take\n     * @category Arrays\n     * @param {Array} array The array to query.\n     * @param {Function|Object|number|string} [callback] The function called\n     *  per element or the number of elements to return. If a property name or\n     *  object is provided it will be used to create a \"_.pluck\" or \"_.where\"\n     *  style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {*} Returns the first element(s) of `array`.\n     * @example\n     *\n     * _.first([1, 2, 3]);\n     * // => 1\n     *\n     * _.first([1, 2, 3], 2);\n     * // => [1, 2]\n     *\n     * _.first([1, 2, 3], function(num) {\n     *   return num < 3;\n     * });\n     * // => [1, 2]\n     *\n     * var characters = [\n     *   { 'name': 'barney',  'blocked': true,  'employer': 'slate' },\n     *   { 'name': 'fred',    'blocked': false, 'employer': 'slate' },\n     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }\n     * ];\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.first(characters, 'blocked');\n     * // => [{ 'name': 'barney', 'blocked': true, 'employer': 'slate' }]\n     *\n     * // using \"_.where\" callback shorthand\n     * _.pluck(_.first(characters, { 'employer': 'slate' }), 'name');\n     * // => ['barney', 'fred']\n     */\n    function first(array, callback, thisArg) {\n      var n = 0,\n          length = array ? array.length : 0;\n\n      if (typeof callback != 'number' && callback != null) {\n        var index = -1;\n        callback = lodash.createCallback(callback, thisArg, 3);\n        while (++index < length && callback(array[index], index, array)) {\n          n++;\n        }\n      } else {\n        n = callback;\n        if (n == null || thisArg) {\n          return array ? array[0] : undefined;\n        }\n      }\n      return slice(array, 0, nativeMin(nativeMax(0, n), length));\n    }\n\n    /**\n     * Flattens a nested array (the nesting can be to any depth). If `isShallow`\n     * is truey, the array will only be flattened a single level. If a callback\n     * is provided each element of the array is passed through the callback before\n     * flattening. The callback is bound to `thisArg` and invoked with three\n     * arguments; (value, index, array).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to flatten.\n     * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Array} Returns a new flattened array.\n     * @example\n     *\n     * _.flatten([1, [2], [3, [[4]]]]);\n     * // => [1, 2, 3, 4];\n     *\n     * _.flatten([1, [2], [3, [[4]]]], true);\n     * // => [1, 2, 3, [[4]]];\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 30, 'pets': ['hoppy'] },\n     *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }\n     * ];\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.flatten(characters, 'pets');\n     * // => ['hoppy', 'baby puss', 'dino']\n     */\n    function flatten(array, isShallow, callback, thisArg) {\n      // juggle arguments\n      if (typeof isShallow != 'boolean' && isShallow != null) {\n        thisArg = callback;\n        callback = (typeof isShallow != 'function' && thisArg && thisArg[isShallow] === array) ? null : isShallow;\n        isShallow = false;\n      }\n      if (callback != null) {\n        array = map(array, callback, thisArg);\n      }\n      return baseFlatten(array, isShallow);\n    }\n\n    /**\n     * Gets the index at which the first occurrence of `value` is found using\n     * strict equality for comparisons, i.e. `===`. If the array is already sorted\n     * providing `true` for `fromIndex` will run a faster binary search.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to search.\n     * @param {*} value The value to search for.\n     * @param {boolean|number} [fromIndex=0] The index to search from or `true`\n     *  to perform a binary search on a sorted array.\n     * @returns {number} Returns the index of the matched value or `-1`.\n     * @example\n     *\n     * _.indexOf([1, 2, 3, 1, 2, 3], 2);\n     * // => 1\n     *\n     * _.indexOf([1, 2, 3, 1, 2, 3], 2, 3);\n     * // => 4\n     *\n     * _.indexOf([1, 1, 2, 2, 3, 3], 2, true);\n     * // => 2\n     */\n    function indexOf(array, value, fromIndex) {\n      if (typeof fromIndex == 'number') {\n        var length = array ? array.length : 0;\n        fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex || 0);\n      } else if (fromIndex) {\n        var index = sortedIndex(array, value);\n        return array[index] === value ? index : -1;\n      }\n      return baseIndexOf(array, value, fromIndex);\n    }\n\n    /**\n     * Gets all but the last element or last `n` elements of an array. If a\n     * callback is provided elements at the end of the array are excluded from\n     * the result as long as the callback returns truey. The callback is bound\n     * to `thisArg` and invoked with three arguments; (value, index, array).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to query.\n     * @param {Function|Object|number|string} [callback=1] The function called\n     *  per element or the number of elements to exclude. If a property name or\n     *  object is provided it will be used to create a \"_.pluck\" or \"_.where\"\n     *  style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Array} Returns a slice of `array`.\n     * @example\n     *\n     * _.initial([1, 2, 3]);\n     * // => [1, 2]\n     *\n     * _.initial([1, 2, 3], 2);\n     * // => [1]\n     *\n     * _.initial([1, 2, 3], function(num) {\n     *   return num > 1;\n     * });\n     * // => [1]\n     *\n     * var characters = [\n     *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },\n     *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },\n     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }\n     * ];\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.initial(characters, 'blocked');\n     * // => [{ 'name': 'barney',  'blocked': false, 'employer': 'slate' }]\n     *\n     * // using \"_.where\" callback shorthand\n     * _.pluck(_.initial(characters, { 'employer': 'na' }), 'name');\n     * // => ['barney', 'fred']\n     */\n    function initial(array, callback, thisArg) {\n      var n = 0,\n          length = array ? array.length : 0;\n\n      if (typeof callback != 'number' && callback != null) {\n        var index = length;\n        callback = lodash.createCallback(callback, thisArg, 3);\n        while (index-- && callback(array[index], index, array)) {\n          n++;\n        }\n      } else {\n        n = (callback == null || thisArg) ? 1 : callback || n;\n      }\n      return slice(array, 0, nativeMin(nativeMax(0, length - n), length));\n    }\n\n    /**\n     * Creates an array of unique values present in all provided arrays using\n     * strict equality for comparisons, i.e. `===`.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {...Array} [array] The arrays to inspect.\n     * @returns {Array} Returns an array of shared values.\n     * @example\n     *\n     * _.intersection([1, 2, 3], [5, 2, 1, 4], [2, 1]);\n     * // => [1, 2]\n     */\n    function intersection() {\n      var args = [],\n          argsIndex = -1,\n          argsLength = arguments.length,\n          caches = getArray(),\n          indexOf = getIndexOf(),\n          trustIndexOf = indexOf === baseIndexOf,\n          seen = getArray();\n\n      while (++argsIndex < argsLength) {\n        var value = arguments[argsIndex];\n        if (isArray(value) || isArguments(value)) {\n          args.push(value);\n          caches.push(trustIndexOf && value.length >= largeArraySize &&\n            createCache(argsIndex ? args[argsIndex] : seen));\n        }\n      }\n      var array = args[0],\n          index = -1,\n          length = array ? array.length : 0,\n          result = [];\n\n      outer:\n      while (++index < length) {\n        var cache = caches[0];\n        value = array[index];\n\n        if ((cache ? cacheIndexOf(cache, value) : indexOf(seen, value)) < 0) {\n          argsIndex = argsLength;\n          (cache || seen).push(value);\n          while (--argsIndex) {\n            cache = caches[argsIndex];\n            if ((cache ? cacheIndexOf(cache, value) : indexOf(args[argsIndex], value)) < 0) {\n              continue outer;\n            }\n          }\n          result.push(value);\n        }\n      }\n      while (argsLength--) {\n        cache = caches[argsLength];\n        if (cache) {\n          releaseObject(cache);\n        }\n      }\n      releaseArray(caches);\n      releaseArray(seen);\n      return result;\n    }\n\n    /**\n     * Gets the last element or last `n` elements of an array. If a callback is\n     * provided elements at the end of the array are returned as long as the\n     * callback returns truey. The callback is bound to `thisArg` and invoked\n     * with three arguments; (value, index, array).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to query.\n     * @param {Function|Object|number|string} [callback] The function called\n     *  per element or the number of elements to return. If a property name or\n     *  object is provided it will be used to create a \"_.pluck\" or \"_.where\"\n     *  style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {*} Returns the last element(s) of `array`.\n     * @example\n     *\n     * _.last([1, 2, 3]);\n     * // => 3\n     *\n     * _.last([1, 2, 3], 2);\n     * // => [2, 3]\n     *\n     * _.last([1, 2, 3], function(num) {\n     *   return num > 1;\n     * });\n     * // => [2, 3]\n     *\n     * var characters = [\n     *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },\n     *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },\n     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }\n     * ];\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.pluck(_.last(characters, 'blocked'), 'name');\n     * // => ['fred', 'pebbles']\n     *\n     * // using \"_.where\" callback shorthand\n     * _.last(characters, { 'employer': 'na' });\n     * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]\n     */\n    function last(array, callback, thisArg) {\n      var n = 0,\n          length = array ? array.length : 0;\n\n      if (typeof callback != 'number' && callback != null) {\n        var index = length;\n        callback = lodash.createCallback(callback, thisArg, 3);\n        while (index-- && callback(array[index], index, array)) {\n          n++;\n        }\n      } else {\n        n = callback;\n        if (n == null || thisArg) {\n          return array ? array[length - 1] : undefined;\n        }\n      }\n      return slice(array, nativeMax(0, length - n));\n    }\n\n    /**\n     * Gets the index at which the last occurrence of `value` is found using strict\n     * equality for comparisons, i.e. `===`. If `fromIndex` is negative, it is used\n     * as the offset from the end of the collection.\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to search.\n     * @param {*} value The value to search for.\n     * @param {number} [fromIndex=array.length-1] The index to search from.\n     * @returns {number} Returns the index of the matched value or `-1`.\n     * @example\n     *\n     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2);\n     * // => 4\n     *\n     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2, 3);\n     * // => 1\n     */\n    function lastIndexOf(array, value, fromIndex) {\n      var index = array ? array.length : 0;\n      if (typeof fromIndex == 'number') {\n        index = (fromIndex < 0 ? nativeMax(0, index + fromIndex) : nativeMin(fromIndex, index - 1)) + 1;\n      }\n      while (index--) {\n        if (array[index] === value) {\n          return index;\n        }\n      }\n      return -1;\n    }\n\n    /**\n     * Removes all provided values from the given array using strict equality for\n     * comparisons, i.e. `===`.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to modify.\n     * @param {...*} [value] The values to remove.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = [1, 2, 3, 1, 2, 3];\n     * _.pull(array, 2, 3);\n     * console.log(array);\n     * // => [1, 1]\n     */\n    function pull(array) {\n      var args = arguments,\n          argsIndex = 0,\n          argsLength = args.length,\n          length = array ? array.length : 0;\n\n      while (++argsIndex < argsLength) {\n        var index = -1,\n            value = args[argsIndex];\n        while (++index < length) {\n          if (array[index] === value) {\n            splice.call(array, index--, 1);\n            length--;\n          }\n        }\n      }\n      return array;\n    }\n\n    /**\n     * Creates an array of numbers (positive and/or negative) progressing from\n     * `start` up to but not including `end`. If `start` is less than `stop` a\n     * zero-length range is created unless a negative `step` is specified.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {number} [start=0] The start of the range.\n     * @param {number} end The end of the range.\n     * @param {number} [step=1] The value to increment or decrement by.\n     * @returns {Array} Returns a new range array.\n     * @example\n     *\n     * _.range(4);\n     * // => [0, 1, 2, 3]\n     *\n     * _.range(1, 5);\n     * // => [1, 2, 3, 4]\n     *\n     * _.range(0, 20, 5);\n     * // => [0, 5, 10, 15]\n     *\n     * _.range(0, -4, -1);\n     * // => [0, -1, -2, -3]\n     *\n     * _.range(1, 4, 0);\n     * // => [1, 1, 1]\n     *\n     * _.range(0);\n     * // => []\n     */\n    function range(start, end, step) {\n      start = +start || 0;\n      step = typeof step == 'number' ? step : (+step || 1);\n\n      if (end == null) {\n        end = start;\n        start = 0;\n      }\n      // use `Array(length)` so engines like Chakra and V8 avoid slower modes\n      // http://youtu.be/XAqIpGU8ZZk#t=17m25s\n      var index = -1,\n          length = nativeMax(0, ceil((end - start) / (step || 1))),\n          result = Array(length);\n\n      while (++index < length) {\n        result[index] = start;\n        start += step;\n      }\n      return result;\n    }\n\n    /**\n     * Removes all elements from an array that the callback returns truey for\n     * and returns an array of removed elements. The callback is bound to `thisArg`\n     * and invoked with three arguments; (value, index, array).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to modify.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Array} Returns a new array of removed elements.\n     * @example\n     *\n     * var array = [1, 2, 3, 4, 5, 6];\n     * var evens = _.remove(array, function(num) { return num % 2 == 0; });\n     *\n     * console.log(array);\n     * // => [1, 3, 5]\n     *\n     * console.log(evens);\n     * // => [2, 4, 6]\n     */\n    function remove(array, callback, thisArg) {\n      var index = -1,\n          length = array ? array.length : 0,\n          result = [];\n\n      callback = lodash.createCallback(callback, thisArg, 3);\n      while (++index < length) {\n        var value = array[index];\n        if (callback(value, index, array)) {\n          result.push(value);\n          splice.call(array, index--, 1);\n          length--;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The opposite of `_.initial` this method gets all but the first element or\n     * first `n` elements of an array. If a callback function is provided elements\n     * at the beginning of the array are excluded from the result as long as the\n     * callback returns truey. The callback is bound to `thisArg` and invoked\n     * with three arguments; (value, index, array).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @alias drop, tail\n     * @category Arrays\n     * @param {Array} array The array to query.\n     * @param {Function|Object|number|string} [callback=1] The function called\n     *  per element or the number of elements to exclude. If a property name or\n     *  object is provided it will be used to create a \"_.pluck\" or \"_.where\"\n     *  style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Array} Returns a slice of `array`.\n     * @example\n     *\n     * _.rest([1, 2, 3]);\n     * // => [2, 3]\n     *\n     * _.rest([1, 2, 3], 2);\n     * // => [3]\n     *\n     * _.rest([1, 2, 3], function(num) {\n     *   return num < 3;\n     * });\n     * // => [3]\n     *\n     * var characters = [\n     *   { 'name': 'barney',  'blocked': true,  'employer': 'slate' },\n     *   { 'name': 'fred',    'blocked': false,  'employer': 'slate' },\n     *   { 'name': 'pebbles', 'blocked': true, 'employer': 'na' }\n     * ];\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.pluck(_.rest(characters, 'blocked'), 'name');\n     * // => ['fred', 'pebbles']\n     *\n     * // using \"_.where\" callback shorthand\n     * _.rest(characters, { 'employer': 'slate' });\n     * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]\n     */\n    function rest(array, callback, thisArg) {\n      if (typeof callback != 'number' && callback != null) {\n        var n = 0,\n            index = -1,\n            length = array ? array.length : 0;\n\n        callback = lodash.createCallback(callback, thisArg, 3);\n        while (++index < length && callback(array[index], index, array)) {\n          n++;\n        }\n      } else {\n        n = (callback == null || thisArg) ? 1 : nativeMax(0, callback);\n      }\n      return slice(array, n);\n    }\n\n    /**\n     * Uses a binary search to determine the smallest index at which a value\n     * should be inserted into a given sorted array in order to maintain the sort\n     * order of the array. If a callback is provided it will be executed for\n     * `value` and each element of `array` to compute their sort ranking. The\n     * callback is bound to `thisArg` and invoked with one argument; (value).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     * @example\n     *\n     * _.sortedIndex([20, 30, 50], 40);\n     * // => 2\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.sortedIndex([{ 'x': 20 }, { 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');\n     * // => 2\n     *\n     * var dict = {\n     *   'wordToNumber': { 'twenty': 20, 'thirty': 30, 'fourty': 40, 'fifty': 50 }\n     * };\n     *\n     * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {\n     *   return dict.wordToNumber[word];\n     * });\n     * // => 2\n     *\n     * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {\n     *   return this.wordToNumber[word];\n     * }, dict);\n     * // => 2\n     */\n    function sortedIndex(array, value, callback, thisArg) {\n      var low = 0,\n          high = array ? array.length : low;\n\n      // explicitly reference `identity` for better inlining in Firefox\n      callback = callback ? lodash.createCallback(callback, thisArg, 1) : identity;\n      value = callback(value);\n\n      while (low < high) {\n        var mid = (low + high) >>> 1;\n        (callback(array[mid]) < value)\n          ? low = mid + 1\n          : high = mid;\n      }\n      return low;\n    }\n\n    /**\n     * Creates an array of unique values, in order, of the provided arrays using\n     * strict equality for comparisons, i.e. `===`.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {...Array} [array] The arrays to inspect.\n     * @returns {Array} Returns an array of combined values.\n     * @example\n     *\n     * _.union([1, 2, 3], [5, 2, 1, 4], [2, 1]);\n     * // => [1, 2, 3, 5, 4]\n     */\n    function union() {\n      return baseUniq(baseFlatten(arguments, true, true));\n    }\n\n    /**\n     * Creates a duplicate-value-free version of an array using strict equality\n     * for comparisons, i.e. `===`. If the array is sorted, providing\n     * `true` for `isSorted` will use a faster algorithm. If a callback is provided\n     * each element of `array` is passed through the callback before uniqueness\n     * is computed. The callback is bound to `thisArg` and invoked with three\n     * arguments; (value, index, array).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @alias unique\n     * @category Arrays\n     * @param {Array} array The array to process.\n     * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Array} Returns a duplicate-value-free array.\n     * @example\n     *\n     * _.uniq([1, 2, 1, 3, 1]);\n     * // => [1, 2, 3]\n     *\n     * _.uniq([1, 1, 2, 2, 3], true);\n     * // => [1, 2, 3]\n     *\n     * _.uniq(['A', 'b', 'C', 'a', 'B', 'c'], function(letter) { return letter.toLowerCase(); });\n     * // => ['A', 'b', 'C']\n     *\n     * _.uniq([1, 2.5, 3, 1.5, 2, 3.5], function(num) { return this.floor(num); }, Math);\n     * // => [1, 2.5, 3]\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');\n     * // => [{ 'x': 1 }, { 'x': 2 }]\n     */\n    function uniq(array, isSorted, callback, thisArg) {\n      // juggle arguments\n      if (typeof isSorted != 'boolean' && isSorted != null) {\n        thisArg = callback;\n        callback = (typeof isSorted != 'function' && thisArg && thisArg[isSorted] === array) ? null : isSorted;\n        isSorted = false;\n      }\n      if (callback != null) {\n        callback = lodash.createCallback(callback, thisArg, 3);\n      }\n      return baseUniq(array, isSorted, callback);\n    }\n\n    /**\n     * Creates an array excluding all provided values using strict equality for\n     * comparisons, i.e. `===`.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to filter.\n     * @param {...*} [value] The values to exclude.\n     * @returns {Array} Returns a new array of filtered values.\n     * @example\n     *\n     * _.without([1, 2, 1, 0, 3, 1, 4], 0, 1);\n     * // => [2, 3, 4]\n     */\n    function without(array) {\n      return baseDifference(array, slice(arguments, 1));\n    }\n\n    /**\n     * Creates an array that is the symmetric difference of the provided arrays.\n     * See http://en.wikipedia.org/wiki/Symmetric_difference.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {...Array} [array] The arrays to inspect.\n     * @returns {Array} Returns an array of values.\n     * @example\n     *\n     * _.xor([1, 2, 3], [5, 2, 1, 4]);\n     * // => [3, 5, 4]\n     *\n     * _.xor([1, 2, 5], [2, 3, 5], [3, 4, 5]);\n     * // => [1, 4, 5]\n     */\n    function xor() {\n      var index = -1,\n          length = arguments.length;\n\n      while (++index < length) {\n        var array = arguments[index];\n        if (isArray(array) || isArguments(array)) {\n          var result = result\n            ? baseUniq(baseDifference(result, array).concat(baseDifference(array, result)))\n            : array;\n        }\n      }\n      return result || [];\n    }\n\n    /**\n     * Creates an array of grouped elements, the first of which contains the first\n     * elements of the given arrays, the second of which contains the second\n     * elements of the given arrays, and so on.\n     *\n     * @static\n     * @memberOf _\n     * @alias unzip\n     * @category Arrays\n     * @param {...Array} [array] Arrays to process.\n     * @returns {Array} Returns a new array of grouped elements.\n     * @example\n     *\n     * _.zip(['fred', 'barney'], [30, 40], [true, false]);\n     * // => [['fred', 30, true], ['barney', 40, false]]\n     */\n    function zip() {\n      var array = arguments.length > 1 ? arguments : arguments[0],\n          index = -1,\n          length = array ? max(pluck(array, 'length')) : 0,\n          result = Array(length < 0 ? 0 : length);\n\n      while (++index < length) {\n        result[index] = pluck(array, index);\n      }\n      return result;\n    }\n\n    /**\n     * Creates an object composed from arrays of `keys` and `values`. Provide\n     * either a single two dimensional array, i.e. `[[key1, value1], [key2, value2]]`\n     * or two arrays, one of `keys` and one of corresponding `values`.\n     *\n     * @static\n     * @memberOf _\n     * @alias object\n     * @category Arrays\n     * @param {Array} keys The array of keys.\n     * @param {Array} [values=[]] The array of values.\n     * @returns {Object} Returns an object composed of the given keys and\n     *  corresponding values.\n     * @example\n     *\n     * _.zipObject(['fred', 'barney'], [30, 40]);\n     * // => { 'fred': 30, 'barney': 40 }\n     */\n    function zipObject(keys, values) {\n      var index = -1,\n          length = keys ? keys.length : 0,\n          result = {};\n\n      if (!values && length && !isArray(keys[0])) {\n        values = [];\n      }\n      while (++index < length) {\n        var key = keys[index];\n        if (values) {\n          result[key] = values[index];\n        } else if (key) {\n          result[key[0]] = key[1];\n        }\n      }\n      return result;\n    }\n\n    /*--------------------------------------------------------------------------*/\n\n    /**\n     * Creates a function that executes `func`, with  the `this` binding and\n     * arguments of the created function, only after being called `n` times.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {number} n The number of times the function must be called before\n     *  `func` is executed.\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new restricted function.\n     * @example\n     *\n     * var saves = ['profile', 'settings'];\n     *\n     * var done = _.after(saves.length, function() {\n     *   console.log('Done saving!');\n     * });\n     *\n     * _.forEach(saves, function(type) {\n     *   asyncSave({ 'type': type, 'complete': done });\n     * });\n     * // => logs 'Done saving!', after all saves have completed\n     */\n    function after(n, func) {\n      if (!isFunction(func)) {\n        throw new TypeError;\n      }\n      return function() {\n        if (--n < 1) {\n          return func.apply(this, arguments);\n        }\n      };\n    }\n\n    /**\n     * Creates a function that, when called, invokes `func` with the `this`\n     * binding of `thisArg` and prepends any additional `bind` arguments to those\n     * provided to the bound function.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {Function} func The function to bind.\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @param {...*} [arg] Arguments to be partially applied.\n     * @returns {Function} Returns the new bound function.\n     * @example\n     *\n     * var func = function(greeting) {\n     *   return greeting + ' ' + this.name;\n     * };\n     *\n     * func = _.bind(func, { 'name': 'fred' }, 'hi');\n     * func();\n     * // => 'hi fred'\n     */\n    function bind(func, thisArg) {\n      return arguments.length > 2\n        ? createWrapper(func, 17, slice(arguments, 2), null, thisArg)\n        : createWrapper(func, 1, null, null, thisArg);\n    }\n\n    /**\n     * Binds methods of an object to the object itself, overwriting the existing\n     * method. Method names may be specified as individual arguments or as arrays\n     * of method names. If no method names are provided all the function properties\n     * of `object` will be bound.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {Object} object The object to bind and assign the bound methods to.\n     * @param {...string} [methodName] The object method names to\n     *  bind, specified as individual method names or arrays of method names.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var view = {\n     *   'label': 'docs',\n     *   'onClick': function() { console.log('clicked ' + this.label); }\n     * };\n     *\n     * _.bindAll(view);\n     * jQuery('#docs').on('click', view.onClick);\n     * // => logs 'clicked docs', when the button is clicked\n     */\n    function bindAll(object) {\n      var funcs = arguments.length > 1 ? baseFlatten(arguments, true, false, 1) : functions(object),\n          index = -1,\n          length = funcs.length;\n\n      while (++index < length) {\n        var key = funcs[index];\n        object[key] = createWrapper(object[key], 1, null, null, object);\n      }\n      return object;\n    }\n\n    /**\n     * Creates a function that, when called, invokes the method at `object[key]`\n     * and prepends any additional `bindKey` arguments to those provided to the bound\n     * function. This method differs from `_.bind` by allowing bound functions to\n     * reference methods that will be redefined or don't yet exist.\n     * See http://michaux.ca/articles/lazy-function-definition-pattern.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {Object} object The object the method belongs to.\n     * @param {string} key The key of the method.\n     * @param {...*} [arg] Arguments to be partially applied.\n     * @returns {Function} Returns the new bound function.\n     * @example\n     *\n     * var object = {\n     *   'name': 'fred',\n     *   'greet': function(greeting) {\n     *     return greeting + ' ' + this.name;\n     *   }\n     * };\n     *\n     * var func = _.bindKey(object, 'greet', 'hi');\n     * func();\n     * // => 'hi fred'\n     *\n     * object.greet = function(greeting) {\n     *   return greeting + 'ya ' + this.name + '!';\n     * };\n     *\n     * func();\n     * // => 'hiya fred!'\n     */\n    function bindKey(object, key) {\n      return arguments.length > 2\n        ? createWrapper(key, 19, slice(arguments, 2), null, object)\n        : createWrapper(key, 3, null, null, object);\n    }\n\n    /**\n     * Creates a function that is the composition of the provided functions,\n     * where each function consumes the return value of the function that follows.\n     * For example, composing the functions `f()`, `g()`, and `h()` produces `f(g(h()))`.\n     * Each function is executed with the `this` binding of the composed function.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {...Function} [func] Functions to compose.\n     * @returns {Function} Returns the new composed function.\n     * @example\n     *\n     * var realNameMap = {\n     *   'pebbles': 'penelope'\n     * };\n     *\n     * var format = function(name) {\n     *   name = realNameMap[name.toLowerCase()] || name;\n     *   return name.charAt(0).toUpperCase() + name.slice(1).toLowerCase();\n     * };\n     *\n     * var greet = function(formatted) {\n     *   return 'Hiya ' + formatted + '!';\n     * };\n     *\n     * var welcome = _.compose(greet, format);\n     * welcome('pebbles');\n     * // => 'Hiya Penelope!'\n     */\n    function compose() {\n      var funcs = arguments,\n          length = funcs.length;\n\n      while (length--) {\n        if (!isFunction(funcs[length])) {\n          throw new TypeError;\n        }\n      }\n      return function() {\n        var args = arguments,\n            length = funcs.length;\n\n        while (length--) {\n          args = [funcs[length].apply(this, args)];\n        }\n        return args[0];\n      };\n    }\n\n    /**\n     * Creates a function which accepts one or more arguments of `func` that when\n     * invoked either executes `func` returning its result, if all `func` arguments\n     * have been provided, or returns a function that accepts one or more of the\n     * remaining `func` arguments, and so on. The arity of `func` can be specified\n     * if `func.length` is not sufficient.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {Function} func The function to curry.\n     * @param {number} [arity=func.length] The arity of `func`.\n     * @returns {Function} Returns the new curried function.\n     * @example\n     *\n     * var curried = _.curry(function(a, b, c) {\n     *   console.log(a + b + c);\n     * });\n     *\n     * curried(1)(2)(3);\n     * // => 6\n     *\n     * curried(1, 2)(3);\n     * // => 6\n     *\n     * curried(1, 2, 3);\n     * // => 6\n     */\n    function curry(func, arity) {\n      arity = typeof arity == 'number' ? arity : (+arity || func.length);\n      return createWrapper(func, 4, null, null, null, arity);\n    }\n\n    /**\n     * Creates a function that will delay the execution of `func` until after\n     * `wait` milliseconds have elapsed since the last time it was invoked.\n     * Provide an options object to indicate that `func` should be invoked on\n     * the leading and/or trailing edge of the `wait` timeout. Subsequent calls\n     * to the debounced function will return the result of the last `func` call.\n     *\n     * Note: If `leading` and `trailing` options are `true` `func` will be called\n     * on the trailing edge of the timeout only if the the debounced function is\n     * invoked more than once during the `wait` timeout.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {Function} func The function to debounce.\n     * @param {number} wait The number of milliseconds to delay.\n     * @param {Object} [options] The options object.\n     * @param {boolean} [options.leading=false] Specify execution on the leading edge of the timeout.\n     * @param {number} [options.maxWait] The maximum time `func` is allowed to be delayed before it's called.\n     * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.\n     * @returns {Function} Returns the new debounced function.\n     * @example\n     *\n     * // avoid costly calculations while the window size is in flux\n     * var lazyLayout = _.debounce(calculateLayout, 150);\n     * jQuery(window).on('resize', lazyLayout);\n     *\n     * // execute `sendMail` when the click event is fired, debouncing subsequent calls\n     * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {\n     *   'leading': true,\n     *   'trailing': false\n     * });\n     *\n     * // ensure `batchLog` is executed once after 1 second of debounced calls\n     * var source = new EventSource('/stream');\n     * source.addEventListener('message', _.debounce(batchLog, 250, {\n     *   'maxWait': 1000\n     * }, false);\n     */\n    function debounce(func, wait, options) {\n      var args,\n          maxTimeoutId,\n          result,\n          stamp,\n          thisArg,\n          timeoutId,\n          trailingCall,\n          lastCalled = 0,\n          maxWait = false,\n          trailing = true;\n\n      if (!isFunction(func)) {\n        throw new TypeError;\n      }\n      wait = nativeMax(0, wait) || 0;\n      if (options === true) {\n        var leading = true;\n        trailing = false;\n      } else if (isObject(options)) {\n        leading = options.leading;\n        maxWait = 'maxWait' in options && (nativeMax(wait, options.maxWait) || 0);\n        trailing = 'trailing' in options ? options.trailing : trailing;\n      }\n      var delayed = function() {\n        var remaining = wait - (now() - stamp);\n        if (remaining <= 0) {\n          if (maxTimeoutId) {\n            clearTimeout(maxTimeoutId);\n          }\n          var isCalled = trailingCall;\n          maxTimeoutId = timeoutId = trailingCall = undefined;\n          if (isCalled) {\n            lastCalled = now();\n            result = func.apply(thisArg, args);\n            if (!timeoutId && !maxTimeoutId) {\n              args = thisArg = null;\n            }\n          }\n        } else {\n          timeoutId = setTimeout(delayed, remaining);\n        }\n      };\n\n      var maxDelayed = function() {\n        if (timeoutId) {\n          clearTimeout(timeoutId);\n        }\n        maxTimeoutId = timeoutId = trailingCall = undefined;\n        if (trailing || (maxWait !== wait)) {\n          lastCalled = now();\n          result = func.apply(thisArg, args);\n          if (!timeoutId && !maxTimeoutId) {\n            args = thisArg = null;\n          }\n        }\n      };\n\n      return function() {\n        args = arguments;\n        stamp = now();\n        thisArg = this;\n        trailingCall = trailing && (timeoutId || !leading);\n\n        if (maxWait === false) {\n          var leadingCall = leading && !timeoutId;\n        } else {\n          if (!maxTimeoutId && !leading) {\n            lastCalled = stamp;\n          }\n          var remaining = maxWait - (stamp - lastCalled),\n              isCalled = remaining <= 0;\n\n          if (isCalled) {\n            if (maxTimeoutId) {\n              maxTimeoutId = clearTimeout(maxTimeoutId);\n            }\n            lastCalled = stamp;\n            result = func.apply(thisArg, args);\n          }\n          else if (!maxTimeoutId) {\n            maxTimeoutId = setTimeout(maxDelayed, remaining);\n          }\n        }\n        if (isCalled && timeoutId) {\n          timeoutId = clearTimeout(timeoutId);\n        }\n        else if (!timeoutId && wait !== maxWait) {\n          timeoutId = setTimeout(delayed, wait);\n        }\n        if (leadingCall) {\n          isCalled = true;\n          result = func.apply(thisArg, args);\n        }\n        if (isCalled && !timeoutId && !maxTimeoutId) {\n          args = thisArg = null;\n        }\n        return result;\n      };\n    }\n\n    /**\n     * Defers executing the `func` function until the current call stack has cleared.\n     * Additional arguments will be provided to `func` when it is invoked.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {Function} func The function to defer.\n     * @param {...*} [arg] Arguments to invoke the function with.\n     * @returns {number} Returns the timer id.\n     * @example\n     *\n     * _.defer(function(text) { console.log(text); }, 'deferred');\n     * // logs 'deferred' after one or more milliseconds\n     */\n    function defer(func) {\n      if (!isFunction(func)) {\n        throw new TypeError;\n      }\n      var args = slice(arguments, 1);\n      return setTimeout(function() { func.apply(undefined, args); }, 1);\n    }\n\n    /**\n     * Executes the `func` function after `wait` milliseconds. Additional arguments\n     * will be provided to `func` when it is invoked.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {Function} func The function to delay.\n     * @param {number} wait The number of milliseconds to delay execution.\n     * @param {...*} [arg] Arguments to invoke the function with.\n     * @returns {number} Returns the timer id.\n     * @example\n     *\n     * _.delay(function(text) { console.log(text); }, 1000, 'later');\n     * // => logs 'later' after one second\n     */\n    function delay(func, wait) {\n      if (!isFunction(func)) {\n        throw new TypeError;\n      }\n      var args = slice(arguments, 2);\n      return setTimeout(function() { func.apply(undefined, args); }, wait);\n    }\n\n    /**\n     * Creates a function that memoizes the result of `func`. If `resolver` is\n     * provided it will be used to determine the cache key for storing the result\n     * based on the arguments provided to the memoized function. By default, the\n     * first argument provided to the memoized function is used as the cache key.\n     * The `func` is executed with the `this` binding of the memoized function.\n     * The result cache is exposed as the `cache` property on the memoized function.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {Function} func The function to have its output memoized.\n     * @param {Function} [resolver] A function used to resolve the cache key.\n     * @returns {Function} Returns the new memoizing function.\n     * @example\n     *\n     * var fibonacci = _.memoize(function(n) {\n     *   return n < 2 ? n : fibonacci(n - 1) + fibonacci(n - 2);\n     * });\n     *\n     * fibonacci(9)\n     * // => 34\n     *\n     * var data = {\n     *   'fred': { 'name': 'fred', 'age': 40 },\n     *   'pebbles': { 'name': 'pebbles', 'age': 1 }\n     * };\n     *\n     * // modifying the result cache\n     * var get = _.memoize(function(name) { return data[name]; }, _.identity);\n     * get('pebbles');\n     * // => { 'name': 'pebbles', 'age': 1 }\n     *\n     * get.cache.pebbles.name = 'penelope';\n     * get('pebbles');\n     * // => { 'name': 'penelope', 'age': 1 }\n     */\n    function memoize(func, resolver) {\n      if (!isFunction(func)) {\n        throw new TypeError;\n      }\n      var memoized = function() {\n        var cache = memoized.cache,\n            key = resolver ? resolver.apply(this, arguments) : keyPrefix + arguments[0];\n\n        return hasOwnProperty.call(cache, key)\n          ? cache[key]\n          : (cache[key] = func.apply(this, arguments));\n      }\n      memoized.cache = {};\n      return memoized;\n    }\n\n    /**\n     * Creates a function that is restricted to execute `func` once. Repeat calls to\n     * the function will return the value of the first call. The `func` is executed\n     * with the `this` binding of the created function.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new restricted function.\n     * @example\n     *\n     * var initialize = _.once(createApplication);\n     * initialize();\n     * initialize();\n     * // `initialize` executes `createApplication` once\n     */\n    function once(func) {\n      var ran,\n          result;\n\n      if (!isFunction(func)) {\n        throw new TypeError;\n      }\n      return function() {\n        if (ran) {\n          return result;\n        }\n        ran = true;\n        result = func.apply(this, arguments);\n\n        // clear the `func` variable so the function may be garbage collected\n        func = null;\n        return result;\n      };\n    }\n\n    /**\n     * Creates a function that, when called, invokes `func` with any additional\n     * `partial` arguments prepended to those provided to the new function. This\n     * method is similar to `_.bind` except it does **not** alter the `this` binding.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {Function} func The function to partially apply arguments to.\n     * @param {...*} [arg] Arguments to be partially applied.\n     * @returns {Function} Returns the new partially applied function.\n     * @example\n     *\n     * var greet = function(greeting, name) { return greeting + ' ' + name; };\n     * var hi = _.partial(greet, 'hi');\n     * hi('fred');\n     * // => 'hi fred'\n     */\n    function partial(func) {\n      return createWrapper(func, 16, slice(arguments, 1));\n    }\n\n    /**\n     * This method is like `_.partial` except that `partial` arguments are\n     * appended to those provided to the new function.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {Function} func The function to partially apply arguments to.\n     * @param {...*} [arg] Arguments to be partially applied.\n     * @returns {Function} Returns the new partially applied function.\n     * @example\n     *\n     * var defaultsDeep = _.partialRight(_.merge, _.defaults);\n     *\n     * var options = {\n     *   'variable': 'data',\n     *   'imports': { 'jq': $ }\n     * };\n     *\n     * defaultsDeep(options, _.templateSettings);\n     *\n     * options.variable\n     * // => 'data'\n     *\n     * options.imports\n     * // => { '_': _, 'jq': $ }\n     */\n    function partialRight(func) {\n      return createWrapper(func, 32, null, slice(arguments, 1));\n    }\n\n    /**\n     * Creates a function that, when executed, will only call the `func` function\n     * at most once per every `wait` milliseconds. Provide an options object to\n     * indicate that `func` should be invoked on the leading and/or trailing edge\n     * of the `wait` timeout. Subsequent calls to the throttled function will\n     * return the result of the last `func` call.\n     *\n     * Note: If `leading` and `trailing` options are `true` `func` will be called\n     * on the trailing edge of the timeout only if the the throttled function is\n     * invoked more than once during the `wait` timeout.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {Function} func The function to throttle.\n     * @param {number} wait The number of milliseconds to throttle executions to.\n     * @param {Object} [options] The options object.\n     * @param {boolean} [options.leading=true] Specify execution on the leading edge of the timeout.\n     * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.\n     * @returns {Function} Returns the new throttled function.\n     * @example\n     *\n     * // avoid excessively updating the position while scrolling\n     * var throttled = _.throttle(updatePosition, 100);\n     * jQuery(window).on('scroll', throttled);\n     *\n     * // execute `renewToken` when the click event is fired, but not more than once every 5 minutes\n     * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {\n     *   'trailing': false\n     * }));\n     */\n    function throttle(func, wait, options) {\n      var leading = true,\n          trailing = true;\n\n      if (!isFunction(func)) {\n        throw new TypeError;\n      }\n      if (options === false) {\n        leading = false;\n      } else if (isObject(options)) {\n        leading = 'leading' in options ? options.leading : leading;\n        trailing = 'trailing' in options ? options.trailing : trailing;\n      }\n      debounceOptions.leading = leading;\n      debounceOptions.maxWait = wait;\n      debounceOptions.trailing = trailing;\n\n      return debounce(func, wait, debounceOptions);\n    }\n\n    /**\n     * Creates a function that provides `value` to the wrapper function as its\n     * first argument. Additional arguments provided to the function are appended\n     * to those provided to the wrapper function. The wrapper is executed with\n     * the `this` binding of the created function.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {*} value The value to wrap.\n     * @param {Function} wrapper The wrapper function.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var p = _.wrap(_.escape, function(func, text) {\n     *   return '<p>' + func(text) + '</p>';\n     * });\n     *\n     * p('Fred, Wilma, & Pebbles');\n     * // => '<p>Fred, Wilma, &amp; Pebbles</p>'\n     */\n    function wrap(value, wrapper) {\n      return createWrapper(wrapper, 16, [value]);\n    }\n\n    /*--------------------------------------------------------------------------*/\n\n    /**\n     * Creates a function that returns `value`.\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @param {*} value The value to return from the new function.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var object = { 'name': 'fred' };\n     * var getter = _.constant(object);\n     * getter() === object;\n     * // => true\n     */\n    function constant(value) {\n      return function() {\n        return value;\n      };\n    }\n\n    /**\n     * Produces a callback bound to an optional `thisArg`. If `func` is a property\n     * name the created callback will return the property value for a given element.\n     * If `func` is an object the created callback will return `true` for elements\n     * that contain the equivalent object properties, otherwise it will return `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @param {*} [func=identity] The value to convert to a callback.\n     * @param {*} [thisArg] The `this` binding of the created callback.\n     * @param {number} [argCount] The number of arguments the callback accepts.\n     * @returns {Function} Returns a callback function.\n     * @example\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36 },\n     *   { 'name': 'fred',   'age': 40 }\n     * ];\n     *\n     * // wrap to create custom callback shorthands\n     * _.createCallback = _.wrap(_.createCallback, function(func, callback, thisArg) {\n     *   var match = /^(.+?)__([gl]t)(.+)$/.exec(callback);\n     *   return !match ? func(callback, thisArg) : function(object) {\n     *     return match[2] == 'gt' ? object[match[1]] > match[3] : object[match[1]] < match[3];\n     *   };\n     * });\n     *\n     * _.filter(characters, 'age__gt38');\n     * // => [{ 'name': 'fred', 'age': 40 }]\n     */\n    function createCallback(func, thisArg, argCount) {\n      var type = typeof func;\n      if (func == null || type == 'function') {\n        return baseCreateCallback(func, thisArg, argCount);\n      }\n      // handle \"_.pluck\" style callback shorthands\n      if (type != 'object') {\n        return property(func);\n      }\n      var props = keys(func),\n          key = props[0],\n          a = func[key];\n\n      // handle \"_.where\" style callback shorthands\n      if (props.length == 1 && a === a && !isObject(a)) {\n        // fast path the common case of providing an object with a single\n        // property containing a primitive value\n        return function(object) {\n          var b = object[key];\n          return a === b && (a !== 0 || (1 / a == 1 / b));\n        };\n      }\n      return function(object) {\n        var length = props.length,\n            result = false;\n\n        while (length--) {\n          if (!(result = baseIsEqual(object[props[length]], func[props[length]], null, true))) {\n            break;\n          }\n        }\n        return result;\n      };\n    }\n\n    /**\n     * Converts the characters `&`, `<`, `>`, `\"`, and `'` in `string` to their\n     * corresponding HTML entities.\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @param {string} string The string to escape.\n     * @returns {string} Returns the escaped string.\n     * @example\n     *\n     * _.escape('Fred, Wilma, & Pebbles');\n     * // => 'Fred, Wilma, &amp; Pebbles'\n     */\n    function escape(string) {\n      return string == null ? '' : String(string).replace(reUnescapedHtml, escapeHtmlChar);\n    }\n\n    /**\n     * This method returns the first argument provided to it.\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @param {*} value Any value.\n     * @returns {*} Returns `value`.\n     * @example\n     *\n     * var object = { 'name': 'fred' };\n     * _.identity(object) === object;\n     * // => true\n     */\n    function identity(value) {\n      return value;\n    }\n\n    /**\n     * Adds function properties of a source object to the destination object.\n     * If `object` is a function methods will be added to its prototype as well.\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @param {Function|Object} [object=lodash] object The destination object.\n     * @param {Object} source The object of functions to add.\n     * @param {Object} [options] The options object.\n     * @param {boolean} [options.chain=true] Specify whether the functions added are chainable.\n     * @example\n     *\n     * function capitalize(string) {\n     *   return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();\n     * }\n     *\n     * _.mixin({ 'capitalize': capitalize });\n     * _.capitalize('fred');\n     * // => 'Fred'\n     *\n     * _('fred').capitalize().value();\n     * // => 'Fred'\n     *\n     * _.mixin({ 'capitalize': capitalize }, { 'chain': false });\n     * _('fred').capitalize();\n     * // => 'Fred'\n     */\n    function mixin(object, source, options) {\n      var chain = true,\n          methodNames = source && functions(source);\n\n      if (!source || (!options && !methodNames.length)) {\n        if (options == null) {\n          options = source;\n        }\n        ctor = lodashWrapper;\n        source = object;\n        object = lodash;\n        methodNames = functions(source);\n      }\n      if (options === false) {\n        chain = false;\n      } else if (isObject(options) && 'chain' in options) {\n        chain = options.chain;\n      }\n      var ctor = object,\n          isFunc = isFunction(ctor);\n\n      forEach(methodNames, function(methodName) {\n        var func = object[methodName] = source[methodName];\n        if (isFunc) {\n          ctor.prototype[methodName] = function() {\n            var chainAll = this.__chain__,\n                value = this.__wrapped__,\n                args = [value];\n\n            push.apply(args, arguments);\n            var result = func.apply(object, args);\n            if (chain || chainAll) {\n              if (value === result && isObject(result)) {\n                return this;\n              }\n              result = new ctor(result);\n              result.__chain__ = chainAll;\n            }\n            return result;\n          };\n        }\n      });\n    }\n\n    /**\n     * Reverts the '_' variable to its previous value and returns a reference to\n     * the `lodash` function.\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @returns {Function} Returns the `lodash` function.\n     * @example\n     *\n     * var lodash = _.noConflict();\n     */\n    function noConflict() {\n      context._ = oldDash;\n      return this;\n    }\n\n    /**\n     * A no-operation function.\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @example\n     *\n     * var object = { 'name': 'fred' };\n     * _.noop(object) === undefined;\n     * // => true\n     */\n    function noop() {\n      // no operation performed\n    }\n\n    /**\n     * Gets the number of milliseconds that have elapsed since the Unix epoch\n     * (1 January 1970 00:00:00 UTC).\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @example\n     *\n     * var stamp = _.now();\n     * _.defer(function() { console.log(_.now() - stamp); });\n     * // => logs the number of milliseconds it took for the deferred function to be called\n     */\n    var now = isNative(now = Date.now) && now || function() {\n      return new Date().getTime();\n    };\n\n    /**\n     * Converts the given value into an integer of the specified radix.\n     * If `radix` is `undefined` or `0` a `radix` of `10` is used unless the\n     * `value` is a hexadecimal, in which case a `radix` of `16` is used.\n     *\n     * Note: This method avoids differences in native ES3 and ES5 `parseInt`\n     * implementations. See http://es5.github.io/#E.\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @param {string} value The value to parse.\n     * @param {number} [radix] The radix used to interpret the value to parse.\n     * @returns {number} Returns the new integer value.\n     * @example\n     *\n     * _.parseInt('08');\n     * // => 8\n     */\n    var parseInt = nativeParseInt(whitespace + '08') == 8 ? nativeParseInt : function(value, radix) {\n      // Firefox < 21 and Opera < 15 follow the ES3 specified implementation of `parseInt`\n      return nativeParseInt(isString(value) ? value.replace(reLeadingSpacesAndZeros, '') : value, radix || 0);\n    };\n\n    /**\n     * Creates a \"_.pluck\" style function, which returns the `key` value of a\n     * given object.\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @param {string} key The name of the property to retrieve.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var characters = [\n     *   { 'name': 'fred',   'age': 40 },\n     *   { 'name': 'barney', 'age': 36 }\n     * ];\n     *\n     * var getName = _.property('name');\n     *\n     * _.map(characters, getName);\n     * // => ['barney', 'fred']\n     *\n     * _.sortBy(characters, getName);\n     * // => [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred',   'age': 40 }]\n     */\n    function property(key) {\n      return function(object) {\n        return object[key];\n      };\n    }\n\n    /**\n     * Produces a random number between `min` and `max` (inclusive). If only one\n     * argument is provided a number between `0` and the given number will be\n     * returned. If `floating` is truey or either `min` or `max` are floats a\n     * floating-point number will be returned instead of an integer.\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @param {number} [min=0] The minimum possible value.\n     * @param {number} [max=1] The maximum possible value.\n     * @param {boolean} [floating=false] Specify returning a floating-point number.\n     * @returns {number} Returns a random number.\n     * @example\n     *\n     * _.random(0, 5);\n     * // => an integer between 0 and 5\n     *\n     * _.random(5);\n     * // => also an integer between 0 and 5\n     *\n     * _.random(5, true);\n     * // => a floating-point number between 0 and 5\n     *\n     * _.random(1.2, 5.2);\n     * // => a floating-point number between 1.2 and 5.2\n     */\n    function random(min, max, floating) {\n      var noMin = min == null,\n          noMax = max == null;\n\n      if (floating == null) {\n        if (typeof min == 'boolean' && noMax) {\n          floating = min;\n          min = 1;\n        }\n        else if (!noMax && typeof max == 'boolean') {\n          floating = max;\n          noMax = true;\n        }\n      }\n      if (noMin && noMax) {\n        max = 1;\n      }\n      min = +min || 0;\n      if (noMax) {\n        max = min;\n        min = 0;\n      } else {\n        max = +max || 0;\n      }\n      if (floating || min % 1 || max % 1) {\n        var rand = nativeRandom();\n        return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand +'').length - 1)))), max);\n      }\n      return baseRandom(min, max);\n    }\n\n    /**\n     * Resolves the value of property `key` on `object`. If `key` is a function\n     * it will be invoked with the `this` binding of `object` and its result returned,\n     * else the property value is returned. If `object` is falsey then `undefined`\n     * is returned.\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @param {Object} object The object to inspect.\n     * @param {string} key The name of the property to resolve.\n     * @returns {*} Returns the resolved value.\n     * @example\n     *\n     * var object = {\n     *   'cheese': 'crumpets',\n     *   'stuff': function() {\n     *     return 'nonsense';\n     *   }\n     * };\n     *\n     * _.result(object, 'cheese');\n     * // => 'crumpets'\n     *\n     * _.result(object, 'stuff');\n     * // => 'nonsense'\n     */\n    function result(object, key) {\n      if (object) {\n        var value = object[key];\n        return isFunction(value) ? object[key]() : value;\n      }\n    }\n\n    /**\n     * A micro-templating method that handles arbitrary delimiters, preserves\n     * whitespace, and correctly escapes quotes within interpolated code.\n     *\n     * Note: In the development build, `_.template` utilizes sourceURLs for easier\n     * debugging. See http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl\n     *\n     * For more information on precompiling templates see:\n     * https://lodash.com/custom-builds\n     *\n     * For more information on Chrome extension sandboxes see:\n     * http://developer.chrome.com/stable/extensions/sandboxingEval.html\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @param {string} text The template text.\n     * @param {Object} data The data object used to populate the text.\n     * @param {Object} [options] The options object.\n     * @param {RegExp} [options.escape] The \"escape\" delimiter.\n     * @param {RegExp} [options.evaluate] The \"evaluate\" delimiter.\n     * @param {Object} [options.imports] An object to import into the template as local variables.\n     * @param {RegExp} [options.interpolate] The \"interpolate\" delimiter.\n     * @param {string} [sourceURL] The sourceURL of the template's compiled source.\n     * @param {string} [variable] The data object variable name.\n     * @returns {Function|string} Returns a compiled function when no `data` object\n     *  is given, else it returns the interpolated text.\n     * @example\n     *\n     * // using the \"interpolate\" delimiter to create a compiled template\n     * var compiled = _.template('hello <%= name %>');\n     * compiled({ 'name': 'fred' });\n     * // => 'hello fred'\n     *\n     * // using the \"escape\" delimiter to escape HTML in data property values\n     * _.template('<b><%- value %></b>', { 'value': '<script>' });\n     * // => '<b>&lt;script&gt;</b>'\n     *\n     * // using the \"evaluate\" delimiter to generate HTML\n     * var list = '<% _.forEach(people, function(name) { %><li><%- name %></li><% }); %>';\n     * _.template(list, { 'people': ['fred', 'barney'] });\n     * // => '<li>fred</li><li>barney</li>'\n     *\n     * // using the ES6 delimiter as an alternative to the default \"interpolate\" delimiter\n     * _.template('hello ${ name }', { 'name': 'pebbles' });\n     * // => 'hello pebbles'\n     *\n     * // using the internal `print` function in \"evaluate\" delimiters\n     * _.template('<% print(\"hello \" + name); %>!', { 'name': 'barney' });\n     * // => 'hello barney!'\n     *\n     * // using a custom template delimiters\n     * _.templateSettings = {\n     *   'interpolate': /{{([\\s\\S]+?)}}/g\n     * };\n     *\n     * _.template('hello {{ name }}!', { 'name': 'mustache' });\n     * // => 'hello mustache!'\n     *\n     * // using the `imports` option to import jQuery\n     * var list = '<% jq.each(people, function(name) { %><li><%- name %></li><% }); %>';\n     * _.template(list, { 'people': ['fred', 'barney'] }, { 'imports': { 'jq': jQuery } });\n     * // => '<li>fred</li><li>barney</li>'\n     *\n     * // using the `sourceURL` option to specify a custom sourceURL for the template\n     * var compiled = _.template('hello <%= name %>', null, { 'sourceURL': '/basic/greeting.jst' });\n     * compiled(data);\n     * // => find the source of \"greeting.jst\" under the Sources tab or Resources panel of the web inspector\n     *\n     * // using the `variable` option to ensure a with-statement isn't used in the compiled template\n     * var compiled = _.template('hi <%= data.name %>!', null, { 'variable': 'data' });\n     * compiled.source;\n     * // => function(data) {\n     *   var __t, __p = '', __e = _.escape;\n     *   __p += 'hi ' + ((__t = ( data.name )) == null ? '' : __t) + '!';\n     *   return __p;\n     * }\n     *\n     * // using the `source` property to inline compiled templates for meaningful\n     * // line numbers in error messages and a stack trace\n     * fs.writeFileSync(path.join(cwd, 'jst.js'), '\\\n     *   var JST = {\\\n     *     \"main\": ' + _.template(mainText).source + '\\\n     *   };\\\n     * ');\n     */\n    function template(text, data, options) {\n      // based on John Resig's `tmpl` implementation\n      // http://ejohn.org/blog/javascript-micro-templating/\n      // and Laura Doktorova's doT.js\n      // https://github.com/olado/doT\n      var settings = lodash.templateSettings;\n      text = String(text || '');\n\n      // avoid missing dependencies when `iteratorTemplate` is not defined\n      options = defaults({}, options, settings);\n\n      var imports = defaults({}, options.imports, settings.imports),\n          importsKeys = keys(imports),\n          importsValues = values(imports);\n\n      var isEvaluating,\n          index = 0,\n          interpolate = options.interpolate || reNoMatch,\n          source = \"__p += '\";\n\n      // compile the regexp to match each delimiter\n      var reDelimiters = RegExp(\n        (options.escape || reNoMatch).source + '|' +\n        interpolate.source + '|' +\n        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +\n        (options.evaluate || reNoMatch).source + '|$'\n      , 'g');\n\n      text.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {\n        interpolateValue || (interpolateValue = esTemplateValue);\n\n        // escape characters that cannot be included in string literals\n        source += text.slice(index, offset).replace(reUnescapedString, escapeStringChar);\n\n        // replace delimiters with snippets\n        if (escapeValue) {\n          source += \"' +\\n__e(\" + escapeValue + \") +\\n'\";\n        }\n        if (evaluateValue) {\n          isEvaluating = true;\n          source += \"';\\n\" + evaluateValue + \";\\n__p += '\";\n        }\n        if (interpolateValue) {\n          source += \"' +\\n((__t = (\" + interpolateValue + \")) == null ? '' : __t) +\\n'\";\n        }\n        index = offset + match.length;\n\n        // the JS engine embedded in Adobe products requires returning the `match`\n        // string in order to produce the correct `offset` value\n        return match;\n      });\n\n      source += \"';\\n\";\n\n      // if `variable` is not specified, wrap a with-statement around the generated\n      // code to add the data object to the top of the scope chain\n      var variable = options.variable,\n          hasVariable = variable;\n\n      if (!hasVariable) {\n        variable = 'obj';\n        source = 'with (' + variable + ') {\\n' + source + '\\n}\\n';\n      }\n      // cleanup code by stripping empty strings\n      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)\n        .replace(reEmptyStringMiddle, '$1')\n        .replace(reEmptyStringTrailing, '$1;');\n\n      // frame code as the function body\n      source = 'function(' + variable + ') {\\n' +\n        (hasVariable ? '' : variable + ' || (' + variable + ' = {});\\n') +\n        \"var __t, __p = '', __e = _.escape\" +\n        (isEvaluating\n          ? ', __j = Array.prototype.join;\\n' +\n            \"function print() { __p += __j.call(arguments, '') }\\n\"\n          : ';\\n'\n        ) +\n        source +\n        'return __p\\n}';\n\n      // Use a sourceURL for easier debugging.\n      // http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl\n      var sourceURL = '\\n/*\\n//# sourceURL=' + (options.sourceURL || '/lodash/template/source[' + (templateCounter++) + ']') + '\\n*/';\n\n      try {\n        var result = Function(importsKeys, 'return ' + source + sourceURL).apply(undefined, importsValues);\n      } catch(e) {\n        e.source = source;\n        throw e;\n      }\n      if (data) {\n        return result(data);\n      }\n      // provide the compiled function's source by its `toString` method, in\n      // supported environments, or the `source` property as a convenience for\n      // inlining compiled templates during the build process\n      result.source = source;\n      return result;\n    }\n\n    /**\n     * Executes the callback `n` times, returning an array of the results\n     * of each callback execution. The callback is bound to `thisArg` and invoked\n     * with one argument; (index).\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @param {number} n The number of times to execute the callback.\n     * @param {Function} callback The function called per iteration.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Array} Returns an array of the results of each `callback` execution.\n     * @example\n     *\n     * var diceRolls = _.times(3, _.partial(_.random, 1, 6));\n     * // => [3, 6, 4]\n     *\n     * _.times(3, function(n) { mage.castSpell(n); });\n     * // => calls `mage.castSpell(n)` three times, passing `n` of `0`, `1`, and `2` respectively\n     *\n     * _.times(3, function(n) { this.cast(n); }, mage);\n     * // => also calls `mage.castSpell(n)` three times\n     */\n    function times(n, callback, thisArg) {\n      n = (n = +n) > -1 ? n : 0;\n      var index = -1,\n          result = Array(n);\n\n      callback = baseCreateCallback(callback, thisArg, 1);\n      while (++index < n) {\n        result[index] = callback(index);\n      }\n      return result;\n    }\n\n    /**\n     * The inverse of `_.escape` this method converts the HTML entities\n     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to their\n     * corresponding characters.\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @param {string} string The string to unescape.\n     * @returns {string} Returns the unescaped string.\n     * @example\n     *\n     * _.unescape('Fred, Barney &amp; Pebbles');\n     * // => 'Fred, Barney & Pebbles'\n     */\n    function unescape(string) {\n      return string == null ? '' : String(string).replace(reEscapedHtml, unescapeHtmlChar);\n    }\n\n    /**\n     * Generates a unique ID. If `prefix` is provided the ID will be appended to it.\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @param {string} [prefix] The value to prefix the ID with.\n     * @returns {string} Returns the unique ID.\n     * @example\n     *\n     * _.uniqueId('contact_');\n     * // => 'contact_104'\n     *\n     * _.uniqueId();\n     * // => '105'\n     */\n    function uniqueId(prefix) {\n      var id = ++idCounter;\n      return String(prefix == null ? '' : prefix) + id;\n    }\n\n    /*--------------------------------------------------------------------------*/\n\n    /**\n     * Creates a `lodash` object that wraps the given value with explicit\n     * method chaining enabled.\n     *\n     * @static\n     * @memberOf _\n     * @category Chaining\n     * @param {*} value The value to wrap.\n     * @returns {Object} Returns the wrapper object.\n     * @example\n     *\n     * var characters = [\n     *   { 'name': 'barney',  'age': 36 },\n     *   { 'name': 'fred',    'age': 40 },\n     *   { 'name': 'pebbles', 'age': 1 }\n     * ];\n     *\n     * var youngest = _.chain(characters)\n     *     .sortBy('age')\n     *     .map(function(chr) { return chr.name + ' is ' + chr.age; })\n     *     .first()\n     *     .value();\n     * // => 'pebbles is 1'\n     */\n    function chain(value) {\n      value = new lodashWrapper(value);\n      value.__chain__ = true;\n      return value;\n    }\n\n    /**\n     * Invokes `interceptor` with the `value` as the first argument and then\n     * returns `value`. The purpose of this method is to \"tap into\" a method\n     * chain in order to perform operations on intermediate results within\n     * the chain.\n     *\n     * @static\n     * @memberOf _\n     * @category Chaining\n     * @param {*} value The value to provide to `interceptor`.\n     * @param {Function} interceptor The function to invoke.\n     * @returns {*} Returns `value`.\n     * @example\n     *\n     * _([1, 2, 3, 4])\n     *  .tap(function(array) { array.pop(); })\n     *  .reverse()\n     *  .value();\n     * // => [3, 2, 1]\n     */\n    function tap(value, interceptor) {\n      interceptor(value);\n      return value;\n    }\n\n    /**\n     * Enables explicit method chaining on the wrapper object.\n     *\n     * @name chain\n     * @memberOf _\n     * @category Chaining\n     * @returns {*} Returns the wrapper object.\n     * @example\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36 },\n     *   { 'name': 'fred',   'age': 40 }\n     * ];\n     *\n     * // without explicit chaining\n     * _(characters).first();\n     * // => { 'name': 'barney', 'age': 36 }\n     *\n     * // with explicit chaining\n     * _(characters).chain()\n     *   .first()\n     *   .pick('age')\n     *   .value();\n     * // => { 'age': 36 }\n     */\n    function wrapperChain() {\n      this.__chain__ = true;\n      return this;\n    }\n\n    /**\n     * Produces the `toString` result of the wrapped value.\n     *\n     * @name toString\n     * @memberOf _\n     * @category Chaining\n     * @returns {string} Returns the string result.\n     * @example\n     *\n     * _([1, 2, 3]).toString();\n     * // => '1,2,3'\n     */\n    function wrapperToString() {\n      return String(this.__wrapped__);\n    }\n\n    /**\n     * Extracts the wrapped value.\n     *\n     * @name valueOf\n     * @memberOf _\n     * @alias value\n     * @category Chaining\n     * @returns {*} Returns the wrapped value.\n     * @example\n     *\n     * _([1, 2, 3]).valueOf();\n     * // => [1, 2, 3]\n     */\n    function wrapperValueOf() {\n      return this.__wrapped__;\n    }\n\n    /*--------------------------------------------------------------------------*/\n\n    // add functions that return wrapped values when chaining\n    lodash.after = after;\n    lodash.assign = assign;\n    lodash.at = at;\n    lodash.bind = bind;\n    lodash.bindAll = bindAll;\n    lodash.bindKey = bindKey;\n    lodash.chain = chain;\n    lodash.compact = compact;\n    lodash.compose = compose;\n    lodash.constant = constant;\n    lodash.countBy = countBy;\n    lodash.create = create;\n    lodash.createCallback = createCallback;\n    lodash.curry = curry;\n    lodash.debounce = debounce;\n    lodash.defaults = defaults;\n    lodash.defer = defer;\n    lodash.delay = delay;\n    lodash.difference = difference;\n    lodash.filter = filter;\n    lodash.flatten = flatten;\n    lodash.forEach = forEach;\n    lodash.forEachRight = forEachRight;\n    lodash.forIn = forIn;\n    lodash.forInRight = forInRight;\n    lodash.forOwn = forOwn;\n    lodash.forOwnRight = forOwnRight;\n    lodash.functions = functions;\n    lodash.groupBy = groupBy;\n    lodash.indexBy = indexBy;\n    lodash.initial = initial;\n    lodash.intersection = intersection;\n    lodash.invert = invert;\n    lodash.invoke = invoke;\n    lodash.keys = keys;\n    lodash.map = map;\n    lodash.mapValues = mapValues;\n    lodash.max = max;\n    lodash.memoize = memoize;\n    lodash.merge = merge;\n    lodash.min = min;\n    lodash.omit = omit;\n    lodash.once = once;\n    lodash.pairs = pairs;\n    lodash.partial = partial;\n    lodash.partialRight = partialRight;\n    lodash.pick = pick;\n    lodash.pluck = pluck;\n    lodash.property = property;\n    lodash.pull = pull;\n    lodash.range = range;\n    lodash.reject = reject;\n    lodash.remove = remove;\n    lodash.rest = rest;\n    lodash.shuffle = shuffle;\n    lodash.sortBy = sortBy;\n    lodash.tap = tap;\n    lodash.throttle = throttle;\n    lodash.times = times;\n    lodash.toArray = toArray;\n    lodash.transform = transform;\n    lodash.union = union;\n    lodash.uniq = uniq;\n    lodash.values = values;\n    lodash.where = where;\n    lodash.without = without;\n    lodash.wrap = wrap;\n    lodash.xor = xor;\n    lodash.zip = zip;\n    lodash.zipObject = zipObject;\n\n    // add aliases\n    lodash.collect = map;\n    lodash.drop = rest;\n    lodash.each = forEach;\n    lodash.eachRight = forEachRight;\n    lodash.extend = assign;\n    lodash.methods = functions;\n    lodash.object = zipObject;\n    lodash.select = filter;\n    lodash.tail = rest;\n    lodash.unique = uniq;\n    lodash.unzip = zip;\n\n    // add functions to `lodash.prototype`\n    mixin(lodash);\n\n    /*--------------------------------------------------------------------------*/\n\n    // add functions that return unwrapped values when chaining\n    lodash.clone = clone;\n    lodash.cloneDeep = cloneDeep;\n    lodash.contains = contains;\n    lodash.escape = escape;\n    lodash.every = every;\n    lodash.find = find;\n    lodash.findIndex = findIndex;\n    lodash.findKey = findKey;\n    lodash.findLast = findLast;\n    lodash.findLastIndex = findLastIndex;\n    lodash.findLastKey = findLastKey;\n    lodash.has = has;\n    lodash.identity = identity;\n    lodash.indexOf = indexOf;\n    lodash.isArguments = isArguments;\n    lodash.isArray = isArray;\n    lodash.isBoolean = isBoolean;\n    lodash.isDate = isDate;\n    lodash.isElement = isElement;\n    lodash.isEmpty = isEmpty;\n    lodash.isEqual = isEqual;\n    lodash.isFinite = isFinite;\n    lodash.isFunction = isFunction;\n    lodash.isNaN = isNaN;\n    lodash.isNull = isNull;\n    lodash.isNumber = isNumber;\n    lodash.isObject = isObject;\n    lodash.isPlainObject = isPlainObject;\n    lodash.isRegExp = isRegExp;\n    lodash.isString = isString;\n    lodash.isUndefined = isUndefined;\n    lodash.lastIndexOf = lastIndexOf;\n    lodash.mixin = mixin;\n    lodash.noConflict = noConflict;\n    lodash.noop = noop;\n    lodash.now = now;\n    lodash.parseInt = parseInt;\n    lodash.random = random;\n    lodash.reduce = reduce;\n    lodash.reduceRight = reduceRight;\n    lodash.result = result;\n    lodash.runInContext = runInContext;\n    lodash.size = size;\n    lodash.some = some;\n    lodash.sortedIndex = sortedIndex;\n    lodash.template = template;\n    lodash.unescape = unescape;\n    lodash.uniqueId = uniqueId;\n\n    // add aliases\n    lodash.all = every;\n    lodash.any = some;\n    lodash.detect = find;\n    lodash.findWhere = find;\n    lodash.foldl = reduce;\n    lodash.foldr = reduceRight;\n    lodash.include = contains;\n    lodash.inject = reduce;\n\n    mixin(function() {\n      var source = {}\n      forOwn(lodash, function(func, methodName) {\n        if (!lodash.prototype[methodName]) {\n          source[methodName] = func;\n        }\n      });\n      return source;\n    }(), false);\n\n    /*--------------------------------------------------------------------------*/\n\n    // add functions capable of returning wrapped and unwrapped values when chaining\n    lodash.first = first;\n    lodash.last = last;\n    lodash.sample = sample;\n\n    // add aliases\n    lodash.take = first;\n    lodash.head = first;\n\n    forOwn(lodash, function(func, methodName) {\n      var callbackable = methodName !== 'sample';\n      if (!lodash.prototype[methodName]) {\n        lodash.prototype[methodName]= function(n, guard) {\n          var chainAll = this.__chain__,\n              result = func(this.__wrapped__, n, guard);\n\n          return !chainAll && (n == null || (guard && !(callbackable && typeof n == 'function')))\n            ? result\n            : new lodashWrapper(result, chainAll);\n        };\n      }\n    });\n\n    /*--------------------------------------------------------------------------*/\n\n    /**\n     * The semantic version number.\n     *\n     * @static\n     * @memberOf _\n     * @type string\n     */\n    lodash.VERSION = '2.4.2';\n\n    // add \"Chaining\" functions to the wrapper\n    lodash.prototype.chain = wrapperChain;\n    lodash.prototype.toString = wrapperToString;\n    lodash.prototype.value = wrapperValueOf;\n    lodash.prototype.valueOf = wrapperValueOf;\n\n    // add `Array` functions that return unwrapped values\n    forEach(['join', 'pop', 'shift'], function(methodName) {\n      var func = arrayRef[methodName];\n      lodash.prototype[methodName] = function() {\n        var chainAll = this.__chain__,\n            result = func.apply(this.__wrapped__, arguments);\n\n        return chainAll\n          ? new lodashWrapper(result, chainAll)\n          : result;\n      };\n    });\n\n    // add `Array` functions that return the existing wrapped value\n    forEach(['push', 'reverse', 'sort', 'unshift'], function(methodName) {\n      var func = arrayRef[methodName];\n      lodash.prototype[methodName] = function() {\n        func.apply(this.__wrapped__, arguments);\n        return this;\n      };\n    });\n\n    // add `Array` functions that return new wrapped values\n    forEach(['concat', 'slice', 'splice'], function(methodName) {\n      var func = arrayRef[methodName];\n      lodash.prototype[methodName] = function() {\n        return new lodashWrapper(func.apply(this.__wrapped__, arguments), this.__chain__);\n      };\n    });\n\n    return lodash;\n  }\n\n  /*--------------------------------------------------------------------------*/\n\n  // expose Lo-Dash\n  var _ = runInContext();\n\n  // some AMD build optimizers like r.js check for condition patterns like the following:\n  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {\n    // Expose Lo-Dash to the global object even when an AMD loader is present in\n    // case Lo-Dash is loaded with a RequireJS shim config.\n    // See http://requirejs.org/docs/api.html#config-shim\n    root._ = _;\n\n    // define as an anonymous module so, through path mapping, it can be\n    // referenced as the \"underscore\" module\n    define(function() {\n      return _;\n    });\n  }\n  // check for `exports` after `define` in case a build optimizer adds an `exports` object\n  else if (freeExports && freeModule) {\n    // in Node.js or RingoJS\n    if (moduleExports) {\n      (freeModule.exports = _)._ = _;\n    }\n    // in Narwhal or Rhino -require\n    else {\n      freeExports._ = _;\n    }\n  }\n  else {\n    // in a browser or Rhino\n    root._ = _;\n  }\n}.call(this));\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails-stringfile/deprecation.js":"/**\n * Module dependencies\n */\nvar _ = require('lodash')\n\t, logMoreInfoLink = require('./links').logMoreInfoLink\n\t, util = require('util');\n\n\n//\n// Used for throttling deprecation notices\n// \nvar featureCache = {};\n\nmodule.exports = {\n\n\tlogUpgradeNotice: function(template, values, log) {\n\t\tlog = log || console.log;\n\t\tif (!_.isArray(values)) values = [values];\n\t\tlog(util.format.apply(null, [template].concat(values)));\n\t},\n\t\n\tlogDeprecationNotice: function(feature, moreInfoURL, log) {\n\n\t\tvar time = new Date().getTime();\n\t\tif (featureCache[feature] && (featureCache[feature] + 5000 > time)) {\n\t\t\treturn false;\n\t\t} else featureCache[feature] = time;\n\n\t\tlog = log || console.log;\n\t\tconsole.log();\n\t\tlog(util.format('Deprecated:   `%s`', feature).bold);\n\t\tif (moreInfoURL) logMoreInfoLink(moreInfoURL, log);\n\t\treturn true;\n\t}\n};","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails-stringfile/links.js":"/**\n * Module dependencies\n */\n\nvar _ = require('lodash')\n\t, util = require('util');\n\n\n\n// Used to detect terminal-URL support (for help links)\nvar IS_MACOS = require('os').platform().match(/darwin/);\n\nmodule.exports = {\n\n\tlogMoreInfoLink: function(url, log) {\n\t\tlog = log || console.log;\n\t\tif (IS_MACOS) {\n\t\t\tlog('See ' + util.format('%s'.underline, url));\n\t\t\tlog('( + double-click to open link from terminal)'.grey);\n\t\t} else return log(util.format('(see %s)', url));\n\t},\n\n\tlogLinks: function(urls, log) {\n\t\tlog = log || console.log;\n\t\t_.each(urls, function(url) {\n\t\t\tlog(' ->', util.format('%s'.underline, url));\n\t\t});\n\t\tif (IS_MACOS) {\n\t\t\tlog('    ( + double-click to open links from terminal)'.grey);\n\t\t}\n\t\tmodule.exports.terminalLinkHelp(log);\n\t},\n\n\tterminalLinkHelp: function (log) {\n\t\tlog = log || console.log;\n\t\tif (IS_MACOS) {\n\t\t\tlog('( + double-click to open links from terminal)'.grey);\n\t\t}\n\t}\n};","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails-stringfile/gettext.js":"/**\n * Module dependencies\n */\nvar util = require('util')\n\t, path = require('path');\n\n\n/**\n * Look up a string by name, using environment variable\n * to detect the appropriate locale.\n * If a stringfile doesn't exist, default to `en`.\n *\n * @api experimental\n *\n * @address {String} keypath    [e.g. 'cli.new.successful']\n * @address {Object} args       [ordered scope args for `util.format()`]\n * @return {String}\n */\nmodule.exports = function getString (keypath, args) {\n\n\tvar locale =\n\tprocess.env.LANGUAGE    ||\n\tprocess.env.LC_ALL      ||\n\tprocess.env.LC_MESSAGES ||\n\tprocess.env.LANG        ||\n\t'en';\n\tlocale = locale.toLowerCase();\n\n\t// Just to be safe, check that there are no '/'\n\t// (in case an attacker attempts to use environment\n\t// variables to load malicious code)\n\tif (locale.match(/[\\/]+/)) return util.format('INVALID LOCALE: %s',locale);\n\n\t// TODO: do something smarter here to determine the proper stringfile\n\tif (locale.match('en')) {\n\t\tlocale = 'en';\n\t}\n\n\tvar stringfile, pathToLocale;\n\ttry {\n\t\tpathToLocale = path.resolve(__dirname, './locales/',locale);\n\t\tstringfile = require( pathToLocale );\n\t}\n\tcatch(e) {\n\n\t\t// In the event of an unresolvable locale,\n\t\t// fail silently and default to english\n\t\tpathToLocale = path.resolve(__dirname, './locales/en');\n\t\tstringfile = require( pathToLocale );\n\n\t\t// return util.format(\n\t\t// 'ERROR LOADING LOCALE: '+\n\t\t// 'Unable to find stringfile for locale `%s`',\n\t\t// locale);\n\t}\n\n\tvar strtemplate = _deepValue(stringfile, keypath);\n\tif (!strtemplate) return util.format('STRING `%s` NOT DEFINED IN `%s` LOCALE!',keypath, locale);\n\n\treturn util.format.apply( null, [strtemplate].concat(args || []));\n};\n\n\n\n/**\n * @api private\n *\n * Lookup a value in an object given a keypath.\n * \n * @param  {Object} object [description]\n * @param  {String} path   [description]\n * @return {[type]}        [description]\n */\nfunction _deepValue (object, path) {\n\tif ('undefined' == typeof object || object === null) {\n\t\treturn null;\n\t}\n\tvar val = object;\n\tpath = path.split('.');\n\twhile (path.length) {\n\t\tvar part = path.shift();\n\t\tif ('undefined' == typeof val[part]) {\n\t\t\treturn null;\n\t\t} else {\n\t\t\tval = val[part];\n\t\t}\n\t}\n\n\t// Try [0] if an object remains\n\tif (typeof val === 'object') {\n\t\tif (typeof val[0] === 'string') val = val[0];\n\t}\n\t\n\treturn val;\n}","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/hooks/request/validate.js":"/**\n * Module dependencies\n */\n\nvar _ = require('@sailshq/lodash');\nvar anchor = require('anchor');\n\n\n\n/**\n * Mixes in `req.validate`.\n *\n * @param  {Request} req\n * @param  {Response} res\n * @return {Request}\n *\n * Note that built-in support for req.validate() will change in Sails v1.0 along\n * with other major changes to `anchor`.\n */\nmodule.exports = function (req, res) {\n  req.validate = _validate;\n\n  /**\n   * req.validate()\n   *\n   * @param  {Object} usage\n   *         (supports either `{type: {}}` or `{}`)\n   *\n   * @param  {String} redirectTo\n   *         (optional)\n   *\n   * @throws {Error}\n   * @api public\n   */\n\n  function _validate (usage, redirectTo) {\n    usage = usage || {};\n\n    // Wrap `usage` in a `type` key, since req.params.all()\n    // always returns an object anyways.\n    var invalidParams = anchor(req.params.all()).to({type: usage});\n    if (invalidParams) {\n\n      var e = new E_INVALID_PARAMS({\n        invalidParams: invalidParams,\n        route: req.url,\n        method: req.method,\n        usage: usage\n      });\n\n      if (redirectTo) {\n        if (req.session && req.flash) {\n          req.flash('error', e);\n        }\n        res.redirect(redirectTo);\n      }\n      else {\n        throw e;\n      }\n    }\n  }\n\n  return req;\n};\n\n\n\n\n\n\n/**\n * Constructs an E_INVALID_PARAMS error.\n * @constructor\n */\nfunction E_INVALID_PARAMS (opts) {\n  this.invalidParams = opts.invalidParams;\n  this.route = opts.route;\n  this.method = opts.method;\n  this.usage = opts.usage;\n\n  // Generate stack trace\n  var e = new Error();\n  this.stack = e.stack;\n}\nE_INVALID_PARAMS.prototype.code = 'E_INVALID_PARAMS';\nE_INVALID_PARAMS.prototype.status = 400;\n\n/**\n * How this error is serialized when sent w/ `res.json()`\n * @return {Object}\n */\nE_INVALID_PARAMS.prototype.toJSON = function () {\n  return _.map(this.invalidParams, function (invalidParam) {\n    return {\n      parameter: invalidParam.property,\n      error: invalidParam.message,\n      expectedType: invalidParam.rule,\n      actualType: invalidParam.actualType,\n      data: invalidParam.data\n    };\n  });\n};\n\n/**\n * How this error appears when logged\n * (or whenever util.inspect is called on it)\n * @return {String}\n */\nE_INVALID_PARAMS.prototype.inspect = function () {\n  var output = 'Invalid parameters sent to route: \"'+this.method + ' ' + this.route+'\"';\n  output += '\\n';\n  output += _.map(this.invalidParams, function (invalidParam) {\n    return '  -> ' + invalidParam.message;\n  });\n  return output;\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/hooks/session/generateSecret.js":"/**\n * Module dependencies\n */\nvar crypto = require('crypto');\nvar _ = require('@sailshq/lodash');\n\n\n/**\n * Generate session secret\n * @return {[type]} [description]\n */\nmodule.exports = function generateSecret() {\n\n  // Combine random and case-specific factors into a base string\n  var factors = {\n    creationDate: (new Date()).getTime(),\n    random: crypto.randomBytes(64).toString('hex'),\n    nodeVersion: process.version\n  };\n  var basestring = '';\n  _.each(factors, function(val) {\n    basestring += val;\n  });\n\n  // Build hash\n  var hash =\n  crypto.createHash('md5')\n  .update(basestring)\n  .digest('hex');\n\n  return hash;\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/hooks/views/add-shim-for-layout-and-partials.js":"/**\n * Module dependencies\n */\n\nvar path = require('path');\n\n\n/**\n * Implement EJS layouts and partials (a la Express 2).\n *\n * For further explanation, see:\n *  => http://sailsjs.org/documentation/concepts/views/layouts#?why-do-layouts-only-work-for-ejs\n * ------------------------------------------------------------------------------------------\n *\n * TODO:\n * Extrapolate this functionality to a separate hook\n * to make it easier for folks to extend it with support\n * for other view engines (e.g. hbs).\n *   => See https://github.com/balderdashy/sails/issues/3707 for more info.\n *\n * @param  {Sails}   sails\n */\nmodule.exports = function addShimForLayoutAndPartials (sails) {\n\n  // If layout config is truthy, attempt to use view partials/layout.\n  if (sails.config.views.layout) {\n\n    // If `http` hook is not enabled, we can't use partials.\n    // (depends on express atm)\n    if (sails.config.hooks.http) {\n\n      // Get the view engine name\n      var engineName = sails.config.views.engine.name || sails.config.views.engine.ext;\n\n      // Get the extension\n      var extension = sails.config.views.engine.ext || sails.config.views.extension;\n\n      // Use ejs-locals for all ejs templates\n      if (engineName === 'ejs') {\n        var ejsLayoutEngine = require('ejs-locals');\n        sails.log.verbose('Overriding ejs engine config with ejslocals to implement layout support...');\n        sails.config.views.engine.fn = ejsLayoutEngine;\n      }//</ejs>\n\n      // Use express-handlebars for handlebars templates, and set up layout functionality.\n      //\n      // > **WARNING**\n      // > Handlebars layout/partial support is EXPERIMENTAL and may be removed at any time.\n      // > It also might stay-- if you would like to see that, please create a proposal in the Sails\n      // > repo on GitHub explaining how you see usage working long-term.  Thanks!\n      else if (engineName === 'handlebars') {\n        var exphbs = require('express-handlebars');\n        sails.log.verbose('Overriding handlebars engine with express-handlebars to implement layout support...');\n        var hbs = exphbs.create({\n          defaultLayout: path.join('..', (sails.config.views.layout + '.' + (extension || 'handlebars')) || ''),\n          helpers: sails.config.views.helpers || {},\n          partialsDir: path.join('views', sails.config.views.partials || ''),\n          extname: extension || 'handlebars'\n        });\n\n        sails.config.views.engine.fn = hbs.engine;\n      }//</handlebars>\n\n    }//</HTTP hook enabled>\n  }//</sails.config.views.layout is truthy>\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/hooks/views/configure.js":"/**\n * Module dependencies\n */\n\nvar path = require('path');\nvar util = require('util');\nvar _ = require('@sailshq/lodash');\nvar consolidate = require('consolidate');\n\n\n/**\n * Marshal relevant parts of sails global configuration,\n * issue deprecation notices, etc.\n *\n * @param  {Sails} sails\n */\nmodule.exports = function configure ( sails ) {\n\n  if (sails.config.viewEngine) {\n    sails.log.warn('The `config.viewEngine` config has been deprecated in favor of `config.views.engine`.');\n    sails.log.warn('It has been automatically migrated, but you\\'ll continue to see this warning until you change your configuration files.');\n    sails.config.views.engine = sails.config.viewEngine;\n  }\n\n  // Normalize view engine config and allow defining a custom extension\n  if (_.isString(sails.config.views.engine)) {\n    var viewExt = sails.config.views.extension || sails.config.views.engine;\n    sails.config.views.engine = {\n      name: sails.config.views.engine,\n      ext: viewExt\n    };\n  }\n\n  // Get the view engine name\n  var engineName = sails.config.views.engine.name || sails.config.views.engine.ext;\n\n  // Ensure valid config\n  if (! (sails.config.views.engine && sails.config.views.engine.ext) ) {\n    sails.log.error('Invalid view engine configuration. `config.views.engine` should');\n    sails.log.error('be set to either a `string` or an `object` with the following properties:');\n    sails.log.error('    {');\n    sails.log.error('        ext: <string>,   // the file extension');\n    sails.log.error('        fn: <function>   // the template engine render function');\n    sails.log.error('    }');\n    sails.log.error('For example: {ext:\"html\", fn: require(\"consolidate\").swig}');\n    sails.log.error('For details: http://expressjs.com/api.html#app.engine');\n    throw new Error('Invalid view engine configuration.');\n  }\n\n  // Try to load view module if a function wasn't specified directly\n  if ( !sails.config.views.engine.fn ) {\n\n    var appDependenciesPath;\n    var fn;\n\n    appDependenciesPath = path.join(sails.config.appPath, 'node_modules');\n\n    try {\n\n      // Try to load the view engine, optionally using a separate module\n      // (see https://github.com/tj/consolidate.js/blob/master/lib/consolidate.js#L568)\n      fn = getEngine(appDependenciesPath,engineName,sails.config.views.engine.module, sails);\n\n      // If the engine doesn't export a function, it's not consolidate-compatible\n      if ( !_.isFunction(fn) ) {\n        sails.log.error(util.format('Invalid view engine (%s)-- are you sure it supports `consolidate`?', engineName));\n        throw new Error();\n      }\n    }\n\n    // If the engine can't be loaded, we can't continue\n    catch (e) {\n      sails.log.error('Your configured server-side view engine (' + engineName + ') could not be found.');\n      sails.log.error('Usually, this just means you need to install a dependency.');\n      sails.log.error('To install ' + engineName + ', try running:  `npm install ' + engineName + ' --save`');\n      sails.log.error('Otherwise, please change your `engine` configuration in config/views.js.');\n      throw e;\n    }\n\n    // Save reference to view rendering function\n    // munge callback to protect against https://github.com/tj/consolidate.js/issues/143\n    sails.config.views.engine.fn = function (str, options, cb) {\n      fn(str, options, function (e, result) { setImmediate(function () { cb(e, result); }); });\n    }\n    sails.log.silly('Configured view engine, `' + engineName + '`');\n  }\n\n  // Let user know that a leading . is not required in the viewEngine option and then fix it\n  if (sails.config.views.engine.ext[0] === '.') {\n    sails.log.warn('A leading `.` is not required in the views.engine option.  Removing it for you...');\n    sails.config.views.engine.ext = sails.config.views.engine.ext.substr(1);\n  }\n\n  // Custom layout location\n  // (if string specified, it's used as the relative path from the views folder)\n  // (if not string, but truthy, relative path from views folder defaults to ./layout.*)\n  // (if falsy, don't use layout)\n  if ( !_.isString(sails.config.views.layout) && sails.config.views.layout ) {\n    sails.config.views.layout = 'layout.' + sails.config.views.engine.ext;\n  }\n\n  var layoutableEngines = [\n    'ejs',\n    'handlebars',\n    'ractive'\n  ];\n  if ( sails.config.views.layout && layoutableEngines.indexOf(engineName) < 0 ) {\n    sails.log.warn('Sails\\' built-in layout support only works with the `' +\n      layoutableEngines.join('`, `') + '` view engines.');\n    sails.log.warn('You\\'re using `'+ engineName +'`.');\n    sails.log.warn('Ignoring `sails.config.views.layout`...');\n  }\n};\n\n\n\n// Load a view engine either from the Consolidate cache or from a module installed\n// locally to the Sails app.\nfunction getEngine(appDependenciesPath, engineName, moduleName, sails) {\n\n  // Most of the time the module name and engine name are the same\n  moduleName = moduleName || engineName;\n\n  // Get the base template loading function from consolidate\n  var fn = consolidate[engineName];\n\n  // If we haven't cached the engine module in consolidate's requires cache, do it now.\n  if(!consolidate.requires[moduleName]) {\n    try {\n      //ensure the engine is required relative to the path of our app\n      consolidate.requires[moduleName] = require(appDependenciesPath+'/' + moduleName);\n      // If the engine name and module names are different, cache the engine under both\n      // keys, since Consolidate likes it both ways:\n      // https://github.com/tj/consolidate.js/blob/master/lib/consolidate.js#L195\n      // https://github.com/tj/consolidate.js/blob/master/lib/consolidate.js#L568\n      if (engineName !== moduleName) {\n        consolidate.requires[engineName] = consolidate.requires[moduleName];\n      }\n    } catch(e) {\n      sails.log.info('Could not find module:', moduleName , 'in path:', appDependenciesPath);\n    }\n  }\n\n  return fn;\n}\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/hooks/views/defaults.js":"/**\n * Implicit defaults\n *\n * @param  {Object} config\n * @context hook\n * \n * @return {Object}\n */\n\nmodule.exports = function defaults (config) {\n\treturn {\n\t\tviews: {\n\n\t\t\t// Engine for views (can be ejs, haml, etc.)\n\t\t\tengine: 'ejs',\n\n\t\t\t// Layout is on by default, in the top level of the view directory\n\t\t\t// true === use default\n\t\t\t// false === don't use a layout\n\t\t\t// string === path to layout\n\t\t\tlayout: true\n\t\t},\n\n\t\tpaths: {\n\t\t\tviews: config.appPath + '/views',\n\t\t\tlayout: config.appPath + '/views/layout.ejs'\n\t\t}\n\t};\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/hooks/views/escape-html-entities-deep.js":"/**\n * Module dependencies\n */\n\nvar _ = require('@sailshq/lodash');\nvar rttc = require('rttc');\n\n\n/**\n * escapeHtmlEntitiesDeep()\n *\n * Escape all HTML entities which exist as strings in the provided\n * data. If the provided data contains any dictionaries or arrays,\n * traverse them recursively. Note that the returned value will be\n * JSON-compatible, and the dehydration process will be carried out\n * using the rules established in rttc.dehydrate().\n *\n * @param {Dictionary} data\n *           The dictionary of data to escape.\n *\n * @returns {JSON} a recursively-HTML-escaped copy of the provided data.\n */\nmodule.exports = function escapeHtmlEntitiesDeep(data){\n\n  return rttc.rebuild(data, function escape(val, type){\n    // _.escape() is for escaping strings for use in HTML.\n    // (this is just the same thing that Lodash uses when you use `<%- %>` in templates)\n    if (type === 'string') {\n      return _.escape(val);\n    }\n    else {\n      return val;\n    }\n  });\n\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/hooks/views/html-scriptify.js":"/**\n * Module dependencies\n */\n\nvar _ = require('@sailshq/lodash');\nvar rttc = require('rttc');\nvar escapeHtmlEntitiesDeep = require('./escape-html-entities-deep');\n\n\n/**\n * htmlScriptify()\n *\n * Generate a string of HTML code that can be injected onto a page\n * in order to expose a JSON-serializable version of the provided\n * data to client-side JavaScript.\n *\n * @required {Dictionary} options.data\n *           The dictionary (i.e. of locals) that will be converted into an HTML snippet containing\n *           our script tag. If any of the keys cannot be coerced to be JSON-serializable (i.e.\n *           contain nothing that isn't a string, number, boolean, plain dictionary, array, or null),\n *           then they are simply excluded.  Additionally, each key is recursively parsed to snip off\n *           any circular references and otherwise ensure full JSON-serializability of ever nested key\n *           therein.  See rttc.dehydrate() for more information.\n *\n * @optional {Array} options.keys\n *           An array of strings; the names of keys in data which should be exposed to on the namespace. If left unspecified, all keys in data will be exposed.\n *\n * @optional {String} options.namespace\n *           The name of the key on the window object where data should be exposed. Defaults to 'SAILS_LOCALS'.\n *\n * @optional {Boolean} options.dontUnescapeOnClient\n *           Defaults to false. When false (by default) client-side JavaScript code will be\n *           injected around the exposed data. When the page loads, the injected client-side\n *           JavaScript runs, unescaping the values so that they are accessible to client-side\n *           JavaScript with no further transformation necessary (i.e. they are immediately\n *           usable just like they would be if they had been fetched using AJAX). If this flag\n *           is enabled, no additional client-side JavaScript code will be injected and so the\n *           exposed values will still be escaped; e.g. `window.SAILS_LOCALS.funnyFace === '&lt;o_o&gt;'`\n *           (this is useful for customizing client-side unescaping logic)\n *\n *\n * @returns {String} a string of HTML code-- specifically a script tag containing the exposed data.\n */\nmodule.exports = function htmlScriptify(options){\n\n  // Validate usage\n  if (!_.isObject(options)) { throw new Error('Usage: A dictionary of options should be provided as the sole argument `htmlScriptify()`'); }\n  // Check required properties\n  else if (_.isUndefined(options.data)) { throw new Error('Usage: `data` is a required option'); }\n  else if (!_.isObject(options.data)) { throw new Error('Usage: `data` should be a dictionary'); }\n  // Check optional properties and apply defaults\n  if (_.isUndefined(options.keys)) {\n    // `options.keys` defaults to `undefined`-- meaning all keys in provided data\n    // are permitted; i.e. no whitelist.\n  }\n  else {\n    try { options.keys = rttc.validate(['string'], options.keys); }\n    catch (e) {\n      if (e.code === 'E_INVALID') { throw new Error('Usage: If provided, `keys` should be an array of strings'); }\n      else { throw e; }\n    }\n  }\n  if (_.isUndefined(options.namespace)) { options.namespace = 'SAILS_LOCALS'; }\n  else {\n    // Note that while we might also consider validating `namespace` as an\n    // ecmascript-compatible variable name, in the interest of avoiding any\n    // more dependencies here, we do not.\n    try { options.namespace = rttc.validate('string', options.namespace); }\n    catch (e) {\n      if (e.code === 'E_INVALID') { throw new Error('Usage: If provided, `namespace` should be a string'); }\n      else { throw e; }\n    }\n  }\n  if (_.isUndefined(options.dontUnescapeOnClient)) { options.dontUnescapeOnClient = false; }\n  else {\n    try { options.dontUnescapeOnClient = rttc.validate('boolean', options.dontUnescapeOnClient); }\n    catch (e) {\n      if (e.code === 'E_INVALID') { throw new Error('Usage: If provided, `dontUnescapeOnClient` should be either `true` or `false`'); }\n      else { throw e; }\n    }\n  }\n\n  // console.log('options.data',options.data);\n  // console.log('_.keys(options.data)',_.keys(options.data));\n\n  // Build and return HTML to inject.\n  var html = '<script type=\"text/javascript\">';\n  html += ' (function (){ ';\n  // Unless `dontUnescapeOnClient` flag was enabled, don't build the code\n  // to do the unescaping. (useful for customizing client-side unescaping logic)\n  if (!options.dontUnescapeOnClient) {\n    // Inject client-side JavaScript code that will be used to unescape the\n    // bootstrapped data.\n    //\n    // This is kind of like _.unescape().\n    // (see https://github.com/lodash/lodash/blob/4.7.0/dist/lodash.js#L14038)\n    // Except it also has to be recursive.  But luckily, we don't have to worry\n    // about circular references, since we know this was just serialized.\n    html += ' var unescape = ' + (function clientSideUnescapeFn(escapedValue){\n      var unescapedValue = escapedValue;\n      // TODO: actually unescape it\n      //\n      // This may kind of suck because it needs to be vanilla JS.\n      // Not planning on any kind of special backwards-compatible support for older browsers,\n      // but if that IS needed, or any other customizations to the client-side escaping code\n      // are necessary, then the built-in client-side escaping can be disabled using\n      // `dontUnescapeOnClient: true`.\n      return unescapedValue;\n    }).toString() + '; ';\n  }\n  html += ' window.'+options.namespace+' = { ';\n\n  // Determine the relevant keys to inject.\n  // (filtering using `options.keys` whitelist, if provided)\n  var keysToInject = _.keys(options.data);\n  if (!_.isUndefined(options.keys)) {\n    keysToInject = _.intersection(keysToInject, options.keys);\n  }\n\n  // Then inject them in our <script> tag string.\n  _.each(keysToInject, function eachRelevantKey(key){\n    var unsafeVal = options.data[key];\n\n    // If this top-level key in the provided data is undefined, exclude it altogether.\n    if (_.isUndefined(unsafeVal)) { return; }\n\n    // Now, dive into `unsafeVal` and recursively HTML-escape any nested strings.\n    // Then, compile the whole thing into a JavaScript string which will accurately\n    // represent it as an r-value (watching out for circular refs along the way).\n    var escapedData = rttc.compile(escapeHtmlEntitiesDeep(unsafeVal));\n\n    // If the `dontUnescapeOnClient` flag was set, then just stick the compiled,\n    // still-HTML-escaped data in place.  (It will have to be recursively unescaped\n    // by hand in the app's custom client-side code!)\n    if (options.dontUnescapeOnClient) {\n      html += ''+key+': '+escapedData+',';\n    }\n    // Otherwise, we're including the client-side code to unescape the data,\n    // so run our unescape function from above.\n    else {\n      html += ''+key+': unescape('+escapedData+'),';\n    }\n  });\n  html += ' }; ';\n  html += ' })(); ';\n  html += '</script>';\n\n  return html;\n\n\n  // ~Example usage:\n  // ============================================================\n  // xss-test:  sails console\n  //\n  // info: Starting app in interactive mode...\n  //\n  // info: Welcome to the Sails console.\n  // info: ( to exit, type <CTRL>+<C> )\n  //\n  // sails> sails.hooks.views.htmlScriptify({data: {3: 'stuff'}, keys: ['4'], namespace: '32', dontUnescapeOnClient: true})\n  // '<script type=\"text/javascript\"> (function (){  window.32 = {  };  })(); </script>'\n  // sails> sails.hooks.views.htmlScriptify({data: {3: 'stuff'}, keys: ['3'], namespace: '32'})\n  // '<script type=\"text/javascript\"> (function (){  var unescape = function (u){\\n      // TODO: implement `unescape()`\\n      return u;\\n    };  window.32 = { 3: unescape(\\'stuff\\'), };  })(); </script>'\n  // sails> sails.hooks.views.htmlScriptify({data: {3: 'stuff'}})\n  // '<script type=\"text/javascript\"> (function (){  var unescape = function (u){\\n      // TODO: implement `unescape()`\\n      // (see https://github.com/lodash/lodash/blob/4.7.0/dist/lodash.js#L14038)\\n      return u;\\n    };  window.SAILS_LOCALS = { 3: unescape(\\'stuff\\'), };  })(); </script>'\n\n  // ~Example of end result:\n  // ============================================================\n  //\n  // <script type=\"text/javascript\">\n  //   window.SAILS_LOCALS = {\n  //     _csrf: (function (escapedValue){\n  //       var unescaped = escapedValue;\n  //       // Unescape all strings in `escapedValue`.\n  //       // (recursively parse escapedValue if it is an array or dictionary)\n  //       // (also need to prevent endless circular recursion for circular objects)\n  //       return unescaped;\n  //     })('d8a831-d8a8381h1-adgadga3'),\n\n  //     me: (function (escapedValue){\n  //       var unescaped = escapedValue;\n  //       // Unescape all strings in `escapedValue`.\n  //       // (recursively parse escapedValue if it is an array or dictionary)\n  //       // (also need to prevent endless circular recursion for circular objects)\n  //       return unescaped;\n  //     })({\n  //       gravatarUrl: '&lt;/script&gt;',\n  //       admin: false\n  //     })\n  //   };\n  // </script>\n\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/hooks/views/render.js":"/**\n * Module dependencies\n */\n\nvar path = require('path');\nvar _ = require('@sailshq/lodash');\n\n\n// TODO: reuse code in res.view.js for most of this to make it more maintainable\n// currently it is not in sync w/ improvements/fixes in that other module.\n\n/**\n * sails.hooks.views.render(relPathToView, options, cb_view)\n *\n * @param {String} relPathToView\n *\t\t\t\t-> path to the view file to load (minus the file extension)\n *\t\t\t\t\trelative to the app's `views` directory\n * @param {Object} options\n *\t\t\t\t-> options hash to pass to template renderer, including locals and locale\n * @param {Function} cb_view(err)\n *\t\t\t\t-> called when the view rendering is complete (response is already sent, or in the process)\n *\t\t\t\t\t(probably should be @api private)\n * @api public\n */\n\nmodule.exports = function (sails) {\n\n  return function render(relPathToView, _options, cb_view) {\n\n    // TODO:\n    // pull out shared logic between this file and res.view.js\n    // into a separate file.\n\n    if (!relPathToView && !_.isString(relPathToView)) {\n      throw new Error('relPathToView must be a string.');\n    }\n\n    // Clone the options, just in case\n    var options = _.cloneDeep(_options || {});\n\n    // Trim trailing slash\n    if (relPathToView[(relPathToView.length - 1)] === '/') {\n      relPathToView = relPathToView.slice(0, -1);\n    }\n\n    // if local `layout` is set to true or unspecified\n    // fall back to global config\n    var layout = options.layout;\n    if (layout === undefined || layout === true) {\n      layout = sails.config.views.layout;\n    }\n\n    // Disable sails built-in layouts for all view engine's except for ejs\n    if (sails.config.views.engine.ext !== 'ejs') {\n      layout = false;\n    }\n\n    var pathToViews = sails.config.paths.views;\n    var absPathToView = path.join(pathToViews, relPathToView) + '.' + sails.config.views.engine.ext;\n\n    // Set layout file if enabled (using ejs-locals)\n    if (layout) {\n      // If a layout was specified, set view local so it will be used\n      options._layoutFile = layout;\n    }\n\n    options.view = options.view || {\n      path: relPathToView,\n      pathFromViews: relPathToView,\n      pathFromApp: path.join(path.relative(sails.config.appPath, sails.config.paths.views), relPathToView),\n      ext: sails.config.views.engine.ext\n    };\n\n    // In development, provide access to complete path to view\n    // via `__dirname`\n    if (sails.config.environment !== 'production') {\n      options.__dirname = options.__dirname ||\n        absPathToView + '.' + sails.config.views.engine.ext;\n    }\n\n    // Set the options for the view rendering engine.  Copy all the current options into 'locals'\n    // in case the template engine expects them there.\n    _.extend(options, {\n      locals: _.cloneDeep(options),\n      settings: {\n        'view engine': sails.config.views.engine.ext,\n        'views': sails.config.paths.views\n      }\n    });\n\n    // Set up a mock request for i18n to use as context\n    var req = {\n      headers: {}\n    };\n\n    // Initialize i18n if hook is enabled\n    if (sails.hooks.i18n) {\n\n      // If a locale was specified as an option, render the view with that locale\n      req.headers['accept-language'] = options.locale || sails.hooks.i18n.defaultLocale;\n\n      require('i18n').init(req, options, function() {\n\n        // Set the locale if necessary\n        if (options.locale) {\n          req.locale = options.locale;\n        }\n\n        // Render the view\n        sails.config.views.engine.fn(absPathToView, options, cb_view);\n      });\n    } else {\n      sails.config.views.engine.fn(absPathToView, options, cb_view);\n    }\n\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/hooks/views/res.view.js":"/**\n * Module dependencies\n */\n\nvar path = require('path');\nvar util = require('util');\nvar _ = require('@sailshq/lodash');\nvar htmlScriptify = require('./html-scriptify');\n\n\n/**\n * Adds `res.view()` (an enhanced version of res.render) and `res.guessView()` methods to response object.\n * `res.view()` automatically renders the appropriate view based on the calling middleware's source route\n * Note: the original function is still accessible via res.render()\n *\n * @param {Request}  req\n * @param {Response} res\n * @param {Function} next\n */\n\nmodule.exports = function _addResViewMethod(req, res, next) {\n\n  var sails = req._sails;\n\n  // TODO: don't pass `next` into this method impl to avoid confusing situations.\n  // i.e. wrap it up:\n  // ```\n  // function (req,res,next) { _addResViewMethod(req,res); next(); }\n  // ```\n\n\n  /**\n   * res.guessView([locals], [couldNotGuessCb])\n   *\n   * @param  {Object} locals\n   * @param  {Function} couldNotGuessCb\n   */\n  res.guessView = function (locals, couldNotGuessCb) {\n    return res.view(locals, function viewReady(err, html) {\n\n      // If this is an \"implied view doesn't exist\" error,\n      // just serve JSON instead.\n      if (err && (err.code === 'E_VIEW_INFER' || err.code === 'E_VIEW_FAILED')) {\n        return (couldNotGuessCb||res.serverError)(err);\n      }\n\n      // But if some other sort of error occurred, call `res.serverError`\n      else if (err) {return res.serverError(err);}\n\n      // Otherwise we're good, serve the view\n      return res.send(html);\n    });\n  };\n\n\n\n  /**\n   * res.view([specifiedPath|locals], [locals])\n   *\n   * @param {String} specifiedPath\n   *\t\t\t\t-> path to the view file to load (minus the file extension)\n   *\t\t\t\t\trelative to the app's `views` directory\n   * @param {Object} locals\n   *\t\t\t\t-> view locals (data that is accessible in the view template)\n   * @param {Function} cb_view(err)\n   *\t\t\t\t-> called when the view rendering is complete (response is already sent, or in the process)\n   *\t\t\t\t\t(probably should be @api private)\n   * @api public\n   */\n  res.view = function(/* specifiedPath, locals, cb_view */) {\n\n    var specifiedPath = arguments[0];\n    var locals = arguments[1];\n    var cb_view = arguments[2];\n\n    // sails.log.silly('Running res.view() with arguments:',arguments);\n\n    // By default, generate a path to the view using what we know about the controller+action\n    var relPathToView;\n\n    // Ensure req.target is an object, then merge it into req.options\n    // (this helps ensure backwards compatibility for users who were relying\n    //  on `req.target` in previous versions of Sails)\n    req.options = _.defaults(req.options, req.target || {});\n\n    // Try to guess the view by looking at the controller/action\n    if (!req.options.view && (req.options.controller || req.options.model)) {\n      relPathToView = (req.options.controller||req.options.model) + '/' + (req.options.action || 'index');\n    }\n    // Use the new view config\n    else {relPathToView = req.options.view;}\n\n    // Now we have a reasonable guess in `relPathToView`\n\n    // If the path to a view was explicitly specified, use that\n    // Serve the view specified\n    //\n    // If first arg is not an obj or function, treat it like the path\n    if (specifiedPath && !_.isObject(specifiedPath) && !_.isFunction(specifiedPath)) {\n      relPathToView = specifiedPath;\n    }\n\n    // If the \"locals\" argument is actually the \"specifiedPath\"\n    // give em the old switcheroo\n    if (!relPathToView && _.isString(arguments[1])) {\n      relPathToView = arguments[1] || relPathToView;\n    }\n    // If first arg ISSSSS AN object, treat it like locals\n    if (_.isObject(arguments[0])) {\n      locals = arguments[0];\n    }\n\n    if (_.isFunction(arguments[1])) {\n      cb_view = arguments[1];\n    }\n\n    // if (_.isFunction(locals)) {\n    //   cb_view = locals;\n    //   locals = {};\n    // }\n    // if (_.isFunction(specifiedPath)) {\n    //   cb_view = specifiedPath;\n    // }\n\n    // If a view path cannot be inferred, send back an error instead\n    if (!relPathToView) {\n      var err = new Error();\n      err.name = 'Error in res.view()';\n      err.type = err.code = 'E_VIEW_INFER';\n      err.message = 'No path specified, and no path could be inferred from the request context.';\n\n      // Prevent endless recursion:\n      if (req._errorInResView) { return res.send(500); }\n      req._errorInResView = err;\n\n      if (cb_view) { return cb_view(err); }\n      else {return res.serverError(err);}\n    }\n\n\n    // Ensure specifiedPath is a string (important)\n    relPathToView = '' + relPathToView + '';\n\n    // Ensure `locals` is an object\n    locals = _.isObject(locals) ? locals : {};\n\n    // Mixin locals from req.options\n    if (req.options.locals) {\n      locals = _.merge(locals, req.options.locals);\n    }\n\n    // Merge with config views locals\n    if (sails.config.views.locals) {\n      // Formerly a deep merge: `_.merge(locals, sails.config.views.locals, _.defaults);`\n      // Now shallow- see https://github.com/balderdashy/sails/issues/3500\n      _.defaults(locals, sails.config.views.locals);\n    }\n\n    // If the path was specified, but invalid\n    // else if (specifiedPath) {\n    // \treturn res.serverError(new Error('Specified path for view (' + specifiedPath + ') is invalid!'));\n    // }\n\n    // Trim trailing slash\n    if (relPathToView[(relPathToView.length - 1)] === '/') {\n      relPathToView = relPathToView.slice(0, -1);\n    }\n    // if local `layout` is set to true or unspecified\n    // fall back to global config\n    var layout = locals.layout;\n    if (locals.layout === undefined || locals.layout === true) {\n      layout = sails.config.views.layout;\n    }\n\n    // Get the view engine name\n    var engineName = sails.config.views.engine.name || sails.config.views.engine.ext;\n\n    // Disable sails built-in layouts for all view engine's except for ejs\n    if (engineName !== 'ejs') {\n      layout = false;\n    }\n\n    // Allow `res.locals.layout` to override if it was set:\n    if (typeof res.locals.layout !== 'undefined') {\n      layout = res.locals.layout;\n    }\n\n    var pathToViews = sails.config.paths.views;\n    var absPathToView = path.join(pathToViews, relPathToView);\n    var absPathToLayout;\n    var relPathToLayout;\n\n    // At this point, layout should be either `false` or a string\n    if (typeof layout !== 'string') {\n      layout = false;\n    }\n\n    // Set layout file if enabled (using ejs-locals)\n    if (layout) {\n\n      // Solve relative path to layout from the view itself\n      // (required by ejs-locals module)\n      absPathToLayout = path.join(pathToViews, layout);\n      relPathToLayout = path.relative(path.dirname(absPathToView), absPathToLayout);\n\n      // If a layout was specified, set view local so it will be used\n      res.locals._layoutFile = relPathToLayout;\n\n      // sails.log.silly('Using layout at: ', absPathToLayout);\n    }\n\n    // Locals passed in to `res.view()` override app and route locals.\n    _.each(locals, function(local, key) {\n      res.locals[key] = local;\n    });\n\n\n    // Provide access to view metadata in locals\n    // (for convenience)\n    if (_.isUndefined(res.locals.view)) {\n      res.locals.view = {\n        path: relPathToView,\n        absPath: absPathToView,\n        pathFromViews: relPathToView,\n        pathFromApp: path.join(path.relative(sails.config.appPath, sails.config.paths.views), relPathToView),\n        ext: sails.config.views.engine.ext\n      };\n    }\n\n    // Set up the `exposeLocalsToBrowser` view helper method\n    // (unless there is already a local by the same name)\n    //\n    // Background:\n    //  -> https://github.com/balderdashy/sails/pull/3522#issuecomment-174242822\n    if (_.isUndefined(res.locals.exposeLocalsToBrowser)) {\n      res.locals.exposeLocalsToBrowser = function (options){\n        if (!_.isObject(options)) { options = {}; }\n\n        // Note:\n        // We get access to locals using a reference obtained via closure--\n        // and since this view helper won't be used until AFTER the rest of\n        // the code in THIS file has run, we know any relevant changes to\n        // `locals` below will be available, since we're referring to the\n        // same object.\n\n        // Note that we include only `locals` + the `_csrf` property (if relevant),\n        // and that we create a new dictionary to avoid tampering with `locals`.\n        var relevantLocals = {};\n        // The `_csrf` check is ignored if the csrf hook is not enabled, or if no\n        // CSRF token is available (i.e. because CSRF protection is disabled in\n        // this app's config)\n        if (sails.hooks.csrf && !_.isNull(res.locals._csrf)) {\n          relevantLocals._csrf = res.locals._csrf;\n        }\n        relevantLocals = _.extend(relevantLocals, locals);\n\n        // We also filter out the `_locals` key.\n        // (TODO: could look into doing this longer term as an optimization-\n        //  but need to investigate other view engines for potential differences)\n        delete relevantLocals._locals;\n\n\n        return htmlScriptify({\n          data: relevantLocals,\n          keys: options.keys,\n          namespace: options.namespace,\n          dontUnescapeOnClient: options.dontUnescapeOnClient\n        });\n      };\n    }\n\n    // In development, provide access to complete path to view via `__dirname` local.\n    if (sails.config.environment !== 'production') {\n      res.locals.__dirname = res.locals.__dirname ||\n        absPathToView + '.' + sails.config.views.engine.ext;\n    }\n\n    // If silly logging is enabled, display some diagnostic information about the res.view() call:\n    if (specifiedPath) { sails.log.silly('View override argument passed to res.view(): ', specifiedPath); }\n    sails.log.silly('Serving view at rel path: ', relPathToView);\n    sails.log.silly('View root: ', sails.config.paths.views);\n\n    // Render the view\n    return res.render(relPathToView, locals, function viewFailedToRender(err, renderedViewStr) {\n\n\n      // Prevent endless recursion:\n      if (err && req._errorInResView) {\n        return res.send(500, err);\n      }\n\n\n      if (err) {\n        req._errorInResView = err;\n\n        // Ensure that if res.serverError() likes to serve views,\n        // it won't this time because we ran into a view error.\n        req.wantsJSON = true;\n\n        // Enhance the raw Express view error object\n        // (this error appears when a view is missing)\n        if (_.isObject(err) && err.view) {\n          err = _.extend({\n            message: util.format(\n              'Could not render view \"%s\".  Tried locating view file @ \"%s\".%s',\n              relPathToView,\n              absPathToView,\n              (layout ? util.format(' Layout configured as \"%s\", so tried using layout @ \"%s\")', layout, absPathToLayout) : '')\n            ),\n            code: 'E_VIEW_FAILED',\n            status: 500\n          }, err);\n          err.inspect = function () {\n            return err.message;\n          };\n        }\n      }\n\n      // If specified, trigger `res.view()` callback instead of proceeding\n      if (typeof cb_view === 'function') {\n        // The provided cb_view callback will receive the error (if there is one)\n        // as the first argument, and the rendered HTML as the second argument.\n        return cb_view(err, renderedViewStr);\n      }\n      else {\n\n        // if a template error occurred, don't rely on any of the Sails request/response methods\n        // (since they may not exist yet at this point in the request lifecycle.)\n        if (err) {\n\n          //////////////////////////////////////////////////////////////////\n          // TODO:\n          // Consider removing this log and deferring to the logging that is\n          // happening in res.serverError() instead.\n          // sails.log.error('Error rendering view at ::', absPathToView);\n          // sails.log.error('with layout located at ::', absPathToLayout);\n          // sails.log.error(err && err.message);\n          //\n          //////////////////////////////////////////////////////////////////\n\n          //////////////////////////////////////////////////////////////////\n          // TODO:\n          // Consider just calling some kind of default error handler fn here\n          // in order to consolidate the \"i dont know wtf i should do w/ this err\" logic.\n          // (keep in mind the `next` we have here is NOT THE SAME as the `next` from\n          //  the point when this error occurred!  It is the next from when this\n          //  method was initially attached to the request object in the views hook.)\n          //\n          if (res.serverError) {\n            req.wantsJSON = true;\n            return res.serverError(err);\n          }\n          else if (process.env.NODE_ENV !== 'production') {\n            return res.json(500, err);\n          }\n          else {return res.send(500);}\n          //\n          //////////////////////////////////////////////////////////////////\n        }\n\n        // If verbose logging is enabled, write a log w/ the layout and view that was rendered.\n        sails.log.verbose('Rendering view: \"%s\" (located @ \"%s\")', relPathToView,absPathToView);\n        layout && sails.log.verbose(' using configured layout:: %s (located @ \"%s\")', layout, absPathToLayout);\n\n        // Finally, send the compiled HTML from the view down to the client\n        res.send(renderedViewStr);\n      }\n\n    });\n  };\n\n  next();\n};\n\n\n\n// Express version updates should be closely monitored.\n// Express is a \"hard\" dependency.\n//\n// While unlikely this will change, it's worth noting that this implementation\n// relies on express's private implementation of res.render() here:\n// https://github.com/visionmedia/express/blob/master/lib/response.js#L799\n//\n// To be safe, the version of the Express dependency in package.json will remain locked\n// until it can be verified that each subsequent version is compatible.  Even patch releases!!\n","/home/travis/build/npmtest/node-npmtest-sails/node_modules/sails/lib/hooks/views/stat-views.js":"/**\n * Stat view files and expose the existence tree on `sails.views`.\n *\n * @param  {Sails}    sails\n * @param  {Hook}     hook\n * @param  {Function} cb\n *         @param {Error} err\n *         @param {Dictionary} detectedViews\n *\n *\n * @api private\n */\n\nmodule.exports = function statViews (sails, hook, cb) {\n  sails.modules.statViews(function (err, detectedViews) {\n    if (err) {\n      return cb(err);\n    }\n\n    // Save existence tree in `sails.views` for consumption later\n    sails.views = detectedViews || {};\n\n    return cb(null, detectedViews);\n  });\n\n};\n"}